{
  "contractName": "DoubleEndedQueueUpgradeable",
  "sourceName": "src/contracts/lib/struct/LDoubleEndedQueueUpgradeable.sol",
  "abi": [
    {
      "inputs": [],
      "name": "Empty",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OutOfBounds",
      "type": "error"
    }
  ],
  "bytecode": "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220adb3e4ec7a2b3cfa4ed114e2cab37f38d9c4af800097fd63a197f1363f9acb7e64736f6c63430008110033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220adb3e4ec7a2b3cfa4ed114e2cab37f38d9c4af800097fd63a197f1363f9acb7e64736f6c63430008110033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "details": "A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that the existing queue contents are left in storage. The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be used in storage, and not in memory. ``` DoubleEndedQueue.Bytes32Deque queue; ```",
    "errors": {
      "Empty()": [
        {
          "details": "An operation (e.g. {front}) couldn't be completed due to the queue being empty."
        }
      ],
      "OutOfBounds()": [
        {
          "details": "An operation (e.g. {at}) couldn't be completed due to an index being out of bounds."
        }
      ]
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "evm": {
    "bytecode": {
      "functionDebugData": {},
      "generatedSources": [],
      "linkReferences": {},
      "opcodes": "PUSH1 0x56 PUSH1 0x37 PUSH1 0xB DUP3 DUP3 DUP3 CODECOPY DUP1 MLOAD PUSH1 0x0 BYTE PUSH1 0x73 EQ PUSH1 0x2A JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x0 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST ADDRESS PUSH1 0x0 MSTORE PUSH1 0x73 DUP2 MSTORE8 DUP3 DUP2 RETURN INVALID PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xAD 0xB3 0xE4 0xEC PUSH27 0x2B3CFA4ED114E2CAB37F38D9C4AF800097FD63A197F1363F9ACB7E PUSH5 0x736F6C6343 STOP ADDMOD GT STOP CALLER ",
      "sourceMap": "721:4695:33:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;721:4695:33;;;;;;;;;;;;;;;;;"
    },
    "deployedBytecode": {
      "functionDebugData": {},
      "generatedSources": [],
      "immutableReferences": {},
      "linkReferences": {},
      "opcodes": "PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xAD 0xB3 0xE4 0xEC PUSH27 0x2B3CFA4ED114E2CAB37F38D9C4AF800097FD63A197F1363F9ACB7E PUSH5 0x736F6C6343 STOP ADDMOD GT STOP CALLER ",
      "sourceMap": "721:4695:33:-:0;;;;;;;;"
    },
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "17200",
        "executionCost": "103",
        "totalCost": "17303"
      },
      "internal": {
        "at(struct DoubleEndedQueueUpgradeable.Bytes32Deque storage pointer,uint256)": "infinite",
        "back(struct DoubleEndedQueueUpgradeable.Bytes32Deque storage pointer)": "infinite",
        "clear(struct DoubleEndedQueueUpgradeable.Bytes32Deque storage pointer)": "infinite",
        "empty(struct DoubleEndedQueueUpgradeable.Bytes32Deque storage pointer)": "infinite",
        "front(struct DoubleEndedQueueUpgradeable.Bytes32Deque storage pointer)": "infinite",
        "length(struct DoubleEndedQueueUpgradeable.Bytes32Deque storage pointer)": "infinite",
        "popBack(struct DoubleEndedQueueUpgradeable.Bytes32Deque storage pointer)": "infinite",
        "popFront(struct DoubleEndedQueueUpgradeable.Bytes32Deque storage pointer)": "infinite",
        "pushBack(struct DoubleEndedQueueUpgradeable.Bytes32Deque storage pointer,bytes32)": "infinite",
        "pushFront(struct DoubleEndedQueueUpgradeable.Bytes32Deque storage pointer,bytes32)": "infinite"
      }
    },
    "methodIdentifiers": {}
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"Empty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OutOfBounds\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that the existing queue contents are left in storage. The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be used in storage, and not in memory. ``` DoubleEndedQueue.Bytes32Deque queue; ```\",\"errors\":{\"Empty()\":[{\"details\":\"An operation (e.g. {front}) couldn't be completed due to the queue being empty.\"}],\"OutOfBounds()\":[{\"details\":\"An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/lib/struct/LDoubleEndedQueueUpgradeable.sol\":\"DoubleEndedQueueUpgradeable\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"src/contracts/lib/math/LSafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary LSafeCast {\\n  /**\\n   * @dev Returns the downcasted uint248 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint248).\\n   *\\n   * Counterpart to Solidity's `uint248` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 248 bits\\n   */\\n  function toUint248(uint256 value) internal pure returns (uint248) {\\n    require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    return uint248(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint240 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint240).\\n   *\\n   * Counterpart to Solidity's `uint240` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 240 bits\\n   */\\n  function toUint240(uint256 value) internal pure returns (uint240) {\\n    require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    return uint240(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint232 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint232).\\n   *\\n   * Counterpart to Solidity's `uint232` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 232 bits\\n   */\\n  function toUint232(uint256 value) internal pure returns (uint232) {\\n    require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    return uint232(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint224 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint224).\\n   *\\n   * Counterpart to Solidity's `uint224` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 224 bits\\n   */\\n  function toUint224(uint256 value) internal pure returns (uint224) {\\n    require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    return uint224(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint216 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint216).\\n   *\\n   * Counterpart to Solidity's `uint216` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 216 bits\\n   */\\n  function toUint216(uint256 value) internal pure returns (uint216) {\\n    require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    return uint216(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint208 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint208).\\n   *\\n   * Counterpart to Solidity's `uint208` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 208 bits\\n   */\\n  function toUint208(uint256 value) internal pure returns (uint208) {\\n    require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    return uint208(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint200 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint200).\\n   *\\n   * Counterpart to Solidity's `uint200` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 200 bits\\n   */\\n  function toUint200(uint256 value) internal pure returns (uint200) {\\n    require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    return uint200(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint192 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint192).\\n   *\\n   * Counterpart to Solidity's `uint192` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 192 bits\\n   */\\n  function toUint192(uint256 value) internal pure returns (uint192) {\\n    require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    return uint192(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint184 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint184).\\n   *\\n   * Counterpart to Solidity's `uint184` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 184 bits\\n   */\\n  function toUint184(uint256 value) internal pure returns (uint184) {\\n    require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    return uint184(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint176 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint176).\\n   *\\n   * Counterpart to Solidity's `uint176` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 176 bits\\n   */\\n  function toUint176(uint256 value) internal pure returns (uint176) {\\n    require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    return uint176(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint168 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint168).\\n   *\\n   * Counterpart to Solidity's `uint168` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 168 bits\\n   */\\n  function toUint168(uint256 value) internal pure returns (uint168) {\\n    require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    return uint168(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint160 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint160).\\n   *\\n   * Counterpart to Solidity's `uint160` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 160 bits\\n   */\\n  function toUint160(uint256 value) internal pure returns (uint160) {\\n    require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    return uint160(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint152 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint152).\\n   *\\n   * Counterpart to Solidity's `uint152` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 152 bits\\n   */\\n  function toUint152(uint256 value) internal pure returns (uint152) {\\n    require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    return uint152(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint144 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint144).\\n   *\\n   * Counterpart to Solidity's `uint144` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 144 bits\\n   */\\n  function toUint144(uint256 value) internal pure returns (uint144) {\\n    require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    return uint144(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint136 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint136).\\n   *\\n   * Counterpart to Solidity's `uint136` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 136 bits\\n   */\\n  function toUint136(uint256 value) internal pure returns (uint136) {\\n    require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    return uint136(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint128 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint128).\\n   *\\n   * Counterpart to Solidity's `uint128` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 128 bits\\n   */\\n  function toUint128(uint256 value) internal pure returns (uint128) {\\n    require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    return uint128(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint120 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint120).\\n   *\\n   * Counterpart to Solidity's `uint120` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 120 bits\\n   */\\n  function toUint120(uint256 value) internal pure returns (uint120) {\\n    require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    return uint120(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint112 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint112).\\n   *\\n   * Counterpart to Solidity's `uint112` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 112 bits\\n   */\\n  function toUint112(uint256 value) internal pure returns (uint112) {\\n    require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    return uint112(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint104 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint104).\\n   *\\n   * Counterpart to Solidity's `uint104` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 104 bits\\n   */\\n  function toUint104(uint256 value) internal pure returns (uint104) {\\n    require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    return uint104(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint96 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint96).\\n   *\\n   * Counterpart to Solidity's `uint96` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 96 bits\\n   */\\n  function toUint96(uint256 value) internal pure returns (uint96) {\\n    require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    return uint96(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint88 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint88).\\n   *\\n   * Counterpart to Solidity's `uint88` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 88 bits\\n   */\\n  function toUint88(uint256 value) internal pure returns (uint88) {\\n    require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    return uint88(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint80 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint80).\\n   *\\n   * Counterpart to Solidity's `uint80` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 80 bits\\n   */\\n  function toUint80(uint256 value) internal pure returns (uint80) {\\n    require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    return uint80(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint72 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint72).\\n   *\\n   * Counterpart to Solidity's `uint72` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 72 bits\\n   */\\n  function toUint72(uint256 value) internal pure returns (uint72) {\\n    require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    return uint72(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint64 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint64).\\n   *\\n   * Counterpart to Solidity's `uint64` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 64 bits\\n   */\\n  function toUint64(uint256 value) internal pure returns (uint64) {\\n    require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    return uint64(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint56 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint56).\\n   *\\n   * Counterpart to Solidity's `uint56` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 56 bits\\n   */\\n  function toUint56(uint256 value) internal pure returns (uint56) {\\n    require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    return uint56(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint48 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint48).\\n   *\\n   * Counterpart to Solidity's `uint48` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 48 bits\\n   */\\n  function toUint48(uint256 value) internal pure returns (uint48) {\\n    require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    return uint48(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint40 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint40).\\n   *\\n   * Counterpart to Solidity's `uint40` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 40 bits\\n   */\\n  function toUint40(uint256 value) internal pure returns (uint40) {\\n    require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    return uint40(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint32 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint32).\\n   *\\n   * Counterpart to Solidity's `uint32` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 32 bits\\n   */\\n  function toUint32(uint256 value) internal pure returns (uint32) {\\n    require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    return uint32(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint24 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint24).\\n   *\\n   * Counterpart to Solidity's `uint24` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 24 bits\\n   */\\n  function toUint24(uint256 value) internal pure returns (uint24) {\\n    require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    return uint24(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint16 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint16).\\n   *\\n   * Counterpart to Solidity's `uint16` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 16 bits\\n   */\\n  function toUint16(uint256 value) internal pure returns (uint16) {\\n    require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    return uint16(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint8 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint8).\\n   *\\n   * Counterpart to Solidity's `uint8` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 8 bits\\n   */\\n  function toUint8(uint256 value) internal pure returns (uint8) {\\n    require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    return uint8(value);\\n  }\\n\\n  /**\\n   * @dev Converts a signed int256 into an unsigned uint256.\\n   *\\n   * Requirements:\\n   *\\n   * - input must be greater than or equal to 0.\\n   */\\n  function toUint256(int256 value) internal pure returns (uint256) {\\n    require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n    return uint256(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int248 from int256, reverting on\\n   * overflow (when the input is less than smallest int248 or\\n   * greater than largest int248).\\n   *\\n   * Counterpart to Solidity's `int248` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 248 bits\\n   */\\n  function toInt248(int256 value) internal pure returns (int248) {\\n    require(value >= type(int248).min && value <= type(int248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    return int248(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int240 from int256, reverting on\\n   * overflow (when the input is less than smallest int240 or\\n   * greater than largest int240).\\n   *\\n   * Counterpart to Solidity's `int240` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 240 bits\\n   */\\n  function toInt240(int256 value) internal pure returns (int240) {\\n    require(value >= type(int240).min && value <= type(int240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    return int240(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int232 from int256, reverting on\\n   * overflow (when the input is less than smallest int232 or\\n   * greater than largest int232).\\n   *\\n   * Counterpart to Solidity's `int232` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 232 bits\\n   */\\n  function toInt232(int256 value) internal pure returns (int232) {\\n    require(value >= type(int232).min && value <= type(int232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    return int232(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int224 from int256, reverting on\\n   * overflow (when the input is less than smallest int224 or\\n   * greater than largest int224).\\n   *\\n   * Counterpart to Solidity's `int224` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 224 bits\\n   */\\n  function toInt224(int256 value) internal pure returns (int224) {\\n    require(value >= type(int224).min && value <= type(int224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    return int224(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int216 from int256, reverting on\\n   * overflow (when the input is less than smallest int216 or\\n   * greater than largest int216).\\n   *\\n   * Counterpart to Solidity's `int216` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 216 bits\\n   */\\n  function toInt216(int256 value) internal pure returns (int216) {\\n    require(value >= type(int216).min && value <= type(int216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    return int216(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int208 from int256, reverting on\\n   * overflow (when the input is less than smallest int208 or\\n   * greater than largest int208).\\n   *\\n   * Counterpart to Solidity's `int208` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 208 bits\\n   */\\n  function toInt208(int256 value) internal pure returns (int208) {\\n    require(value >= type(int208).min && value <= type(int208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    return int208(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int200 from int256, reverting on\\n   * overflow (when the input is less than smallest int200 or\\n   * greater than largest int200).\\n   *\\n   * Counterpart to Solidity's `int200` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 200 bits\\n   */\\n  function toInt200(int256 value) internal pure returns (int200) {\\n    require(value >= type(int200).min && value <= type(int200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    return int200(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int192 from int256, reverting on\\n   * overflow (when the input is less than smallest int192 or\\n   * greater than largest int192).\\n   *\\n   * Counterpart to Solidity's `int192` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 192 bits\\n   */\\n  function toInt192(int256 value) internal pure returns (int192) {\\n    require(value >= type(int192).min && value <= type(int192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    return int192(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int184 from int256, reverting on\\n   * overflow (when the input is less than smallest int184 or\\n   * greater than largest int184).\\n   *\\n   * Counterpart to Solidity's `int184` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 184 bits\\n   */\\n  function toInt184(int256 value) internal pure returns (int184) {\\n    require(value >= type(int184).min && value <= type(int184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    return int184(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int176 from int256, reverting on\\n   * overflow (when the input is less than smallest int176 or\\n   * greater than largest int176).\\n   *\\n   * Counterpart to Solidity's `int176` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 176 bits\\n   */\\n  function toInt176(int256 value) internal pure returns (int176) {\\n    require(value >= type(int176).min && value <= type(int176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    return int176(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int168 from int256, reverting on\\n   * overflow (when the input is less than smallest int168 or\\n   * greater than largest int168).\\n   *\\n   * Counterpart to Solidity's `int168` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 168 bits\\n   */\\n  function toInt168(int256 value) internal pure returns (int168) {\\n    require(value >= type(int168).min && value <= type(int168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    return int168(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int160 from int256, reverting on\\n   * overflow (when the input is less than smallest int160 or\\n   * greater than largest int160).\\n   *\\n   * Counterpart to Solidity's `int160` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 160 bits\\n   */\\n  function toInt160(int256 value) internal pure returns (int160) {\\n    require(value >= type(int160).min && value <= type(int160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    return int160(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int152 from int256, reverting on\\n   * overflow (when the input is less than smallest int152 or\\n   * greater than largest int152).\\n   *\\n   * Counterpart to Solidity's `int152` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 152 bits\\n   */\\n  function toInt152(int256 value) internal pure returns (int152) {\\n    require(value >= type(int152).min && value <= type(int152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    return int152(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int144 from int256, reverting on\\n   * overflow (when the input is less than smallest int144 or\\n   * greater than largest int144).\\n   *\\n   * Counterpart to Solidity's `int144` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 144 bits\\n   */\\n  function toInt144(int256 value) internal pure returns (int144) {\\n    require(value >= type(int144).min && value <= type(int144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    return int144(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int136 from int256, reverting on\\n   * overflow (when the input is less than smallest int136 or\\n   * greater than largest int136).\\n   *\\n   * Counterpart to Solidity's `int136` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 136 bits\\n   */\\n  function toInt136(int256 value) internal pure returns (int136) {\\n    require(value >= type(int136).min && value <= type(int136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    return int136(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int128 from int256, reverting on\\n   * overflow (when the input is less than smallest int128 or\\n   * greater than largest int128).\\n   *\\n   * Counterpart to Solidity's `int128` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 128 bits\\n   */\\n  function toInt128(int256 value) internal pure returns (int128) {\\n    require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    return int128(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int120 from int256, reverting on\\n   * overflow (when the input is less than smallest int120 or\\n   * greater than largest int120).\\n   *\\n   * Counterpart to Solidity's `int120` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 120 bits\\n   */\\n  function toInt120(int256 value) internal pure returns (int120) {\\n    require(value >= type(int120).min && value <= type(int120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    return int120(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int112 from int256, reverting on\\n   * overflow (when the input is less than smallest int112 or\\n   * greater than largest int112).\\n   *\\n   * Counterpart to Solidity's `int112` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 112 bits\\n   */\\n  function toInt112(int256 value) internal pure returns (int112) {\\n    require(value >= type(int112).min && value <= type(int112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    return int112(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int104 from int256, reverting on\\n   * overflow (when the input is less than smallest int104 or\\n   * greater than largest int104).\\n   *\\n   * Counterpart to Solidity's `int104` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 104 bits\\n   */\\n  function toInt104(int256 value) internal pure returns (int104) {\\n    require(value >= type(int104).min && value <= type(int104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    return int104(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int96 from int256, reverting on\\n   * overflow (when the input is less than smallest int96 or\\n   * greater than largest int96).\\n   *\\n   * Counterpart to Solidity's `int96` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 96 bits\\n   */\\n  function toInt96(int256 value) internal pure returns (int96) {\\n    require(value >= type(int96).min && value <= type(int96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    return int96(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int88 from int256, reverting on\\n   * overflow (when the input is less than smallest int88 or\\n   * greater than largest int88).\\n   *\\n   * Counterpart to Solidity's `int88` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 88 bits\\n   */\\n  function toInt88(int256 value) internal pure returns (int88) {\\n    require(value >= type(int88).min && value <= type(int88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    return int88(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int80 from int256, reverting on\\n   * overflow (when the input is less than smallest int80 or\\n   * greater than largest int80).\\n   *\\n   * Counterpart to Solidity's `int80` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 80 bits\\n   */\\n  function toInt80(int256 value) internal pure returns (int80) {\\n    require(value >= type(int80).min && value <= type(int80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    return int80(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int72 from int256, reverting on\\n   * overflow (when the input is less than smallest int72 or\\n   * greater than largest int72).\\n   *\\n   * Counterpart to Solidity's `int72` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 72 bits\\n   */\\n  function toInt72(int256 value) internal pure returns (int72) {\\n    require(value >= type(int72).min && value <= type(int72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    return int72(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int64 from int256, reverting on\\n   * overflow (when the input is less than smallest int64 or\\n   * greater than largest int64).\\n   *\\n   * Counterpart to Solidity's `int64` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 64 bits\\n   */\\n  function toInt64(int256 value) internal pure returns (int64) {\\n    require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    return int64(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int56 from int256, reverting on\\n   * overflow (when the input is less than smallest int56 or\\n   * greater than largest int56).\\n   *\\n   * Counterpart to Solidity's `int56` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 56 bits\\n   */\\n  function toInt56(int256 value) internal pure returns (int56) {\\n    require(value >= type(int56).min && value <= type(int56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    return int56(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int48 from int256, reverting on\\n   * overflow (when the input is less than smallest int48 or\\n   * greater than largest int48).\\n   *\\n   * Counterpart to Solidity's `int48` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 48 bits\\n   */\\n  function toInt48(int256 value) internal pure returns (int48) {\\n    require(value >= type(int48).min && value <= type(int48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    return int48(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int40 from int256, reverting on\\n   * overflow (when the input is less than smallest int40 or\\n   * greater than largest int40).\\n   *\\n   * Counterpart to Solidity's `int40` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 40 bits\\n   */\\n  function toInt40(int256 value) internal pure returns (int40) {\\n    require(value >= type(int40).min && value <= type(int40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    return int40(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int32 from int256, reverting on\\n   * overflow (when the input is less than smallest int32 or\\n   * greater than largest int32).\\n   *\\n   * Counterpart to Solidity's `int32` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 32 bits\\n   */\\n  function toInt32(int256 value) internal pure returns (int32) {\\n    require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    return int32(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int24 from int256, reverting on\\n   * overflow (when the input is less than smallest int24 or\\n   * greater than largest int24).\\n   *\\n   * Counterpart to Solidity's `int24` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 24 bits\\n   */\\n  function toInt24(int256 value) internal pure returns (int24) {\\n    require(value >= type(int24).min && value <= type(int24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    return int24(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int16 from int256, reverting on\\n   * overflow (when the input is less than smallest int16 or\\n   * greater than largest int16).\\n   *\\n   * Counterpart to Solidity's `int16` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 16 bits\\n   */\\n  function toInt16(int256 value) internal pure returns (int16) {\\n    require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    return int16(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int8 from int256, reverting on\\n   * overflow (when the input is less than smallest int8 or\\n   * greater than largest int8).\\n   *\\n   * Counterpart to Solidity's `int8` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 8 bits\\n   */\\n  function toInt8(int256 value) internal pure returns (int8) {\\n    require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    return int8(value);\\n  }\\n\\n  /**\\n   * @dev Converts an unsigned uint256 into a signed int256.\\n   *\\n   * Requirements:\\n   *\\n   * - input must be less than or equal to maxInt256.\\n   */\\n  function toInt256(uint256 value) internal pure returns (int256) {\\n    // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n    require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n    return int256(value);\\n  }\\n}\\n\",\"keccak256\":\"0x585aea6afb922beec7d3a437a665c09eace3b3431e4941c09a681a0228fbb412\",\"license\":\"MIT\"},\"src/contracts/lib/struct/LDoubleEndedQueueUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../math/LSafeCast.sol\\\";\\n\\n/**\\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\\n * the existing queue contents are left in storage.\\n *\\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\\n * used in storage, and not in memory.\\n * ```\\n * DoubleEndedQueue.Bytes32Deque queue;\\n * ```\\n */\\nlibrary DoubleEndedQueueUpgradeable {\\n  /**\\n   * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\\n   */\\n  error Empty();\\n\\n  /**\\n   * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\\n   */\\n  error OutOfBounds();\\n\\n  /**\\n   * @dev Indices are signed integers because the queue can grow in any direction. They are 128 bits so begin and end\\n   * are packed in a single storage slot for efficient access. Since the items are added one at a time we can safely\\n   * assume that these 128-bit indices will not overflow, and use unchecked arithmetic.\\n   *\\n   * Struct members have an underscore prefix indicating that they are \\\"private\\\" and should not be read or written to\\n   * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\\n   * lead to unexpected behavior.\\n   *\\n   * Indices are in the range [begin, end) which means the first item is at data[begin] and the last item is at\\n   * data[end - 1].\\n   */\\n  struct Bytes32Deque {\\n    int128 _begin;\\n    int128 _end;\\n    mapping(int128 => bytes32) _data;\\n  }\\n\\n  /**\\n   * @dev Inserts an item at the end of the queue.\\n   */\\n  function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\\n    int128 backIndex = deque._end;\\n    deque._data[backIndex] = value;\\n    unchecked {\\n      deque._end = backIndex + 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes the item at the end of the queue and returns it.\\n   *\\n   * Reverts with `Empty` if the queue is empty.\\n   */\\n  function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\\n    if (empty(deque)) revert Empty();\\n    int128 backIndex;\\n    unchecked {\\n      backIndex = deque._end - 1;\\n    }\\n    value = deque._data[backIndex];\\n    delete deque._data[backIndex];\\n    deque._end = backIndex;\\n  }\\n\\n  /**\\n   * @dev Inserts an item at the beginning of the queue.\\n   */\\n  function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\\n    int128 frontIndex;\\n    unchecked {\\n      frontIndex = deque._begin - 1;\\n    }\\n    deque._data[frontIndex] = value;\\n    deque._begin = frontIndex;\\n  }\\n\\n  /**\\n   * @dev Removes the item at the beginning of the queue and returns it.\\n   *\\n   * Reverts with `Empty` if the queue is empty.\\n   */\\n  function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\\n    if (empty(deque)) revert Empty();\\n    int128 frontIndex = deque._begin;\\n    value = deque._data[frontIndex];\\n    delete deque._data[frontIndex];\\n    unchecked {\\n      deque._begin = frontIndex + 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the item at the beginning of the queue.\\n   *\\n   * Reverts with `Empty` if the queue is empty.\\n   */\\n  function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\\n    if (empty(deque)) revert Empty();\\n    int128 frontIndex = deque._begin;\\n    return deque._data[frontIndex];\\n  }\\n\\n  /**\\n   * @dev Returns the item at the end of the queue.\\n   *\\n   * Reverts with `Empty` if the queue is empty.\\n   */\\n  function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\\n    if (empty(deque)) revert Empty();\\n    int128 backIndex;\\n    unchecked {\\n      backIndex = deque._end - 1;\\n    }\\n    return deque._data[backIndex];\\n  }\\n\\n  /**\\n   * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\\n   * `length(deque) - 1`.\\n   *\\n   * Reverts with `OutOfBounds` if the index is out of bounds.\\n   */\\n  function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\\n    // int256(deque._begin) is a safe upcast\\n    int128 idx = LSafeCast.toInt128(int256(deque._begin) + LSafeCast.toInt256(index));\\n    if (idx >= deque._end) revert OutOfBounds();\\n    return deque._data[idx];\\n  }\\n\\n  /**\\n   * @dev Resets the queue back to being empty.\\n   *\\n   * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\\n   * out on potential gas refunds.\\n   */\\n  function clear(Bytes32Deque storage deque) internal {\\n    deque._begin = 0;\\n    deque._end = 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of items in the queue.\\n   */\\n  function length(Bytes32Deque storage deque) internal view returns (uint256) {\\n    // The interface preserves the invariant that begin <= end so we assume this will not overflow.\\n    // We also assume there are at most int256.max items in the queue.\\n    unchecked {\\n      return uint256(int256(deque._end) - int256(deque._begin));\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the queue is empty.\\n   */\\n  function empty(Bytes32Deque storage deque) internal view returns (bool) {\\n    return deque._end <= deque._begin;\\n  }\\n}\\n\",\"keccak256\":\"0x37d770f60f5858470edc713de527034b455ea5917fc07f1cb264e353f72d37e5\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  }
}