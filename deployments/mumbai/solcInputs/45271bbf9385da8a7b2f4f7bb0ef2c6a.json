{
  "language": "Solidity",
  "sources": {
    "src/contracts/acl/AccessControlManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IAccessControl.sol\";\nimport \"./AccessControlStorage.sol\";\nimport \"./IGroupManagement.sol\";\nimport \"./IRealmManagement.sol\";\nimport \"./IRoleManagement.sol\";\nimport \"./IContextManagement.sol\";\nimport \"../lib/struct/LEnumerableSet.sol\";\nimport \"../lib/struct/LEnumerableMap.sol\";\nimport \"../lib/acl/LContextManagement.sol\";\nimport \"../lib/acl/LRoleManagement.sol\";\nimport \"../lib/acl/LGroupManagement.sol\";\nimport \"../lib/acl/LRealmManagement.sol\";\nimport \"../lib/acl/LAccessControl.sol\";\nimport \"../proxy/Initializable.sol\";\nimport \"../proxy/BaseUUPSProxy.sol\";\n\ncontract AccessControlManager is\n  AccessControlStorage,\n  BaseUUPSProxy,\n  IContextManagement,\n  IAccessControl,\n  IGroupManagement,\n  IRealmManagement,\n  IRoleManagement\n{\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableMap for LEnumerableMap.Bytes32ToBytes32Map;\n  using LEnumerableMap for LEnumerableMap.AddressToUintMap;\n\n  constructor() {}\n\n  function initialize(\n    string calldata domainName,\n    string calldata domainVersion,\n    string calldata domainRealm,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n\n    LAccessControl.initializeContext(_data);\n\n    __BASE_UUPS_init(domainName, domainVersion, realm, accessControlManager);\n\n    RequestRegisterContext[] memory rc = LAccessControl.createRequestContext();\n    LContextManagement.registerAccessControlManagerContext(_data, address(this), realm, rc);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      domainName,\n      domainVersion,\n      realm,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n    return\n      interfaceId == type(IAccessControl).interfaceId ||\n      interfaceId == type(IContextManagement).interfaceId ||\n      interfaceId == type(IRoleManagement).interfaceId ||\n      interfaceId == type(IGroupManagement).interfaceId ||\n      interfaceId == type(IRealmManagement).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function hasAccess(\n    bytes32 context,\n    address account,\n    bytes4 signature\n  ) external view returns (bool) {\n    return LAccessControl.hasAccess(_data, context, account, signature);\n  }\n\n  function isLivelySystemAdminRole(address account) external view returns (bool) {\n    return LAccessControl.isLivelySystemAdminRole(_data, account);\n  }\n\n  function isLivelyAdminRole(address account) external view returns (bool) {\n    return LAccessControl.isLivelyAdminRole(_data, account);\n  }\n\n  function isLivelyAssetManagerRole(address account) external view returns (bool) {\n    return LAccessControl.isLivelyAssetManagerRole(_data, account);\n  }\n\n  function isLivelyAssetAdminRole(address account) external view returns (bool) {\n    return LAccessControl.isLivelyAssetAdminRole(_data, account);\n  }\n\n  function isLivelyCommunityDaoRole(address account) external view returns (bool) {\n    return LAccessControl.isLivelyCommunityDaoRole(_data, account);\n  }\n\n  function isLivelyCommunityDaoExecutorRole(address account) external view returns (bool) {\n    return LAccessControl.isLivelyCommunityDaoExecutorRole(_data, account);\n  }\n\n  function isLivelyGeneralGroup(bytes32 role) external view returns (bool) {\n    return LAccessControl.isLivelyGeneralGroup(_data, role);\n  }\n\n  function isLivelyDaoGroup(bytes32 role) external view returns (bool) {\n    return LAccessControl.isLivelyDaoGroup(_data, role);\n  }\n\n  function isLivelyAssetGroup(bytes32 role) external view returns (bool) {\n    return LAccessControl.isLivelyAssetGroup(_data, role);\n  }\n\n  function isLivelyGeneralRealm(bytes32 context) external view returns (bool) {\n    return LAccessControl.isLivelyGeneralRealm(_data, context);\n  }\n\n  function isLivelyAssetRealm(bytes32 context) external view returns (bool) {\n    return LAccessControl.isLivelyAssetRealm(_data, context);\n  }\n\n  function isContextSafeMode(bytes32 context) external view returns (bool) {\n    return LAccessControl.isContextSafeMode(_data, context);\n  }\n\n  function isContextUpgradable(bytes32 context) external view returns (bool) {\n    return LAccessControl.isContextUpgradable(_data, context);\n  }\n\n  function isRealmUpgradable(bytes32 realm) external view returns (bool) {\n    return LAccessControl.isRealmUpgradable(_data, realm);\n  }\n\n  function isGroupExists(bytes32 group) external view returns (bool) {\n    return LAccessControl.isGroupExists(_data, group);\n  }\n\n  function isGroupEnabled(bytes32 group) external view returns (bool) {\n    return LAccessControl.isGroupEnabled(_data, group);\n  }\n\n  function isContextExists(bytes32 context) external view returns (bool) {\n    return LAccessControl.isContextExists(_data, context);\n  }\n\n  function isContextFunctionExists(bytes32 context, bytes4 functionSelector) external view returns (bool) {\n    return LAccessControl.isContextFunctionExists(_data, context, functionSelector);\n  }\n\n  function isContextFunctionEnabled(bytes32 context, bytes4 functionSelector) external view returns (bool) {\n    return LAccessControl.isContextFunctionEnabled(_data, context, functionSelector);\n  }\n\n  function isContextEnabled(bytes32 context) external view returns (bool) {\n    return LAccessControl.isContextEnabled(_data, context);\n  }\n\n  function isRoleExists(bytes32 role) external view returns (bool) {\n    return LAccessControl.isRoleExists(_data, role);\n  }\n\n  function isRoleEnabled(bytes32 role) external view returns (bool) {\n    return LAccessControl.isRoleEnabled(_data, role);\n  }\n\n  function isRealmExists(bytes32 realm) external view returns (bool) {\n    return LAccessControl.isRealmExists(_data, realm);\n  }\n\n  function isRealmEnabled(bytes32 realm) external view returns (bool) {\n    return LAccessControl.isRealmEnabled(_data, realm);\n  }\n\n  function registerContext(\n    bytes memory signature,\n    RequestContext calldata rc,\n    RequestRegisterContext[] calldata rrc\n  ) external returns (bytes32) {\n    (bytes32 context, address signer) = LContextManagement.registerContext(_data, signature, rc, rrc);\n    emit ContextRegistered(context, rc.contractId, signer, _msgSender(), rc.realm);\n    return context;\n  }\n\n  function registerPredictContext(\n    bytes memory signature,\n    RequestPredictContext calldata rpc,\n    RequestRegisterContext[] calldata rrc\n  ) external returns (bytes32) {\n    (address contractId, bytes32 context, address signer) = LContextManagement.registerPredictContext(_data, signature, rpc, rrc);\n    emit PredictContextRegistered(context, contractId, _msgSender(), signer, rpc.deployer, rpc.subject, rpc.realm);\n    return context;\n  }\n\n  function updateContext(\n    bytes32 ctx,\n    bytes memory signature,\n    RequestContext calldata rc,\n    RequestUpdateContext[] calldata rcr\n  ) external returns (address) {\n    (address contractId, address sender) = LContextManagement.updateContext(_data, ctx, signature, rc, rcr);\n    emit ContextUpdated(ctx, contractId, sender, rc.realm);\n    return contractId;\n  }\n\n  function addContextFuncRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool) {\n    bytes32 realm = LContextManagement.addContextFuncRole(_data, ctx, functionSelector, role);\n    emit ContextFuncRoleAdded(ctx, role, msg.sender, functionSelector, realm);\n    return true;\n  }\n\n  function removeContextFunc(bytes32 ctx, bytes4 functionSelector) external returns (bool) {\n    bytes32 realm = LContextManagement.removeContextFunc(_data, ctx, functionSelector);\n    emit ContextFuncRemoved(ctx, msg.sender, functionSelector, realm);\n    return true;\n  }\n\n  function grantContextRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool) {\n    bytes32 realm = LContextManagement.grantContextRole(_data, ctx, functionSelector, role);\n    emit ContextRoleGranted(ctx, role, msg.sender, functionSelector, realm);\n    return true;\n  }\n\n  function revokeContextRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool) {\n    bytes32 realm = LContextManagement.revokeContextRole(_data, ctx, functionSelector, role);\n    emit ContextRoleRevoked(ctx, role, msg.sender, functionSelector, realm);\n    return true;\n  }\n\n  function setContextStatus(bytes32 ctx, bool status) external returns (bool) {\n    (bool success, bytes32 realm) = LContextManagement.setContextStatus(_data, ctx, status);\n    emit ContextStatusChanged(ctx, _msgSender(), realm, status);\n    return success;\n  }\n\n  function setContextRealm(bytes32 ctx, bytes32 realm) external returns (bool) {\n    (bool success, bytes32 oldRealm) = LContextManagement.setContextRealm(_data, ctx, realm);\n    emit ContextRealmChanged(ctx, _msgSender(), realm, oldRealm);\n    return success;\n  }\n\n  function hasContextRole(\n    bytes32 ctx,\n    bytes32 role,\n    bytes4 functionSelector\n  ) external view returns (bool) {\n    return LContextManagement.hasContextRole(_data, ctx, role, functionSelector);\n  }\n\n  function getContextInfo(bytes32 ctx) external view returns (ResponseContext memory) {\n    return LContextManagement.getContextInfo(_data, ctx);\n  }\n\n  function getContextFuncs(bytes32 ctx) external view returns (bytes4[] memory) {\n    return LContextManagement.getContextFuncs(_data, ctx);\n  }\n\n  function registerGroup(string calldata name, bool status) external returns (bytes32) {\n    bytes32 group = LGroupManagement.registerGroup(_data, name, status);\n    emit GroupRegistered(group, _msgSender(), name, status);\n    return group;\n  }\n\n  function setGroupStatus(bytes32 group, bool status) external returns (bool) {\n    emit GroupStatusChanged(group, _msgSender(), status);\n    return LGroupManagement.setGroupStatus(_data, group, status);\n  }\n\n  function hasGroupRole(bytes32 group, bytes32 role) external view returns (bool) {\n    return LGroupManagement.hasGroupRole(_data, group, role);\n  }\n\n  function getGroupInfo(bytes32 group) external view returns (string memory, bool) {\n    return LGroupManagement.getGroupInfo(_data, group);\n  }\n\n  function getGroupRoles(bytes32 group) external view returns (bytes32[] memory) {\n    return LGroupManagement.getGroupRoles(_data, group);\n  }\n\n  function registerRealm(\n    string calldata name,\n    bool status,\n    bool isUpgradable\n  ) external returns (bytes32) {\n    bytes32 realm = LRealmManagement.registerRealm(_data, name, status, isUpgradable);\n    emit RealmRegistered(realm, _msgSender(), name, status, isUpgradable);\n    return realm;\n  }\n\n  function setRealmStatus(bytes32 realm, bool status) external returns (bool) {\n    emit RealmStatusChanged(realm, _msgSender(), status);\n    return LRealmManagement.setRealmStatus(_data, realm, status);\n  }\n\n  function setRealmUpgradeStatus(bytes32 realm, bool status) external returns (bool) {\n    emit RealmUpgradeStatusChanged(realm, _msgSender(), status);\n    return LRealmManagement.setRealmUpgradeStatus(_data, realm, status);\n  }\n\n  function hasRealmContext(bytes32 realm, bytes32 context) external view returns (bool) {\n    return LRealmManagement.hasRealmContext(_data, realm, context);\n  }\n\n  function getRealmInfo(bytes32 realm)\n    external\n    view\n    returns (\n      string memory,\n      bool,\n      bool\n    )\n  {\n    return LRealmManagement.getRealmInfo(_data, realm);\n  }\n\n  function getRealmContexts(bytes32 realm) external view returns (bytes32[] memory) {\n    return LRealmManagement.getRealmContexts(_data, realm);\n  }\n\n  function grantRoleAccount(bytes32 role, address account) external returns (bool) {\n    emit RoleAccountGranted(_msgSender(), role, account);\n    return LRoleManagement.grantRoleAccount(_data, role, account);\n  }\n\n  function batchGrantRoleAccount(UpdateRoleRequest[] calldata requests) external returns (bool) {\n    for (uint i; i < requests.length; i++) {\n      emit RoleAccountGranted(_msgSender(), requests[i].role, requests[i].account);\n    }\n    return LRoleManagement.batchGrantRoleAccount(_data, requests);    \n  }\n\n  function revokeRoleAccount(bytes32 role, address account) external returns (bool) {\n    emit RoleAccountRevoked(_msgSender(), role, account);\n    return LRoleManagement.revokeRoleAccount(_data, role, account);\n  }\n\n  function batchRevokeRoleAccount(UpdateRoleRequest[] calldata requests) external returns (bool) {\n    for (uint i; i < requests.length; i++) {\n      emit RoleAccountRevoked(_msgSender(), requests[i].role, requests[i].account);\n    }\n    return LRoleManagement.batchRevokeRoleAccount(_data, requests);\n  }\n\n  function registerRole(\n    string calldata name,\n    bytes32 group,\n    bool status\n  ) external returns (bytes32) {\n    bytes32 role = LRoleManagement.registerRole(_data, name, group, status);\n    emit RoleRegistered(_msgSender(), role, name, group, status);\n    return role;\n  }\n\n  function batchRegisterRole(RegiterRoleRequest[] calldata requests) external returns(bytes32[] memory) {\n    bytes32[] memory roles = LRoleManagement.batchRegisterRole(_data, requests);\n    for (uint i; i < requests.length; i++) {\n      emit RoleRegistered(_msgSender(), roles[i], requests[i].name, requests[i].group, requests[i].status);\n    }\n    \n    return roles;\n  }\n\n  function setRoleStatus(bytes32 role, bool status) external returns (bool) {\n    (bool success, bytes32 group) = LRoleManagement.setRoleStatus(_data, role, status);\n    emit RoleStatusChanged(_msgSender(), role, group, status);\n    return success;\n  }\n\n  function setRoleGroup(bytes32 role, bytes32 group) external returns (bool) {\n    (bool success, bytes32 oldGroup) = LRoleManagement.setRoleGroup(_data, role, group);\n    emit RoleGroupChanged(_msgSender(), role, group, oldGroup);\n    return success;\n  }\n\n  function getRoleInfo(bytes32 role)\n    external\n    view\n    returns (\n      string memory,\n      bytes32,\n      bool\n    )\n  {\n    return LRoleManagement.getRoleInfo(_data, role);\n  }\n\n  function getRoleAccounts(bytes32 role) external view returns (address[] memory) {\n    return LRoleManagement.getRoleAccounts(_data, role);\n  }\n\n  function hasRoleAccount(bytes32 role, address account) external view returns (bool) {\n    return LRoleManagement.hasRoleAccount(_data, role, account);\n  }\n\n  function getLibraries() external pure returns (address[] memory) {\n    address[] memory libs = new address[](5);\n    libs[0] = address(LAccessControl);\n    libs[1] = address(LContextManagement);\n    libs[2] = address(LRealmManagement);\n    libs[3] = address(LRoleManagement);\n    libs[4] = address(LGroupManagement);\n    return libs;\n  }\n}\n"
    },
    "src/contracts/acl/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IAccessControl {\n  /**\n   * @dev Function called by apps to check ACL\n   * @return boolean indicating whether the ACL allows\n   */\n  function hasAccess(\n    bytes32 context,\n    address account,\n    bytes4 signature\n  ) external view returns (bool);\n\n  function isLivelySystemAdminRole(address account) external view returns (bool);\n\n  function isLivelyAdminRole(address account) external view returns (bool);\n\n  function isLivelyAssetManagerRole(address account) external view returns (bool);\n\n  function isLivelyAssetAdminRole(address account) external view returns (bool);\n\n  function isLivelyCommunityDaoRole(address account) external view returns (bool);\n\n  function isLivelyCommunityDaoExecutorRole(address account) external view returns (bool);\n\n  function isLivelyGeneralGroup(bytes32 role) external view returns (bool);\n\n  function isLivelyDaoGroup(bytes32 role) external view returns (bool);\n\n  function isLivelyAssetGroup(bytes32 role) external view returns (bool);\n\n  function isLivelyGeneralRealm(bytes32 context) external view returns (bool);\n\n  function isLivelyAssetRealm(bytes32 context) external view returns (bool);\n\n  function isContextSafeMode(bytes32 context) external view returns (bool);\n\n  function isContextUpgradable(bytes32 context) external view returns (bool);\n\n  function isContextExists(bytes32 context) external view returns (bool);\n\n  function isContextFunctionExists(bytes32 context, bytes4 functionSelector) external view returns (bool);\n\n  function isContextFunctionEnabled(bytes32 context, bytes4 functionSelector) external view returns (bool);\n\n  function isContextEnabled(bytes32 context) external view returns (bool);\n\n  function isGroupExists(bytes32 group) external view returns (bool);\n\n  function isGroupEnabled(bytes32 group) external view returns (bool);\n\n  function isRoleExists(bytes32 role) external view returns (bool);\n\n  function isRoleEnabled(bytes32 role) external view returns (bool);\n\n  function isRealmExists(bytes32 realm) external view returns (bool);\n\n  function isRealmEnabled(bytes32 realm) external view returns (bool); \n\n  function isRealmUpgradable(bytes32 realm) external view returns (bool);\n}\n"
    },
    "src/contracts/acl/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../lib/struct/LEnumerableSet.sol\";\nimport \"../lib/struct/LEnumerableMap.sol\";\nimport \"../proxy/BaseUUPSStorage.sol\";\n\nabstract contract AccessControlStorage is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableMap for LEnumerableMap.Bytes32ToBytes32Map;\n  using LEnumerableMap for LEnumerableMap.AddressToUintMap;\n\n  enum Status {\n    NONE,\n    ENABLED,\n    DISABLED\n  }\n\n  struct RoleStat {\n    bytes32 role;\n    Status status;\n  }\n\n  struct Context {\n    bytes32 realm;\n    address contractId;\n    bool isEnabled;\n    mapping(bytes4 => RoleStat) resources; // function selector => RoleStat\n    LEnumerableSet.Bytes32Set funcSet;\n  }\n\n  struct Role {\n    bytes32 group;\n    string name;\n    bool isEnabled;\n    LEnumerableSet.AddressSet accountSet;\n  }\n\n  struct Realm {\n    string name;\n    bool isEnabled;\n    bool isUpgradable;\n    LEnumerableSet.Bytes32Set ctxSet;\n  }\n\n  struct Group {\n    string name;\n    bool isEnabled;\n    LEnumerableSet.Bytes32Set roleSet;\n  }\n\n  struct DataCollections {\n    mapping(address => mapping(bytes32 => Status)) accountMap;\n    mapping(bytes32 => Context) ctxMap;\n    mapping(bytes32 => Role) roleMap;\n    mapping(bytes32 => Realm) realmMap;\n    mapping(bytes32 => Group) groupMap;\n  }\n\n  DataCollections internal _data;\n\n  // Note: for next upgrade add new variables after this line\n}\n"
    },
    "src/contracts/acl/IGroupManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IGroupManagement {\n  event GroupRegistered(bytes32 indexed group, address indexed sender, string name, bool status);\n\n  event GroupStatusChanged(bytes32 indexed group, address indexed sender, bool status);\n\n  function registerGroup(string calldata name, bool status) external returns (bytes32);\n\n  function setGroupStatus(bytes32 group, bool status) external returns (bool);\n\n  function hasGroupRole(bytes32 group, bytes32 role) external view returns (bool);\n\n  function getGroupInfo(bytes32 group) external view returns (string memory, bool);\n\n  function getGroupRoles(bytes32 group) external view returns (bytes32[] memory);\n}\n"
    },
    "src/contracts/acl/IRealmManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IRealmManagement {\n  event RealmRegistered(bytes32 indexed realm, address indexed sender, string name, bool status, bool isUpgradable);\n\n  event RealmStatusChanged(bytes32 indexed realm, address indexed sender, bool status);\n\n  event RealmUpgradeStatusChanged(bytes32 indexed realm, address indexed sender, bool status);\n\n  function registerRealm(\n    string calldata name,\n    bool status,\n    bool isUpgradable\n  ) external returns (bytes32);\n\n  function setRealmStatus(bytes32 realm, bool status) external returns (bool);\n\n  function setRealmUpgradeStatus(bytes32 realm, bool status) external returns (bool);\n\n  function hasRealmContext(bytes32 realm, bytes32 context) external view returns (bool);\n\n  function getRealmInfo(bytes32 realm)\n    external\n    view\n    returns (\n      string memory,\n      bool,\n      bool\n    );\n\n  function getRealmContexts(bytes32 realm) external view returns (bytes32[] memory);\n}\n"
    },
    "src/contracts/acl/IRoleManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IRoleManagement {\n\n  struct RegiterRoleRequest {\n    bytes32 group;\n    string name;    \n    bool status;\n  }\n\n  struct UpdateRoleRequest {\n    bytes32 role;\n    address account;\n  }\n\n  event RoleAccountGranted(address indexed sender, bytes32 indexed role, address indexed account);\n\n  event RoleAccountRevoked(address indexed sender, bytes32 indexed role, address indexed account);\n\n  event RoleRegistered(\n    address indexed sender,\n    bytes32 indexed role,\n    string indexed name,\n    bytes32 group,\n    bool isEnabled\n  );\n\n  event RoleStatusChanged(address indexed sender, bytes32 indexed role, bytes32 indexed group, bool status);\n\n  event RoleGroupChanged(address indexed sender, bytes32 indexed role, bytes32 indexed newGroup, bytes32 oldGroup);\n\n  function registerRole(\n    string calldata name,\n    bytes32 group,\n    bool status\n  ) external returns (bytes32);\n\n  function batchRegisterRole(RegiterRoleRequest[] calldata requests) external returns(bytes32[] memory);\n\n  function grantRoleAccount(bytes32 role, address account) external returns (bool);\n\n  function batchGrantRoleAccount(UpdateRoleRequest[] calldata requests) external returns (bool);\n\n  function revokeRoleAccount(bytes32 role, address account) external returns (bool);\n\n  function batchRevokeRoleAccount(UpdateRoleRequest[] calldata requests) external returns (bool);\n\n  function setRoleStatus(bytes32 role, bool status) external returns (bool);\n\n  function setRoleGroup(bytes32 role, bytes32 group) external returns (bool);\n\n  function getRoleInfo(bytes32 role)\n    external\n    view\n    returns (\n      string memory,\n      bytes32,\n      bool\n    );\n\n  function getRoleAccounts(bytes32 role) external view returns (address[] memory);\n\n  function hasRoleAccount(bytes32 role, address account) external view returns (bool);\n}\n"
    },
    "src/contracts/acl/IContextManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IContextManagement {\n  enum UpdateContextStatus {\n    DISABLE,\n    ENABLE,\n    REMOVE\n  }\n\n  struct RequestContext {\n    bytes32 name;\n    bytes32 version;\n    bytes32 realm;\n    address contractId;\n    bool status;\n  }\n\n   struct RequestPredictContext {\n    bytes32 name;\n    bytes32 version;\n    bytes32 realm;\n    bytes32 salt;\n    address subject;\n    address deployer;\n    bool status;\n  }\n\n  struct RequestRegisterContext {\n    bytes32 role;\n    bytes4[] funcSelectors;\n    bool isEnabled;\n  }\n\n  struct RequestUpdateContext {\n    bytes32 role;\n    bytes4[] funcSelectors;\n    UpdateContextStatus updateStatus;\n  }\n\n  struct ResponseContext {\n    bytes32 name;\n    bytes32 version;\n    bytes32 realm;\n    address contractId;\n    bool isSafeMode;\n    bool isUpgradable;\n  }\n\n  event ContextRegistered(bytes32 indexed context, address indexed contractId, address indexed sender, address signer, bytes32 realm);\n\n  event PredictContextRegistered(bytes32 indexed context, address indexed contractId, address indexed sender, address signer, address deployer, address subject, bytes32 realm);\n\n  event ContextUpdated(bytes32 indexed context, address indexed contractId, address indexed sender, bytes32 realm);\n\n  event ContextStatusChanged(bytes32 indexed context, address indexed sender, bytes32 indexed realm, bool status);\n\n  event ContextFuncRoleAdded(\n    bytes32 indexed context,\n    bytes32 indexed role,\n    address indexed sender,\n    bytes4 functionSelector,\n    bytes32 realm\n  );\n\n  event ContextFuncRemoved(bytes32 indexed context, address indexed sender, bytes4 functionSelector, bytes32 realm);\n\n  event ContextRoleGranted(\n    bytes32 indexed context,\n    bytes32 indexed role,\n    address indexed sender,\n    bytes4 functionSelector,\n    bytes32 realm\n  );\n\n  event ContextRoleRevoked(\n    bytes32 indexed context,\n    bytes32 indexed role,\n    address indexed sender,\n    bytes4 functionSelector,\n    bytes32 realm\n  );\n\n  event ContextRealmChanged(bytes32 indexed context, address indexed sender, bytes32 indexed realm, bytes32 oldRealm);\n\n  function registerContext(\n    bytes memory signature,\n    RequestContext calldata rc,\n    RequestRegisterContext[] calldata rcr\n  ) external returns (bytes32);\n\n  function registerPredictContext(\n    bytes memory signature,\n    RequestPredictContext calldata rpc,\n    RequestRegisterContext[] calldata rrc\n  ) external returns (bytes32);\n\n  function updateContext(\n    bytes32 ctx,\n    bytes memory signature,\n    RequestContext calldata rc,\n    RequestUpdateContext[] calldata ruc\n  ) external returns (address);\n\n  function addContextFuncRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool);\n\n  function removeContextFunc(bytes32 ctx, bytes4 functionSelector) external returns (bool);\n\n  function grantContextRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool);\n\n  function revokeContextRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool);\n\n  function setContextRealm(bytes32 ctx, bytes32 realm) external returns (bool);\n\n  function setContextStatus(bytes32 ctx, bool status) external returns (bool);\n\n  function hasContextRole(\n    bytes32 ctx,\n    bytes32 role,\n    bytes4 functionSelector\n  ) external view returns (bool);\n\n  function getContextInfo(bytes32 ctx) external view returns (ResponseContext memory);\n\n  function getContextFuncs(bytes32 ctx) external view returns (bytes4[] memory);\n}\n"
    },
    "src/contracts/lib/struct/LEnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary LEnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n    return _values(set._inner);\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(AddressSet storage set) internal view returns (address[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/contracts/lib/struct/LEnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./LEnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) \n * - `address -> uint256` (`AddressToUintMap`) \n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) \n * - `uint256 -> uint256` (`UintToUintMap`) \n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) \n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an array of EnumerableMap.\n * ====\n */\nlibrary LEnumerableMap {\n    using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        LEnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToUintMap storage map,\n        uint256 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToUintMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key), errorMessage));\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        AddressToUintMap storage map,\n        address key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, key, errorMessage));\n    }\n}\n"
    },
    "src/contracts/lib/acl/LContextManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../LContextUtils.sol\";\nimport \"./LAccessControl.sol\";\nimport \"../cryptography/LECDSA.sol\";\nimport \"../proxy/LClones.sol\";\n\nlibrary LContextManagement {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LClones for address;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LContextManagement\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  bytes32 public constant TYPE_HASH =\n    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n  \n  bytes32 public constant CTX_MESSAGE_TYPEHASH =\n    keccak256(\"Context(address contractId,string name,string version,string realm)\");\n  \n  bytes32 public constant PREDICT_CTX_MESSAGE_TYPEHASH =\n    keccak256(\"PredictContext(address deployer,address subject,string realm)\");\n\n  function registerAccessControlManagerContext(\n    AccessControlStorage.DataCollections storage data,\n    address newContract,\n    bytes32 realm,\n    IContextManagement.RequestRegisterContext[] calldata rc\n  ) external returns (bytes32) {\n    return _registerContext(data, newContract, realm, true, rc);\n  }\n\n  function registerContext(\n    AccessControlStorage.DataCollections storage data,\n    bytes memory signature,\n    IContextManagement.RequestContext calldata rc,\n    IContextManagement.RequestRegisterContext[] calldata rrc\n  ) external returns (bytes32, address) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n\n    bytes32 structHash = _getContextMessageHash(rc.contractId, rc.name, rc.version, rc.realm);\n    bytes32 msgDigest = _hashTypedDataV4(structHash);\n    (address msgSigner, LECDSA.RecoverError recoverErr) = LECDSA.tryRecover(msgDigest, signature);\n\n    require(recoverErr == LECDSA.RecoverError.NoError, \"Illegal ECDASA Signature\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msgSigner,\n        IContextManagement.registerContext.selector\n      ),\n      \"RegisterContext Access Denied\"\n    );\n    return (_registerContext(data, rc.contractId, rc.realm, rc.status, rrc), msgSigner);\n  }\n\n  function registerPredictContext(\n      AccessControlStorage.DataCollections storage data,\n      bytes memory signature,\n      IContextManagement.RequestPredictContext calldata rpc,\n      IContextManagement.RequestRegisterContext[] calldata rrc\n  ) external returns (address, bytes32, address) {\n        require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n\n    bytes32 structHash = _getPredictContextMessageHash(rpc.deployer, rpc.subject, rpc.realm);\n    bytes32 msgDigest = _hashTypedDataV4(structHash);\n    (address msgSigner, LECDSA.RecoverError recoverErr) = LECDSA.tryRecover(msgDigest, signature);\n\n    require(recoverErr == LECDSA.RecoverError.NoError, \"Illegal ECDASA Signature\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msgSigner,\n        IContextManagement.registerContext.selector\n      ),\n      \"RegisterPredictContext Access Denied\"\n    );\n\n    (address contractId, bytes32 ctx) = _registerPredictContext(data, rrc, rpc);\n    return (contractId, ctx, msgSigner);\n  }\n\n\n  function _getContextMessageHash(\n    address contractId,\n    bytes32 name,\n    bytes32 version,\n    bytes32 realm\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(CTX_MESSAGE_TYPEHASH, contractId, name, version, realm));\n  }\n\n  function _getPredictContextMessageHash(\n    address deployer,\n    address subject,\n    bytes32 realm\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(PREDICT_CTX_MESSAGE_TYPEHASH, deployer, subject, realm));\n  }\n\n  function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {\n    return LECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          TYPE_HASH,\n          IProxy(address(this)).contractName(),\n          IProxy(address(this)).contractVersion(),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  function _registerContext(\n    AccessControlStorage.DataCollections storage data,\n    address newContract,\n    bytes32 realm,\n    bool status,\n    IContextManagement.RequestRegisterContext[] calldata rrc\n  ) private returns (bytes32) {\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    bytes32 ctx = LContextUtils.generateCtx(newContract);\n    require(data.ctxMap[ctx].contractId == address(0), \"Context Already Registered\");\n    data.realmMap[realm].ctxSet.add(ctx);\n    AccessControlStorage.Context storage newContext = data.ctxMap[ctx];\n    newContext.realm = realm;\n    newContext.contractId = newContract;\n    newContext.isEnabled = status;\n\n    for (uint256 i = 0; i < rrc.length; i++) {\n      require(bytes(data.roleMap[rrc[i].role].name).length != 0, \"Role Not Found\");\n      for (uint256 j = 0; j < rrc[i].funcSelectors.length; j++) {\n        newContext.resources[rrc[i].funcSelectors[j]].role = rrc[i].role;\n        newContext.resources[rrc[i].funcSelectors[j]].status = rrc[i].isEnabled\n          ? AccessControlStorage.Status.ENABLED\n          : AccessControlStorage.Status.DISABLED;\n        newContext.funcSet.add(rrc[i].funcSelectors[j]);\n      }\n    }\n\n    return ctx;\n  }\n\n  function _registerPredictContext(\n    AccessControlStorage.DataCollections storage data,\n    IContextManagement.RequestRegisterContext[] calldata rrc,\n    IContextManagement.RequestPredictContext calldata rpc\n  ) private returns (address, bytes32) {\n    require(bytes(data.realmMap[rpc.realm].name).length != 0, \"Realm Not Found\");\n\n    address predictedContractId = rpc.subject.predictDeterministicAddress(rpc.salt, rpc.deployer);\n    bytes32 ctx = LContextUtils.generateCtx(predictedContractId);\n\n    require(data.ctxMap[ctx].contractId == address(0), \"Context Already Registered\");\n    data.realmMap[rpc.realm].ctxSet.add(ctx);\n    AccessControlStorage.Context storage newContext = data.ctxMap[ctx];\n    newContext.realm = rpc.realm;\n    newContext.contractId = predictedContractId;\n    newContext.isEnabled = rpc.status;\n\n    for (uint256 i = 0; i < rrc.length; i++) {  \n      require(bytes(data.roleMap[rrc[i].role].name).length != 0, \"Role Not Found\");\n      for (uint256 j = 0; j < rrc[i].funcSelectors.length; j++) {\n        newContext.resources[rrc[i].funcSelectors[j]].role = rrc[i].role;\n        newContext.resources[rrc[i].funcSelectors[j]].status = rrc[i].isEnabled\n          ? AccessControlStorage.Status.ENABLED\n          : AccessControlStorage.Status.DISABLED;\n        newContext.funcSet.add(rrc[i].funcSelectors[j]);\n      }\n    }\n\n    return (predictedContractId, ctx);\n  }\n\n  function updateContext(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes memory signature,\n    IContextManagement.RequestContext calldata rc,\n    IContextManagement.RequestUpdateContext[] calldata ruc\n  ) external returns (address, address) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n\n    bytes32 structHash = _getContextMessageHash(rc.contractId, rc.name, rc.version, rc.realm);\n    bytes32 msgDigest = _hashTypedDataV4(structHash);\n    (address msgSigner, LECDSA.RecoverError recoverErr) = LECDSA.tryRecover(msgDigest, signature);\n    require(recoverErr == LECDSA.RecoverError.NoError, \"Illegal ECDASA Signature\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msgSigner,\n        IContextManagement.updateContext.selector\n      ),\n      \"UpdateContext Access Denied\"\n    );\n    return (_updateContext(data, ctx, rc.realm, rc.status, ruc), msgSigner);\n  }\n\n  function _updateContext(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes32 realm,\n    bool status,\n    IContextManagement.RequestUpdateContext[] calldata ruc\n  ) internal returns (address) {\n    address contractId = data.ctxMap[ctx].contractId;\n    require(contractId != address(0), \"Context Not Found\");\n    require(contractId == msg.sender, \"Update Context Forbidden\");\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    data.ctxMap[ctx].isEnabled = status;\n\n    if (data.ctxMap[ctx].realm != realm) {\n      data.realmMap[data.ctxMap[ctx].realm].ctxSet.remove(ctx);\n      data.realmMap[realm].ctxSet.add(ctx);\n    }\n    data.ctxMap[ctx].realm = realm;\n\n    for (uint256 i = 0; i < ruc.length; i++) {\n      require(bytes(data.roleMap[ruc[i].role].name).length != 0, \"Role Not Found\");\n      for (uint256 j = 0; j < ruc[i].funcSelectors.length; j++) {\n        if (\n          ruc[i].updateStatus == IContextManagement.UpdateContextStatus.ENABLE ||\n          ruc[i].updateStatus == IContextManagement.UpdateContextStatus.DISABLE\n        ) {\n          data.ctxMap[ctx].resources[ruc[i].funcSelectors[j]].role = ruc[i].role;\n          data.ctxMap[ctx].resources[ruc[i].funcSelectors[j]].status = ruc[i].updateStatus ==\n            IContextManagement.UpdateContextStatus.ENABLE\n            ? AccessControlStorage.Status.ENABLED\n            : AccessControlStorage.Status.DISABLED;\n          if (!data.ctxMap[ctx].funcSet.contains(ruc[i].funcSelectors[j])) {\n            data.ctxMap[ctx].funcSet.add(ruc[i].funcSelectors[j]);\n          }\n        } else {\n          delete data.ctxMap[ctx].resources[ruc[i].funcSelectors[j]].role;\n          delete data.ctxMap[ctx].resources[ruc[i].funcSelectors[j]].status;\n          data.ctxMap[ctx].funcSet.remove(ruc[i].funcSelectors[j]);\n        }\n      }\n    }\n    return contractId;\n  }\n\n  function addContextFuncRole(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.addContextFuncRole.selector\n      ),\n      \"AddContextFuncRole Access Denied\"\n    );\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(!data.ctxMap[ctx].funcSet.contains(functionSelector), \"FunctionSelector Already Exists\");\n    data.ctxMap[ctx].resources[functionSelector].role = role;\n    data.ctxMap[ctx].resources[functionSelector].status = AccessControlStorage.Status.ENABLED;\n    data.ctxMap[ctx].funcSet.add(functionSelector);\n    return data.ctxMap[ctx].realm;\n  }\n\n  function removeContextFunc(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes4 functionSelector\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.removeContextFunc.selector\n      ),\n      \"RemoveContextFunc Access Denied\"\n    );\n\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Remove ACL Context\");\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    require(data.ctxMap[ctx].funcSet.contains(functionSelector), \"FunctionSelector Not Found\");\n    delete data.ctxMap[ctx].resources[functionSelector].role;\n    delete data.ctxMap[ctx].resources[functionSelector].status;\n    data.ctxMap[ctx].funcSet.remove(functionSelector);\n    return data.ctxMap[ctx].realm;\n  }\n\n  function grantContextRole(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.grantContextRole.selector\n      ),\n      \"GrantContextRole Access Denied\"\n    );\n\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Grant ACL Context\");\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(data.ctxMap[ctx].funcSet.contains(functionSelector), \"FunctionSelector Not Found\");\n    data.ctxMap[ctx].resources[functionSelector].role = role;\n    data.ctxMap[ctx].resources[functionSelector].status = AccessControlStorage.Status.ENABLED;\n    return data.ctxMap[ctx].realm;\n  }\n\n  function revokeContextRole(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.revokeContextRole.selector\n      ),\n      \"RevokeContextRole Access Denied\"\n    );\n\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Revoke ACL Context\");\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(data.ctxMap[ctx].funcSet.contains(functionSelector), \"FunctionSelector Not Found\");\n    data.ctxMap[ctx].resources[functionSelector].status = AccessControlStorage.Status.DISABLED;\n    return data.ctxMap[ctx].realm;\n  }\n\n  function setContextStatus(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bool status\n  ) external returns (bool, bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.setContextStatus.selector\n      ),\n      \"SetContextStatus Access Denied\"\n    );\n\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Change ACL Context Status\");\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    data.ctxMap[ctx].isEnabled = status;\n    return (true, data.ctxMap[ctx].realm);\n  }\n\n  function setContextRealm(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes32 realm\n  ) external returns (bool, bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.setContextRealm.selector\n      ),\n      \"SetContextRealm Access Denied\"\n    );\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Change ACL Context Realm\");\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    require(data.ctxMap[ctx].realm != realm, \"Illegal Realm Duplication\");\n    bytes32 oldRealm = data.ctxMap[ctx].realm;\n    data.realmMap[realm].ctxSet.add(ctx);\n    data.realmMap[data.ctxMap[ctx].realm].ctxSet.remove(ctx);\n    return (true, oldRealm);\n  }\n\n  function hasContextRole(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes32 role,\n    bytes4 functionSelector\n  ) external view returns (bool) {\n    return\n      data.ctxMap[ctx].contractId != address(0) &&\n      data.ctxMap[ctx].resources[functionSelector].role == role &&\n      data.ctxMap[ctx].resources[functionSelector].status == AccessControlStorage.Status.ENABLED;\n  }\n\n  function getContextInfo(AccessControlStorage.DataCollections storage data, bytes32 ctx)\n    external\n    view\n    returns (IContextManagement.ResponseContext memory)\n  {\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    bytes32 name = IProxy(data.ctxMap[ctx].contractId).contractName();\n    bytes32 version = IProxy(data.ctxMap[ctx].contractId).contractVersion();\n    bool isSafeMode = IProxy(data.ctxMap[ctx].contractId).isSafeMode();\n    bool isUpgradable = IProxy(data.ctxMap[ctx].contractId).isUpgradable();\n\n    return\n      IContextManagement.ResponseContext({\n        name: name,\n        version: version,\n        contractId: data.ctxMap[ctx].contractId,\n        realm: data.ctxMap[ctx].realm,\n        isSafeMode: isSafeMode,\n        isUpgradable: isUpgradable\n      });\n  }\n\n  function getContextFuncs(AccessControlStorage.DataCollections storage data, bytes32 ctx)\n    external\n    view\n    returns (bytes4[] memory)\n  {\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    bytes4[] memory funcs = new bytes4[](data.ctxMap[ctx].funcSet.length());\n    for (uint32 i = 0; i < data.ctxMap[ctx].funcSet.length(); i++) {\n      funcs[i] = bytes4(data.ctxMap[ctx].funcSet.at(i));\n    }\n    return funcs;\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LAccessControl);\n  }\n}\n"
    },
    "src/contracts/lib/acl/LRoleManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../../acl/IRoleManagement.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../LContextUtils.sol\";\nimport \"./LAccessControl.sol\";\n\nlibrary LRoleManagement {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LRoleManagement\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  function registerRole(\n    AccessControlStorage.DataCollections storage data,\n    string calldata name,\n    bytes32 group,\n    bool isEnabled\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.registerRole.selector\n      ),\n      \"RegisterRole Access Denied\"\n    );\n  \n    return _registerRole(data, name, group, isEnabled);\n  }\n\n  function batchRegisterRole(AccessControlStorage.DataCollections storage data, IRoleManagement.RegiterRoleRequest[] calldata requests) external returns(bytes32[] memory) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.batchRegisterRole.selector\n      ),\n      \"BatchRegisterRole Access Denied\"\n    );\n    bytes32[] memory roles = new bytes32[](requests.length);\n    for(uint i; i < requests.length; i++) {\n      roles[i] = _registerRole(data, requests[i].name, requests[i].group, requests[i].status);\n    }\n    return roles;\n  }\n\n  function _registerRole(\n    AccessControlStorage.DataCollections storage data,\n    string calldata name,\n    bytes32 group,\n    bool isEnabled\n  ) private returns (bytes32) {\n    require(bytes(data.groupMap[group].name).length != 0, \"Group Not Found\");\n    require(bytes(name).length != 0, \"Role Name Invalid\");\n    bytes32 roleKey = keccak256(abi.encodePacked(name));\n    require(bytes(data.roleMap[roleKey].name).length == 0, \"Role Already Registered\");\n\n    data.groupMap[group].roleSet.add(roleKey);\n    AccessControlStorage.Role storage newRole = data.roleMap[roleKey];\n    newRole.name = name;\n    newRole.group = group;\n    newRole.isEnabled = isEnabled;\n    return roleKey;\n  }\n\n\n  function grantRoleAccount(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    address account\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.grantRoleAccount.selector\n      ),\n      \"GrantRoleAccount Access Denied\"\n    );\n\n    _grantRoleAccount(data, role, account);\n    return true;\n  }\n\n  function batchGrantRoleAccount(AccessControlStorage.DataCollections storage data, IRoleManagement.UpdateRoleRequest[] calldata requests) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.batchGrantRoleAccount.selector\n      ),\n      \"BatchGrantRoleAccount Access Denied\"\n    );\n    for(uint i; i < requests.length; i++) {\n      _grantRoleAccount(data, requests[i].role, requests[i].account);\n    }\n    return true;\n  }\n\n   function _grantRoleAccount(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    address account\n  ) private returns (bool) {\n    if(role == LAccessControl.LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE) {      \n      require(account.code.length > 0, \"Illegal Grant Community Dao Executor Role\");\n    }\n\n    if(role == LAccessControl.LIVELY_ASSET_MANAGER_ROLE) {      \n      require(account.code.length > 0, \"Illegal Grant Asset Manager Role\");\n    }\n\n    require(role != LAccessControl.LIVELY_ANONYMOUS_ROLE, \"Illegal Grant Anonymous Role\");\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(account != address(0), \"Address Invalid\");\n    data.accountMap[account][role] = AccessControlStorage.Status.ENABLED;\n    if (!data.roleMap[role].accountSet.contains(account)) {\n      data.roleMap[role].accountSet.add(account);\n    }\n    return true;\n  }\n\n  function revokeRoleAccount(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    address account\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.revokeRoleAccount.selector\n      ),\n      \"RevokeRoleAccount Access Denied\"\n    );\n    \n    _revokeRoleAccount(data, role, account);\n    return true;\n  }\n\n  function batchRevokeRoleAccount(AccessControlStorage.DataCollections storage data, IRoleManagement.UpdateRoleRequest[] calldata requests) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.batchRevokeRoleAccount.selector\n      ),\n      \"BatchRevokeRoleAccount Access Denied\"\n    );\n    for(uint i; i < requests.length; i++) {\n      _revokeRoleAccount(data, requests[i].role, requests[i].account);\n    }\n    return true;\n  }\n\n  function _revokeRoleAccount(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    address account\n  ) private returns (bool) {    \n    if (role == LAccessControl.LIVELY_ADMIN_ROLE || role == LAccessControl.LIVELY_SYSTEM_ADMIN_ROLE) {\n      require(data.roleMap[role].accountSet.length() > 1, \"Illegal Revoke Role Account\");    \n    } \n\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(account != address(0), \"Address Invalid\");\n    require(data.roleMap[role].accountSet.contains(account), \"Account Not Found\");\n    require(data.accountMap[account][role] != AccessControlStorage.Status.NONE, \"Account Role Not Found\");\n    data.accountMap[account][role] = AccessControlStorage.Status.DISABLED;\n    data.roleMap[role].accountSet.remove(account);\n    return true;\n  }\n\n  function setRoleStatus(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    bool status\n  ) external returns (bool, bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.setRoleStatus.selector\n      ),\n      \"SetRoleStatus Access Denied\"\n    );\n    require(\n      role != LAccessControl.LIVELY_ANONYMOUS_ROLE &&\n        role != LAccessControl.LIVELY_ADMIN_ROLE &&\n        role != LAccessControl.LIVELY_SYSTEM_ADMIN_ROLE,\n      \"Illegal Change Role Status\"\n    );\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    data.roleMap[role].isEnabled = status;\n    return (true, data.roleMap[role].group);\n  }\n\n  function setRoleGroup(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    bytes32 group\n  ) external returns (bool, bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.setRoleGroup.selector\n      ),\n      \"SetRoleGroup Access Denied\"\n    );\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(bytes(data.groupMap[group].name).length != 0, \"Group Not Found\");\n    require(data.roleMap[role].group != group, \"Illegal Group Duplication\");\n    bytes32 oldGroup = data.roleMap[role].group;\n    data.groupMap[data.roleMap[role].group].roleSet.remove(role);\n    data.groupMap[group].roleSet.add(role);\n    data.roleMap[role].group = group;\n    return (true, oldGroup);\n  }\n\n  function getRoleInfo(AccessControlStorage.DataCollections storage data, bytes32 role)\n    external\n    view\n    returns (\n      string memory,\n      bytes32,\n      bool\n    )\n  {\n    return (data.roleMap[role].name, data.roleMap[role].group, data.roleMap[role].isEnabled);\n  }\n\n  function getRoleAccounts(AccessControlStorage.DataCollections storage data, bytes32 role)\n    external\n    view\n    returns (address[] memory)\n  {\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    return data.roleMap[role].accountSet.values();\n  }\n\n  function hasRoleAccount(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    address account\n  ) external view returns (bool) {\n    return\n      bytes(data.roleMap[role].name).length != 0 &&\n      account != address(0) &&\n      data.accountMap[account][role] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LAccessControl);\n  }\n}\n"
    },
    "src/contracts/lib/acl/LGroupManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../../acl/IGroupManagement.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../LContextUtils.sol\";\nimport \"./LAccessControl.sol\";\n\nlibrary LGroupManagement {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LGroupManagement\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  function registerGroup(\n    AccessControlStorage.DataCollections storage data,\n    string calldata name,\n    bool status\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IGroupManagement.registerGroup.selector\n      ),\n      \"RegisterGroup Access Denied\"\n    );\n    require(bytes(name).length != 0, \"Group Name Invalid\");\n    bytes32 groupKey = keccak256(abi.encodePacked(name));\n    require(bytes(data.groupMap[groupKey].name).length == 0, \"Group Already Registered\");\n\n    AccessControlStorage.Group storage newGroup = data.groupMap[groupKey];\n    newGroup.name = name;\n    newGroup.isEnabled = status;\n    return groupKey;\n  }\n\n  function setGroupStatus(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 group,\n    bool status\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n\n    if (group == LAccessControl.LIVELY_GENERAL_GROUP) {\n      bytes32 context = LContextUtils.generateCtx(address(this));\n      bytes4 signature = IRealmManagement.setRealmStatus.selector;\n      bytes32 role = data.ctxMap[context].resources[signature].role;\n      require(\n        data.ctxMap[context].isEnabled &&\n          data.ctxMap[context].resources[signature].status == AccessControlStorage.Status.ENABLED &&\n          data.realmMap[data.ctxMap[context].realm].isEnabled &&\n          data.accountMap[msg.sender][role] == AccessControlStorage.Status.ENABLED,\n        \"SetGroupStatus Access Denied\"\n      );\n    } else {\n      require(\n        LAccessControl.hasAccess(\n          data,\n          LContextUtils.generateCtx(address(this)),\n          msg.sender,\n          IGroupManagement.setGroupStatus.selector\n        ),\n        \"SetGroupStatus Access Denied\"\n      );\n    }\n    require(bytes(data.groupMap[group].name).length != 0, \"Group Not Found\");\n    data.groupMap[group].isEnabled = status;\n    return true;\n  }\n\n  function hasGroupRole(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 group,\n    bytes32 role\n  ) external view returns (bool) {\n    return bytes(data.groupMap[group].name).length != 0 && data.groupMap[group].roleSet.contains(role);\n  }\n\n  function getGroupInfo(AccessControlStorage.DataCollections storage data, bytes32 group)\n    external\n    view\n    returns (string memory, bool)\n  {\n    return (data.groupMap[group].name, data.groupMap[group].isEnabled);\n  }\n\n  function getGroupRoles(AccessControlStorage.DataCollections storage data, bytes32 group)\n    external\n    view\n    returns (bytes32[] memory)\n  {\n    return data.groupMap[group].roleSet.values();\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LAccessControl);\n  }\n}\n"
    },
    "src/contracts/lib/acl/LRealmManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../../acl/IRealmManagement.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../LContextUtils.sol\";\nimport \"./LAccessControl.sol\";\n\nlibrary LRealmManagement {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LRealmManagement\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  function registerRealm(\n    AccessControlStorage.DataCollections storage data,\n    string calldata name,\n    bool status,\n    bool isUpgradable\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRealmManagement.registerRealm.selector\n      ),\n      \"RegisterRealm Access Denied\"\n    );\n    require(bytes(name).length != 0, \"Realm Name Invalid\");\n    bytes32 realmKey = keccak256(abi.encodePacked(name));\n    require(bytes(data.realmMap[realmKey].name).length == 0, \"Realm Already Registered\");\n\n    AccessControlStorage.Realm storage newRealm = data.realmMap[realmKey];\n    newRealm.name = name;\n    newRealm.isEnabled = status;\n    newRealm.isUpgradable = isUpgradable;\n    return realmKey;\n  }\n\n  function setRealmStatus(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 realm,\n    bool status\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    if (LAccessControl.LIVELY_GENERAL_REALM == realm) {\n      bytes32 context = LContextUtils.generateCtx(address(this));\n      bytes4 signature = IRealmManagement.setRealmStatus.selector;\n      bytes32 role = data.ctxMap[context].resources[signature].role;\n      require(\n        data.ctxMap[context].isEnabled &&\n          data.ctxMap[context].resources[signature].status == AccessControlStorage.Status.ENABLED &&\n          data.groupMap[data.roleMap[role].group].isEnabled &&\n          data.accountMap[msg.sender][role] == AccessControlStorage.Status.ENABLED,\n        \"SetRealmStatus Access Denied\"\n      );\n    } else {\n      require(\n        LAccessControl.hasAccess(\n          data,\n          LContextUtils.generateCtx(address(this)),\n          msg.sender,\n          IRealmManagement.setRealmStatus.selector\n        ),\n        \"SetRealmStatus Access Denied\"\n      );\n    }\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    data.realmMap[realm].isEnabled = status;\n    return true;\n  }\n\n  function setRealmUpgradeStatus(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 realm,\n    bool status\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRealmManagement.setRealmUpgradeStatus.selector\n      ),\n      \"SetRealmUpgradeStatus Access Denied\"\n    );\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    data.realmMap[realm].isUpgradable = status;\n    return true;\n  }\n\n  function hasRealmContext(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 realm,\n    bytes32 context\n  ) external view returns (bool) {\n    return bytes(data.realmMap[realm].name).length != 0 && data.realmMap[realm].ctxSet.contains(context);\n  }\n\n  function getRealmInfo(AccessControlStorage.DataCollections storage data, bytes32 realm)\n    external\n    view\n    returns (\n      string memory,\n      bool,\n      bool\n    )\n  {\n    return (data.realmMap[realm].name, data.realmMap[realm].isEnabled, data.realmMap[realm].isUpgradable);\n  }\n\n  function getRealmContexts(AccessControlStorage.DataCollections storage data, bytes32 realm)\n    external\n    view\n    returns (bytes32[] memory)\n  {\n    return data.realmMap[realm].ctxSet.values();\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LAccessControl);\n  }\n}\n"
    },
    "src/contracts/lib/acl/LAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../acl/IRoleManagement.sol\";\nimport \"../../acl/IGroupManagement.sol\";\nimport \"../../acl/IRealmManagement.sol\";\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../LContextUtils.sol\";\n\nlibrary LAccessControl {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LAccessControl\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  bytes32 public constant LIVELY_GENERAL_REALM = keccak256(abi.encodePacked(\"LIVELY_GENERAL_REALM\"));\n  bytes32 public constant LIVELY_ASSET_REALM = keccak256(abi.encodePacked(\"LIVELY_ASSET_REALM\"));\n\n  bytes32 public constant LIVELY_GENERAL_GROUP = keccak256(abi.encodePacked(\"LIVELY_GENERAL_GROUP\"));\n  bytes32 public constant LIVELY_DAO_GROUP = keccak256(abi.encodePacked(\"LIVELY_DAO_GROUP\"));\n  bytes32 public constant LIVELY_ASSET_GROUP = keccak256(abi.encodePacked(\"LIVELY_ASSET_GROUP\"));\n\n  bytes32 public constant LIVELY_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_SYSTEM_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_SYSTEM_ADMIN_ROLE\"));\n  \n  bytes32 public constant LIVELY_ASSET_MANAGER_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_MANAGER_ROLE\"));\n  bytes32 public constant LIVELY_ASSET_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_ADMIN_ROLE\"));\n  \n  bytes32 public constant LIVELY_COMMUNITY_DAO_ROLE = keccak256(abi.encodePacked(\"LIVELY_COMMUNITY_DAO_ROLE\"));  \n  bytes32 public constant LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE = keccak256(abi.encodePacked(\"LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE\"));\n  \n  bytes32 public constant LIVELY_ANONYMOUS_ROLE = keccak256(abi.encodePacked(\"LIVELY_ANONYMOUS_ROLE\"));\n\n  function initializeContext(AccessControlStorage.DataCollections storage data) external {\n    data.accountMap[msg.sender][LIVELY_ADMIN_ROLE] = AccessControlStorage.Status.ENABLED;\n    data.accountMap[msg.sender][LIVELY_SYSTEM_ADMIN_ROLE] = AccessControlStorage.Status.ENABLED;\n\n    data.roleMap[LIVELY_ADMIN_ROLE].name = \"LIVELY_ADMIN_ROLE\";\n    data.roleMap[LIVELY_ADMIN_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_ADMIN_ROLE].group = LIVELY_GENERAL_GROUP;\n    data.roleMap[LIVELY_ADMIN_ROLE].accountSet.add(msg.sender);\n\n    data.roleMap[LIVELY_SYSTEM_ADMIN_ROLE].name = \"LIVELY_SYSTEM_ADMIN_ROLE\";\n    data.roleMap[LIVELY_SYSTEM_ADMIN_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_SYSTEM_ADMIN_ROLE].group = LIVELY_GENERAL_GROUP;\n    data.roleMap[LIVELY_SYSTEM_ADMIN_ROLE].accountSet.add(msg.sender);\n\n    data.roleMap[LIVELY_ASSET_MANAGER_ROLE].name = \"LIVELY_ASSET_MANAGER_ROLE\";\n    data.roleMap[LIVELY_ASSET_MANAGER_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_ASSET_MANAGER_ROLE].group = LIVELY_ASSET_GROUP;\n\n    data.roleMap[LIVELY_ASSET_ADMIN_ROLE].name = \"LIVELY_ASSET_ADMIN_ROLE\";\n    data.roleMap[LIVELY_ASSET_ADMIN_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_ASSET_ADMIN_ROLE].group = LIVELY_ASSET_GROUP;\n\n    data.roleMap[LIVELY_COMMUNITY_DAO_ROLE].name = \"LIVELY_COMMUNITY_DAO_ROLE\";\n    data.roleMap[LIVELY_COMMUNITY_DAO_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_COMMUNITY_DAO_ROLE].group = LIVELY_DAO_GROUP;\n\n    data.roleMap[LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE].name = \"LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE\";\n    data.roleMap[LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE].group = LIVELY_DAO_GROUP;\n    \n    data.roleMap[LIVELY_ANONYMOUS_ROLE].name = \"LIVELY_ANONYMOUS_ROLE\";\n    data.roleMap[LIVELY_ANONYMOUS_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_ANONYMOUS_ROLE].group = LIVELY_GENERAL_GROUP;\n\n    data.groupMap[LIVELY_GENERAL_GROUP].name = \"LIVELY_GENERAL_GROUP\";\n    data.groupMap[LIVELY_GENERAL_GROUP].isEnabled = true;\n    data.groupMap[LIVELY_GENERAL_GROUP].roleSet.add(LIVELY_ADMIN_ROLE);\n    data.groupMap[LIVELY_GENERAL_GROUP].roleSet.add(LIVELY_SYSTEM_ADMIN_ROLE);\n\n    data.groupMap[LIVELY_DAO_GROUP].name = \"LIVELY_DAO_GROUP\";\n    data.groupMap[LIVELY_DAO_GROUP].isEnabled = true;\n    data.groupMap[LIVELY_DAO_GROUP].roleSet.add(LIVELY_COMMUNITY_DAO_ROLE);\n    data.groupMap[LIVELY_DAO_GROUP].roleSet.add(LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE);\n\n    data.groupMap[LIVELY_ASSET_GROUP].name = \"LIVELY_ASSET_GROUP\";\n    data.groupMap[LIVELY_ASSET_GROUP].isEnabled = true;\n    data.groupMap[LIVELY_ASSET_GROUP].roleSet.add(LIVELY_ASSET_MANAGER_ROLE);\n    data.groupMap[LIVELY_ASSET_GROUP].roleSet.add(LIVELY_ASSET_ADMIN_ROLE);\n\n    data.realmMap[LIVELY_GENERAL_REALM].name = \"LIVELY_GENERAL_REALM\";\n    data.realmMap[LIVELY_GENERAL_REALM].isEnabled = true;\n    data.realmMap[LIVELY_GENERAL_REALM].isUpgradable = true;\n    data.realmMap[LIVELY_GENERAL_REALM].ctxSet.add(LContextUtils.generateCtx(address(this)));\n\n    data.realmMap[LIVELY_ASSET_REALM].name = \"LIVELY_ASSET_REALM\";\n    data.realmMap[LIVELY_ASSET_REALM].isEnabled = true;\n    data.realmMap[LIVELY_ASSET_REALM].isUpgradable = true;  \n  }\n\n  function createRequestContext() external pure returns (IContextManagement.RequestRegisterContext[] memory) {\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n    rrc[0].role = LIVELY_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](22);\n    rrc[0].funcSelectors[0] = IProxy.setUpgradeStatus.selector;\n    rrc[0].funcSelectors[1] = IProxy.setSafeMode.selector;\n    rrc[0].funcSelectors[2] = IContextManagement.addContextFuncRole.selector;\n    rrc[0].funcSelectors[3] = IContextManagement.removeContextFunc.selector;\n    rrc[0].funcSelectors[4] = IContextManagement.grantContextRole.selector;\n    rrc[0].funcSelectors[5] = IContextManagement.revokeContextRole.selector;\n    rrc[0].funcSelectors[6] = IContextManagement.setContextRealm.selector;\n    rrc[0].funcSelectors[7] = IContextManagement.setContextStatus.selector;\n    rrc[0].funcSelectors[8] = IRoleManagement.registerRole.selector;\n    rrc[0].funcSelectors[9] = IRoleManagement.batchRegisterRole.selector;\n    rrc[0].funcSelectors[10] = IRoleManagement.grantRoleAccount.selector;\n    rrc[0].funcSelectors[11] = IRoleManagement.batchGrantRoleAccount.selector;\n    rrc[0].funcSelectors[12] = IRoleManagement.revokeRoleAccount.selector;\n    rrc[0].funcSelectors[13] = IRoleManagement.batchRevokeRoleAccount.selector;\n    rrc[0].funcSelectors[14] = IRoleManagement.setRoleStatus.selector;\n    rrc[0].funcSelectors[15] = IRoleManagement.setRoleGroup.selector;\n    rrc[0].funcSelectors[16] = IGroupManagement.registerGroup.selector;\n    rrc[0].funcSelectors[17] = IGroupManagement.setGroupStatus.selector;\n    rrc[0].funcSelectors[18] = IRealmManagement.registerRealm.selector;\n    rrc[0].funcSelectors[19] = IRealmManagement.setRealmStatus.selector;\n    rrc[0].funcSelectors[20] = IRealmManagement.setRealmUpgradeStatus.selector;\n    rrc[0].funcSelectors[21] = bytes4(keccak256(\"withdrawBalance(address)\"));\n\n    rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](4);\n    rrc[1].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[1].funcSelectors[1] = IProxy.upgradeTo.selector;\n    rrc[1].funcSelectors[2] = IContextManagement.registerContext.selector;\n    rrc[1].funcSelectors[3] = IContextManagement.updateContext.selector;\n\n    return rrc;\n  }\n\n  function hasAccess(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 context,\n    address account,\n    bytes4 signature\n  ) external view returns (bool) {\n    bytes32 role = data.ctxMap[context].resources[signature].role;\n    if (role == LIVELY_ANONYMOUS_ROLE) {\n      return\n        data.ctxMap[context].isEnabled &&\n        data.ctxMap[context].resources[signature].status == AccessControlStorage.Status.ENABLED;\n    } else {\n      return\n        data.ctxMap[context].isEnabled &&\n        data.ctxMap[context].resources[signature].status == AccessControlStorage.Status.ENABLED &&\n        data.realmMap[data.ctxMap[context].realm].isEnabled &&\n        data.groupMap[data.roleMap[role].group].isEnabled &&\n        data.accountMap[account][role] == AccessControlStorage.Status.ENABLED;\n    }\n  }\n\n  function isLivelySystemAdminRole(AccessControlStorage.DataCollections storage data, address account)\n    external\n    view\n    returns (bool)\n  {\n    return data.accountMap[account][LIVELY_SYSTEM_ADMIN_ROLE] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isLivelyAdminRole(AccessControlStorage.DataCollections storage data, address account) external view returns (bool) {\n    return data.accountMap[account][LIVELY_ADMIN_ROLE] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isLivelyAssetManagerRole(AccessControlStorage.DataCollections storage data, address account) external view returns (bool) {\n    return data.accountMap[account][LIVELY_ASSET_MANAGER_ROLE] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isLivelyAssetAdminRole(AccessControlStorage.DataCollections storage data, address account) external view returns (bool) {\n    return data.accountMap[account][LIVELY_ASSET_ADMIN_ROLE] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isLivelyCommunityDaoRole(AccessControlStorage.DataCollections storage data, address account) external view returns (bool) {\n    return data.accountMap[account][LIVELY_COMMUNITY_DAO_ROLE] == AccessControlStorage.Status.ENABLED;  \n  }\n\n  function isLivelyCommunityDaoExecutorRole(AccessControlStorage.DataCollections storage data, address account) external view returns (bool) {\n    return data.accountMap[account][LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isLivelyGeneralGroup(AccessControlStorage.DataCollections storage data, bytes32 role) external view returns (bool) {\n    return data.groupMap[LIVELY_GENERAL_GROUP].roleSet.contains(role);\n  }\n\n  function isLivelyAssetGroup(AccessControlStorage.DataCollections storage data, bytes32 role) external view returns (bool) {\n    return data.groupMap[LIVELY_ASSET_GROUP].roleSet.contains(role);\n  }\n\n  function isLivelyDaoGroup(AccessControlStorage.DataCollections storage data, bytes32 role) external view returns (bool) {\n    return data.groupMap[LIVELY_DAO_GROUP].roleSet.contains(role);\n  }\n\n  function isLivelyGeneralRealm(AccessControlStorage.DataCollections storage data, bytes32 context)\n    external\n    view\n    returns (bool)\n  {\n    return data.realmMap[LIVELY_GENERAL_REALM].ctxSet.contains(context);\n  }\n\n  function isLivelyAssetRealm(AccessControlStorage.DataCollections storage data, bytes32 context)\n    external\n    view\n    returns (bool)\n  {\n    return data.realmMap[LIVELY_ASSET_REALM].ctxSet.contains(context);\n  }\n\n\n  function isContextSafeMode(AccessControlStorage.DataCollections storage data, bytes32 context) external view returns (bool) {\n    return IProxy(data.ctxMap[context].contractId).isSafeMode();\n  }\n\n  function isContextUpgradable(AccessControlStorage.DataCollections storage data, bytes32 context)\n    external\n    view\n    returns (bool)\n  {\n    return IProxy(data.ctxMap[context].contractId).isUpgradable();\n  }\n\n  function isRealmUpgradable(AccessControlStorage.DataCollections storage data, bytes32 realm) external view returns (bool) {\n    if (bytes(data.realmMap[realm].name).length == 0) return false;\n    return data.realmMap[realm].isUpgradable;\n  }\n\n  function isGroupExists(AccessControlStorage.DataCollections storage data, bytes32 group) external view returns (bool) {\n    return bytes(data.groupMap[group].name).length > 0;\n  }\n\n  function isGroupEnabled(AccessControlStorage.DataCollections storage data, bytes32 group) external view returns (bool) {\n    return bytes(data.groupMap[group].name).length > 0 && data.groupMap[group].isEnabled;\n  }\n\n  function isContextExists(AccessControlStorage.DataCollections storage data, bytes32 context) external view returns (bool) {\n    return data.ctxMap[context].contractId != address(0);\n  }\n\n  function isContextFunctionExists(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 context,\n    bytes4 functionSelector\n  ) external view returns (bool) {\n    return data.ctxMap[context].contractId != address(0) && data.ctxMap[context].funcSet.contains(functionSelector);\n  }\n\n  function isContextFunctionEnabled(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 context,\n    bytes4 functionSelector\n  ) external view returns (bool) {\n    return\n      data.ctxMap[context].contractId != address(0) &&\n      data.ctxMap[context].resources[functionSelector].status == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isContextEnabled(AccessControlStorage.DataCollections storage data, bytes32 context) external view returns (bool) {\n    return data.ctxMap[context].contractId != address(0) && data.ctxMap[context].isEnabled;\n  }\n\n  function isRoleExists(AccessControlStorage.DataCollections storage data, bytes32 role) external view returns (bool) {\n    return bytes(data.roleMap[role].name).length > 0;\n  }\n\n  function isRoleEnabled(AccessControlStorage.DataCollections storage data, bytes32 role) external view returns (bool) {\n    return bytes(data.roleMap[role].name).length > 0 && data.roleMap[role].isEnabled;\n  }\n\n  function isRealmExists(AccessControlStorage.DataCollections storage data, bytes32 realm) external view returns (bool) {\n    return bytes(data.realmMap[realm].name).length > 0;\n  }\n\n  function isRealmEnabled(AccessControlStorage.DataCollections storage data, bytes32 realm) external view returns (bool) {\n    return bytes(data.realmMap[realm].name).length > 0 && data.realmMap[realm].isEnabled;\n  }\n}\n"
    },
    "src/contracts/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../lib/LAddress.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n   * @custom:oz-retyped-from bool\n   */\n  uint16 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private _initializing;\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n   * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n   */\n  modifier initializer() {\n    bool isTopLevelCall = !_initializing;\n    require(\n      (isTopLevelCall && _initialized < 1) || (!LAddress.isContract(address(this)) && _initialized == 1),\n      \"Contract Already Initialized\"\n    );\n    _initialized = 1;\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n   * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n   * used to initialize parent contracts.\n   *\n   * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n   * initialization step. This is essential to configure modules that are added through upgrades and that require\n   * initialization.\n   *\n   * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n   * a contract, executing them in the right order is up to the developer or operator.\n   */\n  modifier reinitializer(uint16 version) {\n    require(!_initializing && _initialized < version, \"Contract Already Initialized\");\n    _initialized = version;\n    _initializing = true;\n    _;\n    _initializing = false;\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n   * {initializer} and {reinitializer} modifiers, directly or indirectly.\n   */\n  modifier onlyInitializing() {\n    require(_initializing, \"Contract Not Initializing\");\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n   * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n   * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n   * through proxies.\n   */\n  function _disableInitializers() internal virtual {\n    require(!_initializing, \"Contract Initializing Invalid\");\n    if (_initialized < type(uint16).max) {\n      _initialized = type(uint16).max;\n    }\n  }\n\n  function _getInitializedCount() internal view returns (uint16) {\n    return _initialized;\n  }\n\n  function _isInitializing() internal view returns (bool) {\n    return _initializing;\n  }\n}\n"
    },
    "src/contracts/proxy/BaseUUPSProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IERC1822.sol\";\nimport \"./IProxy.sol\";\nimport \"./BaseProxy.sol\";\nimport \"./BaseUUPSStorage.sol\";\nimport \"./Initializable.sol\";\nimport \"../lib/LAddress.sol\";\nimport \"../lib/LStorageSlot.sol\";\nimport \"../acl/IAccessControl.sol\";\nimport \"../acl/IContextManagement.sol\";\nimport \"../utils/Message.sol\";\nimport \"../utils/ERC165.sol\";\nimport \"../lib/LContextUtils.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n\n * An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\n\nabstract contract BaseUUPSProxy is\n  BaseUUPSStorage,\n  BaseProxy,\n  Initializable,\n  IProxy,\n  IERC1822Proxiable,\n    Message,\n    ERC165\n{\n  /**\n   * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n   * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n   * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n   * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n   * fail.\n   */\n  modifier onlyProxy() {\n    require(address(this) != __self, \"Illegal Contract Call\");\n    require(_implementation() == __self, \"Proxy Called Invalid\");\n    _;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyLocalAdmin() {\n    require(_getLocalAdmin() == _msgSender(), \"Caller Not Authorized\");\n    _;\n  }\n\n  /**\n   * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n   * callable on the implementing contract but not through proxies.\n   */\n  modifier notDelegated() {\n    require(address(this) == __self, \"Illegal Contract Delegatecall\");\n    _;\n  }\n\n  modifier safeModeCheck() {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    _;\n  }\n\n  modifier aclCheck(bytes4 selector) {\n    require(_hasPermission(selector), \"Access Denied\");\n    _;\n  }\n\n  function _hasPermission(bytes4 selector) internal returns (bool) {\n    if (address(this) == _accessControlManager) {\n      bytes memory data = abi.encodeWithSelector(\n        IAccessControl.hasAccess.selector,\n        LContextUtils.generateCtx(address(this)),\n        _msgSender(),\n        selector\n      );\n      bytes memory returndata = LAddress.functionDelegateCall(_implementation(), data, \"Delegatecall hasAccess Failed\");\n      return uint8(returndata[returndata.length - 1]) == 1;\n    } else {\n      return\n        IAccessControl(_accessControlManager).hasAccess(\n          LContextUtils.generateCtx(address(this)),\n          _msgSender(),\n          selector\n        );\n    }\n  }\n\n  function _isRealmUpgradable() internal returns (bool) {\n    if (address(this) == _accessControlManager) {\n      bytes memory data = abi.encodeWithSelector(IAccessControl.isRealmUpgradable.selector, _domainRealm);\n      bytes memory returndata = LAddress.functionDelegateCall(\n        _implementation(),\n        data,\n        \"Delegatecall isRealmUpgradable Failed\"\n      );\n      return uint8(returndata[returndata.length - 1]) == 1;\n    } else {\n      return IAccessControl(_accessControlManager).isRealmUpgradable(_domainRealm);\n    }\n  }\n\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n   */\n\n  constructor() {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n    // set contract Admin (implementation contract)\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = _msgSender();\n\n    // set _isUpgradable and _isSafeMode of contact\n    _isUpgradable = false;\n    _isSafeMode = true;\n  }\n\n  function __BASE_UUPS_init(\n    string calldata domainName,\n    string calldata domainVersion,\n    bytes32 domainRealm,\n    address accessControl\n  ) internal {\n    __BASE_UUPS_init_unchained(domainName, domainVersion, domainRealm, accessControl);\n  }\n\n  function __BASE_UUPS_init_unchained(\n    string calldata domainName,\n    string calldata domainVersion,\n    bytes32 domainRealm,\n    address accessControl\n  ) internal onlyInitializing {\n    _domainName = keccak256(abi.encodePacked(domainName));\n    _domainVersion = keccak256(abi.encodePacked(domainVersion));\n    _domainRealm = domainRealm;\n    if (accessControl == address(0)) {\n      _accessControlManager = address(this);\n    } else {\n      try IERC165(accessControl).supportsInterface(type(IAccessControl).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid AccessControlManager\");\n      } catch {\n        revert(\"Illegal AccessControlManager\");\n      }\n      _accessControlManager = accessControl;\n    }\n    _isUpgradable = false;\n    _isSafeMode = false;\n    _setLocalAdmin(_msgSender());\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return\n      interfaceId == type(IProxy).interfaceId ||\n      interfaceId == type(IERC1822Proxiable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _implementation() internal view override returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    require(LAddress.isContract(newImplementation), \"Illegal Contract Address\");\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(msg.sender, address(this), newImplementation);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal returns (bytes memory) {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      return LAddress.functionDelegateCall(newImplementation, data, \"Delegatecall Failed\");\n    }\n    return new bytes(0);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal returns (bytes memory) {\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n      return new bytes(0);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"Invalid UUPS Contract\");\n      } catch {\n        revert(\"Illegal UUPS Contract\");\n      }\n\n      try IERC165(newImplementation).supportsInterface(type(IProxy).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid IProxy Contract\");\n      } catch {\n        revert(\"Illegal IProxy Contract\");\n      }\n\n      return _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n\n  /**\n   * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n   * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n   *\n   * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n   * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n   * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n   */\n  function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n    return _IMPLEMENTATION_SLOT;\n  }\n\n  function upgradeTo(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) external virtual onlyProxy returns (bytes memory) {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_isUpgradable, \"Upgrade Call Rejected\");\n    _authorizeUpgrade(newImplementation);\n    return _upgradeToAndCallUUPS(newImplementation, data, forceCall);\n  }\n\n  /**\n   * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n   * {upgradeTo} and {upgradeToAndCall}.\n   *\n   * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n   *\n   * ```solidity\n   * function _authorizeUpgrade(address) internal override onlyOwner {}\n   * ```\n   */\n  function _authorizeUpgrade(address newImplementation) internal virtual {\n    require(newImplementation != _implementation(), \"Illegal New Implementation\");\n    require(_hasPermission(this.upgradeTo.selector), \"Upgrade Context Forbidden\");\n  }\n\n  function localAdmin() external view returns (address) {\n    return _getLocalAdmin();\n  }\n\n  function setLocalAdmin(address newLocalAdmin) external onlyProxy returns (bool) {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_hasPermission(this.setLocalAdmin.selector), \"SetLocalAdmin Forbidden\");\n    require(newLocalAdmin != address(0), \"Address Invalid\");\n    _setLocalAdmin(newLocalAdmin);\n    return true;\n  }\n\n  /**\n   * @dev Returns the current admin.require(!_isSafeMode, \"SafeMode: Call Rejected\");\n   */\n  function _getLocalAdmin() internal view returns (address) {\n    return LStorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 admin slot.\n   */\n  function _setLocalAdmin(address newAdmin) internal {\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    emit LocalAdminChanged(_msgSender(), address(this), newAdmin);\n  }\n\n  // In each upgrade the initialize requirement must be changed\n  function setSafeMode(bool status) external onlyProxy returns (bool) {\n    require(_getInitializedCount() > 0, \"Contract Not Initialized\");\n    require(_hasPermission(this.setSafeMode.selector), \"SetSafeMode Forbidden\");\n    _isSafeMode = status;\n    emit SafeModeChanged(_msgSender(), address(this), _domainRealm, status);\n    return status;\n  }\n\n  function setUpgradeStatus(bool status) external onlyProxy returns (bool) {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_hasPermission(this.setUpgradeStatus.selector), \"SetUpgradeStatus Forbidden\");\n    require(_isRealmUpgradable(), \"Realm Upgrade Forbidden\");\n    _isUpgradable = status;\n    emit UpgradeStatusChanged(_msgSender(), address(this), _domainRealm, status);\n    return status;\n  }\n\n  function contractName() external view returns (bytes32) {\n    return _domainName;\n  }\n\n  function contractVersion() external view returns (bytes32) {\n    return _domainVersion;\n  }\n\n  function contractRealm() external view returns (bytes32) {\n    return _domainRealm;\n  }\n\n  function contractContext() external view returns (bytes32) {\n    return LContextUtils.generateCtx(address(this));\n  }\n\n  function accessControlManager() external view returns (address) {\n    return _accessControlManager;\n  }\n\n  function subjectAddress() external view returns (address) {\n    return _implementation();\n  }\n\n  function isSafeMode() external view returns (bool) {\n    return _isSafeMode;\n  }\n\n  function isUpgradable() external view returns (bool) {\n    return _isUpgradable;\n  }\n\n  function domainSeparator() external view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    return keccak256(abi.encode(_TYPE_HASH, _domainName, _domainVersion, block.chainid, address(this)));\n  }\n\n  function initVersion() external view returns (uint16) {\n    return _getInitializedCount();\n  }\n\n  function withdrawBalance(address recepient) public {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_hasPermission(this.withdrawBalance.selector), \"Withdraw Balance Forbidden\");\n    payable(recepient).transfer(address(this).balance);\n  }\n\n  // solhint-disable-next-line\n  receive() external payable override {}\n\n  // solhint-disable-next-line\n  fallback() external payable override {}\n}\n"
    },
    "src/contracts/proxy/BaseUUPSStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n */\n\nabstract contract BaseUUPSStorage {\n  // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n  bytes32 internal constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n   * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n   */\n  bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  bytes32 internal constant _TYPE_HASH =\n    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n  \n  address internal immutable __self = address(this);\n\n  bytes32 internal _domainName;\n  bytes32 internal _domainVersion;\n  bytes32 internal _domainRealm;\n  address internal _accessControlManager;\n  bool internal _isSafeMode;\n  bool internal _isUpgradable;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[64] private __reserved;\n}\n"
    },
    "src/contracts/proxy/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IBaseProxy.sol\";\n\ninterface IProxy is IBaseProxy {\n  /**\n   * @dev Emitted when the admin account has changed.\n   */\n  event LocalAdminChanged(address indexed sender, address indexed proxy, address newAdmin);\n\n  event SafeModeChanged(address indexed sender, address indexed proxy, bytes32 indexed realm, bool status);\n\n  event UpgradeStatusChanged(address indexed sender, address indexed proxy, bytes32 indexed realm, bool status);\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n   */\n  event Initialized(\n    address indexed sender,\n    address indexed proxy,\n    address indexed subject,\n    string name,\n    string version,\n    bytes32 realm,\n    uint16 initCount\n  );\n\n  function upgradeTo(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) external returns (bytes memory);\n\n  function setSafeMode(bool status) external returns (bool);\n\n  function setUpgradeStatus(bool status) external returns (bool);\n\n  function setLocalAdmin(address newAdmin) external returns (bool);\n\n  function contractName() external view returns (bytes32);\n\n  function contractVersion() external view returns (bytes32);\n\n  function contractRealm() external view returns (bytes32);\n\n  function contractContext() external view returns (bytes32);\n\n  function accessControlManager() external view returns (address);\n\n  function subjectAddress() external view returns (address);\n\n  function isSafeMode() external view returns (bool);\n\n  function isUpgradable() external view returns (bool);\n\n  function localAdmin() external view returns (address);\n\n  function domainSeparator() external view returns (bytes32);\n\n  function initVersion() external view returns (uint16);\n\n}\n"
    },
    "src/contracts/lib/LContextUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the context\n */\nlibrary LContextUtils {\n  function generateCtx(address contractId) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(contractId));\n  }\n}\n"
    },
    "src/contracts/lib/cryptography/LECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../LStrings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary LECDSA {\n  enum RecoverError {\n    NoError,\n    InvalidSignature,\n    InvalidSignatureLength,\n    InvalidSignatureS,\n    InvalidSignatureV\n  }\n\n  function _throwError(RecoverError error) private pure {\n    if (error == RecoverError.NoError) {\n      return; // no error: do nothing\n    } else if (error == RecoverError.InvalidSignature) {\n      revert(\"ECDSA: invalid signature\");\n    } else if (error == RecoverError.InvalidSignatureLength) {\n      revert(\"ECDSA: invalid signature length\");\n    } else if (error == RecoverError.InvalidSignatureS) {\n      revert(\"ECDSA: invalid signature 's' value\");\n    } else if (error == RecoverError.InvalidSignatureV) {\n      revert(\"ECDSA: invalid signature 'v' value\");\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature` or error string. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   *\n   * Documentation for signature generation:\n   * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n   * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n   *\n   */\n  function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n    // Check the signature length\n    // - case 65: r,s,v signature (standard)\n    // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n      return tryRecover(hash, v, r, s);\n    } else if (signature.length == 64) {\n      bytes32 r;\n      bytes32 vs;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        vs := mload(add(signature, 0x40))\n      }\n      return tryRecover(hash, r, vs);\n    } else {\n      return (address(0), RecoverError.InvalidSignatureLength);\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature`. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   */\n  function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n   *\n   * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n   */\n  function tryRecover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address, RecoverError) {\n    bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\n    return tryRecover(hash, v, r, s);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n   */\n  function recover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   */\n  function tryRecover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address, RecoverError) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      return (address(0), RecoverError.InvalidSignatureS);\n    }\n    if (v != 27 && v != 28) {\n      return (address(0), RecoverError.InvalidSignatureV);\n    }\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    if (signer == address(0)) {\n      return (address(0), RecoverError.InvalidSignature);\n    }\n\n    return (signer, RecoverError.NoError);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   */\n  function recover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", LStrings.toString(s.length), s));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Typed Data, created from a\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\n   * to the one signed with the\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n   * JSON-RPC method as part of EIP-712.\n   *\n   * See {recover}.\n   */\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n  }\n}\n"
    },
    "src/contracts/lib/proxy/LClones.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n */\nlibrary LClones {\n  /**\n   * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n   *\n   * This function uses the create opcode, which should never revert.\n   */\n  function clone(address implementation) internal returns (address instance) {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(ptr, 0x14), shl(0x60, implementation))\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      instance := create(0, ptr, 0x37)\n    }\n    require(instance != address(0), \"ERC1167: create failed\");\n  }\n\n  /**\n   * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n   *\n   * This function uses the create2 opcode and a `salt` to deterministically deploy\n   * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n   * the clones cannot be deployed twice at the same address.\n   */\n  function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(ptr, 0x14), shl(0x60, implementation))\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      instance := create2(0, ptr, 0x37, salt)\n    }\n    require(instance != address(0), \"ERC1167: create2 failed\");\n  }\n\n  /**\n   * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n   */\n  function predictDeterministicAddress(\n    address implementation,\n    bytes32 salt,\n    address deployer\n  ) internal pure returns (address predicted) {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(ptr, 0x14), shl(0x60, implementation))\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n      mstore(add(ptr, 0x38), shl(0x60, deployer))\n      mstore(add(ptr, 0x4c), salt)\n      mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n      predicted := keccak256(add(ptr, 0x37), 0x55)\n    }\n  }\n\n  /**\n   * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n   */\n  function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n    return predictDeterministicAddress(implementation, salt, address(this));\n  }\n}\n"
    },
    "src/contracts/proxy/IBaseProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IBaseProxy {\n  event Upgraded(address indexed sender, address indexed proxy, address indexed newImplementation);\n}\n"
    },
    "src/contracts/lib/LStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev String operations.\n */\nlibrary LStrings {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n   */\n  function toHexString(address addr) internal pure returns (string memory) {\n      return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n"
    },
    "src/contracts/lib/LAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary LAddress {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"SendValue Failed\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, \"Call Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Call With Value Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Insufficient Balance For Call\");\n    require(LAddress.isContract(target), \"Illegal Contract Address\");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Static Call Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(LAddress.isContract(target), \"Illegal Contract Address\");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Delegate Call Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory message\n  ) internal returns (bytes memory) {\n    require(LAddress.isContract(target), \"Illegal Contract Address\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return LAddress.verifyCallResult(success, returndata, message);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason using the provided one.\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "src/contracts/proxy/IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n  /**\n   * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n   * address.\n   *\n   * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n   * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n   * function revert if invoked through a proxy.\n   */\n  function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "src/contracts/proxy/BaseProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract BaseProxy {\n  /**\n   * @dev Delegates the current call to `implementation`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _delegate(address implementation) internal virtual {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates the current call to the address returned by `_implementation()`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _fallback() internal virtual {\n    _beforeFallback();\n    _delegate(_implementation());\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  fallback() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n   * is empty.\n   */\n  receive() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n   * call, or as part of the Solidity `fallback` or `receive` functions.\n   *\n   * If overridden should call `super._beforeFallback()`.\n   */\n  function _beforeFallback() internal virtual {}\n}\n"
    },
    "src/contracts/lib/LStorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary LStorageSlot {\n  struct AddressSlot {\n    address value;\n  }\n\n  struct BooleanSlot {\n    bool value;\n  }\n\n  struct Bytes32Slot {\n    bytes32 value;\n  }\n\n  struct Uint256Slot {\n    uint256 value;\n  }\n\n  /**\n   * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n   */\n  function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n   */\n  function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n   */\n  function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n   */\n  function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n}\n"
    },
    "src/contracts/utils/Message.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Message {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n"
    },
    "src/contracts/utils/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "src/contracts/utils/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/token/lively/LivelyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Extra.sol\";\nimport \"./IERC20Pause.sol\";\nimport \"./IERC20Lock.sol\";\nimport \"./LivelyStorage.sol\";\nimport \"../asset/IAssetEntity.sol\";\nimport \"../asset/IAssetManagerERC20.sol\";\nimport \"../asset/ERC20/IAssetERC20.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\nimport \"../../lib/token/LTokenERC20.sol\";\nimport \"../../lib/cryptography/LECDSA.sol\";\nimport \"../../lib/LCounters.sol\";\nimport \"../../lib/math/LBasisPointsMath.sol\";\nimport \"../../lib/math/LSafeMath.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../acl/IContextManagement.sol\";\n\ncontract LivelyToken is LivelyStorage, BaseUUPSProxy, IERC20, IERC20Extra, IERC20Pause, IERC20Lock {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LCounters for LCounters.Counter;\n  using LBasisPointsMath for uint256;\n  using LSafeMath for uint256;\n\n  struct InitRequest {\n    string domainName;\n    string domainVersion;\n    string domainRealm;\n    bytes signature;\n    uint256 taxRateValue;\n    address accessControlManager;\n  }\n\n  constructor() {}\n\n  function lockToken(LockTokenRequest calldata lockRequest) external returns (bytes32) {\n    _policyInterceptor(this.lockToken.selector, lockRequest.source, true, true);\n    return _lockToken(lockRequest);\n  }\n\n  function batchLockToken(LockTokenRequest[] calldata lockRequest) external returns (bytes32[] memory) {\n    _policyInterceptor(this.batchLockToken.selector, address(0), true, false);\n    uint totalAmount = 0;\n    bytes32[] memory lockIds = new bytes32[](lockRequest.length);\n    for (uint i = 0; i < lockRequest.length; i++) {\n      require(!_data.pausedList.contains(lockRequest[i].source), \"ERC20Pause: Account Suspended\");\n      lockIds[i] = _lockToken(lockRequest[i]);\n      totalAmount += lockRequest[i].amount;\n    }\n\n    emit BatchTokenLocked(_msgSender(), totalAmount);\n    return lockIds;\n  }\n\n  function claimToken(bytes32 lockId) external returns (uint256) {\n    _policyInterceptor(this.claimToken.selector, _msgSender(), true, true);\n      return _claimToken(lockId);\n  }\n\n  function batchClaimToken(bytes32[] calldata lockIds) external returns (uint256) {    \n    _policyInterceptor(this.batchClaimToken.selector, _msgSender(), true, true);\n    uint totalAmount = 0;\n    for (uint i = 0; i < lockIds.length; i++) {\n      totalAmount += _claimToken(lockIds[i]);\n    }\n\n    emit BatchTokenClaimed(_msgSender(), totalAmount);\n    return totalAmount;\n  }\n\n  function unlockToken(UnLockTokenRequest calldata unlockRequest) external returns (uint256) {\n    _policyInterceptor(this.unlockToken.selector, unlockRequest.account, true, true);\n    return _unlockToken(unlockRequest);\n  }\n\n  function batchUnlockToken(UnLockTokenRequest[] calldata unlockRequest) external returns (uint256) {\n    _policyInterceptor(this.batchUnlockToken.selector, address(0), true, false);\n    uint totalAmount = 0;\n    for (uint i = 0; i < unlockRequest.length; i++) {\n      require(!_data.pausedList.contains(unlockRequest[i].account), \"ERC20Pause: Account Suspended\");\n      totalAmount += _unlockToken(unlockRequest[i]);\n    }\n\n    emit BatchTokenUnlocked(_msgSender(), totalAmount);\n    return totalAmount;\n  }\n\n  function pause(address account) external {\n    _policyInterceptor(this.pause.selector, address(0), false, false);\n    require(account != address(0), \"Invalid Account Address\");\n    require(!_data.pausedList.contains(account), \"Account Already Paused\");\n    _data.pausedList.add(account);\n    emit Paused(_msgSender(), account);\n  }\n\n  function unpause(address account) external {\n    _policyInterceptor(this.unpause.selector, address(0), false, false);\n    require(account != address(0), \"Invalid Account Address\");\n    require(_data.pausedList.contains(account), \"Account Not Found\");\n    _data.pausedList.remove(account);\n    emit Unpaused(_msgSender(), account);\n  }\n\n  function pauseAll() external {\n    _policyInterceptor(this.pauseAll.selector, address(0), false, false);\n    _isPaused = true;\n    emit PausedAll(_msgSender());\n  }\n\n  function unpauseAll() external {\n    _policyInterceptor(this.unpauseAll.selector, address(0), false, false);\n    _isPaused = false;\n    emit UnpausedAll(_msgSender());\n  }\n\n  function updateTaxRate(uint256 rate) external returns (bool) {\n    _policyInterceptor(this.updateTaxRate.selector, address(0), false, false);\n    _taxRate = rate;\n    emit TaxRateUpdated(_msgSender(), rate);\n    return true;\n  }\n\n  function batchUpdateTaxWhitelist(BatchUpdateTaxWhitelistRequest[] calldata request) external {\n    _policyInterceptor(this.batchUpdateTaxWhitelist.selector, address(0), false, false);\n    for (uint256 i = 0; i < request.length; i++) {\n      _updateTaxWhitelist(request[i].account, request[i].isDeleted);\n    }\n  }\n\n  function updateTaxWhitelist(address account, bool isDeleted) external returns (bool) {\n    _policyInterceptor(this.updateTaxWhitelist.selector, address(0), false, false);\n    return _updateTaxWhitelist(account, isDeleted);\n  }\n\n  function transfer(address recipient, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.transfer.selector, _msgSender(), true, true);\n    if (_taxRate > 0 && !_data.taxWhitelist.contains(_msgSender())) {\n      _taxTransfer(_msgSender(), recipient, amount);\n    } else {\n      _transfer(_msgSender(), recipient, amount);\n    }\n    return true;\n  }\n\n  function transferFrom(address source, address recipient, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.transferFrom.selector, source, true, true);\n    return _transferFrom(source, recipient, amount);\n  }\n\n  function batchTransfer(BatchTransferRequest[] calldata request) external returns (bool) {\n    _policyInterceptor(this.batchTransfer.selector, _msgSender(), true, true);\n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < request.length; i++) {\n      totalAmount += request[i].amount;\n      _transfer(_msgSender(), request[i].to, request[i].amount);\n    }\n\n    emit BatchTransfer(_msgSender(), totalAmount);\n    return true;\n  }\n\n  function batchTransferFrom(BatchTransferFromRequest[] calldata request) external returns (bool) {    \n    _policyInterceptor(this.batchTransferFrom.selector, address(0), true, false);\n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < request.length; i++) {\n      require(!_data.pausedList.contains(request[i].from), \"ERC20Pause: Account Suspended\");\n      totalAmount += request[i].amount;\n      _transferFrom(request[i].from, request[i].to, request[i].amount);\n    }\n\n    emit BatchTransferFrom(_msgSender(), totalAmount);\n    return true;\n  }\n\n  function approve(address spender, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.approve.selector, _msgSender(), true, true);\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.increaseAllowance.selector, _msgSender(), true, true);\n    address owner = _msgSender();\n    uint256 currentAllowance = _allowance(owner, spender) + amount;\n    _approve(owner, spender, currentAllowance);\n    emit ApprovalIncreased(owner, spender, amount);\n    return currentAllowance;\n  }\n\n  function decreaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.decreaseAllowance.selector, _msgSender(), true, true);\n    address owner = _msgSender();\n    _spendAllowance(owner, spender, amount);\n    emit ApprovalDecreased(owner, spender, amount);\n    return _allowance(owner, spender);\n  }\n\n   function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    bytes calldata signature\n  ) external returns (bool) {\n    _policyInterceptor(this.permit.selector, owner, true, true);\n    require(block.timestamp <= deadline, \"Permit Deadline Expired\");\n    bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n    bytes32 hash = LECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    address signer = LECDSA.recover(hash, signature);\n\n    require(signer == owner, \"Illegal ECDASA Signature\");\n    _approve(owner, spender, value);\n    return true;\n  }\n\n  function mint(address account, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.mint.selector, account, true, true);\n    return _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.burn.selector, account, true, true);\n    require(account != address(0), \"Invalid Account Address\");\n    uint256 accountBalance = _data.accounts[account].balance;\n    require(accountBalance >= amount, \"Insufficient Account Balance\");\n    unchecked {\n      _data.accounts[account].balance = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n    emit Burn(_msgSender(), account, amount, _totalSupply);\n    return _totalSupply;\n  }\n\n  function name() external view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() external view returns (string memory) {\n    return _symbol;\n  }\n\n  function totalSupply() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) external view returns (uint256) {\n    return _data.accounts[account].balance;\n  }\n\n  function totalBalanceOf(address account) external view returns (uint256) {\n    return _data.accounts[account].lockBalance + _data.accounts[account].balance;\n  }\n\n  function lockBalanceOf(address account) external view returns (uint256) {\n    return _data.accounts[account].lockBalance;\n  }\n\n  function allowance(address owner, address spender) external view returns (uint256) {\n    return _allowance(owner, spender);\n  }\n\n  function taxRate() external view returns (uint256) {\n    return _taxRate;\n  }\n\n  function taxTreasury() external view returns (address) {\n    return _taxTreasury;\n  }\n\n  function taxWhitelist() external view returns (address[] memory) {\n    return _data.taxWhitelist.values();\n  }\n\n  function nonce(address owner) external view returns (uint256) {\n    return _data.accounts[owner].nonce.current();\n  }\n\n  function isPaused(address account) external view returns (bool) {\n    return account != address(0) && _data.pausedList.contains(account);\n  }\n\n  function isPausedAll() external view returns (bool) {\n    return _isPaused;\n  }\n\n  function pausedAccounts() external view returns (address[] memory) {\n    return _data.pausedList.values();\n  }\n\n  function lockInfo(bytes32 lockId, address account) external view returns (uint256, uint128, uint128, address, uint8) {\n    AssetLock storage lock = _data.locks[account][lockId];\n    return (lock.amount, lock.lockedAt, lock.claimedAt, lock.source, uint8(lock.status));\n  }\n\n  function decimals() external pure returns (uint8) {\n    return 18;\n  }\n\n  function initialize(InitRequest calldata request) public onlyProxy onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(request.domainRealm));\n    __BASE_UUPS_init(request.domainName, request.domainVersion, realm, request.accessControlManager);\n\n    _name = \"LIVELY\";\n    _symbol = \"LVL\";\n    _taxRate = request.taxRateValue;\n    _isTokenDistributed = false;\n    _initContext(request.domainName, request.domainVersion, realm, request.signature);\n  }\n\n  function _tokensDistributionValidation(address account) private view {\n    require(_data.accounts[account].balance == 0, \"AssetId Already Distributed\");\n  }\n\n  function tokensDistribution(address assetManager, address[7] calldata assets) public safeModeCheck aclCheck(this.tokensDistribution.selector) returns (bool) {\n    require(!_isTokenDistributed, \"Token Already Distributed\");\n\n    try IERC165(assetManager).supportsInterface(type(IAssetManagerERC20).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetManagerERC20\");\n    } catch {\n      revert(\"Illegal IAssetManagerERC20\");\n    }     \n\n    _mint(assetManager, 5_000_000_000 * 10 ** 18);  // 5 billion tokens according to tokenomics\n\n    for (uint i = 0; i < 7; i++) {\n       try IERC165(assets[i]).supportsInterface(type(IAssetEntity).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid IAssetEntity\");\n      } catch {\n        revert(\"Illegal IAssetEntity\");\n      }\n      require(IAssetEntity(assets[i]).assetToken() == address(this), \"Invalid Asset Token\");\n      if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_AUDIO_VIDEO_PROGRAM_ASSET\"))) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 500_000_000 * 10 ** 18);     // 10% \n\n      } else if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_FOUNDING_TEAM_ASSET\"))) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 900_000_000 * 10 ** 18);     // 18%\n\n      } else if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_TREASURY_ASSET\"))) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 750_000_000 * 10 ** 18);     // 15%\n\n      } else if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_PUBLIC_SALE_ASSET\"))) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 2_000_000_000 * 10 ** 18);   // 40%\n\n      } else if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_VALIDATORS_REWARDS_ASSET\"))) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 300_000_000 * 10 ** 18);     // 6%\n\n      } else if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_CROWD_FOUNDING_ASSET\"))) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 550_000_000 * 10 ** 18);     // 11%\n\n      } else if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_TAX_TREASURY_ASSET\"))) {\n        require(_taxTreasury == address(0), \"TaxTreasury Already Registered\");\n        _taxTreasury = assets[i];\n\n      } else {\n        revert(\"Asset Not Supported\");\n      }\n    }\n\n    _isTokenDistributed = true;\n    return true;\n  }\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {  \n    return\n      interfaceId == type(IERC20).interfaceId ||\n      interfaceId == type(IERC20Extra).interfaceId ||\n      interfaceId == type(IERC20Pause).interfaceId ||\n      interfaceId == type(IERC20Lock).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function getLibrary() public pure returns(address) {\n    return address(LTokenERC20);\n  }\n\n  function _initContext(\n    string calldata domainName,\n    string calldata domainVersion,\n    bytes32 realm,\n    bytes calldata signature\n  ) internal {\n    (IContextManagement.RequestContext memory rc, IContextManagement.RequestRegisterContext[] memory rrc) = LTokenERC20\n      .createRequestContext(_domainName, _domainVersion, _domainRealm);\n\n    IContextManagement(_accessControlManager).registerContext(signature, rc, rrc);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      domainName,\n      domainVersion,\n      realm,\n      _getInitializedCount()\n    );\n  }\n\n  function _updateTaxWhitelist(address account, bool isDeleted) internal returns (bool){\n    emit TaxWhitelistUpdated(_msgSender(), account, isDeleted);\n    return LTokenERC20.updateTaxWhitelist(_data, account, isDeleted);\n  }\n\n  function _mint(address account, uint256 amount) internal returns (uint256) {\n    require(account != address(0), \"Invalid Account Address\");\n    _totalSupply += amount;\n    _data.accounts[account].balance += amount;\n    emit Mint(_msgSender(), account, amount, _totalSupply);\n    return _totalSupply;\n  }\n\n  function _transfer(address src, address dest, uint256 amount) internal {\n    LTokenERC20.transfer(_data, src, dest, amount);\n    emit Transfer(src, dest, amount);\n  }\n\n  function _taxTransfer(\n    address source,\n    address recipient,\n    uint256 amount\n  ) internal {\n    uint256 tax = amount.mulBP(_taxRate);\n    uint256 tokensToTransfer = amount.sub(tax, \"Insufficient Transfer Amount\");\n\n    _transfer(source, _taxTreasury, tax);\n    _transfer(source, recipient, tokensToTransfer);\n  }\n\n  function _transferFrom(\n    address source,\n    address recipient,\n    uint256 amount\n  ) internal returns (bool) {\n    address spender = _msgSender();\n    if (_taxRate > 0 && !_data.taxWhitelist.contains(_msgSender())) {\n      _taxTransfer(source, recipient, amount);\n    } else {\n      _transfer(source, recipient, amount);\n    }\n\n    _spendAllowance(source, spender, amount);    \n    emit TransferFrom(spender, source, recipient, amount);\n    return true;\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal {\n    require(owner != address(0), \"Invalid Owner Address\");\n    require(spender != address(0), \"Invalid Spender Address\");\n\n    _data.allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _spendAllowance(address owner, address spender, uint256 amount) internal {\n    uint256 currentAllowance = _allowance(owner, spender);\n    require(currentAllowance >= amount, \"Insufficient Account Allowance\");\n    unchecked {\n      _approve(owner, spender, currentAllowance - amount);\n    }\n  }\n\n  function _useNonce(address owner) internal returns (uint256 current) {\n    LCounters.Counter storage localNonce = _data.accounts[owner].nonce;\n    current = localNonce.current();\n    localNonce.increment();\n  }\n\n  function _lockToken(LockTokenRequest calldata lockRequest) internal returns (bytes32) {\n    bytes32 lockId = LTokenERC20.lockToken(_data, lockRequest);  \n    emit TokenLocked(lockId, _msgSender(), lockRequest.source, lockRequest.dest, lockRequest.timestamp, lockRequest.amount);\n    return lockId;\n  }\n\n  function _claimToken(bytes32 lockId) internal returns (uint256) {\n    uint lockAmount = LTokenERC20.claimToken(_data, lockId);\n    emit TokenClaimed(lockId, _msgSender(), _data.locks[_msgSender()][lockId].source, lockAmount);\n    return lockAmount;\n  }\n\n  function _unlockToken(UnLockTokenRequest calldata unlockRequest) internal returns (uint256) {\n    (address srcAccount, uint lockAmount) = LTokenERC20.unlockToken(_data, unlockRequest);\n    emit TokenUnlocked(unlockRequest.lockId, _msgSender(), unlockRequest.account, srcAccount, lockAmount, unlockRequest.reason);\n    return lockAmount;\n  }\n\n  function _allowance(address owner, address spender) internal view returns (uint256) {\n    return _data.allowances[owner][spender];\n  }\n\n  function _policyInterceptor(bytes4 funcSelector, address account, bool isCheckingTokenPaused, bool isCheckingAccountPaused) private safeModeCheck aclCheck(funcSelector) {\n    if(isCheckingTokenPaused) {\n      require(!_isPaused, \"ERC20Pause: Call Rejected\");\n    }\n\n    if (isCheckingAccountPaused) {\n      require(!_data.pausedList.contains(account), \"ERC20Pause: Account Suspended\");\n    }\n  }\n}\n"
    },
    "src/contracts/token/lively/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "src/contracts/token/lively/IERC20Extra.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IERC20Extra {\n  struct BatchTransferRequest {\n    address to;\n    uint256 amount;\n  }\n\n  struct BatchTransferFromRequest {\n    address from;\n    address to;\n    uint256 amount;\n  }\n\n  struct BatchUpdateTaxWhitelistRequest {\n    address account;\n    bool isDeleted;\n  }\n\n  event ApprovalIncreased(address indexed owner, address indexed spender, uint256 amount);\n\n  event ApprovalDecreased(address indexed owner, address indexed spender, uint256 amount);\n\n  event TransferFrom(address indexed sender, address indexed from, address indexed to, uint256 amount);\n\n  event BatchTransfer(address indexed sender, uint256 totalAmount);\n\n  event BatchTransferFrom(address indexed sender, uint256 totalAmount);\n\n  event TaxRateUpdated(address indexed sender, uint256 rate);\n\n  event TaxWhitelistUpdated(address indexed sender, address indexed account, bool isDeleted);\n\n  event Burn(address indexed sender, address indexed account, uint256 amount, uint256 totalSupply);\n\n  event Mint(address indexed sender, address indexed account, uint256 amount, uint256 totalSupply);\n\n  function increaseAllowance(address spender, uint256 amount) external returns (uint256);\n\n  function decreaseAllowance(address spender, uint256 amount) external returns (uint256);\n\n  function burn(address account, uint256 amount) external returns (uint256);\n\n  function mint(address account, uint256 amount) external returns (uint256);\n\n  function batchTransfer(BatchTransferRequest[] calldata request) external returns (bool);\n\n  function batchTransferFrom(BatchTransferFromRequest[] calldata request) external returns (bool);\n\n  function updateTaxRate(uint256 taxRate) external returns (bool);\n\n  function updateTaxWhitelist(address account, bool isDeleted) external returns (bool);\n\n  function batchUpdateTaxWhitelist(BatchUpdateTaxWhitelistRequest[] calldata request) external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    bytes calldata signature\n  ) external returns (bool);\n\n  function taxRate() external view returns (uint256);\n\n  function taxTreasury() external view returns (address);\n\n  function taxWhitelist() external view returns (address[] memory);\n\n  function nonce(address owner) external view returns (uint256);\n}\n"
    },
    "src/contracts/token/lively/IERC20Pause.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IERC20Pause {\n  event Paused(address indexed sender, address indexed account);\n\n  event Unpaused(address indexed sender, address indexed account);\n\n  event PausedAll(address indexed sender);\n\n  event UnpausedAll(address indexed sender);\n\n  function pause(address account) external;\n\n  function unpause(address account) external;\n\n  function pauseAll() external;\n\n  function unpauseAll() external;\n\n  function isPaused(address account) external view returns (bool);\n\n  function isPausedAll() external view returns (bool);\n\n  function pausedAccounts() external view returns (address[] memory);\n}\n"
    },
    "src/contracts/token/lively/IERC20Lock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IERC20Lock {\n\n  struct LockTokenRequest {\n    address source;\n    address dest;\n    uint256 timestamp;\n    uint256 amount;\n  }\n\n  struct UnLockTokenRequest {\n    bytes32 lockId;\n    address account;\n    string reason;\n  }\n\n  event TokenLocked(bytes32 indexed id, address indexed sender, address indexed src, address account, uint256 timestamp, uint256 amount);\n\n  event TokenClaimed(bytes32 indexed id, address indexed sender, address indexed src, uint256 amount);\n\n  event TokenUnlocked(bytes32 indexed id, address indexed sender, address indexed account, address dest, uint256 amount, string reason);\n\n  event BatchTokenClaimed(address indexed sender, uint256 totalAmount);\n\n  event BatchTokenUnlocked(address indexed sender, uint256 totalAmount);\n\n  event BatchTokenLocked(address indexed sender, uint256 totalAmount);\n\n  function lockToken(LockTokenRequest calldata lockRequest) external returns (bytes32);\n\n  function batchLockToken(LockTokenRequest[] calldata lockRequest) external returns (bytes32[] memory);\n\n  function unlockToken(UnLockTokenRequest calldata unlockRequest) external returns (uint256);\n\n  function batchUnlockToken(UnLockTokenRequest[] calldata unlockRequest) external returns (uint256);\n\n  function claimToken(bytes32 lockId) external returns (uint256);\n\n  function batchClaimToken(bytes32[] calldata lockIds) external returns (uint256);\n\n  function lockInfo(bytes32 lockId, address account) external view returns (uint256, uint128, uint128, address, uint8);\n\n  function totalBalanceOf(address account) external view returns (uint256);\n\n  function lockBalanceOf(address account) external view returns (uint256);\n\n}"
    },
    "src/contracts/token/lively/LivelyStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../proxy/BaseUUPSStorage.sol\";\nimport \"../../lib/LCounters.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\n\nabstract contract LivelyStorage is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LCounters for LCounters.Counter;\n\n  enum LockState {\n    NONE,\n    LOCKED,\n    CLAIMED,\n    UNLOCKED\n  }\n\n  struct AccountInfo {\n    uint256 balance;\n    uint256 lockBalance;\n    LCounters.Counter nonce;\n  }\n\n  struct AssetLock {\n    uint256 amount;\n    uint128 lockedAt;\n    uint128 claimedAt;\n    address source;\n    LockState status;    \n  }\n\n  struct DataCollection {\n    mapping(address => AccountInfo) accounts;\n    mapping(address => mapping(address => uint256)) allowances;\n    mapping(address => mapping(bytes32 => AssetLock)) locks;\n    LEnumerableSet.AddressSet pausedList;\n    LEnumerableSet.AddressSet taxWhitelist;\n  }\n\n  bytes32 internal constant _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n  string internal _name;\n  string internal _symbol;\n  uint256 internal _totalSupply;\n  uint256 internal _taxRate;\n  address internal _taxTreasury;\n  bool internal _isPaused;\n  bool internal _isTokenDistributed;\n\n  DataCollection internal _data;\n\n  // Note: for next upgrade add new variables after this line\n}\n"
    },
    "src/contracts/token/asset/IAssetEntity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IAssetEntity {\n\n  enum Status {\n    NONE,\n    ACTIVE,\n    SAFE_MODE\n  }\n\n  enum AssetType {\n    NONE,\n    ERC20,\n    ERC721,\n    ERC1155\n  }\n\n  event AssetInitialized(\n    address indexed sender,\n    address indexed assetId,\n    address indexed tokenId,\n    address assetManager,\n    address assetSubject,\n    string name,\n    string version,\n    bytes32 realm,\n    bytes32 role\n  );\n  \n  event AssetSafeModeChanged(address indexed sender, address indexed assetId, bytes32 indexed realm, bool status);\n\n  function assetSafeModeSet(bool status) external returns (bool);\n\n  function assetSafeMode() external view returns (bool);\n\n  function assetType() external view returns (AssetType);\n\n  function assetToken() external view returns (address);\n\n  function assetName() external view returns (bytes32);\n\n  function assetVersion() external view returns (bytes32);\n\n  function assetRealm() external view returns (bytes32);\n\n  function assetRole() external view returns (bytes32);\n\n  function assetAcl() external view returns (address);\n\n  function assetInitVersion() external view returns (uint16);\n}"
    },
    "src/contracts/token/asset/IAssetManagerERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../lively/IERC20Extra.sol\";\nimport \"../lively/IERC20Lock.sol\";\nimport \"./IAssetEntity.sol\";\n\ninterface IAssetManagerERC20 {\n\n  struct CreateAssetRequest {\n    bytes32 role; \n    bytes32 salt;\n    address tokenId; \n    string assetName; \n    string assetVersion;     \n  }\n\n  event AssetSubjectUpdated(address indexed sender, address indexed assetSubject);\n\n  event TokenRegistered(address indexed sender, address indexed tokenId, string tokenName, string tokenSymbol);\n  \n  event AssetCreated(address indexed sender, address indexed assetId, address indexed tokenId, address assetSubject);\n\n  event AssetRegistered(address indexed sender, address indexed assetId, address indexed tokenId);\n\n  event AssetRemoved(address indexed sender, address indexed assetId, address indexed tokenId);\n  \n  event TokenSafeModeChanged(address indexed sender, address indexed tokenId, bool isEnabled);\n\n  function createAsset(CreateAssetRequest calldata request) external returns (address);\n\n  function updateAssetSubject(address assetSubject, bytes calldata assetCreationSignature) external returns (bool);\n\n  function registerToken(address tokenId) external returns (bool);\n\n  function registerAsset(address assetId) external returns (bool);\n\n  function removeAsset(address assetId) external returns (bool);\n\n  function setSafeModeToken(address tokenId, bool isEnabled) external returns (bool);\n\n  function tokenLock(address assetId, IERC20Lock.LockTokenRequest calldata lockRequest) external returns (bytes32);\n\n  function tokenBatchLock(address assetId, IERC20Lock.LockTokenRequest[] calldata lockRequests) external returns (bytes32[] memory);\n\n  function tokenTransfer(address assetId, address to, uint256 amount) external returns (bool);\n\n  function tokenBatchTransfer(address assetId, IERC20Extra.BatchTransferRequest[] calldata request) external returns (bool);\n\n  function tokenTransferFrom(address assetId, address from, address to, uint256 amount) external returns (bool);\n\n  function tokenBatchTransferFrom(address assetId, IERC20Extra.BatchTransferFromRequest[] calldata request) external returns (bool);\n\n  function tokenApprove(address assetId, address spender, uint256 amount) external returns (bool);\n\n  function tokenIncreaseAllowance(address assetId, address spender, uint256 amount) external returns (uint256);\n\n  function tokenDecreaseAllowance(address assetId, address spender, uint256 amount) external returns (uint256);\n\n  function getAllTokens() external view returns(address[] memory);\n\n  function getTokenInfo(address tokenId) external view returns (IAssetEntity.Status, address[] memory);\n\n  function isAssetExists(address assetId) external view returns (bool);\n\n  function isTokenExists(address tokenId) external view returns (bool);\n\n  function getAssetSubject() external view returns (address);\n\n  function predictAddress(address implementation, bytes32 salt, address deployer) external view returns (address);\n}"
    },
    "src/contracts/token/asset/ERC20/IAssetERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../lively/IERC20Extra.sol\";\nimport \"../../lively/IERC20Lock.sol\";\n\ninterface IAssetERC20 {\n\n  event AssetERC20Called(address indexed sender, address indexed assetId, bytes4 indexed functionSelector);\n\n  function tokenLock(IERC20Lock.LockTokenRequest calldata lockRequest) external returns (bytes32);\n\n  function tokenBatchLock(IERC20Lock.LockTokenRequest[] calldata lockRequests) external returns (bytes32[] memory);\n\n  function tokenTransfer(address to, uint256 amount) external returns (bool);\n\n  function tokenBatchTransfer(IERC20Extra.BatchTransferRequest[] calldata request) external returns (bool);\n\n  function tokenTransferFrom(address from, address to, uint256 amount) external returns (bool);\n\n  function tokenBatchTransferFrom(IERC20Extra.BatchTransferFromRequest[] calldata request) external returns (bool);\n\n  function tokenApprove(address spender, uint256 amount) external returns (bool);\n\n  function tokenIncreaseAllowance(address spender, uint256 amount) external returns (uint256);\n\n  function tokenDecreaseAllowance(address spender, uint256 amount) external returns (uint256);\n\n  function tokenBalance() external view returns (uint256); \n\n  function assetBalance() external view returns (uint256); \n}"
    },
    "src/contracts/lib/token/LTokenERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../token/lively/IERC20.sol\";\nimport \"../../token/lively/IERC20Extra.sol\";\nimport \"../../token/lively/IERC20Pause.sol\";\nimport \"../../token/lively/IERC20Lock.sol\";\nimport \"../../token/lively/LivelyStorage.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../acl/IAccessControl.sol\";\nimport \"../struct/LEnumerableSet.sol\";\n\nlibrary LTokenERC20 {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LTokenERC20\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  bytes32 public constant LIVELY_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_SYSTEM_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_SYSTEM_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_ANONYMOUS_ROLE = keccak256(abi.encodePacked(\"LIVELY_ANONYMOUS_ROLE\"));\n  bytes32 public constant LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE = keccak256(abi.encodePacked(\"LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE\"));\n  bytes32 public constant LIVELY_ASSET_MANAGER_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_MANAGER_ROLE\"));\n\n  function createRequestContext(\n    bytes32 domainName,\n    bytes32 domainVersion,\n    bytes32 realm\n  )\n    external\n    view\n    returns (IContextManagement.RequestContext memory, IContextManagement.RequestRegisterContext[] memory)\n  {\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](5);\n    rrc[0].role = LIVELY_ANONYMOUS_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](10);\n    rrc[0].funcSelectors[0] = IERC20.transfer.selector;\n    rrc[0].funcSelectors[1] = IERC20.transferFrom.selector;\n    rrc[0].funcSelectors[2] = IERC20.approve.selector;\n    rrc[0].funcSelectors[3] = IERC20Extra.batchTransfer.selector;\n    rrc[0].funcSelectors[4] = IERC20Extra.batchTransferFrom.selector;\n    rrc[0].funcSelectors[5] = IERC20Extra.permit.selector;\n    rrc[0].funcSelectors[6] = IERC20Extra.increaseAllowance.selector;\n    rrc[0].funcSelectors[7] = IERC20Extra.decreaseAllowance.selector;\n    rrc[0].funcSelectors[8] = IERC20Lock.claimToken.selector;\n    rrc[0].funcSelectors[9] = IERC20Lock.batchClaimToken.selector;\n\n    rrc[1].role = LIVELY_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](12);\n    rrc[1].funcSelectors[0] = IProxy.setUpgradeStatus.selector;\n    rrc[1].funcSelectors[1] = IProxy.setSafeMode.selector;\n    rrc[1].funcSelectors[2] = IERC20Extra.burn.selector;\n    rrc[1].funcSelectors[3] = IERC20Extra.mint.selector;\n    rrc[1].funcSelectors[4] = IERC20Extra.updateTaxRate.selector;\n    rrc[1].funcSelectors[5] = IERC20Extra.updateTaxWhitelist.selector;   \n    rrc[1].funcSelectors[6] = IERC20Extra.batchUpdateTaxWhitelist.selector;\n    rrc[1].funcSelectors[7] = IERC20Pause.pause.selector;\n    rrc[1].funcSelectors[8] = IERC20Pause.unpause.selector;\n    rrc[1].funcSelectors[9] = IERC20Pause.pauseAll.selector;\n    rrc[1].funcSelectors[10] = IERC20Pause.unpauseAll.selector;\n    rrc[1].funcSelectors[11] = bytes4(keccak256(\"withdrawBalance(address)\"));\n\n    rrc[2].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[2].isEnabled = true;\n    rrc[2].funcSelectors = new bytes4[](2);\n    rrc[2].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[2].funcSelectors[1] = IProxy.upgradeTo.selector;\n\n    rrc[3].role = LIVELY_ASSET_MANAGER_ROLE;\n    rrc[3].isEnabled = true;\n    rrc[3].funcSelectors = new bytes4[](3);\n    rrc[3].funcSelectors[0] = IERC20Lock.lockToken.selector;  \n    rrc[3].funcSelectors[1] = IERC20Lock.batchLockToken.selector;  \n    rrc[3].funcSelectors[2] = bytes4(keccak256(\"tokensDistribution(address,address[7])\"));\n    \n    rrc[4].role = LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE;\n    rrc[4].isEnabled = true;\n    rrc[4].funcSelectors = new bytes4[](2);\n    rrc[4].funcSelectors[0] = IERC20Lock.unlockToken.selector;\n    rrc[4].funcSelectors[1] = IERC20Lock.batchUnlockToken.selector;\n\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: domainName,\n      version: domainVersion,\n      realm: realm,\n      contractId: address(this),\n      status: true\n    });\n\n    return (rc, rrc);\n  }\n\n  function lockToken(LivelyStorage.DataCollection storage data, IERC20Lock.LockTokenRequest memory lockRequest) external returns(bytes32) {\n    require(lockRequest.source != address(0), \"Invalid Source Address\");\n    require(lockRequest.dest != address(0), \"Invalid Destination Address\");\n    require(lockRequest.source != lockRequest.dest, \"Illegal Destination Address\");\n    require(lockRequest.timestamp > block.timestamp + 1 days, \"Illegal Timestamp\");\n    require(lockRequest.amount > 0, \"Illegal amount\");\n\n    bytes32 lockId = keccak256(abi.encodePacked(lockRequest.source, lockRequest.dest, lockRequest.timestamp, lockRequest.amount));\n    require(data.locks[lockRequest.dest][lockId].source == address(0), \"LockId Already Exists\");\n    \n    uint256 srcBalance = data.accounts[lockRequest.source].balance;\n    require(srcBalance >= lockRequest.amount, \"Insufficient Account Balance\");\n    unchecked {\n      data.accounts[lockRequest.source].balance = srcBalance - lockRequest.amount;\n    }\n    data.accounts[lockRequest.dest].lockBalance += lockRequest.amount;\n\n    LivelyStorage.AssetLock storage assetLock = data.locks[lockRequest.dest][lockId];\n    assetLock.lockedAt = uint128(block.timestamp);\n    assetLock.claimedAt = uint128(lockRequest.timestamp);\n    assetLock.source = lockRequest.source;\n    assetLock.amount = lockRequest.amount;\n    assetLock.status = LivelyStorage.LockState.LOCKED;\n    return lockId;\n  }\n\n  function claimToken(LivelyStorage.DataCollection storage data, bytes32 lockId) external returns(uint256) {\n    require(lockId != bytes32(0), \"Invalid LockId\");\n    require(data.locks[msg.sender][lockId].source != address(0), \"LockId Not Found\");\n    require(data.locks[msg.sender][lockId].claimedAt < uint128(block.timestamp), \"Illegal Claim Lock\");\n\n    uint256 lockAmount = data.locks[msg.sender][lockId].amount;\n    uint256 lockBalance = data.accounts[msg.sender].lockBalance;\n    require(lockBalance >= lockAmount, \"Insufficient Account Lock Balance\");\n    unchecked {\n      data.accounts[msg.sender].lockBalance = lockBalance - lockAmount;\n    }\n    data.accounts[msg.sender].balance += lockAmount;\n    data.locks[msg.sender][lockId].status = LivelyStorage.LockState.CLAIMED;\n    return lockAmount;\n  }  \n\n  function unlockToken(LivelyStorage.DataCollection storage data, IERC20Lock.UnLockTokenRequest calldata unlockRequest) external returns (address, uint256) {\n    require(unlockRequest.lockId != bytes32(0), \"Invalid LockId\");\n    require(data.locks[unlockRequest.account][unlockRequest.lockId].source != address(0), \"LockId Not Found\");\n    require(data.locks[unlockRequest.account][unlockRequest.lockId].status == LivelyStorage.LockState.LOCKED, \"Invalid Lock State\");\n\n    uint256 lockAmount = data.locks[unlockRequest.account][unlockRequest.lockId].amount;\n    uint256 lockBalance = data.accounts[unlockRequest.account].lockBalance;\n    address srcAccount = data.locks[unlockRequest.account][unlockRequest.lockId].source;    \n    require(lockBalance >= lockAmount, \"Insufficient Account Lock Balance\");\n    unchecked {\n      data.accounts[unlockRequest.account].lockBalance = lockBalance - lockAmount;\n    }\n    data.accounts[srcAccount].balance += lockAmount;\n    data.locks[unlockRequest.account][unlockRequest.lockId].status = LivelyStorage.LockState.UNLOCKED;\n    return (srcAccount,lockAmount);\n  }\n\n  function transfer(LivelyStorage.DataCollection storage data, address src, address dest, uint256 amount) external {\n    require(src != address(0), \"Invalid Source Address\");\n    require(dest != address(0), \"Invalid Destination Address\");\n    require(src != dest, \"Illegal Self Transfer\");\n    require(amount > 0, \"Invalid Transfer Amount\");\n\n    uint256 srcBalance = data.accounts[src].balance;\n    require(srcBalance >= amount, \"Insufficient Account Balance\");\n    unchecked {\n      data.accounts[src].balance = srcBalance - amount;\n    }\n    data.accounts[dest].balance += amount;\n  }\n\n  function updateTaxWhitelist(LivelyStorage.DataCollection storage data, address account, bool isDeleted) external returns (bool){\n    require(account != address(0), \"Invalid Account Address\");\n    if (isDeleted) {\n      require(data.taxWhitelist.contains(account), \"Account Not Found\");\n      data.taxWhitelist.remove(account);\n    } else {\n      require(!data.taxWhitelist.contains(account), \"Account Already Exists\");\n      data.taxWhitelist.add(account);\n    }\n\n    return true;\n  }\n\n}\n"
    },
    "src/contracts/lib/LCounters.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary LCounters {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    unchecked {\n      counter._value += 1;\n    }\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n    unchecked {\n      counter._value = value - 1;\n    }\n  }\n\n  function reset(Counter storage counter) internal {\n    counter._value = 0;\n  }\n}\n"
    },
    "src/contracts/lib/math/LBasisPointsMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport \"./LSafeMath.sol\";\n\nlibrary LBasisPointsMath {\n  using LSafeMath for uint256;\n\n  uint256 private constant _BASIS_POINTS = 10000;\n\n  function mulBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    return amt.mul(bp).div(_BASIS_POINTS);\n  }\n\n  function divBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    require(bp > 0, \"Illegal Divide Zero\");\n    return amt.mul(_BASIS_POINTS).div(bp);\n  }\n\n  function addBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    if (amt == 0) return 0;\n    if (bp == 0) return amt;\n    return amt.add(mulBP(amt, bp));\n  }\n\n  function subBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    if (amt == 0) return 0;\n    if (bp == 0) return amt;\n    return amt.sub(mulBP(amt, bp));\n  }\n}\n"
    },
    "src/contracts/lib/math/LSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary LSafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, with an overflow flag.\n   */\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      uint256 c = a + b;\n      if (c < a) return (false, 0);\n      return (true, c);\n    }\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n   */\n  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b > a) return (false, 0);\n      return (true, a - b);\n    }\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n   */\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n      // benefit is lost if 'b' is also tested.\n      // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n      if (a == 0) return (true, 0);\n      uint256 c = a * b;\n      if (c / a != b) return (false, 0);\n      return (true, c);\n    }\n  }\n\n  /**\n   * @dev Returns the division of two unsigned integers, with a division by zero flag.\n   */\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b == 0) return (false, 0);\n      return (true, a / b);\n    }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n   */\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b == 0) return (false, 0);\n      return (true, a % b);\n    }\n  }\n\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   *\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   *\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator.\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * reverting when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a % b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {trySub}.\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b <= a, errorMessage);\n      return a - b;\n    }\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b > 0, errorMessage);\n      return a / b;\n    }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * reverting with custom message when dividing by zero.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {tryMod}.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b > 0, errorMessage);\n      return a % b;\n    }\n  }\n}\n"
    },
    "src/contracts/token/asset/ERC20/AssetERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IAssetERC20.sol\";\nimport \"../IAssetEntity.sol\";\nimport \"../IAssetManagerERC20.sol\";\nimport \"../../lively/IERC20.sol\";\nimport \"../../../proxy/Initializable.sol\";\nimport \"../../../utils/Message.sol\";\nimport \"../../../utils/ERC165.sol\";\nimport \"../../../lib/cryptography/LECDSA.sol\";\nimport \"../../../lib/LContextUtils.sol\";\nimport \"../../../lib/LAddress.sol\";\nimport \"../../../acl/IAccessControl.sol\";\nimport \"../../../acl/IContextManagement.sol\";\n\ncontract AssetERC20 is Initializable, Message, ERC165, IAssetERC20, IAssetEntity {\n  using LAddress for address;\n\n  struct InitRequest {\n    bytes32 domainRealm;\n    bytes32 assetRole;\n    bytes32 salt;\n    address subject;\n    address erc20Token;\n    address accessControl;\n    address assetManager;\n    string domainName;\n    string domainVersion;\n    bytes signature;\n  }\n\n  bytes32 private constant _LIVELY_ASSET_GROUP = keccak256(abi.encodePacked(\"LIVELY_ASSET_GROUP\"));\n  bytes32 private constant _LIVELY_ASSET_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_ADMIN_ROLE\"));\n  bytes32 private constant _LIVELY_ASSET_MANAGER_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_MANAGER_ROLE\"));\n\n  address private _accessControlManager;\n  address private _erc20Token;\n  bytes32 private _domainName;\n  bytes32 private _domainVersion;\n  bytes32 private _domainRealm;\n  bytes32 private _assetRole;\n  bool private _isSafeMode;\n  \n  constructor() { _isSafeMode = true; }\n\n  function initialize(InitRequest calldata request) public initializer {\n\n    try IERC165(request.erc20Token).supportsInterface(type(IERC20).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid ERC20Token Address\");\n    } catch {\n      revert(\"Illegal ERC20Token Address\");\n    }\n\n    try IERC165(request.erc20Token).supportsInterface(type(IERC20Extra).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid ERC20TokenExtra Address\");\n    } catch {\n      revert(\"Illegal ERC20TokenExtra Address\");\n    }\n\n    try IERC165(request.erc20Token).supportsInterface(type(IERC20Lock).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid ERC20TokenLock Address\");\n    } catch {\n      revert(\"Illegal ERC20TokenLock\");\n    }\n\n    try IERC165(request.accessControl).supportsInterface(type(IAccessControl).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid AccessControlManager\");\n    } catch {\n      revert(\"Illegal AccessControlManager\");\n    }     \n\n    try IERC165(request.assetManager).supportsInterface(type(IAssetManagerERC20).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetManagerERC20\");\n    } catch {\n      revert(\"Illegal IAssetManagerERC20\");\n    }     \n\n    _accessControlManager = request.accessControl;\n    require(IAccessControl(_accessControlManager).isRoleEnabled(request.assetRole), \"Role Not Found OR Disabled \");\n\n    _domainRealm = request.domainRealm;    \n    _domainName = keccak256(abi.encodePacked(request.domainName));\n    _domainVersion = keccak256(abi.encodePacked(request.domainVersion));    \n    _erc20Token = request.erc20Token;\n    _assetRole = request.assetRole;\n    _isSafeMode = false;\n  \n    (IContextManagement.RequestPredictContext memory rpc, IContextManagement.RequestRegisterContext[] memory rrc) = \n      _createRequestContext(_domainName, _domainVersion, _domainRealm, _assetRole, request.salt, request.subject, request.assetManager);\n\n    IContextManagement(_accessControlManager).registerPredictContext(request.signature, rpc, rrc);\n\n    emit AssetInitialized(\n      _msgSender(),\n      address(this),\n      _erc20Token,\n      request.assetManager,\n      request.subject,\n      request.domainName,\n      request.domainVersion,\n      _domainRealm,\n      _assetRole      \n    );\n  }\n\n  function _createRequestContext(\n    bytes32 domainName,\n    bytes32 domainVersion,\n    bytes32 realm,\n    bytes32 role,\n    bytes32 salt,\n    address subject,\n    address deployer\n  )\n    internal\n    pure\n    returns (IContextManagement.RequestPredictContext memory, IContextManagement.RequestRegisterContext[] memory)\n  {\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n\n    rrc[0].role = _LIVELY_ASSET_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](1);\n    rrc[0].funcSelectors[0] = this.assetSafeModeSet.selector;\n\n    rrc[1].role = role;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](10);\n    rrc[1].funcSelectors[0] = IAssetERC20.tokenLock.selector;\n    rrc[1].funcSelectors[1] = IAssetERC20.tokenBatchLock.selector;\n    rrc[1].funcSelectors[2] = IAssetERC20.tokenTransfer.selector;\n    rrc[1].funcSelectors[3] = IAssetERC20.tokenBatchTransfer.selector;\n    rrc[1].funcSelectors[4] = IAssetERC20.tokenTransferFrom.selector;\n    rrc[1].funcSelectors[5] = IAssetERC20.tokenBatchTransferFrom.selector;\n    rrc[1].funcSelectors[6] = IAssetERC20.tokenApprove.selector;\n    rrc[1].funcSelectors[7] = IAssetERC20.tokenIncreaseAllowance.selector;\n    rrc[1].funcSelectors[8] = IAssetERC20.tokenDecreaseAllowance.selector;\n    rrc[1].funcSelectors[9] = this.withdrawBalance.selector;\n\n    IContextManagement.RequestPredictContext memory rpc = IContextManagement.RequestPredictContext({\n      name: domainName,\n      version: domainVersion,\n      realm: realm,\n      salt: salt,\n      subject: subject, \n      deployer: deployer,\n      status: true\n    });\n\n    return (rpc, rrc);\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return\n      interfaceId == type(IAssetEntity).interfaceId ||\n      interfaceId == type(IAssetERC20).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function tokenLock(IERC20Lock.LockTokenRequest calldata lockRequest) external returns (bytes32) {\n    _policyInterceptor(this.tokenLock.selector);\n    require(lockRequest.source == address(this), \"Illegal Source Addres\");\n\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenLock.selector);\n    return IERC20Lock(_erc20Token).lockToken(lockRequest);\n  }\n\n  function tokenBatchLock(IERC20Lock.LockTokenRequest[] calldata lockRequests) external returns (bytes32[] memory) {\n    _policyInterceptor(this.tokenBatchLock.selector);\n    for(uint i = 0; i < lockRequests.length; i++) {\n      require(lockRequests[i].source == address(this), \"Illegal Source Addres\");\n    }\n\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenBatchLock.selector);  \n    return IERC20Lock(_erc20Token).batchLockToken(lockRequests);\n  }\n\n  function tokenTransfer(address to, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.tokenTransfer.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenTransfer.selector);\n    return IERC20(_erc20Token).transfer(to, amount);\n  }\n\n  function tokenBatchTransfer(IERC20Extra.BatchTransferRequest[] calldata request) external returns (bool) {\n    _policyInterceptor(this.tokenBatchTransfer.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenBatchTransfer.selector);\n    return IERC20Extra(_erc20Token).batchTransfer(request);\n  }\n\n  function tokenTransferFrom(address from, address to, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.tokenTransferFrom.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenTransferFrom.selector);\n    return IERC20(_erc20Token).transferFrom(from, to, amount);\n  }\n\n  function tokenBatchTransferFrom(IERC20Extra.BatchTransferFromRequest[] calldata request) external returns (bool) {\n    _policyInterceptor(this.tokenBatchTransferFrom.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenBatchTransferFrom.selector);\n    return IERC20Extra(_erc20Token).batchTransferFrom(request);\n  }\n\n  function tokenApprove(address spender, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.tokenApprove.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenApprove.selector);\n    return IERC20(_erc20Token).approve(spender, amount);\n  }\n\n  function tokenIncreaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.tokenIncreaseAllowance.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenIncreaseAllowance.selector);\n    return IERC20Extra(_erc20Token).increaseAllowance(spender, amount);\n  }\n\n  function tokenDecreaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.tokenDecreaseAllowance.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenDecreaseAllowance.selector);\n    return IERC20Extra(_erc20Token).decreaseAllowance(spender, amount);\n  }\n\n  function assetSafeModeSet(bool status) override public returns (bool) {\n    require(IAccessControl(_accessControlManager).hasAccess(LContextUtils.generateCtx(address(this)),_msgSender(),this.assetSafeModeSet.selector), \"AssetERC20 Access Denied\");\n    require(_getInitializedCount() > 0, \"AssetERC20 Not Initialized\");\n    _isSafeMode = status;    \n    emit AssetSafeModeChanged(_msgSender(), address(this), _domainRealm, status);\n    return status;  \n  }\n\n  function withdrawBalance(address recepient) public {\n    _policyInterceptor(this.withdrawBalance.selector);\n    payable(recepient).transfer(address(this).balance);\n  }\n\n  function assetSafeMode() external view returns (bool) {\n    return _isSafeMode;\n  }\n\n  function assetType() external pure returns (AssetType) {\n    return AssetType.ERC20;\n  }\n\n  function assetToken() external view returns (address) {\n    return _erc20Token;\n  }\n\n  function assetName() external view returns (bytes32) {\n    return _domainName;\n  }\n\n  function assetVersion() external view returns (bytes32) {\n    return _domainVersion;\n  }\n\n  function assetRealm() external view returns (bytes32) {\n    return _domainRealm;\n  }\n\n  function assetRole() external view returns (bytes32) {\n    return _assetRole;\n  }\n\n   function assetAcl() external view returns (address) {\n    return _accessControlManager;\n   }\n\n  function assetInitVersion() external view returns (uint16) {\n    return _getInitializedCount();\n  }\n\n  // solhint-disable-next-line\n  receive() external payable {}\n\n  // solhint-disable-next-line\n  fallback() external payable {}\n\n  function tokenBalance() external view returns (uint256) {\n    return IERC20(_erc20Token).balanceOf(address(this));\n  }\n\n  function assetBalance() external view returns (uint256) {\n    return address(this).balance;\n  }\n\n  function _policyInterceptor(bytes4 funcSelector) private view {\n    require(!_isSafeMode, \"SafeMode: AssetERC20 Call Rejected\");\n    require(IAccessControl(_accessControlManager).hasAccess(LContextUtils.generateCtx(address(this)),_msgSender(),funcSelector), \"AssetERC20 Access Denied\");\n  }\n\n}"
    },
    "src/contracts/test/acl/AccessControlManagerTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./AccessControlStorageTest.sol\";\nimport \"../../acl/IAccessControl.sol\";\nimport \"../../acl/IGroupManagement.sol\";\nimport \"../../acl/IRealmManagement.sol\";\nimport \"../../acl/IRoleManagement.sol\";\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../lib/struct/LEnumerableMap.sol\";\nimport \"../../lib/acl/LContextManagement.sol\";\nimport \"../../lib/acl/LRoleManagement.sol\";\nimport \"../../lib/acl/LGroupManagement.sol\";\nimport \"../../lib/acl/LRealmManagement.sol\";\nimport \"../../lib/acl/LAccessControl.sol\";\nimport \"../../proxy/Initializable.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\ncontract AccessControlManagerTest is\n  AccessControlStorageTest,\n  BaseUUPSProxy\n  // IContextManagement,\n  // IAccessControl,\n  // IGroupManagement,\n  // IRealmManagement,\n  // IRoleManagement\n{\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableMap for LEnumerableMap.Bytes32ToBytes32Map;\n  using LEnumerableMap for LEnumerableMap.AddressToUintMap;\n\n  constructor() {}\n\n  function initialize() public onlyProxy reinitializer(2) {\n    _data.dummy_1 = 100;\n    dummy_2 = keccak256(\"UPDATE_TEST\");\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n    return\n      interfaceId == type(IAccessControl).interfaceId ||\n      interfaceId == type(IContextManagement).interfaceId ||\n      interfaceId == type(IRoleManagement).interfaceId ||\n      interfaceId == type(IGroupManagement).interfaceId ||\n      interfaceId == type(IRealmManagement).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n}\n"
    },
    "src/contracts/test/acl/AccessControlStorageTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../lib/struct/LEnumerableMap.sol\";\nimport \"../../proxy/BaseUUPSStorage.sol\";\n\nabstract contract AccessControlStorageTest is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableMap for LEnumerableMap.Bytes32ToBytes32Map;\n  using LEnumerableMap for LEnumerableMap.AddressToUintMap;\n\n  enum Status {\n    NONE,\n    ENABLED,\n    DISABLED\n  }\n\n  struct RoleStat {\n    bytes32 role;\n    Status status;\n  }\n\n  struct Context {\n    bytes32 realm;\n    address contractId;\n    bool isEnabled;\n    mapping(bytes4 => RoleStat) resources; // function selector => RoleStat\n    LEnumerableSet.Bytes32Set funcSet;\n  }\n\n  struct Role {\n    bytes32 group;\n    string name;\n    bool isEnabled;\n    LEnumerableSet.AddressSet accountSet;\n  }\n\n  struct Realm {\n    string name;\n    bool isEnabled;\n    bool isUpgradable;\n    LEnumerableSet.Bytes32Set ctxSet;\n  }\n\n  struct Group {\n    string name;\n    bool isEnabled;\n    LEnumerableSet.Bytes32Set roleSet;\n  }\n\n  struct DataCollections {\n    mapping(address => mapping(bytes32 => Status)) accountMap;\n    mapping(bytes32 => Context) ctxMap;\n    mapping(bytes32 => Role) roleMap;\n    mapping(bytes32 => Realm) realmMap;\n    mapping(bytes32 => Group) groupMap;\n    uint256 dummy_1;\n  }\n\n  DataCollections internal _data;\n  bytes32 internal dummy_2;\n}\n"
    },
    "src/contracts/utils/MulticallUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../lib/LAddress.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = _functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(LAddress.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return LAddress.verifyCallResult(success, returndata, \"Address: Call Failed\");\n    }\n}\n"
    },
    "src/contracts/test/proxy/ERC1967UpgradeTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../lib/LAddress.sol\";\nimport \"../../lib/LStorageSlot.sol\";\n\nabstract contract ERC1967UpgradeTest {\n  bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n  // invalid\n  bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  event Upgraded(address indexed implementation);\n\n  function _getImplementation() internal view returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    require(LAddress.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      LAddress.functionDelegateCall(newImplementation, data);\n    }\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n      } catch {\n        revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n      }\n      _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Emitted when the admin account has changed.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Returns the current admin.\n   */\n  function _getAdmin() internal view returns (address) {\n    return LStorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 admin slot.\n   */\n  function _setAdmin(address newAdmin) private {\n    require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   *\n   * Emits an {AdminChanged} event.\n   */\n  function _changeAdmin(address newAdmin) internal {\n    emit AdminChanged(_getAdmin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n   * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n   */\n  bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n}\n"
    },
    "src/contracts/test/proxy/UUPSUpgradeableTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../proxy/IERC1822.sol\";\nimport \"./ERC1967UpgradeTest.sol\";\nimport \"../../utils/ERC165.sol\";\n\ncontract UUPSUpgradeableTest is IERC1822Proxiable, ERC1967UpgradeTest, ERC165 {\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n  address private immutable __self = address(this);\n\n  modifier onlyProxy() {\n    require(address(this) != __self, \"Function must be called through delegatecall\");\n    require(_getImplementation() == __self, \"Function must be called through active proxy\");\n    _;\n  }\n\n  modifier notDelegated() {\n    require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n    _;\n  }\n\n  function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n    return _IMPLEMENTATION_SLOT;\n  }\n\n  function upgradeTo(address newImplementation) external virtual onlyProxy {\n    _authorizeUpgrade(newImplementation);\n    _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n  }\n\n  function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n    _authorizeUpgrade(newImplementation);\n    _upgradeToAndCallUUPS(newImplementation, data, true);\n  }\n\n  function _authorizeUpgrade(address newImplementation) internal virtual {}\n}\n"
    },
    "src/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IBaseProxy.sol\";\nimport \"./BaseProxy.sol\";\nimport \"./IERC1822.sol\";\nimport \"./IProxy.sol\";\nimport \"./BaseUUPSStorage.sol\";\nimport \"../lib/LAddress.sol\";\nimport \"../lib/LStorageSlot.sol\";\nimport \"../utils/IERC165.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\n\ncontract Proxy is BaseUUPSStorage, BaseProxy, IBaseProxy {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address logic, bytes memory data) payable {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = msg.sender;\n    _isSafeMode = true;\n    _upgradeToAndCallUUPS(logic, data, false);\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view override returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) private {\n    _setImplementation(newImplementation);\n    emit Upgraded(msg.sender, address(this), _implementation());\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) private returns (bytes memory) {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      return LAddress.functionDelegateCall(newImplementation, data);\n    }\n    return new bytes(0);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) private returns (bytes memory) {\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n      return new bytes(0);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"Invalid UUPS Contract\");\n      } catch {\n        revert(\"Illegal UUPS Contract\");\n      }\n\n      try IERC165(newImplementation).supportsInterface(type(IProxy).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid IProxy Contract\");\n      } catch {\n        revert(\"Illegal IProxy Contract\");\n      }\n      return _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n}\n"
    },
    "src/contracts/token/asset/AssetManagerStorageERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IAssetEntity.sol\";\nimport \"../../proxy/BaseUUPSStorage.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\n\nabstract contract AssetManagerStorageERC20 is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  struct TokenData {    \n    LEnumerableSet.AddressSet assets;\n    IAssetEntity.Status status;\n  }\n\n  struct DataCollection {\n    mapping(address => TokenData) tokens;\n    LEnumerableSet.AddressSet tokensSet;\n  }\n\n  address internal _assetSubjectERC20;\n  bytes internal _assetCreationSignature;\n  DataCollection internal _data;\n\n  // Note: for next upgrade add new variables after this line\n}"
    },
    "src/contracts/lib/token/LAssetManagerERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../token/asset/IAssetManagerERC20.sol\";\nimport \"../../token/asset/AssetManagerStorageERC20.sol\";\nimport \"../../token/asset/ERC20/AssetERC20.sol\";\nimport \"../../token/lively/IERC20.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../acl/IGroupManagement.sol\";\nimport \"../../acl/IRoleManagement.sol\";\nimport \"../../acl/IAccessControl.sol\";\nimport \"../../utils/IERC165.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../LContextUtils.sol\";\nimport \"../proxy/LClones.sol\";\n\nlibrary LAssetManagerERC20 {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LClones for address;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LAssetManagerERC20\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  bytes32 public constant LIVELY_ASSET_GROUP = keccak256(abi.encodePacked(\"LIVELY_ASSET_GROUP\"));\n  bytes32 public constant LIVELY_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_SYSTEM_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_SYSTEM_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_ASSET_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_ASSET_MANAGER_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_MANAGER_ROLE\"));\n\n  function createRequestContext(\n    bytes32 domainName,\n    bytes32 domainVersion,\n    bytes32 realm\n  )\n    external\n    view\n    returns (IContextManagement.RequestContext memory, IContextManagement.RequestRegisterContext[] memory)\n  {\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](3);\n\n    rrc[0].role = LIVELY_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](2);\n    rrc[0].funcSelectors[0] = IProxy.setUpgradeStatus.selector;\n    rrc[0].funcSelectors[1] = IProxy.setSafeMode.selector;\n\n    rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](2);\n    rrc[1].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[1].funcSelectors[1] = IProxy.upgradeTo.selector;\n\n    rrc[2].role = LIVELY_ASSET_ADMIN_ROLE;\n    rrc[2].isEnabled = true;\n    rrc[2].funcSelectors = new bytes4[](17);\n    rrc[2].funcSelectors[0] = IAssetManagerERC20.tokenLock.selector;\n    rrc[2].funcSelectors[1] = IAssetManagerERC20.tokenBatchLock.selector;\n    rrc[2].funcSelectors[2] = IAssetManagerERC20.tokenTransfer.selector;\n    rrc[2].funcSelectors[3] = IAssetManagerERC20.tokenBatchTransfer.selector;\n    rrc[2].funcSelectors[4] = IAssetManagerERC20.tokenTransferFrom.selector;\n    rrc[2].funcSelectors[5] = IAssetManagerERC20.tokenBatchTransferFrom.selector;\n    rrc[2].funcSelectors[6] = IAssetManagerERC20.tokenApprove.selector;\n    rrc[2].funcSelectors[7] = IAssetManagerERC20.tokenIncreaseAllowance.selector;\n    rrc[2].funcSelectors[8] = IAssetManagerERC20.tokenDecreaseAllowance.selector;\n    rrc[2].funcSelectors[9] =  IAssetManagerERC20.createAsset.selector;\n    rrc[2].funcSelectors[10] = IAssetManagerERC20.updateAssetSubject.selector;\n    rrc[2].funcSelectors[11] = IAssetManagerERC20.registerToken.selector;\n    rrc[2].funcSelectors[12] = IAssetManagerERC20.registerAsset.selector;\n    rrc[2].funcSelectors[13] = IAssetManagerERC20.removeAsset.selector;\n    rrc[2].funcSelectors[14] = IAssetManagerERC20.setSafeModeToken.selector;\n    rrc[2].funcSelectors[15] = bytes4(keccak256(\"livelyTokensDistribution(address)\"));\n    rrc[2].funcSelectors[16] = bytes4(keccak256(\"withdrawBalance(address)\"));\n      \n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: domainName,\n      version: domainVersion,\n      realm: realm,\n      contractId: address(this),\n      status: true\n    });\n\n    return (rc, rrc);\n  }\n\n  function createAsset(AssetManagerStorageERC20.DataCollection storage data, IAssetManagerERC20.CreateAssetRequest calldata request, address accessControlManager, address assetSubject, bytes calldata assetCreationSignature) external returns (address, address) {\n    require(bytes(request.assetName).length > 0 , \"Invalid Asset Name\");\n    require(bytes(request.assetVersion).length > 0 , \"Invalid Asset Version\");\n    require(request.tokenId != address(0) , \"Invalid TokenId Address\");\n    require(assetSubject != address(0), \"Invalid Asset Subject ERC20\");\n    require(data.tokensSet.contains(request.tokenId), \"TokenId Not Found\");\n\n    bytes32 assetGroup = LIVELY_ASSET_GROUP;\n    require(IGroupManagement(accessControlManager).hasGroupRole(assetGroup, request.role), \"Asset Role Not Found\");\n  \n    AssetManagerStorageERC20.TokenData storage tokenData = data.tokens[request.tokenId];\n    require(!tokenData.assets.contains(assetSubject.predictDeterministicAddress(request.salt)), \"AssetId Already Exists\");\n\n    AssetERC20.InitRequest memory initRequest = AssetERC20.InitRequest ({\n      domainName: request.assetName,\n      domainVersion: request.assetVersion,  \n      domainRealm: IProxy(address(this)).contractRealm(),\n      erc20Token: request.tokenId,\n      accessControl: accessControlManager,\n      assetManager: address(this),\n      assetRole: request.role,\n      salt: request.salt,\n      subject: assetSubject,\n      signature: assetCreationSignature\n    });\n\n    address newAsset = assetSubject.cloneDeterministic(request.salt);\n    AssetERC20(payable(newAsset)).initialize(initRequest);\n    tokenData.assets.add(newAsset);\n    return (newAsset, assetSubject);\n  }\n\n  function registerToken(AssetManagerStorageERC20.DataCollection storage data, address tokenId) external returns (string memory, string memory) {   \n    require(!data.tokensSet.contains(tokenId), \"TokenId Already Registered\");\n\n    try IERC165(tokenId).supportsInterface(type(IERC20).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid ERC20\");\n    } catch {\n      revert(\"Illegal ERC20\");\n    }\n\n    try IERC165(tokenId).supportsInterface(type(IERC20Extra).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid ERC20Extra\");\n    } catch {\n      revert(\"Illegal ERC20Extra\");\n    }\n\n    try IERC165(tokenId).supportsInterface(type(IERC20Lock).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid ERC20Lock\");\n    } catch {\n      revert(\"Illegal ERC20Lock\");\n    }\n\n    string memory tokenName = IERC20(tokenId).name();\n    string memory tokenSymbol = IERC20(tokenId).symbol();\n\n    data.tokensSet.add(tokenId);\n    AssetManagerStorageERC20.TokenData storage tokenData = data.tokens[tokenId];\n    tokenData.status = IAssetEntity.Status.ACTIVE;\n    return (tokenName, tokenSymbol);\n  }\n\n  function registerAsset(AssetManagerStorageERC20.DataCollection storage data, address assetId) external returns (bool, address) {\n    require(assetId != address(0), \"Invalid AssetId Address\");\n    \n    try IERC165(assetId).supportsInterface(type(IAssetERC20).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetERC20\");\n    } catch {\n      revert(\"Illegal IAssetERC20\");\n    }\n\n    try IERC165(assetId).supportsInterface(type(IAssetEntity).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetEntity\");\n    } catch {\n      revert(\"Illegal IAssetEntity\");\n    }\n\n\n    address tokenId = IAssetEntity(assetId).assetToken();\n    require(data.tokensSet.contains(tokenId), \"TokenId Not Found\");\n    \n    AssetManagerStorageERC20.TokenData storage tokenData = data.tokens[tokenId];\n    require(!tokenData.assets.contains(assetId), \"AssetId Already Registered\");\n    \n    tokenData.assets.add(assetId);\n    if(IAssetEntity(assetId).assetSafeMode()) {\n      IAssetEntity(assetId).assetSafeModeSet(false);\n    }\n    return (true, tokenId);\n  }\n\n  function removeAsset(AssetManagerStorageERC20.DataCollection storage data, address assetId) external returns (address) {\n    require(assetId != address(0), \"Invalid AssetId Address\");\n    \n    address tokenId = IAssetEntity(assetId).assetToken();\n    require(data.tokensSet.contains(tokenId), \"TokenId Not Found\");\n    \n    AssetManagerStorageERC20.TokenData storage tokenData = data.tokens[tokenId];\n    require(tokenData.assets.contains(assetId), \"AssetId Not Found\");\n    \n    tokenData.assets.remove(assetId);\n    if(!IAssetEntity(assetId).assetSafeMode()) {\n      IAssetEntity(assetId).assetSafeModeSet(true);\n    }    \n    return tokenId;\n  }\n\n  function setSafeModeToken(AssetManagerStorageERC20.DataCollection storage data, address tokenId, bool isEnabled) external returns (bool) {    \n    require(data.tokensSet.contains(tokenId), \"TokenId Not Found\");\n    AssetManagerStorageERC20.TokenData storage tokenData = data.tokens[tokenId];\n    for(uint i = 0; i < tokenData.assets.length(); i++) {\n      IAssetEntity(tokenData.assets.at(i)).assetSafeModeSet(isEnabled);\n    }\n\n    tokenData.status = IAssetEntity.Status.SAFE_MODE;  \n    return true;\n  }\n\n  function predictAddress(address implementation, bytes32 salt, address deployer) external pure returns (address) {\n    return implementation.predictDeterministicAddress(salt, deployer);\n  }\n}"
    },
    "src/contracts/token/asset/AssetManagerERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IAssetManagerERC20.sol\";\nimport \"./IAssetEntity.sol\";\nimport \"./AssetManagerStorageERC20.sol\";\nimport \"./ERC20/IAssetERC20.sol\";\nimport \"../lively/IERC20.sol\";\nimport \"../lively/LivelyToken.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\nimport \"../../lib/token/LAssetManagerERC20.sol\";\n\ncontract AssetManagerERC20 is AssetManagerStorageERC20, BaseUUPSProxy, IAssetManagerERC20 {\n\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  struct InitRequest {\n    string domainName;\n    string domainVersion;\n    string domainRealm;    \n    address accessControlManager;\n    bytes assetManagerSignature;\n  }\n\n  constructor() {}\n\n  function initialize(InitRequest calldata request) public onlyProxy onlyLocalAdmin initializer {\n\n    bytes32 realm = keccak256(abi.encodePacked(request.domainRealm));\n    __BASE_UUPS_init(request.domainName, request.domainVersion, realm, request.accessControlManager);\n\n    (IContextManagement.RequestContext memory rc, IContextManagement.RequestRegisterContext[] memory rrc) = \n      LAssetManagerERC20.createRequestContext(_domainName, _domainVersion, _domainRealm);\n\n    IContextManagement(_accessControlManager).registerContext(request.assetManagerSignature, rc, rrc);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      request.domainName,\n      request.domainVersion,\n      realm,\n      _getInitializedCount()\n    );\n  }\n\n  function livelyTokensDistribution(address tokenId) public returns (bool) {\n    _policyInterceptor(this.livelyTokensDistribution.selector);\n    require(_data.tokensSet.contains(tokenId), \"TokenId Not Found\");\n    \n    TokenData storage tokenData = _data.tokens[tokenId];\n    require(tokenData.assets.length() == 7, \"Asset Required Failed\");\n\n    address[7] memory assets;\n    for(uint i = 0; i < 7; i++) {\n      assets[i] = tokenData.assets.at(i);\n    }\n    return LivelyToken(payable(tokenId)).tokensDistribution(address(this), assets);\n  }\n\n   /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IAssetManagerERC20).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  function tokenLock(address assetId, IERC20Lock.LockTokenRequest calldata lockRequest) external returns (bytes32) {\n    _validationAndPolicyInterceptor(assetId, this.tokenLock.selector);\n    return IAssetERC20(assetId).tokenLock(lockRequest);\n  }\n\n  function tokenBatchLock(address assetId, IERC20Lock.LockTokenRequest[] calldata lockRequests) external returns (bytes32[] memory) {\n    _validationAndPolicyInterceptor(assetId, this.tokenBatchLock.selector);\n    return IAssetERC20(assetId).tokenBatchLock(lockRequests);\n  }\n\n  function tokenTransfer(address assetId, address to, uint256 amount) external returns (bool) {\n    _validationAndPolicyInterceptor(assetId, this.tokenTransfer.selector);\n    return IAssetERC20(assetId).tokenTransfer(to, amount);\n  }\n\n  function tokenBatchTransfer(address assetId, IERC20Extra.BatchTransferRequest[] calldata request) external returns (bool) {\n    _validationAndPolicyInterceptor(assetId, this.tokenBatchTransfer.selector);\n    return IAssetERC20(assetId).tokenBatchTransfer(request);\n  }\n\n  function tokenTransferFrom(address assetId, address from, address to, uint256 amount) external returns (bool) {\n    _validationAndPolicyInterceptor(assetId, this.tokenTransferFrom.selector);\n    return IAssetERC20(assetId).tokenTransferFrom(from, to, amount);\n  }\n\n  function tokenBatchTransferFrom(address assetId, IERC20Extra.BatchTransferFromRequest[] calldata request) external returns (bool) {\n    _validationAndPolicyInterceptor(assetId, this.tokenBatchTransferFrom.selector);\n    return IAssetERC20(assetId).tokenBatchTransferFrom(request);\n  }\n\n  function tokenApprove(address assetId, address spender, uint256 amount) external returns (bool) {\n    _validationAndPolicyInterceptor(assetId, this.tokenApprove.selector);\n    return IAssetERC20(assetId).tokenApprove(spender, amount);\n  }\n\n  function tokenIncreaseAllowance(address assetId, address spender, uint256 amount) external returns (uint256) {\n    _validationAndPolicyInterceptor(assetId, this.tokenIncreaseAllowance.selector);\n    return IAssetERC20(assetId).tokenIncreaseAllowance(spender, amount);\n  }\n\n  function tokenDecreaseAllowance(address assetId, address spender, uint256 amount) external returns (uint256) {\n    _validationAndPolicyInterceptor(assetId, this.tokenDecreaseAllowance.selector);\n    return IAssetERC20(assetId).tokenDecreaseAllowance(spender, amount);\n  }\n\n  function createAsset(CreateAssetRequest calldata request) external returns (address) {\n    _policyInterceptor(this.createAsset.selector);\n    (address newAsset, address assetSubject) = LAssetManagerERC20.createAsset(_data, request, _accessControlManager, _assetSubjectERC20, _assetCreationSignature);\n    emit AssetCreated(_msgSender(), newAsset, request.tokenId, assetSubject);\n    return newAsset;\n  }\n\n  function registerToken(address tokenId) external returns (bool) {\n    _policyInterceptor(this.registerToken.selector);\n    (string memory tokenName, string memory tokenSymbol) = LAssetManagerERC20.registerToken(_data, tokenId);\n    emit TokenRegistered(_msgSender(), tokenId, tokenName, tokenSymbol);\n    return true;\n  }\n\n  function registerAsset(address assetId) external returns (bool) {\n    _policyInterceptor(this.registerAsset.selector);\n    (bool result, address tokenId) = LAssetManagerERC20.registerAsset(_data, assetId);\n    emit AssetRegistered(_msgSender(), assetId, tokenId);\n    return result;\n  }\n\n  function removeAsset(address assetId) external returns (bool) { \n    _policyInterceptor(this.removeAsset.selector);\n    address tokenId = LAssetManagerERC20.removeAsset(_data, assetId);\n    emit AssetRemoved(_msgSender(), assetId, tokenId);\n    return true;\n  }\n\n  function updateAssetSubject(address assetSubject, bytes calldata assetCreationSignature) external returns (bool) {\n    _policyInterceptor(this.updateAssetSubject.selector);\n    try IERC165(assetSubject).supportsInterface(type(IAssetERC20).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetERC20\");\n    } catch {\n      revert(\"Illegal IAssetERC20\");\n    }\n\n    try IERC165(assetSubject).supportsInterface(type(IAssetEntity).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetEntity\");\n    } catch {\n      revert(\"Illegal IAssetEntity\");\n    }\n\n    require(_assetSubjectERC20 != assetSubject, \"AssetSubject Already Exists\");\n    require(assetCreationSignature.length > 0, \"Invalid Signature\");\n    _assetSubjectERC20 = assetSubject;\n    _assetCreationSignature = assetCreationSignature;\n    emit AssetSubjectUpdated(_msgSender(), assetSubject);\n    return true;\n  }\n\n  function setSafeModeToken(address tokenId, bool isEnabled) external returns (bool) {\n    _policyInterceptor(this.setSafeModeToken.selector);\n    emit TokenSafeModeChanged(_msgSender(), tokenId, isEnabled);\n    return LAssetManagerERC20.setSafeModeToken(_data, tokenId, isEnabled);\n  }\n\n  function getAllTokens() external view returns(address[] memory) {\n    return _data.tokensSet.values();\n  }\n\n  function getTokenInfo(address tokenId) external view returns (IAssetEntity.Status, address[] memory) {\n   TokenData storage tokenData = _data.tokens[tokenId];\n    return (tokenData.status, tokenData.assets.values());\n  }\n\n  function isSafeModeAsset(address assetId) external view returns (bool) {\n    return IAssetEntity(assetId).assetSafeMode();\n  }\n\n  function isAssetExists(address assetId) external view returns (bool) {\n    return _data.tokens[IAssetEntity(assetId).assetToken()].assets.contains(assetId);\n  }\n\n  function isTokenExists(address tokenId) external view returns (bool) {\n    return _data.tokensSet.contains(tokenId);\n  }\n\n  function predictAddress(address implementation, bytes32 salt, address deployer) external pure returns (address) {\n    return LAssetManagerERC20.predictAddress(implementation, salt, deployer);\n  }\n\n  function getAssetSubject() external view returns (address) {\n    return _assetSubjectERC20;\n  }\n\n  function getLibrary() public pure returns(address) {\n    return address(LAssetManagerERC20);\n  }\n\n  function _policyInterceptor(bytes4 funcSelector) private safeModeCheck aclCheck(funcSelector) {}\n\n  function _validationAndPolicyInterceptor(address assetId, bytes4 funcSelector) private {\n    _policyInterceptor(funcSelector);\n    require(assetId != address(0), \"Invalid AssetId\");\n\n    try IERC165(assetId).supportsInterface(type(IAssetEntity).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetEntity\");\n    } catch {\n      revert(\"Illegal IAssetEntity\");\n    }\n\n    address tokenId = IAssetEntity(assetId).assetToken();\n    require(_data.tokensSet.contains(tokenId), \"TokenId Not Found\");\n    \n    TokenData storage tokenData = _data.tokens[tokenId];    \n    require(tokenData.assets.contains(assetId), \"AssetId Not Found\");\n  }\n}"
    },
    "src/contracts/lib/token/LSafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../token/lively/IERC20.sol\";\nimport \"../../token/lively/IERC20Extra.sol\";\nimport \"../../token/lively/IERC20Lock.sol\";\nimport \"../LAddress.sol\";\n\n/**\n * @title LSafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary LSafeERC20 {\n    using LAddress for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transfer.selector, to, value));    \n    }\n\n    function batchTransfer(IERC20Extra token, IERC20Extra.BatchTransferRequest[] calldata request) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.batchTransfer.selector, request));\n    }    \n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function batchTransferFrom(IERC20Extra token, IERC20Extra.BatchTransferFromRequest[] calldata request) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.batchTransferFrom.selector, request));\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Extra token,\n        address spender,\n        uint256 value\n    ) internal returns (uint256) {\n        bytes memory returndata = _callMandatoryReturn(address(token), abi.encodeWithSelector(token.increaseAllowance.selector, spender, value));                   \n        return abi.decode(returndata, (uint256));       \n    }\n\n    function safeDecreaseAllowance(\n        IERC20Extra token,\n        address spender,\n        uint256 value\n    ) internal returns (uint256) {        \n        bytes memory returndata = _callMandatoryReturn(address(token), abi.encodeWithSelector(token.decreaseAllowance.selector, spender, value));\n        return abi.decode(returndata, (uint256));\n    }\n\n    function safePermit(\n        IERC20Extra token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        bytes calldata signature\n    ) internal {\n        uint256 nonceBefore = token.nonce(owner);\n        token.permit(owner, spender, value, deadline, signature);\n        uint256 nonceAfter = token.nonce(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20Extra: Permit Failed\");\n    }\n\n    function lockToken(IERC20Lock token, IERC20Lock.LockTokenRequest calldata lockRequest) internal returns (bytes32) {\n        bytes memory returndata = _callMandatoryReturn(address(token), abi.encodeWithSelector(token.lockToken.selector, lockRequest));                   \n        return abi.decode(returndata, (bytes32));\n    }\n\n    function batchLockToken(IERC20Lock token, IERC20Lock.LockTokenRequest[] calldata lockRequest) internal returns (bytes32[] memory) {\n        bytes memory returndata = _callMandatoryReturn(address(token), abi.encodeWithSelector(token.batchLockToken.selector, lockRequest));                   \n        return abi.decode(returndata, (bytes32[]));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(address token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: Call Failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: Operation Failed\");\n        }\n    }\n\n    function _callMandatoryReturn(address token, bytes memory data) private returns (bytes memory){\n        return address(token).functionCall(data, \"SafeERC20: Call Failed\");\n    }\n}\n"
    },
    "src/contracts/lib/cryptography/LSignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./LECDSA.sol\";\nimport \"../LAddress.sol\";\nimport \"../../utils/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n */\nlibrary LSignatureChecker {\n  /**\n   * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n   * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n   *\n   * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n   * change through time. It could return true at block N and false at block N+1 (or the opposite).\n   */\n  function isValidSignatureNow(\n    address signer,\n    bytes32 hash,\n    bytes memory signature\n  ) internal view returns (bool) {\n    (address recovered, LECDSA.RecoverError error) = LECDSA.tryRecover(hash, signature);\n    if (error == LECDSA.RecoverError.NoError && recovered == signer) {\n      return true;\n    }\n\n    (bool success, bytes memory result) = signer.staticcall(\n      abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n    );\n    return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\n  }\n}\n"
    },
    "src/contracts/utils/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n  /**\n   * @dev Should return whether the signature provided is valid for the provided data\n   * @param hash      Hash of the data to be signed\n   * @param signature Signature byte array associated with _data\n   */\n  function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "src/contracts/test/proxy/BaseUUPSProxyTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\nimport \"../../acl/IContextManagement.sol\";\n\ncontract BaseUUPSProxyTest is BaseUUPSProxy {\n  bytes32 public constant LIVELY_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_SYSTEM_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_SYSTEM_ADMIN_ROLE\"));\n\n  event UpgradeToAnonymous(address indexed sender, address indexed newImplementation);\n  event UpgradeToTester(address indexed sender, address indexed newImplementation);\n\n  function initialize(\n    string calldata domainName,\n    string calldata domainVersion,\n    string calldata domainRealm,\n    bytes memory signature,\n    address accessControlManager\n  ) public onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n    __BASE_UUPS_init(domainName, domainVersion, realm, accessControlManager);\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: keccak256(abi.encodePacked(domainName)),\n      version: keccak256(abi.encodePacked(domainVersion)),\n      realm: realm,\n      contractId: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n    rrc[0].role = LIVELY_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](2);\n    rrc[0].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[0].funcSelectors[1] = IProxy.setUpgradeStatus.selector;\n\n    rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](2);\n    rrc[1].funcSelectors[0] = IProxy.setSafeMode.selector;\n    rrc[1].funcSelectors[1] = IProxy.upgradeTo.selector;\n    IContextManagement(accessControlManager).registerContext(signature, rc, rrc);\n  }\n\n  function initializeWithInvalidRealm(\n    string calldata domainName,\n    string calldata domainVersion,\n    string calldata domainRealm,\n    bytes memory signature,\n    address accessControlManager\n  ) public onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n    _domainName = keccak256(abi.encodePacked(domainName));\n    _domainVersion = keccak256(abi.encodePacked(domainVersion));\n    _domainRealm = realm;\n    if (accessControlManager == address(0)) {\n      _accessControlManager = address(this);\n    } else {\n      try IERC165(accessControlManager).supportsInterface(type(IAccessControl).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid AccessControlManager\");\n      } catch {\n        revert(\"Illegal AccessControlManager\");\n      }\n      _accessControlManager = accessControlManager;\n    }\n    _isUpgradable = false;\n    _isSafeMode = false;\n\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: keccak256(abi.encodePacked(domainName)),\n      version: keccak256(abi.encodePacked(domainVersion)),\n      realm: realm,\n      contractId: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n    rrc[0].role = LIVELY_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](2);\n    rrc[0].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[0].funcSelectors[1] = IProxy.setUpgradeStatus.selector;\n\n    rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](2);\n    rrc[1].funcSelectors[0] = IProxy.setSafeMode.selector;\n    rrc[1].funcSelectors[1] = IProxy.upgradeTo.selector;\n    IContextManagement(accessControlManager).registerContext(signature, rc, rrc);\n  }\n\n  function initializeWithInvalidRole(\n    string calldata domainName,\n    string calldata domainVersion,\n    string calldata domainRealm,\n    bytes memory signature,\n    address accessControlManager\n  ) public onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n    __BASE_UUPS_init(domainName, domainVersion, realm, accessControlManager);\n\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: keccak256(abi.encodePacked(domainName)),\n      version: keccak256(abi.encodePacked(domainVersion)),\n      realm: realm,\n      contractId: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](1);\n    rrc[0].role = keccak256(abi.encodePacked(\"LIVELY_WORLD_ADMIN\"));\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](2);\n    rrc[0].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[0].funcSelectors[1] = IProxy.setUpgradeStatus.selector;\n\n    IContextManagement(accessControlManager).registerContext(signature, rc, rrc);\n  }\n\n  function reInitialize(bytes memory signature) public onlyLocalAdmin reinitializer(2) {\n    _domainRealm = keccak256(abi.encodePacked(\"LIVELY_VERSE_REALM\"));\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: _domainName,\n      version: _domainVersion,\n      realm: _domainRealm,\n      contractId: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestUpdateContext[] memory ruc = new IContextManagement.RequestUpdateContext[](5);\n    ruc[0].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[0].updateStatus = IContextManagement.UpdateContextStatus.DISABLE;\n    ruc[0].funcSelectors = new bytes4[](1);\n    ruc[0].funcSelectors[0] = IProxy.upgradeTo.selector;\n\n    ruc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[1].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n    ruc[1].funcSelectors = new bytes4[](1);\n    ruc[1].funcSelectors[0] = this.upgradeToAndCall.selector;\n\n    ruc[2].role = keccak256(abi.encodePacked(\"TESTER_ROLE\"));\n    ruc[2].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n    ruc[2].funcSelectors = new bytes4[](1);\n    ruc[2].funcSelectors[0] = this.upgradeToTesterRole.selector;\n\n    ruc[3].role = keccak256(abi.encodePacked(\"LIVELY_ANONYMOUS_ROLE\"));\n    ruc[3].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n    ruc[3].funcSelectors = new bytes4[](1);\n    ruc[3].funcSelectors[0] = this.upgradeToAnonymousRole.selector;\n\n    ruc[4].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[4].updateStatus = IContextManagement.UpdateContextStatus.REMOVE;\n    ruc[4].funcSelectors = new bytes4[](1);\n    ruc[4].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n\n    IContextManagement(_accessControlManager).updateContext(\n      LContextUtils.generateCtx(address(this)),\n      signature,\n      rc,\n      ruc\n    );\n  }\n\n  function reInitializeWithInvalidRealm(bytes memory signature) public onlyLocalAdmin reinitializer(2) {\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: _domainName,\n      version: _domainVersion,\n      realm: keccak256(abi.encodePacked(\"LIVELY_REALM\")),\n      contractId: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestUpdateContext[] memory ruc = new IContextManagement.RequestUpdateContext[](2);\n    ruc[0].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[0].updateStatus = IContextManagement.UpdateContextStatus.DISABLE;\n    ruc[0].funcSelectors = new bytes4[](1);\n    ruc[0].funcSelectors[0] = IProxy.upgradeTo.selector;\n\n    ruc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[1].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n    ruc[1].funcSelectors = new bytes4[](1);\n    ruc[1].funcSelectors[0] = this.upgradeToAndCall.selector;\n\n    IContextManagement(_accessControlManager).updateContext(\n      LContextUtils.generateCtx(address(this)),\n      signature,\n      rc,\n      ruc\n    );\n  }\n\n  function reInitializeWithInvalidRole(bytes memory signature) public onlyLocalAdmin reinitializer(2) {\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: _domainName,\n      version: _domainVersion,\n      realm: _domainRealm,\n      contractId: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestUpdateContext[] memory rrc = new IContextManagement.RequestUpdateContext[](1);\n    rrc[0].role = keccak256(abi.encodePacked(\"LIVELY_WORLD_ADMIN\"));\n    rrc[0].updateStatus = IContextManagement.UpdateContextStatus.DISABLE;\n    rrc[0].funcSelectors = new bytes4[](1);\n    rrc[0].funcSelectors[0] = IProxy.upgradeTo.selector;\n\n    IContextManagement(_accessControlManager).updateContext(\n      LContextUtils.generateCtx(address(this)),\n      signature,\n      rc,\n      rrc\n    );\n  }\n\n  //    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n  //        return _IMPLEMENTATION_SLOT;\n  //    }\n\n  function upgradeToTesterRole(address newImplementation) external virtual onlyProxy {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_isUpgradable, \"Upgrade Call Rejected\");\n    require(_hasPermission(this.upgradeToTesterRole.selector), \"upgradeToTesterRole Forbidden\");\n    emit UpgradeToTester(msg.sender, newImplementation);\n  }\n\n  function upgradeToAnonymousRole(address newImplementation) external virtual onlyProxy {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_isUpgradable, \"Upgrade Call Rejected\");\n    require(_hasPermission(this.upgradeToAnonymousRole.selector), \"upgradeToAnonymousRole Forbidden\");\n    emit UpgradeToAnonymous(msg.sender, newImplementation);\n  }\n\n  function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n    _authorizeUpgrade(newImplementation);\n    _upgradeToAndCallUUPS(newImplementation, data, true);\n  }\n\n  //    function _authorizeUpgrade(address newImplementation) internal virtual override {}\n}\n"
    },
    "src/contracts/test/proxy/ERC1967ProxyTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../../proxy/BaseProxy.sol\";\nimport \"./ERC1967UpgradeTest.sol\";\n\ncontract ERC1967ProxyTest is BaseProxy, ERC1967UpgradeTest {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    _upgradeToAndCall(_logic, _data, false);\n  }\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _implementation() internal view virtual override returns (address impl) {\n    return ERC1967UpgradeTest._getImplementation();\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
