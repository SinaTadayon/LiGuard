{
  "language": "Solidity",
  "sources": {
    "src/contracts/acl/ACLManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IACL.sol\";\nimport \"./IACLGenerals.sol\";\nimport \"./ACLStorage.sol\";\nimport \"./IACLManager.sol\";\nimport \"./scope/IContextManagement.sol\";\nimport \"./scope/IFunctionManagement.sol\";\nimport \"./scope/IRealmManagement.sol\";\nimport \"./scope/IDomainManagement.sol\";\nimport \"./scope/IUniverseManagement.sol\";\nimport \"./agent/IMemberManagement.sol\";\nimport \"./agent/IRoleManagement.sol\";\nimport \"./agent/ITypeManagement.sol\";\nimport \"./policy/IPolicyManagement.sol\";\nimport \"./profile/IProfileACL.sol\";\nimport \"./profile/IProfileACLGenerals.sol\";\nimport \"./profile/IProfileManagement.sol\";\nimport \"./profile/scope/IProfileContextManagement.sol\";\nimport \"./profile/scope/IProfileFunctionManagement.sol\";\nimport \"./profile/scope/IProfileRealmManagement.sol\";\nimport \"./profile/scope/IProfileDomainManagement.sol\";\nimport \"./profile/scope/IProfileUniverseManagement.sol\";\nimport \"./profile/agent/IProfileMemberManagement.sol\";\nimport \"./profile/agent/IProfileRoleManagement.sol\";\nimport \"./profile/agent/IProfileTypeManagement.sol\";\nimport \"./profile/policy/IProfilePolicyManagement.sol\";\nimport \"../lib/struct/LEnumerableSet.sol\";\nimport \"../lib/acl/LACLStorage.sol\";\nimport \"../lib/acl/LACLCommons.sol\";\nimport \"../proxy/Initializable.sol\";\nimport \"../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Access Control Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ACLManager is ACLStorage, BaseUUPSProxy, IACLManager {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  // General Roles ID\n  bytes32 internal constant _LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_VERSE.LIVELY_MASTER_ADMIN\"));\n  bytes32 internal constant _LIVELY_VERSE_SYSTEM_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_VERSE.LIVELY_SYSTEM_MASTER_ADMIN\"));\n\n  constructor() {}\n\n  function initialize(string calldata contractName, string calldata contractVersion)\n    public\n    onlyProxy\n    onlyLocalAdmin\n    initializer\n  {\n    LACLCommons.registerProxyFacet(_data, _implementation());\n    __BASE_UUPS_init(contractName, contractVersion, address(this));\n    _firstInit = true;\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  function getFirstInit() public view returns (bool) {\n    return _firstInit;\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n    return\n      interfaceId == type(IACL).interfaceId ||\n      interfaceId == type(IACLManager).interfaceId ||\n      interfaceId == type(IACLGenerals).interfaceId ||\n      interfaceId == type(IPolicyManagement).interfaceId ||\n      interfaceId == type(IFunctionManagement).interfaceId ||\n      interfaceId == type(IContextManagement).interfaceId ||\n      interfaceId == type(IRealmManagement).interfaceId ||\n      interfaceId == type(IDomainManagement).interfaceId ||\n      interfaceId == type(IUniverseManagement).interfaceId ||\n      interfaceId == type(IMemberManagement).interfaceId ||\n      interfaceId == type(IRoleManagement).interfaceId ||\n      interfaceId == type(ITypeManagement).interfaceId ||\n      interfaceId == type(IProfileManagement).interfaceId ||\n      interfaceId == type(IProfileACL).interfaceId ||\n      interfaceId == type(IProfileACLGenerals).interfaceId ||\n      interfaceId == type(IProfilePolicyManagement).interfaceId ||\n      interfaceId == type(IProfileFunctionManagement).interfaceId ||\n      interfaceId == type(IProfileContextManagement).interfaceId ||\n      interfaceId == type(IProfileRealmManagement).interfaceId ||\n      interfaceId == type(IProfileDomainManagement).interfaceId ||\n      interfaceId == type(IProfileUniverseManagement).interfaceId ||\n      interfaceId == type(IProfileMemberManagement).interfaceId ||\n      interfaceId == type(IProfileRoleManagement).interfaceId ||\n      interfaceId == type(IProfileTypeManagement).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function aclRegisterFacet(FacetRegisterRequest[] calldata requests) external onlyProxy returns (bool) {\n    require(_sstat == ProxySafeModeStatus.DISABLED, \"Rejected\");\n    if (_firstInit) {\n      require(_getLocalAdmin() == _msgSender(), \"Forbidden\");\n    } else {\n      require(_hasPermission(this.aclRegisterFacet.selector) == IACL.AuthorizationStatus.PERMITTED, \"Access Denied\");\n    }\n    return _doAclRegisterFacet(requests);\n  }\n\n  function _doAclRegisterFacet(FacetRegisterRequest[] calldata requests) internal returns (bool) {\n    for (uint256 i = 0; i < requests.length; i++) {\n      LACLCommons.aclRegisterFacet(_data, requests[i]);\n      emit ACLFacetRegistered(_msgSender(), requests[i].facetId, requests[i].subjectId);\n    }\n    return true;\n  }\n\n  function aclUpgradeFacet(FacetUpgradeRequest[] calldata requests)\n    external\n    onlyProxy\n    aclCheck(this.aclUpgradeFacet.selector)\n    returns (bool)\n  {\n    require(_sstat == ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(!_firstInit, \"Illegal INIT\");\n    for (uint256 i = 0; i < requests.length; i++) {\n      require(_data.facetSet.contains(requests[i].facetId), \"Facet Not Found\");\n\n      FacetEntity storage facetEntity = _data.facets[requests[i].facetId];\n      require(requests[i].subjectId != address(0) && facetEntity.subjectId != requests[i].subjectId, \"Illegal Upgrade\");\n\n      facetEntity.subjectId = requests[i].subjectId;\n      for (uint256 j = 0; j < requests[i].functions.length; j++) {\n        if (requests[i].functions[j].action == ActionType.REMOVE) {\n          for (uint256 z = 0; z < requests[i].functions[j].selectors.length; z++) {\n            require(_data.selectors[requests[i].functions[j].selectors[z]] != address(0), \"Selector Not Found\");\n            delete _data.selectors[requests[i].functions[j].selectors[z]];\n            emit ACLFacetFunctionUpgraded(\n              msg.sender,\n              requests[i].facetId,\n              requests[i].functions[j].selectors[z],\n              ActionType.REMOVE\n            );\n          }\n        } else if (requests[i].functions[j].action == ActionType.ADD) {\n          for (uint256 z = 0; z < requests[i].functions[j].selectors.length; z++) {\n            require(_data.selectors[requests[i].functions[j].selectors[z]] == address(0), \"Illegal Selector\");\n            _data.selectors[requests[i].functions[j].selectors[z]] = requests[i].facetId;\n            emit ACLFacetFunctionUpgraded(\n              msg.sender,\n              requests[i].facetId,\n              requests[i].functions[j].selectors[z],\n              ActionType.ADD\n            );\n          }\n        }\n      }\n      emit ACLFacetUpgraded(_msgSender(), requests[i].facetId, requests[i].subjectId);\n    }\n    return true;\n  }\n\n  function aclGetFacets() public view returns (address[] memory) {\n    return _data.facetSet.values();\n  }\n\n  function aclGetFacet(bytes4 selector) external view returns (address) {\n    return _data.selectors[selector];\n  }\n\n  function aclHasSelector(bytes4 selector) external view returns (bool) {\n    return _data.selectors[selector] != address(0);\n  }\n\n  function aclGetFacetInfo(address facetId) external view returns (FacetInfo memory) {\n    FacetEntity storage facetEntity = _data.facets[facetId];\n    return FacetInfo({subjectId: facetEntity.subjectId});\n  }\n\n  function initACL(\n    address contextManagerAddress,\n    address functionManagerAddress,\n    address livelyAdmin,\n    address systemAdmin\n  ) public onlyProxy onlyLocalAdmin {\n    require(_firstInit, \"Already INIT\");\n    _firstInit = false;\n    LACLCommons.initACLAgents(_data, livelyAdmin, systemAdmin);\n\n    _initACLScopes(contextManagerAddress, functionManagerAddress, LACLUtils.accountGenerateId(livelyAdmin));\n\n    emit ACLInitialized(msg.sender, livelyAdmin, systemAdmin, contextManagerAddress, functionManagerAddress);\n  }\n\n  function _initACLScopes(\n    address contextManagerAddress,\n    address functionManagerAddress,\n    bytes32 livelyMasterAdminMemberId\n  ) internal {\n    // Create ACL Domain\n    bytes32 aclTypeId = LACLUtils.generateId2(\"TYPE.LIVELY_VERSE.LIVELY_GUARD.MASTER\");\n    bytes32 aclDomainId = LACLUtils.generateId2(\"DOMAIN.LIVELY_VERSE.LIVELY_GUARD\");\n    bytes32 aclRealmId = LACLUtils.generateId2(\"REALM.LIVELY_VERSE.LIVELY_GUARD.ACL\");\n    bytes32 aclContextManagerId = LACLUtils.accountGenerateId(contextManagerAddress);\n    bytes32 aclFunctionManagerId = LACLUtils.accountGenerateId(functionManagerAddress);\n    bytes32 aclContextRegisterId = LACLUtils.functionGenerateId(\n      contextManagerAddress,\n      IContextManagement.contextRegister.selector\n    );\n    bytes32 aclFunctionRegisterId = LACLUtils.functionGenerateId(\n      functionManagerAddress,\n      IFunctionManagement.functionRegister.selector\n    );\n\n    {\n      DomainEntity storage aclDomain = _data.domainWriteSlot(aclDomainId);\n      aclDomain.name = \"DOMAIN.LIVELY_VERSE.LIVELY_GUARD\";\n      aclDomain.universeId = _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      aclDomain.realmLimit = 3;\n      aclDomain.bs.stype = ScopeType.DOMAIN;\n      aclDomain.bs.alstat = AlterabilityStatus.UPDATABLE;\n      aclDomain.bs.acstat = ActivityStatus.ENABLED;\n      aclDomain.bs.adminId = aclTypeId;\n      aclDomain.realms.add(aclRealmId);\n      aclDomain.bs.referredByAgent = 2;\n\n      // Create Realm ACL\n      RealmEntity storage aclRealm = _data.realmWriteSlot(aclRealmId);\n      aclRealm.name = \"REALM.LIVELY_VERSE.LIVELY_GUARD.ACL\";\n      aclRealm.contextLimit = 128;\n      aclRealm.domainId = aclDomainId;\n      aclRealm.bs.stype = ScopeType.REALM;\n      aclRealm.bs.alstat = AlterabilityStatus.UPDATABLE;\n      aclRealm.bs.acstat = ActivityStatus.ENABLED;\n      aclRealm.bs.adminId = aclTypeId;\n      aclRealm.contexts.add(aclContextManagerId);\n      aclRealm.contexts.add(aclFunctionManagerId);\n    }\n\n    {\n      // Create ContextManager Context ACL\n      ContextEntity storage aclContextManagerEntity = _data.contextWriteSlot(aclContextManagerId);\n      aclContextManagerEntity.realmId = aclRealmId;\n      aclContextManagerEntity.contractId = contextManagerAddress;\n      aclContextManagerEntity.functionLimit = type(uint8).max;\n      aclContextManagerEntity.bs.stype = ScopeType.CONTEXT;\n      aclContextManagerEntity.bs.alstat = AlterabilityStatus.UPGRADABLE;\n      aclContextManagerEntity.bs.acstat = ActivityStatus.ENABLED;\n      aclContextManagerEntity.bs.adminId = aclTypeId;\n      aclContextManagerEntity.functions.add(aclContextRegisterId);\n\n      // Create FunctionManager Context ACL\n      ContextEntity storage aclFunctionManagerEntity = _data.contextWriteSlot(aclFunctionManagerId);\n      aclFunctionManagerEntity.realmId = aclRealmId;\n      aclFunctionManagerEntity.contractId = functionManagerAddress;\n      aclFunctionManagerEntity.functionLimit = type(uint8).max;\n      aclFunctionManagerEntity.bs.stype = ScopeType.CONTEXT;\n      aclFunctionManagerEntity.bs.alstat = AlterabilityStatus.UPGRADABLE;\n      aclFunctionManagerEntity.bs.acstat = ActivityStatus.ENABLED;\n      aclFunctionManagerEntity.bs.adminId = aclTypeId;\n      aclFunctionManagerEntity.functions.add(aclFunctionRegisterId);\n\n      // Create Function ContextRegister ACL\n      FunctionEntity storage functionContextRegisterEntity = _data.functionWriteSlot(aclContextRegisterId);\n      functionContextRegisterEntity.contextId = aclContextManagerId;\n      functionContextRegisterEntity.policyCode = 250;\n      functionContextRegisterEntity.selector = IContextManagement.contextRegister.selector;\n      functionContextRegisterEntity.bs.stype = ScopeType.FUNCTION;\n      functionContextRegisterEntity.bs.alstat = AlterabilityStatus.UPDATABLE;\n      functionContextRegisterEntity.bs.acstat = ActivityStatus.ENABLED;\n      functionContextRegisterEntity.bs.adminId = aclTypeId;\n      functionContextRegisterEntity.agentId = _LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID;\n\n      // Create Function FunctionRegister ACL\n      FunctionEntity storage aclFunctionRegister = _data.functionWriteSlot(aclFunctionRegisterId);\n      aclFunctionRegister.contextId = aclContextManagerId;\n      aclFunctionRegister.policyCode = 250;\n      aclFunctionRegister.selector = IFunctionManagement.functionRegister.selector;\n      aclFunctionRegister.bs.stype = ScopeType.FUNCTION;\n      aclFunctionRegister.bs.alstat = AlterabilityStatus.UPDATABLE;\n      aclFunctionRegister.bs.acstat = ActivityStatus.ENABLED;\n      aclFunctionRegister.bs.adminId = aclTypeId;\n      aclFunctionRegister.agentId = _LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID;\n    }\n\n    {\n      // Create ACL Type\n      TypeEntity storage aclType = _data.typeWriteSlot(aclTypeId);\n      aclType.name = \"TYPE.LIVELY_VERSE.LIVELY_GUARD.MASTER\";\n      aclType.roleLimit = type(uint16).max;\n      aclType.scopeId = aclDomainId;\n      aclType.ba.adminId = _LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      aclType.ba.atype = AgentType.TYPE;\n      aclType.ba.acstat = ActivityStatus.ENABLED;\n      aclType.ba.alstat = AlterabilityStatus.UPDATABLE;\n\n      // Create Admin Role\n      bytes32 aclAdminRoleId = LACLUtils.generateId2(\"ROLE.LIVELY_VERSE.LIVELY_GUARD.MASTER_ADMIN\");\n      RoleEntity storage aclAdminRole = _data.roleWriteSlot(aclAdminRoleId);\n      aclAdminRole.name = \"ROLE.LIVELY_VERSE.LIVELY_GUARD.MASTER_ADMIN\";\n      aclAdminRole.scopeId = aclDomainId;\n      aclAdminRole.typeId = aclTypeId;\n      aclAdminRole.memberLimit = type(uint24).max;\n      aclAdminRole.memberCount = 1;\n      aclAdminRole.ba.atype = AgentType.ROLE;\n      aclAdminRole.ba.acstat = ActivityStatus.ENABLED;\n      aclAdminRole.ba.alstat = AlterabilityStatus.UPDATABLE;\n      aclAdminRole.ba.adminId = _LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n\n      // acl\n      aclType.roles.add(aclAdminRoleId);\n      aclType.members[livelyMasterAdminMemberId] = aclAdminRoleId;\n    }\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LACLCommons);\n  }\n}\n"
    },
    "src/contracts/acl/IACL.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\n/**\n * @title Access Control Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IACL {\n  enum AuthorizationStatus {\n    PERMITTED,\n    UNAUTHORIZED,\n    POLICY_FORBIDDEN,\n    CALL_FORBIDDEN,\n    ROLE_SCOPE_FORBIDDEN,\n    MEMBER_NOT_FOUND,\n    ROLE_NOT_FOUND,\n    TYPE_NOT_FOUND,\n    FUNCTION_NOT_FOUND,\n    CONTEXT_NOT_FOUND,\n    REALM_NOT_FOUND,\n    DOMAIN_NOT_FOUND,\n    MEMBER_ACTIVITY_FORBIDDEN,\n    ROLE_ACTIVITY_FORBIDDEN,\n    TYPE_ACTIVITY_FORBIDDEN,\n    FUNCTION_ACTIVITY_FORBIDDEN,\n    CONTEXT_ACTIVITY_FORBIDDEN,\n    REALM_ACTIVITY_FORBIDDEN,\n    DOMAIN_ACTIVITY_FORBIDDEN,\n    UNIVERSE_ACTIVITY_FORBIDDEN\n  }\n\n  error ACLUnauthorized();\n  error ACLPolicyForbidden();\n  error ACLCallForbidden();\n  error ACLRoleScopeForbidden();\n  error ACLMemberNotFound();\n  error ACLRoleNotFound();\n  error ACLTypeNotFound();\n  error ACLFunctionNotFound();\n  error ACLContextNotFound();\n  error ACLRealmNotFound();\n  error ACLDomainNotFound();\n  error ACLMemberActivityForbidden();\n  error ACLRoleActivityForbidden();\n  error ACLTypeActivityForbidden();\n  error ACLFunctionActivityForbidden();\n  error ACLContextActivityForbidden();\n  error ACLRealmActivityForbidden();\n  error ACLDomainActivityForbidden();\n  error ACLUniverseActivityForbidden();\n\n  error ACLActionForbidden(AuthorizationStatus);\n\n  enum AdminAccessStatus {\n    PERMITTED,\n    NOT_PERMITTED,\n    POLICY_FORBIDDEN,\n    ROLE_NOT_FOUND,\n    TYPE_NOT_FOUND,\n    FUNCTION_NOT_FOUND,\n    ROLE_ACTIVITY_FORBIDDEN,\n    TYPE_ACTIVITY_FORBIDDEN\n  }\n\n  error AdminAccessNotPermitted();\n  error AdminAccessPolicyForbidden();\n  error AdminAccessRoleNotFound();\n  error AdminAccessTypeNotFound();\n  error AdminAccessFunctionNotFound();\n  error AdminAccessRoleActivityForbidden();\n  error AdminAccessTypeActivityForbidden();\n\n  error SetAdminForbidden(AdminAccessStatus);\n\n  function hasAccess(bytes32 functionId) external returns (AuthorizationStatus);\n\n  function hasMemberAccess(bytes32 functionId, bytes32 memberId) external returns (AuthorizationStatus);\n\n  function hasCSAccess(address contractId, bytes4 selector) external returns (AuthorizationStatus);\n\n  function hasAccountAccess(\n    address contractId,\n    bytes4 selector,\n    address accountId\n  ) external returns (AuthorizationStatus);\n}\n"
    },
    "src/contracts/acl/IACLGenerals.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IACLCommons.sol\";\n\n/**\n * @title Access Control Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IACLGenerals is IACLCommons {\n  // Anonymouse type\n  function getAnonymousType() external pure returns (bytes32);\n\n  // Any type\n  function getAnyType() external pure returns (bytes32);\n\n  // scope master type\n  function getScopeMasterType() external pure returns (bytes32);\n\n  // type master type\n  function getTypeMasterType() external pure returns (bytes32);\n\n  // member master type\n  function getMemberMasterType() external pure returns (bytes32);\n\n  // system master type\n  function getSystemMasterType() external pure returns (bytes32);\n\n  // lively master type\n  function getLivelyMasterType() external pure returns (bytes32);\n\n  // Policy Master type\n  function getPolicyMasterType() external pure returns (bytes32);\n\n  // Profile Master type\n  function getProfileMasterType() external pure returns (bytes32);\n\n  // Universe Scope\n  function getUniverseScope() external pure returns (bytes32);\n\n  // general\n  function isAgentExist(bytes32 agentId) external view returns (bool);\n\n  function isScopeExist(bytes32 scopeId) external view returns (bool);\n\n  function getScopeBaseInfo(bytes32 scopeId) external view returns (BaseScope memory);\n\n  function getAgentBaseInfo(bytes32 agentId) external view returns (BaseAgent memory);\n\n  function isScopesCompatible(bytes32 destScopeId, bytes32 srcScopeId) external view returns (bool);\n}\n"
    },
    "src/contracts/acl/ACLStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IACLCommons.sol\";\nimport \"../proxy/BaseUUPSStorage.sol\";\nimport \"../lib/struct/LEnumerableSet.sol\";\n\n/**\n * @title Abstract Access Control List Storage Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nabstract contract ACLStorage is BaseUUPSStorage, IACLCommons {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  struct DataCollection {\n    mapping(bytes32 => BaseAgent) agents;\n    mapping(bytes32 => BaseScope) scopes;\n    mapping(bytes32 => PolicyEntity) policies;\n    mapping(bytes32 => bytes32) rolePolicyMap;\n    mapping(bytes32 => ProfileEntity) profiles;\n    mapping(address => ProfileAccount) profileAccounts;\n    mapping(bytes4 => address) selectors;\n    mapping(address => FacetEntity) facets;\n    LEnumerableSet.AddressSet facetSet;\n  }\n\n  bytes32 public constant CTX_MESSAGE_TYPEHASH =\n    keccak256(\"Context(address contractId,string name,string version,string realm)\");\n\n  bytes32 public constant PREDICT_CTX_MESSAGE_TYPEHASH =\n    keccak256(\"PredictContext(address deployer,address subject,string realm)\");\n\n  bytes32 public constant MEMBER_SIGNATURE_MESSAGE_TYPEHASH =\n    keccak256(\"MemberSignature(address account,uint256 expiredAt)\");\n\n  bytes32 public constant PROFILE_CTX_MESSAGE_TYPEHASH =\n    keccak256(\"ProfileContext(string profile,address contractId,string name,string version,string realm)\");\n\n  bytes32 public constant PROFILE_PREDICT_CTX_MESSAGE_TYPEHASH =\n    keccak256(\"ProfilePredictContext(string profile,address deployer,address subject,string realm)\");\n\n  bytes32 public constant PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH =\n    keccak256(\"ProfileMemberSignature(string profile,address account,uint256 expiredAt)\");\n\n  // General Types ID\n  bytes32 internal constant _LIVELY_VERSE_LIVELY_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_MASTER\"));\n  bytes32 internal constant _LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_SYSTEM_MASTER\"));\n  bytes32 internal constant _LIVELY_VERSE_ANONYMOUS_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_ANONYMOUS\"));\n  bytes32 internal constant _LIVELY_VERSE_ANY_TYPE_ID = keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_ANY\"));\n  bytes32 internal constant _LIVELY_VERSE_SCOPE_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_SCOPE_MASTER\"));\n  bytes32 internal constant _LIVELY_VERSE_MEMBER_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_MEMBER_MASTER\"));\n  bytes32 internal constant _LIVELY_VERSE_TYPE_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_TYPE_MASTER\"));\n  bytes32 internal constant _LIVELY_VERSE_POLICY_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_POLICY_MASTER\"));\n  bytes32 internal constant _LIVELY_VERSE_PROFILE_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_PROFILE_MASTER\"));\n\n  // Universe Scope ID\n  bytes32 internal constant _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID =\n    keccak256(abi.encodePacked(\"UNIVERSE.LIVELY_VERSE\"));\n\n  // General Profile Type\n  bytes32 internal constant _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_PROFILE.LIVELY_MASTER\"));\n  bytes32 internal constant _LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_PROFILE.LIVELY_SYSTEM_MASTER\"));\n  bytes32 internal constant _LIVELY_PROFILE_ANY_TYPE_ID = keccak256(abi.encodePacked(\"TYPE.LIVELY_PROFILE.LIVELY_ANY\"));\n  bytes32 internal constant _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID =\n    keccak256(abi.encodePacked(\"UNIVERSE.LIVELY_PROFILE\"));\n\n  bool internal _firstInit;\n  DataCollection internal _data;\n  // Note: for next upgrade add new variables after this line\n}\n"
    },
    "src/contracts/acl/IACLManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IACLCommons.sol\";\n\n/**\n * @title Access Control Manager Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IACLManager is IACLCommons {\n  // Request Types\n  struct FacetSelectorUpgradeRequest {\n    ActionType action;\n    bytes4[] selectors;\n  }\n\n  struct FacetUpgradeRequest {\n    address facetId;\n    address subjectId;\n    FacetSelectorUpgradeRequest[] functions;\n  }\n\n  struct FacetRegisterRequest {\n    address facetId;\n    address subjectId;\n    bytes4[] selectors;\n  }\n\n  struct FacetInfo {\n    address subjectId;\n  }\n\n  event ACLFacetRegistered(address indexed sender, address indexed facetId, address indexed subjectId);\n\n  event ACLFacetUpgraded(address indexed sender, address indexed facetId, address indexed subjectId);\n\n  event ACLFacetFunctionUpgraded(address indexed sender, address indexed facetId, bytes4 selector, ActionType action);\n\n  event ACLInitialized(\n    address indexed sender,\n    address indexed admin,\n    address indexed systemAdmin,\n    address contextManager,\n    address functionManager\n  );\n\n  function aclRegisterFacet(FacetRegisterRequest[] calldata requests) external returns (bool);\n\n  function aclUpgradeFacet(FacetUpgradeRequest[] calldata requests) external returns (bool);\n\n  function aclGetFacets() external view returns (address[] memory);\n\n  function aclGetFacet(bytes4 selector) external view returns (address);\n\n  function aclHasSelector(bytes4 selector) external view returns (bool);\n\n  function aclGetFacetInfo(address facetId) external view returns (FacetInfo memory);\n}\n"
    },
    "src/contracts/acl/scope/IContextManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../IACLCommons.sol\";\n\n/**\n * @title Context Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IContextManagement is IACLCommons {\n  struct ContextRegisterRequest {\n    bytes32 realmId;\n    bytes32 adminId;\n    bytes32 salt;\n    string name;\n    string version;\n    address contractId;\n    address subject;\n    address deployer;\n    int16 functionLimit;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    bytes signature;\n  }\n\n  struct ContextUpdateFunctionLimitRequest {\n    bytes32 contextId;\n    uint8 functionLimit;\n  }\n\n  struct ContextInfo {\n    bytes32 realmId;\n    bytes32 adminId;\n    address contractId;\n    uint8 functionCount;\n    uint8 functionLimit;\n    uint32 referredByAgent;\n    AgentType adminType;\n    ScopeType stype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n  }\n\n  event ContextRegistered(\n    address indexed sender,\n    bytes32 indexed contextId,\n    address indexed contractId,\n    bytes32 realmId,\n    address deployer,\n    address subject,\n    bytes32 adminId\n  );\n\n  event ContextAdminUpdated(address indexed sender, bytes32 indexed contextId, bytes32 indexed adminId);\n\n  event ContextActivityUpdated(address indexed sender, bytes32 indexed contextId, ActivityStatus acstat);\n\n  event ContextAlterabilityUpdated(address indexed sender, bytes32 indexed contextId, AlterabilityStatus alstat);\n\n  event ContextFunctionLimitUpdated(address indexed sender, bytes32 indexed contextId, uint8 functionLimit);\n\n  event ContextRemoved(address indexed sender, bytes32 indexed contextId, bool isSoftDelete);\n\n  function contextRegister(MemberSignature calldata memberSign, ContextRegisterRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function contextUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function contextUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function contextUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function contextUpdateFunctionLimit(\n    MemberSignature calldata memberSign,\n    ContextUpdateFunctionLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function contextRemove(MemberSignature calldata memberSign, bytes32[] calldata contexts) external returns (bool);\n\n  function contextCheckId(bytes32 contextId) external view returns (bool);\n\n  function contextCheckAccount(address contractId) external view returns (bool);\n\n  function contextCheckAdmin(bytes32 contextId, address account) external view returns (bool);\n\n  function contextHasFunction(bytes32 contextId, bytes32 functionId) external view returns (bool);\n\n  function contextHasSelector(address contractId, bytes4 selector) external view returns (bool);\n\n  function contextGetFunctions(bytes32 contextId) external view returns (bytes32[] memory);\n\n  function contextGetInfo(bytes32 contextId) external view returns (ContextInfo memory);\n}\n"
    },
    "src/contracts/acl/scope/IFunctionManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../IACLCommons.sol\";\n\n/**\n * @title Function Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IFunctionManagement is IACLCommons {\n  struct FunctionRegisterRequest {\n    bytes signature;\n    bytes32 realmId;\n    bytes32 salt;\n    string name;\n    string version;\n    address subject;\n    address deployer;\n    address contractId;\n    FunctionRequest[] functions;\n  }\n\n  struct FunctionRequest {\n    bytes32 adminId;\n    bytes32 agentId;\n    bytes4 selector;\n    uint8 policyCode;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n  }\n\n  struct FunctionUpdatePolicyRequest {\n    bytes32 functionId;\n    uint8 policyCode;\n  }\n\n  struct FunctionUpdateAgentRequest {\n    bytes32 functionId;\n    bytes32 agentId;\n  }\n\n  struct FunctionInfo {\n    bytes32 adminId;\n    bytes32 agentId;\n    bytes32 contextId;\n    bytes4 selector;\n    uint32 referredByAgent;\n    ScopeType stype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    AgentType adminType;\n    AgentType agentType;\n    uint8 policyCode;\n  }\n\n  event FunctionRegistered(\n    address indexed sender,\n    bytes32 indexed contextId,\n    bytes32 indexed functionId,\n    bytes32 adminId,\n    bytes32 agentId\n  );\n\n  event FunctionAdminUpdated(address indexed sender, bytes32 indexed functionId, bytes32 indexed adminId);\n\n  event FunctionAgentUpdated(address indexed sender, bytes32 indexed functionId, bytes32 indexed agentId);\n\n  event FunctionActivityUpdated(address indexed sender, bytes32 indexed functionId, ActivityStatus acstat);\n\n  event FunctionAlterabilityUpdated(address indexed sender, bytes32 indexed functionId, AlterabilityStatus alstat);\n\n  event FunctionPolicyUpdated(address indexed sender, bytes32 indexed functionId, uint8 policyCode);\n\n  event FunctionRemoved(address indexed sender, bytes32 indexed functionId, bool isSoftDeleted);\n\n  function functionRegister(MemberSignature calldata memberSign, FunctionRegisterRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function functionUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function functionUpdateAgent(MemberSignature calldata memberSign, FunctionUpdateAgentRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function functionUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function functionUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function functionUpdatePolicyCode(\n    MemberSignature calldata memberSign,\n    FunctionUpdatePolicyRequest[] calldata requests\n  ) external returns (bool);\n\n  function functionRemove(MemberSignature calldata memberSign, bytes32[] calldata functions) external returns (bool);\n\n  function functionCheckId(bytes32 functionId) external view returns (bool);\n\n  function functionCheckSelector(address contractId, bytes4 selector) external view returns (bool);\n\n  function functionCheckAdmin(bytes32 functionId, address account) external view returns (bool);\n\n  function functionCheckAgent(bytes32 functionId, address account) external view returns (bool);\n\n  function functionGetInfo(bytes32 functionId) external view returns (FunctionInfo memory);\n}\n"
    },
    "src/contracts/acl/scope/IRealmManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../IACLCommons.sol\";\n\n/**\n * @title Realm Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\n\ninterface IRealmManagement is IACLCommons {\n  struct RealmRegisterRequest {\n    bytes32 domainId;\n    bytes32 adminId;\n    int64 contextLimit;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  struct RealmMoveContextRequest {\n    bytes32 realmId;\n    bytes32 targetRealmId;\n    bytes32 contextId;\n  }\n\n  struct RealmUpdateContextLimitRequest {\n    bytes32 realmId;\n    uint32 contextLimit;\n  }\n\n  struct RealmInfo {\n    bytes32 domainId;\n    bytes32 adminId;\n    uint32 contextLimit;\n    uint32 contextCount;\n    uint32 referredByAgent;\n    ScopeType stype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    AgentType adminType;\n    string name;\n  }\n\n  event RealmRegistered(address indexed sender, bytes32 indexed realmId, bytes32 indexed domainId, bytes32 adminId);\n\n  event RealmContextMoved(\n    address indexed sender,\n    bytes32 indexed realmId,\n    bytes32 indexed contextId,\n    bytes32 newRealmId\n  );\n\n  event RealmAdminUpdated(address indexed sender, bytes32 indexed realmId, bytes32 indexed adminId);\n\n  event RealmContextLimitUpdated(address indexed sender, bytes32 indexed realmId, uint32 contextLimit);\n\n  event RealmActivityUpdated(address indexed sender, bytes32 indexed realmId, ActivityStatus acstat);\n\n  event RealmAlterabilityUpdated(address indexed sender, bytes32 indexed realmId, AlterabilityStatus alstat);\n\n  event RealmRemoved(address indexed sender, bytes32 indexed realmId, bool isSoftDeleted);\n\n  function realmRegister(MemberSignature calldata memberSign, RealmRegisterRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function realmUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function realmMoveContext(MemberSignature calldata memberSign, RealmMoveContextRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function realmUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function realmUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function realmUpdateContextLimit(\n    MemberSignature calldata memberSign,\n    RealmUpdateContextLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function realmRemove(MemberSignature calldata memberSign, bytes32[] calldata realms) external returns (bool);\n\n  function realmCheckId(bytes32 realmId) external view returns (bool);\n\n  function realmCheckName(string calldata realmName) external view returns (bool);\n\n  function realmCheckAdmin(bytes32 realmId, address account) external view returns (bool);\n\n  function realmHasFunction(bytes32 realmId, bytes32 functionId) external view returns (bool);\n\n  function realmHasContext(bytes32 realmId, bytes32 contextId) external view returns (bool);\n\n  function realmGetContexts(bytes32 realmId) external view returns (bytes32[] memory);\n\n  function realmGetInfo(bytes32 realmId) external view returns (RealmInfo memory);\n}\n"
    },
    "src/contracts/acl/scope/IDomainManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\n/**\n * @title Domain Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\n\nimport \"../IACLCommons.sol\";\n\ninterface IDomainManagement is IACLCommons {\n  struct DomainRegisterRequest {\n    bytes32 adminId;\n    int24 realmLimit;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  struct DomainUpdateRealmLimitRequest {\n    bytes32 domainId;\n    uint16 realmLimit;\n  }\n\n  struct DomainMoveRealmRequest {\n    bytes32 domainId;\n    bytes32 targetDomainId;\n    bytes32 realmId;\n  }\n\n  struct DomainInfo {\n    bytes32 adminId;\n    bytes32 universeId;\n    uint16 realmLimit;\n    uint16 realmCount;\n    uint32 referredByAgent;\n    ScopeType stype;\n    AgentType adminType;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  event DomainRegistered(address indexed sender, bytes32 indexed domainId, bytes32 indexed adminId);\n\n  event DomainRealmMoved(\n    address indexed sender,\n    bytes32 indexed domainId,\n    bytes32 indexed realmId,\n    bytes32 newDomainId\n  );\n\n  event DomainAdminUpdated(address indexed sender, bytes32 indexed domainId, bytes32 indexed adminId);\n\n  event DomainRealmLimitUpdated(address indexed sender, bytes32 indexed domainId, uint16 realmLimit);\n\n  event DomainActivityUpdated(address indexed sender, bytes32 indexed domainId, ActivityStatus acstat);\n\n  event DomainAlterabilityUpdated(address indexed sender, bytes32 indexed domainId, AlterabilityStatus alstat);\n\n  event DomainRemoved(address indexed sender, bytes32 indexed domainId, bool isSoftDeleted);\n\n  function domainRegister(MemberSignature calldata memberSign, DomainRegisterRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function domainUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function domainUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function domainUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function domainMoveRealm(MemberSignature calldata memberSign, DomainMoveRealmRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function domainUpdateRealmLimit(\n    MemberSignature calldata memberSign,\n    DomainUpdateRealmLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function domainRemove(MemberSignature calldata memberSign, bytes32[] calldata domains) external returns (bool);\n\n  function domainCheckId(bytes32 domainId) external view returns (bool);\n\n  function domainCheckName(string calldata domainName) external view returns (bool);\n\n  function domainCheckAdmin(bytes32 domainId, address account) external view returns (bool);\n\n  function domainHasFunction(bytes32 domainId, bytes32 functionId) external view returns (bool);\n\n  function domainHasContext(bytes32 domainId, bytes32 contextId) external view returns (bool);\n\n  function domainHasRealm(bytes32 domainId, bytes32 realmId) external view returns (bool);\n\n  function domainGetRealms(bytes32 domainId) external view returns (bytes32[] memory);\n\n  function domainGetInfo(bytes32 domainId) external view returns (DomainInfo memory);\n}\n"
    },
    "src/contracts/acl/scope/IUniverseManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\n/**\n * @title Domain Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\n\nimport \"../IACLCommons.sol\";\n\ninterface IUniverseManagement is IACLCommons {\n  struct UniverseInfo {\n    bytes32 id;\n    bytes32 adminId;\n    uint16 domainLimit;\n    uint16 domainCount;\n    uint32 referredByAgent;\n    ScopeType stype;\n    AgentType adminType;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n  }\n\n  event UniverseAdminUpdated(address indexed sender, bytes32 indexed universeId, bytes32 indexed adminId);\n\n  event UniverseDomainLimitUpdated(address indexed sender, bytes32 indexed universeId, uint16 domainLimit);\n\n  event UniverseActivityUpdated(address indexed sender, bytes32 indexed universeId, ActivityStatus acstat);\n\n  event UniverseAlterabilityUpdated(address indexed sender, bytes32 indexed universeId, AlterabilityStatus alstat);\n\n  function universeUpdateActivityStatus(MemberSignature calldata memberSign, ActivityStatus acstat)\n    external\n    returns (ActivityStatus);\n\n  function universeUpdateAlterabilityStatus(MemberSignature calldata memberSign, AlterabilityStatus alstat)\n    external\n    returns (AlterabilityStatus);\n\n  function universeUpdateAdmin(MemberSignature calldata memberSign, bytes32 newAdminId) external returns (bool);\n\n  function universeUpdateDomainLimit(MemberSignature calldata memberSign, uint16 domainLimit) external returns (bool);\n\n  function universeCheckAdmin(address account) external view returns (bool);\n\n  function universeGetDomains() external view returns (bytes32[] memory);\n\n  function universeGetInfo() external view returns (UniverseInfo memory);\n}\n"
    },
    "src/contracts/acl/agent/IMemberManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../IACLCommons.sol\";\n\n/**\n * @title Member Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IMemberManagement is IACLCommons {\n  struct MemberRegisterRequest {\n    bytes32 roleId;\n    bytes32 adminId;\n    address account;\n    GeneralLimit limits;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n  }\n\n  struct MemberUpdateGeneralLimitRequest {\n    bytes32 memberId;\n    GeneralLimit limits;\n  }\n\n  struct MemberInfo {\n    bytes32 adminId;\n    address account;\n    GeneralLimit limits;\n    uint16 typeCount;\n    AgentType adminType;\n    AgentType atype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n  }\n\n  event MemberRegistered(\n    address indexed sender,\n    bytes32 indexed memberId,\n    address indexed account,\n    bytes32 roleId,\n    bytes32 adminId,\n    GeneralLimit limits\n  );\n\n  event MemberGeneralLimitUpdated(address indexed sender, bytes32 indexed memberId, GeneralLimit limits);\n\n  event MemberAdminUpdated(address indexed sender, bytes32 indexed memberId, bytes32 indexed adminId);\n\n  event MemberActivityUpdated(address indexed sender, bytes32 indexed memberId, ActivityStatus acstat);\n\n  event MemberAlterabilityUpdated(address indexed sender, bytes32 indexed memberId, AlterabilityStatus alstat);\n\n  event MemberRoleRevoked(address indexed sender, bytes32 indexed memberId, bytes32 indexed roleId, bytes32 typeId);\n\n  event MemberRemoved(address indexed sender, bytes32 indexed memberId, bool isCompleted);\n\n  function memberRegister(MemberSignature calldata memberSign, MemberRegisterRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function memberUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function memberUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function memberUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function memberUpdateGeneralLimit(\n    MemberSignature calldata memberSign,\n    MemberUpdateGeneralLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function memberRemove(MemberSignature calldata memberSign, bytes32[] calldata members) external returns (bool);\n\n  function memberCheckId(bytes32 memberId) external view returns (bool);\n\n  function memberCheckAccount(address account) external view returns (bool);\n\n  function memberCheckAdmin(bytes32 memberId, address account) external view returns (bool);\n\n  function memberHasType(bytes32 memberId, bytes32 typeId) external view returns (bool);\n\n  function memberGetTypes(bytes32 memberId) external view returns (bytes32[] memory);\n\n  function memberGetInfo(bytes32 memberId) external view returns (MemberInfo memory);\n}\n"
    },
    "src/contracts/acl/agent/IRoleManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../IACLCommons.sol\";\n\n/**\n * @title Role Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IRoleManagement is IACLCommons {\n  struct RoleRegisterRequest {\n    bytes32 adminId;\n    bytes32 scopeId;\n    bytes32 typeId;\n    int32 memberLimit;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  struct RoleGrantMembersRequest {\n    bytes32 roleId;\n    bytes32[] members;\n  }\n\n  struct RoleRevokeMembersRequest {\n    bytes32 roleId;\n    bytes32[] members;\n  }\n\n  struct RoleUpdateMemberLimitRequest {\n    bytes32 roleId;\n    uint24 memberLimit;\n  }\n\n  struct RoleInfo {\n    bytes32 scopeId;\n    bytes32 typeId;\n    bytes32 adminId;\n    uint24 memberLimit;\n    uint24 memberCount;\n    AgentType adminType;\n    AgentType atype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  event RoleRegistered(\n    address indexed sender,\n    bytes32 indexed roleId,\n    bytes32 indexed typeId,\n    bytes32 adminId,\n    bytes32 scopeId\n  );\n\n  event RoleMemberDeleted(\n    address indexed sender,\n    bytes32 indexed roleId,\n    bytes32 indexed memberId,\n    bytes32 typeId,\n    address account\n  );\n\n  event RoleMemberGranted(address indexed sender, bytes32 indexed roleId, bytes32 indexed memberId, bytes32 typeId);\n\n  event RoleMemberRevoked(address indexed sender, bytes32 indexed roleId, bytes32 indexed memberId, bytes32 typeId);\n\n  event RoleMemberLimitUpdated(address indexed sender, bytes32 indexed roleId, uint24 memberLimit);\n\n  event RoleAdminUpdated(address indexed sender, bytes32 indexed roleId, bytes32 indexed adminId);\n\n  event RoleScopeUpdated(address indexed sender, bytes32 indexed roleId, bytes32 indexed scopeId);\n\n  event RoleActivityUpdated(address indexed sender, bytes32 indexed roleId, ActivityStatus acstat);\n\n  event RoleAlterabilityUpdated(address indexed sender, bytes32 indexed roleId, AlterabilityStatus alstat);\n\n  event RoleRemoved(address indexed sender, bytes32 indexed roleId);\n\n  function roleRegister(MemberSignature calldata memberSign, RoleRegisterRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function roleGrantMembers(MemberSignature calldata memberSign, RoleGrantMembersRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function roleRevokeMembers(MemberSignature calldata memberSign, RoleRevokeMembersRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function roleUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function roleUpdateScope(MemberSignature calldata memberSign, UpdateScopeRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function roleUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function roleUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function roleUpdateMemberLimit(MemberSignature calldata memberSign, RoleUpdateMemberLimitRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function roleRemove(MemberSignature calldata memberSign, bytes32[] calldata roles) external returns (bool);\n\n  function roleCheckId(bytes32 roleId) external view returns (bool);\n\n  function roleCheckName(string calldata roleName) external view returns (bool);\n\n  function roleCheckAdmin(bytes32 roleId, address account) external view returns (bool);\n\n  function roleHasAccount(bytes32 roleId, address account) external view returns (bool);\n\n  function roleGetInfo(bytes32 roleId) external view returns (RoleInfo memory);\n}\n"
    },
    "src/contracts/acl/agent/ITypeManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../IACLCommons.sol\";\n\n/**\n * @title Type Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface ITypeManagement is IACLCommons {\n  struct TypeRegisterRequest {\n    bytes32 adminId;\n    bytes32 scopeId;\n    int24 roleLimit;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  struct TypeUpdateRoleLimitRequest {\n    bytes32 typeId;\n    uint16 roleLimit;\n  }\n\n  struct TypeInfo {\n    bytes32 scopeId;\n    bytes32 adminId;\n    uint16 roleLimit;\n    uint16 roleCount;\n    AgentType adminType;\n    AgentType atype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  event TypeRegistered(address indexed sender, bytes32 indexed typeId, bytes32 indexed scopeId, bytes32 adminId);\n\n  event TypeActivityUpdated(address indexed sender, bytes32 indexed typeId, ActivityStatus acstat);\n\n  event TypeAlterabilityUpdated(address indexed sender, bytes32 indexed typeId, AlterabilityStatus alstat);\n\n  event TypeRoleLimitUpdated(address indexed sender, bytes32 indexed typeId, uint16 roleLimit);\n\n  event TypeScopeUpdated(address indexed sender, bytes32 indexed typeId, bytes32 indexed scopeId);\n\n  event TypeAdminUpdated(address indexed sender, bytes32 indexed typeId, bytes32 indexed adminId);\n\n  event TypeRemoved(address indexed sender, bytes32 indexed typeId);\n\n  function typeRegister(MemberSignature calldata memberSign, TypeRegisterRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function typeUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function typeUpdateScope(MemberSignature calldata memberSign, UpdateScopeRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function typeUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function typeUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function typeUpdateRoleLimit(MemberSignature calldata memberSign, TypeUpdateRoleLimitRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function typeRemove(MemberSignature calldata memberSign, bytes32[] calldata types) external returns (bool);\n\n  function typeCheckId(bytes32 typeId) external view returns (bool);\n\n  function typeCheckName(string calldata typeName) external view returns (bool);\n\n  function typeCheckAdmin(bytes32 typeId, address account) external view returns (bool);\n\n  function typeHasAccount(bytes32 typeId, address account) external view returns (bool);\n\n  function typeHasRole(bytes32 typeId, bytes32 roleId) external view returns (bool);\n\n  function typeGetRoles(bytes32 typeId) external view returns (bytes32[] memory);\n\n  function typeGetInfo(bytes32 typeId) external view returns (TypeInfo memory);\n}\n"
    },
    "src/contracts/acl/policy/IPolicyManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../IACLCommons.sol\";\n\n/**\n * @title Policy Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\n\ninterface IPolicyManagement is IACLCommons {\n  struct PolicyRegisterRequest {\n    bytes32 adminId;\n    bytes32 scopeId;\n    uint8 policyCode;\n    int24 roleLimit;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  struct PolicyAddRolesRequest {\n    bytes32 policyId;\n    bytes32[] roles;\n  }\n\n  struct PolicyRemoveRolesRequest {\n    bytes32 policyId;\n    bytes32[] roles;\n  }\n\n  struct PolicyUpdateCodeRequest {\n    bytes32 policyId;\n    uint8 policyCode;\n  }\n\n  struct PolicyUpdateRoleLimitRequest {\n    bytes32 policyId;\n    uint16 roleLimit;\n  }\n\n  struct PolicyInfo {\n    bytes32 adminId;\n    bytes32 scopeId;\n    string name;\n    uint16 roleLimit;\n    uint16 roleCount;\n    uint8 policyCode;\n    AgentType adminType;\n    ScopeType scopeType;\n    PolicyType ptype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n  }\n\n  event PolicyRegistered(\n    address indexed sender,\n    bytes32 indexed policyId,\n    bytes32 indexed scopeId,\n    bytes32 adminId,\n    uint8 policyCode\n  );\n\n  event PolicyRoleAdded(address indexed sender, bytes32 indexed policyId, bytes32 indexed roleId);\n\n  event PolicyRoleRemoved(address indexed sender, bytes32 indexed policyId, bytes32 indexed roleId);\n\n  event PolicyActivityUpdated(address indexed sender, bytes32 indexed policyId, ActivityStatus acstat);\n\n  event PolicyAlterabilityUpdated(address indexed sender, bytes32 indexed policyId, AlterabilityStatus alstat);\n\n  event PolicyCodeUpdated(address indexed sender, bytes32 indexed policyId, uint8 policyCode, PolicyType ptype);\n\n  event PolicyRoleLimitUpdated(address indexed sender, bytes32 indexed policyId, uint16 roleLimit);\n\n  event PolicyAdminUpdated(address indexed sender, bytes32 indexed policyId, bytes32 indexed adminId);\n\n  event PolicyScopeUpdated(address indexed sender, bytes32 indexed policyId, bytes32 indexed scopeId);\n\n  event PolicyRemoved(address indexed sender, bytes32 indexed policyId);\n\n  function policyRegister(MemberSignature calldata memberSign, PolicyRegisterRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function policyAddRoles(MemberSignature calldata memberSign, PolicyAddRolesRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function policyRemoveRoles(MemberSignature calldata memberSign, PolicyRemoveRolesRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function policyUpdateCodes(MemberSignature calldata memberSign, PolicyUpdateCodeRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function policyUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function policyUpdateScope(MemberSignature calldata memberSign, UpdateScopeRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function policyUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function policyUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function policyUpdateRoleLimit(MemberSignature calldata memberSign, PolicyUpdateRoleLimitRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function policyRemove(MemberSignature calldata memberSign, bytes32[] calldata policies) external returns (bool);\n\n  function policyCheckId(bytes32 policyId) external view returns (bool);\n\n  function policyCheckName(string calldata policyName) external view returns (bool);\n\n  function policyCheckAdmin(bytes32 policyId, address account) external view returns (bool);\n\n  function policyCheckRole(bytes32 roleId) external view returns (bool);\n\n  function policyCheckAccess(bytes32 policyId, bytes32 functionId) external view returns (bool);\n\n  function policyCheckRoleAccess(bytes32 roleId, bytes32 functionId) external view returns (bool);\n\n  function policyHasRole(bytes32 policyId, bytes32 roleId) external view returns (bool);\n\n  function policyGetInfoByRole(bytes32 roleId) external view returns (PolicyInfo memory);\n\n  function policyGetInfo(bytes32 policyId) external view returns (PolicyInfo memory);\n\n  function policyGetRoles(bytes32 policyId) external view returns (bytes32[] memory);\n}\n"
    },
    "src/contracts/acl/profile/IProfileACL.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\n/**\n * @title Access Control Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IProfileACL {\n  enum ProfileAuthorizationStatus {\n    PERMITTED,\n    UNAUTHORIZED,\n    POLICY_FORBIDDEN,\n    PROFILE_CALL_FORBIDDEN,\n    MEMBER_CALL_FORBIDDEN,\n    ROLE_SCOPE_FORBIDDEN,\n    MEMBER_NOT_FOUND,\n    ROLE_NOT_FOUND,\n    TYPE_NOT_FOUND,\n    FUNCTION_NOT_FOUND,\n    CONTEXT_NOT_FOUND,\n    REALM_NOT_FOUND,\n    DOMAIN_NOT_FOUND,\n    MEMBER_ACTIVITY_FORBIDDEN,\n    ROLE_ACTIVITY_FORBIDDEN,\n    TYPE_ACTIVITY_FORBIDDEN,\n    FUNCTION_ACTIVITY_FORBIDDEN,\n    CONTEXT_ACTIVITY_FORBIDDEN,\n    REALM_ACTIVITY_FORBIDDEN,\n    DOMAIN_ACTIVITY_FORBIDDEN,\n    UNIVERSE_ACTIVITY_FORBIDDEN,\n    PROFILE_ACTIVITY_FORBIDDEN\n  }\n\n  error ProfileACLUnauthorized();\n  error ProfileACLPolicyForbidden();\n  error ProfileACLCallForbidden();\n  error ProfileACLRoleScopeForbidden();\n  error ProfileACLMemberCallForbidden();\n  error ProfileACLMemberNotFound();\n  error ProfileACLRoleNotFound();\n  error ProfileACLTypeNotFound();\n  error ProfileACLFunctionNotFound();\n  error ProfileACLContextNotFound();\n  error ProfileACLRealmNotFound();\n  error ProfileACLDomainNotFound();\n  error ProfileACLMemberActivityForbidden();\n  error ProfileACLRoleActivityForbidden();\n  error ProfileACLTypeActivityForbidden();\n  error ProfileACLFunctionActivityForbidden();\n  error ProfileACLContextActivityForbidden();\n  error ProfileACLRealmActivityForbidden();\n  error ProfileACLDomainActivityForbidden();\n  error ProfileACLUniverseActivityForbidden();\n  error ProfileACLProfileActivityForbidden();\n\n  enum ProfileAdminAccessStatus {\n    PERMITTED,\n    NOT_PERMITTED,\n    POLICY_FORBIDDEN,\n    ROLE_NOT_FOUND,\n    TYPE_NOT_FOUND,\n    FUNCTION_NOT_FOUND,\n    ROLE_ACTIVITY_FORBIDDEN,\n    TYPE_ACTIVITY_FORBIDDEN\n  }\n\n  error ProfileAdminAccessNotPermitted();\n  error ProfileAdminAccessPolicyForbidden();\n  error ProfileAdminAccessRoleNotFound();\n  error ProfileAdminAccessTypeNotFound();\n  error ProfileAdminAccessFunctionNotFound();\n  error ProfileAdminAccessRoleActivityForbidden();\n  error ProfileAdminAccessTypeActivityForbidden();\n\n  error ProfileSetAdminForbidden(ProfileAdminAccessStatus);\n\n  function profileHasAccess(bytes32 profileId, bytes32 functionId) external returns (ProfileAuthorizationStatus);\n\n  function profileHasMemberAccess(\n    bytes32 profileId,\n    bytes32 functionId,\n    bytes32 memberId\n  ) external returns (ProfileAuthorizationStatus);\n\n  function profileHasCSAccess(\n    bytes32 profileId,\n    address contractId,\n    bytes4 selector\n  ) external returns (ProfileAuthorizationStatus);\n\n  function profileHasAccountAccess(\n    bytes32 profileId,\n    address contractId,\n    bytes4 selector,\n    address accountId\n  ) external returns (ProfileAuthorizationStatus);\n}\n"
    },
    "src/contracts/acl/profile/IProfileACLGenerals.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../IACLCommons.sol\";\n\n/**\n * @title Access Control General Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IProfileACLGenerals is IACLCommons {\n  // Anonymouse type\n  function profileAnonymousType() external pure returns (bytes32);\n\n  // Any type\n  function profileAnyType() external pure returns (bytes32);\n\n  // system master type\n  function profileSystemMasterType() external pure returns (bytes32);\n\n  // profile master type\n  function profileMasterType() external pure returns (bytes32);\n\n  // Universe Scope\n  function profileUniverseScope() external pure returns (bytes32);\n\n  // general\n  function profileIsAgentExist(bytes32 profileId, bytes32 agentId) external view returns (bool);\n\n  function profileIsScopeExist(bytes32 profileId, bytes32 scopeId) external view returns (bool);\n\n  function profileScopeBaseInfo(bytes32 profileId, bytes32 scopeId) external view returns (BaseScope memory);\n\n  function profileAgentBaseInfo(bytes32 profileId, bytes32 agentId) external view returns (BaseAgent memory);\n\n  function profileIsScopesCompatible(\n    bytes32 profileId,\n    bytes32 destScopeId,\n    bytes32 srcScopeId\n  ) external view returns (bool);\n}\n"
    },
    "src/contracts/acl/profile/IProfileManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../IACLCommons.sol\";\n\n/**\n * @title Profile Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IProfileManagement is IACLCommons {\n  struct ProfileRegisterRequest {\n    string name;\n    ProfileRegisterLimit registerLimits;\n    ProfileLimit limits;\n    address profileOwner;\n    address profileSystemAdmin;\n    bytes32 adminId;\n  }\n\n  struct ProfileUpdateOwnerAccountRequest {\n    bytes32 profileId;\n    address newOwner;\n  }\n\n  struct ProfileUpdateLimitsRequest {\n    bytes32 profileId;\n    ProfileRegisterLimit registerLimits;\n    ProfileLimit limits;\n  }\n\n  struct ProfileInfo {\n    string name;\n    bytes32 adminId;\n    address owner;\n    ProfileRegisterLimit registerLimits;\n    ProfileLimit limits;\n    AgentType adminType;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n  }\n\n  event ProfileRegistered(\n    address indexed sender,\n    bytes32 indexed profileId,\n    address indexed profileOwner,\n    address profileSystemAdmin,\n    bytes32 adminId,\n    ProfileRegisterLimit registerlimits,\n    ProfileLimit limits\n  );\n\n  event ProfileAdminUpdated(address indexed sender, bytes32 indexed profileId, bytes32 indexed adminId);\n\n  event ProfileActivityUpdated(address indexed sender, bytes32 indexed profileId, ActivityStatus acstat);\n\n  event ProfileAlterabilityUpdated(address indexed sender, bytes32 indexed profileId, AlterabilityStatus alstat);\n\n  event ProfileLimitsUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    ProfileLimit limit,\n    ProfileRegisterLimit registerLimit\n  );\n\n  event ProfileOwnerAccountUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    address indexed owner,\n    address newOwner\n  );\n\n  function profileRegister(MemberSignature calldata memberSign, ProfileRegisterRequest[] calldata request)\n    external\n    returns (bool);\n\n  function profileUpdateLimits(MemberSignature calldata memberSign, ProfileUpdateLimitsRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function profileUpdateOwnerAccount(\n    MemberSignature calldata memberSign,\n    ProfileUpdateOwnerAccountRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function profileUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool);\n\n  function profileCheckId(bytes32 profileId) external view returns (bool);\n\n  function profileCheckName(string calldata name) external view returns (bool);\n\n  function profileCheckOwner(bytes32 profileId, address account) external view returns (bool);\n\n  function profileCheckProfileAdmin(bytes32 profileId, address account) external view returns (bool);\n\n  function profileCheckProfileSystemAdmin(bytes32 profileId, address account) external view returns (bool);\n\n  function profileCheckAdmin(bytes32 profileId, address account) external view returns (bool);\n\n  function profileGetProfileAccount(address account) external view returns (bytes32[] memory);\n\n  function profileGetAdmins(bytes32 profileId) external view returns (bytes32[] memory);\n\n  function profileGetInfo(bytes32 profileId) external view returns (ProfileInfo memory);\n}\n"
    },
    "src/contracts/acl/profile/scope/IProfileContextManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../../IACLCommons.sol\";\n\n/**\n * @title Profile Context Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IProfileContextManagement is IACLCommons {\n  struct ProfileContextRegisterRequest {\n    bytes32 realmId;\n    bytes32 adminId;\n    bytes32 salt;\n    string name;\n    string version;\n    address contractId;\n    address subject;\n    address deployer;\n    int16 functionLimit;\n    bytes signature;\n  }\n\n  struct ProfileContextUpdateFunctionLimitRequest {\n    bytes32 contextId;\n    uint8 functionLimit;\n  }\n\n  struct ProfileContextInfo {\n    bytes32 realmId;\n    bytes32 adminId;\n    address contractId;\n    uint8 functionCount;\n    uint8 functionLimit;\n    uint32 referredByAgent;\n    AgentType adminType;\n    ScopeType stype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n  }\n\n  event ProfileContextRegistered(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed contextId,\n    bytes32 realmId,\n    bytes32 adminId,\n    address contractId,\n    address deployer,\n    address subject\n  );\n\n  event ProfileContextAdminUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed contextId,\n    bytes32 adminId\n  );\n\n  event ProfileContextActivityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed contextId,\n    ActivityStatus acstat\n  );\n\n  event ProfileContextAlterabilityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed contextId,\n    AlterabilityStatus alstat\n  );\n\n  event ProfileContextFunctionLimitUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed contextId,\n    uint8 functionLimit\n  );\n\n  event ProfileContextRemoved(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed contextId,\n    bool isSoftDelete\n  );\n\n  function profileContextRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileContextRegisterRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileContextUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileContextUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileContextUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileContextUpdateFunctionLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileContextUpdateFunctionLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileContextRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata contexts)\n    external\n    returns (bool);\n\n  function profileContextCheckId(bytes32 profileId, bytes32 contextId) external view returns (bool);\n\n  function profileContextCheckAccount(bytes32 profileId, address contractId) external view returns (bool);\n\n  function profileContextCheckAdmin(\n    bytes32 profileId,\n    bytes32 contextId,\n    address account\n  ) external view returns (bool);\n\n  function profileContextHasFunction(\n    bytes32 profileId,\n    bytes32 contextId,\n    bytes32 functionId\n  ) external view returns (bool);\n\n  function profileContextHasSelector(\n    bytes32 profileId,\n    address contractId,\n    bytes4 selector\n  ) external view returns (bool);\n\n  function profileContextGetFunctions(bytes32 profileId, bytes32 contextId) external view returns (bytes32[] memory);\n\n  function profileContextGetInfo(bytes32 profileId, bytes32 contextId)\n    external\n    view\n    returns (ProfileContextInfo memory);\n}\n"
    },
    "src/contracts/acl/profile/scope/IProfileFunctionManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../../IACLCommons.sol\";\n\n/**\n * @title Profile Function Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IProfileFunctionManagement is IACLCommons {\n  struct ProfileFunctionRegisterRequest {\n    bytes signature;\n    bytes32 realmId;\n    bytes32 salt;\n    string name;\n    string version;\n    address subject;\n    address deployer;\n    address contractId;\n    ProfileFunctionRequest[] functions;\n  }\n\n  struct ProfileFunctionRequest {\n    bytes32 adminId;\n    bytes32 agentId;\n    bytes4 selector;\n    uint8 policyCode;\n  }\n\n  struct ProfileFunctionUpdatePolicyRequest {\n    bytes32 functionId;\n    uint8 policyCode;\n  }\n\n  struct ProfileFunctionUpdateAgentRequest {\n    bytes32 functionId;\n    bytes32 agentId;\n  }\n\n  struct ProfileFunctionInfo {\n    bytes32 adminId;\n    bytes32 agentId;\n    bytes32 contextId;\n    bytes4 selector;\n    uint32 referredByAgent;\n    ScopeType stype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    AgentType adminType;\n    AgentType agentType;\n    uint8 policyCode;\n  }\n\n  event ProfileFunctionRegistered(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed functionId,\n    bytes32 contextId,\n    bytes32 adminId,\n    bytes32 agentId\n  );\n\n  event ProfileFunctionAdminUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed functionId,\n    bytes32 adminId\n  );\n\n  event ProfileFunctionAgentUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed functionId,\n    bytes32 agentId\n  );\n\n  event ProfileFunctionActivityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed functionId,\n    ActivityStatus acstat\n  );\n\n  event ProfileFunctionAlterabilityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed functionId,\n    AlterabilityStatus alstat\n  );\n\n  event ProfileFunctionPolicyUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed functionId,\n    uint8 policyCode\n  );\n\n  event ProfileFunctionRemoved(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed functionId,\n    bool isSoftDeleted\n  );\n\n  function profileFunctionRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileFunctionRegisterRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileFunctionUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileFunctionUpdateAgent(\n    ProfileMemberSignature calldata memberSign,\n    ProfileFunctionUpdateAgentRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileFunctionUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileFunctionUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileFunctionUpdatePolicyCode(\n    ProfileMemberSignature calldata memberSign,\n    ProfileFunctionUpdatePolicyRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileFunctionRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata functions)\n    external\n    returns (bool);\n\n  function profileFunctionCheckId(bytes32 profileId, bytes32 functionId) external view returns (bool);\n\n  function profileFunctionCheckSelector(\n    bytes32 profileId,\n    address contractId,\n    bytes4 selector\n  ) external view returns (bool);\n\n  function profileFunctionCheckAdmin(\n    bytes32 profileId,\n    bytes32 functionId,\n    address account\n  ) external view returns (bool);\n\n  function profileFunctionCheckAgent(\n    bytes32 profileId,\n    bytes32 functionId,\n    address account\n  ) external view returns (bool);\n\n  function profileFunctionGetInfo(bytes32 profileId, bytes32 functionId)\n    external\n    view\n    returns (ProfileFunctionInfo memory);\n}\n"
    },
    "src/contracts/acl/profile/scope/IProfileRealmManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../../IACLCommons.sol\";\n\n/**\n * @title Realm Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\n\ninterface IProfileRealmManagement is IACLCommons {\n  struct ProfileRealmRegisterRequest {\n    bytes32 domainId;\n    bytes32 adminId;\n    int64 contextLimit;\n    string name;\n  }\n\n  struct ProfileRealmMoveContextRequest {\n    bytes32 realmId;\n    bytes32 targetRealmId;\n    bytes32 contextId;\n  }\n\n  struct ProfileRealmUpdateContextLimitRequest {\n    bytes32 realmId;\n    uint32 contextLimit;\n  }\n\n  struct ProfileRealmInfo {\n    bytes32 domainId;\n    bytes32 adminId;\n    uint32 contextLimit;\n    uint32 contextCount;\n    uint32 referredByAgent;\n    ScopeType stype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    AgentType adminType;\n    string name;\n  }\n\n  event ProfileRealmRegistered(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed realmId,\n    bytes32 domainId,\n    bytes32 adminId\n  );\n\n  event ProfileRealmContextMoved(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed realmId,\n    bytes32 contextId,\n    bytes32 newRealmId\n  );\n\n  event ProfileRealmAdminUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed realmId,\n    bytes32 adminId\n  );\n\n  event ProfileRealmContextLimitUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed realmId,\n    uint32 contextLimit\n  );\n\n  event ProfileRealmActivityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed realmId,\n    ActivityStatus acstat\n  );\n\n  event ProfileRealmAlterabilityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed realmId,\n    AlterabilityStatus alstat\n  );\n\n  event ProfileRealmRemoved(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed realmId,\n    bool isSoftDeleted\n  );\n\n  function profileRealmRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRealmRegisterRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRealmUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRealmMoveContext(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRealmMoveContextRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRealmUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRealmUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRealmUpdateContextLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRealmUpdateContextLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRealmRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata realms)\n    external\n    returns (bool);\n\n  function profileRealmCheckId(bytes32 profileId, bytes32 realmId) external view returns (bool);\n\n  function profileRealmCheckName(bytes32 profileId, string calldata realmName) external view returns (bool);\n\n  function profileRealmCheckAdmin(\n    bytes32 profileId,\n    bytes32 realmId,\n    address account\n  ) external view returns (bool);\n\n  function profileRealmHasFunction(\n    bytes32 profileId,\n    bytes32 realmId,\n    bytes32 functionId\n  ) external view returns (bool);\n\n  function profileRealmHasContext(\n    bytes32 profileId,\n    bytes32 realmId,\n    bytes32 contextId\n  ) external view returns (bool);\n\n  function profileRealmGetContexts(bytes32 profileId, bytes32 realmId) external view returns (bytes32[] memory);\n\n  function profileRealmGetInfo(bytes32 profileId, bytes32 realmId) external view returns (ProfileRealmInfo memory);\n}\n"
    },
    "src/contracts/acl/profile/scope/IProfileDomainManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\n/**\n * @title Profile Domain Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\n\nimport \"../../IACLCommons.sol\";\n\ninterface IProfileDomainManagement is IACLCommons {\n  struct ProfileDomainRegisterRequest {\n    bytes32 adminId;\n    int24 realmLimit;\n    string name;\n  }\n\n  struct ProfileDomainMoveRealmRequest {\n    bytes32 domainId;\n    bytes32 targetDomainId;\n    bytes32 realmId;\n  }\n\n  struct ProfileDomainUpdateRealmLimitRequest {\n    bytes32 domainId;\n    uint16 realmLimit;\n  }\n\n  struct ProfileDomainInfo {\n    bytes32 adminId;\n    bytes32 universeId;\n    uint16 realmLimit;\n    uint16 realmCount;\n    uint32 referredByAgent;\n    ScopeType stype;\n    AgentType adminType;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  event ProfileDomainRegistered(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed domainId,\n    bytes32 adminId\n  );\n\n  event ProfileDomainRealmMoved(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed domainId,\n    bytes32 realmId,\n    bytes32 newDomainId\n  );\n\n  event ProfileDomainAdminUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed domainId,\n    bytes32 adminId\n  );\n\n  event ProfileDomainRealmLimitUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed domainId,\n    uint16 realmLimit\n  );\n\n  event ProfileDomainActivityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed domainId,\n    ActivityStatus acstat\n  );\n\n  event ProfileDomainAlterabilityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed domainId,\n    AlterabilityStatus alstat\n  );\n\n  event ProfileDomainRemoved(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed domainId,\n    bool isSoftDeleted\n  );\n\n  function profileDomainRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileDomainRegisterRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileDomainUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileDomainUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileDomainUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileDomainMoveRealm(\n    ProfileMemberSignature calldata memberSign,\n    ProfileDomainMoveRealmRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileDomainUpdateRealmLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileDomainUpdateRealmLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileDomainRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata domains)\n    external\n    returns (bool);\n\n  function profileDomainCheckId(bytes32 profileId, bytes32 domainId) external view returns (bool);\n\n  function profileDomainCheckName(bytes32 profileId, string calldata domainName) external view returns (bool);\n\n  function profileDomainCheckAdmin(\n    bytes32 profileId,\n    bytes32 domainId,\n    address account\n  ) external view returns (bool);\n\n  function profileDomainHasFunction(\n    bytes32 profileId,\n    bytes32 domainId,\n    bytes32 functionId\n  ) external view returns (bool);\n\n  function profileDomainHasContext(\n    bytes32 profileId,\n    bytes32 domainId,\n    bytes32 contextId\n  ) external view returns (bool);\n\n  function profileDomainHasRealm(\n    bytes32 profileId,\n    bytes32 domainId,\n    bytes32 realmId\n  ) external view returns (bool);\n\n  function profileDomainGetRealms(bytes32 profileId, bytes32 domainId) external view returns (bytes32[] memory);\n\n  function profileDomainGetInfo(bytes32 profileId, bytes32 domainId) external view returns (ProfileDomainInfo memory);\n}\n"
    },
    "src/contracts/acl/profile/scope/IProfileUniverseManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\n/**\n * @title Domain Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\n\nimport \"../../IACLCommons.sol\";\n\ninterface IProfileUniverseManagement is IACLCommons {\n  struct ProfileUniverseInfo {\n    bytes32 id;\n    bytes32 adminId;\n    uint16 domainLimit;\n    uint16 domainCount;\n    uint32 referredByAgent;\n    ScopeType stype;\n    AgentType adminType;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n  }\n\n  event ProfileUniverseAdminUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed universeId,\n    bytes32 adminId\n  );\n\n  event ProfileUniverseDomainLimitUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed universeId,\n    uint16 domainLimit\n  );\n\n  event ProfileUniverseActivityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed universeId,\n    ActivityStatus acstat\n  );\n\n  event ProfileUniverseAlterabilityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed universeId,\n    AlterabilityStatus alstat\n  );\n\n  function profileUniverseUpdateActivityStatus(ProfileMemberSignature calldata memberSign, ActivityStatus acstat)\n    external\n    returns (bool);\n\n  function profileUniverseUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    AlterabilityStatus alstat\n  ) external returns (bool);\n\n  function profileUniverseUpdateAdmin(ProfileMemberSignature calldata memberSign, bytes32 adminId)\n    external\n    returns (bool);\n\n  function profileUniverseUpdateDomainLimit(ProfileMemberSignature calldata memberSign, uint16 domainLimit)\n    external\n    returns (bool);\n\n  function profileUniverseCheckAdmin(bytes32 profileId, address account) external view returns (bool);\n\n  function profileUniverseGetDomains(bytes32 profileId) external view returns (bytes32[] memory);\n\n  function profileUniverseGetInfo(bytes32 profileId) external view returns (ProfileUniverseInfo memory);\n}\n"
    },
    "src/contracts/acl/profile/agent/IProfileMemberManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../../IACLCommons.sol\";\n\n/**\n * @title Member Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IProfileMemberManagement is IACLCommons {\n  struct ProfileMemberRegisterRequest {\n    bytes32 adminId;\n    bytes32 roleId;\n    int24 typeLimit;\n    int24 callLimit;\n    address account;\n    ProfileRegisterLimit registerLimit;\n  }\n\n  struct ProfileMemberUpdateLimitRequest {\n    bytes32 memberId;\n    uint16 limit;\n  }\n\n  struct ProfileMemberUpdateRegisterLimitRequest {\n    bytes32 memberId;\n    ProfileRegisterLimit registerLimit;\n  }\n\n  struct ProfileMemberInfo {\n    bytes32 adminId;\n    address account;\n    uint16 typeLimit;\n    uint16 typeCount;\n    uint16 callLimit;\n    ProfileRegisterLimit registerLimit;\n    AgentType adminType;\n    AgentType atype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n  }\n\n  event ProfileMemberRegistered(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed memberId,\n    bytes32 roleId,\n    bytes32 adminId,\n    ProfileRegisterLimit registerLimit\n  );\n\n  event ProfileMemberTypeLimitUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed memberId,\n    uint16 typeLimit\n  );\n\n  event ProfileMemberRegisterLimitUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed memberId,\n    ProfileRegisterLimit registerLimit\n  );\n\n  event ProfileMemberCallLimitUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed memberId,\n    uint16 callLimit\n  );\n\n  event ProfileMemberAdminUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed memberId,\n    bytes32 adminId\n  );\n\n  event ProfileMemberActivityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed memberId,\n    ActivityStatus acstat\n  );\n\n  event ProfileMemberAlterabilityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed memberId,\n    AlterabilityStatus alstat\n  );\n\n  event ProfileMemberRoleRevoked(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed memberId,\n    bytes32 roleId,\n    bytes32 typeId\n  );\n\n  event ProfileMemberRemoved(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed memberId,\n    bool isCompleted\n  );\n\n  function profileMemberRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileMemberRegisterRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileMemberUpdateTypeLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileMemberUpdateLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileMemberUpdateRegisterLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileMemberUpdateRegisterLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileMemberUpdateCallLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileMemberUpdateLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileMemberUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileMemberUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileMemberUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileMemberRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata members)\n    external\n    returns (bool);\n\n  function profileMemberCheckId(bytes32 profileId, bytes32 memberId) external view returns (bool);\n\n  function profileMemberCheckAccount(bytes32 profileId, address account) external view returns (bool);\n\n  function profileMemberCheckAdmin(\n    bytes32 profileId,\n    bytes32 memberId,\n    address account\n  ) external view returns (bool);\n\n  function profileMemberHasType(\n    bytes32 profileId,\n    bytes32 memberId,\n    bytes32 typeId\n  ) external view returns (bool);\n\n  function profileMemberGetTypes(bytes32 profileId, bytes32 memberId) external view returns (bytes32[] memory);\n\n  function profileMemberGetInfo(bytes32 profileId, bytes32 memberId) external view returns (ProfileMemberInfo memory);\n}\n"
    },
    "src/contracts/acl/profile/agent/IProfileRoleManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../../IACLCommons.sol\";\n\n/**\n * @title Role Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IProfileRoleManagement is IACLCommons {\n  struct ProfileRoleRegisterRequest {\n    bytes32 adminId;\n    bytes32 scopeId;\n    bytes32 typeId;\n    string name;\n    int32 memberLimit;\n  }\n\n  struct ProfileRoleGrantMembersRequest {\n    bytes32 roleId;\n    bytes32[] members;\n  }\n\n  struct ProfileRoleRevokeMembersRequest {\n    bytes32 roleId;\n    bytes32[] members;\n  }\n\n  struct ProfileRoleUpdateMemberLimitRequest {\n    bytes32 roleId;\n    uint24 memberLimit;\n  }\n\n  struct ProfileRoleInfo {\n    bytes32 scopeId;\n    bytes32 typeId;\n    bytes32 adminId;\n    uint24 memberLimit;\n    uint24 memberCount;\n    AgentType adminType;\n    AgentType atype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  event ProfileRoleRegistered(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed roleId,\n    bytes32 typeId,\n    bytes32 adminId,\n    bytes32 scopeId\n  );\n\n  event ProfileRoleMemberDeleted(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed memberId,\n    bytes32 roleId,\n    bytes32 typeId,\n    address account\n  );\n\n  event ProfileRoleMemberGranted(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed roleId,\n    bytes32 memberId,\n    bytes32 typeId\n  );\n\n  event ProfileRoleMemberRevoked(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed roleId,\n    bytes32 memberId,\n    bytes32 typeId\n  );\n\n  event ProfileRoleMemberLimitUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed roleId,\n    uint24 memberLimit\n  );\n\n  event ProfileRoleAdminUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed roleId,\n    bytes32 adminId\n  );\n\n  event ProfileRoleScopeUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed roleId,\n    bytes32 scopeId\n  );\n\n  event ProfileRoleActivityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed roleId,\n    ActivityStatus acstat\n  );\n\n  event ProfileRoleAlterabilityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed roleId,\n    AlterabilityStatus alstat\n  );\n\n  event ProfileRoleRemoved(address indexed sender, bytes32 indexed profileId, bytes32 indexed roleId);\n\n  function profileRoleRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRoleRegisterRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRoleGrantMembers(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRoleGrantMembersRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRoleRevokeMembers(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRoleRevokeMembersRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRoleUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRoleUpdateScope(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateScopeRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRoleUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRoleUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRoleUpdateMemberLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRoleUpdateMemberLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileRoleRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata roles)\n    external\n    returns (bool);\n\n  function profileRoleCheckId(bytes32 profileId, bytes32 roleId) external view returns (bool);\n\n  function profileRoleCheckName(bytes32 profileId, string calldata roleName) external view returns (bool);\n\n  function profileRoleCheckAdmin(\n    bytes32 profileId,\n    bytes32 roleId,\n    address account\n  ) external view returns (bool);\n\n  function profileRoleHasAccount(\n    bytes32 profileId,\n    bytes32 roleId,\n    address account\n  ) external view returns (bool);\n\n  function profileRoleGetInfo(bytes32 profileId, bytes32 roleId) external view returns (ProfileRoleInfo memory);\n}\n"
    },
    "src/contracts/acl/profile/agent/IProfileTypeManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../../IACLCommons.sol\";\n\n/**\n * @title Type Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IProfileTypeManagement is IACLCommons {\n  struct ProfileTypeRegisterRequest {\n    bytes32 adminId;\n    bytes32 scopeId;\n    string name;\n    int24 roleLimit;\n  }\n\n  struct ProfileTypeUpdateRoleLimitRequest {\n    bytes32 typeId;\n    uint16 roleLimit;\n  }\n\n  struct ProfileTypeInfo {\n    bytes32 scopeId;\n    bytes32 adminId;\n    uint16 roleLimit;\n    uint16 roleCount;\n    AgentType adminType;\n    AgentType atype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  event ProfileTypeRegistered(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed typeId,\n    bytes32 scopeId,\n    bytes32 adminId\n  );\n\n  event ProfileTypeActivityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed typeId,\n    ActivityStatus acstat\n  );\n\n  event ProfileTypeAlterabilityUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed typeId,\n    AlterabilityStatus alstat\n  );\n\n  event ProfileTypeRoleLimitUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed typeId,\n    uint16 roleLimit\n  );\n\n  event ProfileTypeScopeUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed typeId,\n    bytes32 scopeId\n  );\n\n  event ProfileTypeAdminUpdated(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed typeId,\n    bytes32 adminId\n  );\n\n  event ProfileTypeRemoved(address indexed sender, bytes32 indexed profileId, bytes32 indexed typeId);\n\n  function profileTypeRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileTypeRegisterRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileTypeUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileTypeUpdateScope(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateScopeRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileTypeUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileTypeUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileTypeUpdateRoleLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileTypeUpdateRoleLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function profileTypeRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata types)\n    external\n    returns (bool);\n\n  function profileTypeCheckId(bytes32 profileId, bytes32 typeId) external view returns (bool);\n\n  function profileTypeCheckName(bytes32 profileId, string calldata typeName) external view returns (bool);\n\n  function profileTypeCheckAdmin(\n    bytes32 profileId,\n    bytes32 typeId,\n    address account\n  ) external view returns (bool);\n\n  function profileTypeHasAccount(\n    bytes32 profileId,\n    bytes32 typeId,\n    address account\n  ) external view returns (bool);\n\n  function profileTypeHasRole(\n    bytes32 profileId,\n    bytes32 typeId,\n    bytes32 roleId\n  ) external view returns (bool);\n\n  function profileTypeGetRoles(bytes32 profileId, bytes32 typeId) external view returns (bytes32[] memory);\n\n  function profileTypeGetInfo(bytes32 profileId, bytes32 typeId) external view returns (ProfileTypeInfo memory);\n}\n"
    },
    "src/contracts/acl/profile/policy/IProfilePolicyManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../../IACLCommons.sol\";\n\n/**\n * @title Profile Policy Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\n\ninterface IProfilePolicyManagement is IACLCommons {\n  struct ProfilePolicyRegisterRequest {\n    bytes32 adminId;\n    bytes32 scopeId;\n    int24 roleLimit;\n    uint8 policyCode;\n    string name;\n  }\n\n  struct ProfilePolicyAddRolesRequest {\n    bytes32 policyId;\n    bytes32[] roles;\n  }\n\n  struct ProfilePolicyRemoveRolesRequest {\n    bytes32 policyId;\n    bytes32[] roles;\n  }\n\n  struct ProfilePolicyUpdateCodeRequest {\n    bytes32 policyId;\n    uint8 policyCode;\n  }\n\n  struct ProfilePolicyUpdateRoleLimitRequest {\n    bytes32 policyId;\n    uint16 roleLimit;\n  }\n\n  struct ProfilePolicyInfo {\n    bytes32 adminId;\n    bytes32 scopeId;\n    string name;\n    uint16 roleLimit;\n    uint16 roleCount;\n    uint8 policyCode;\n    AgentType adminType;\n    ScopeType scopeType;\n    PolicyType ptype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n  }\n\n  event ProfilePolicyRegistered(\n    address indexed sender,\n    bytes32 indexed profileId,\n    bytes32 indexed policyId,\n    bytes32 scopeId,\n    bytes32 adminId,\n    uint8 policyCode\n  );\n\n  event ProfilePolicyRoleAdded(\n    address indexed sender,\n    bytes32 indexed profieId,\n    bytes32 indexed policyId,\n    bytes32 roleId\n  );\n\n  event ProfilePolicyRoleRemoved(\n    address indexed sender,\n    bytes32 indexed profieId,\n    bytes32 indexed policyId,\n    bytes32 roleId\n  );\n\n  event ProfilePolicyActivityUpdated(\n    address indexed sender,\n    bytes32 indexed profieId,\n    bytes32 indexed policyId,\n    ActivityStatus acstat\n  );\n\n  event ProfilePolicyAlterabilityUpdated(\n    address indexed sender,\n    bytes32 indexed profieId,\n    bytes32 indexed policyId,\n    AlterabilityStatus alstat\n  );\n\n  event ProfilePolicyCodeUpdated(\n    address indexed sender,\n    bytes32 indexed profieId,\n    bytes32 indexed policyId,\n    uint8 policyCode,\n    PolicyType ptype\n  );\n\n  event ProfilePolicyRoleLimitUpdated(\n    address indexed sender,\n    bytes32 indexed profieId,\n    bytes32 indexed policyId,\n    uint16 roleLimit\n  );\n\n  event ProfilePolicyAdminUpdated(\n    address indexed sender,\n    bytes32 indexed profieId,\n    bytes32 indexed policyId,\n    bytes32 adminId\n  );\n\n  event ProfilePolicyScopeUpdated(\n    address indexed sender,\n    bytes32 indexed profieId,\n    bytes32 indexed policyId,\n    bytes32 scopeId\n  );\n\n  event ProfilePolicyRemoved(address indexed sender, bytes32 indexed profieId, bytes32 indexed policyId);\n\n  function profilePolicyRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfilePolicyRegisterRequest[] calldata requests\n  ) external returns (bool);\n\n  function profilePolicyAddRoles(\n    ProfileMemberSignature calldata memberSign,\n    ProfilePolicyAddRolesRequest[] calldata requests\n  ) external returns (bool);\n\n  function profilePolicyRemoveRoles(\n    ProfileMemberSignature calldata memberSign,\n    ProfilePolicyRemoveRolesRequest[] calldata requests\n  ) external returns (bool);\n\n  function profilePolicyUpdateCodes(\n    ProfileMemberSignature calldata memberSign,\n    ProfilePolicyUpdateCodeRequest[] calldata requests\n  ) external returns (bool);\n\n  function profilePolicyUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool);\n\n  function profilePolicyUpdateScope(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateScopeRequest[] calldata requests\n  ) external returns (bool);\n\n  function profilePolicyUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profilePolicyUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool);\n\n  function profilePolicyUpdateRoleLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfilePolicyUpdateRoleLimitRequest[] calldata requests\n  ) external returns (bool);\n\n  function profilePolicyRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata policies)\n    external\n    returns (bool);\n\n  function profilePolicyCheckId(bytes32 profileId, bytes32 policyId) external view returns (bool);\n\n  function profilePolicyCheckName(bytes32 profileId, string calldata policyName) external view returns (bool);\n\n  function profilePolicyCheckAdmin(\n    bytes32 profileId,\n    bytes32 policyId,\n    address account\n  ) external view returns (bool);\n\n  function profilePolicyCheckRole(bytes32 profileId, bytes32 roleId) external view returns (bool);\n\n  function profilePolicyCheckAccess(\n    bytes32 profileId,\n    bytes32 policyId,\n    bytes32 functionId\n  ) external view returns (bool);\n\n  function profilePolicyCheckRoleAccess(\n    bytes32 profileId,\n    bytes32 roleId,\n    bytes32 functionId\n  ) external view returns (bool);\n\n  function profilePolicyHasRole(\n    bytes32 profileId,\n    bytes32 policyId,\n    bytes32 roleId\n  ) external view returns (bool);\n\n  function profilePolicyGetInfoByRole(bytes32 profileId, bytes32 roleId)\n    external\n    view\n    returns (ProfilePolicyInfo memory);\n\n  function profilePolicyGetInfo(bytes32 profileId, bytes32 policyId) external view returns (ProfilePolicyInfo memory);\n\n  function profilePolicyGetRoles(bytes32 profileId, bytes32 policyId) external view returns (bytes32[] memory);\n}\n"
    },
    "src/contracts/lib/struct/LEnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary LEnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n    return _values(set._inner);\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(AddressSet storage set) internal view returns (address[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/contracts/lib/acl/LACLStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../../acl/IACLCommons.sol\";\nimport \"../../acl/ACLStorage.sol\";\n\n/**\n * @title ACL Storage Library\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nlibrary LACLStorage {\n  function universeReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.UniverseEntity storage ge)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.UNIVERSE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        ge.slot := keccak256(ptr, 0x40)\n      }\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\n      revert(\"GID Not Found\");\n    } else {\n      revert(\"Illeagl GID Slot\");\n    }\n  }\n\n  function universeWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.UniverseEntity storage ge)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.UNIVERSE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        ge.slot := keccak256(ptr, 0x40)\n      }\n    } else {\n      revert(\"Illegal GID Slot\");\n    }\n  }\n\n  function functionReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.FunctionEntity storage fc)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.FUNCTION) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        fc.slot := keccak256(ptr, 0x40)\n      }\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\n      revert(\"FID Not Found\");\n    } else {\n      revert(\"Illeagl FID Slot\");\n    }\n  }\n\n  function functionTryReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.FunctionEntity storage fc, bool result)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.FUNCTION) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        fc.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        fc.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function functionWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.FunctionEntity storage fc)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.FUNCTION) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        fc.slot := keccak256(ptr, 0x40)\n      }\n    } else {\n      revert(\"Illegal FID Slot\");\n    }\n  }\n\n  function functionTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.FunctionEntity storage fe, bool result)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.FUNCTION) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        fe.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        fe.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function contextReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.ContextEntity storage ce)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.CONTEXT) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        ce.slot := keccak256(ptr, 0x40)\n      }\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\n      revert(\"CID Not Found\");\n    } else {\n      revert(\"Illegal CID Slot\");\n    }\n  }\n\n  function contextTryReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.ContextEntity storage ce, bool result)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.CONTEXT) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        ce.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        ce.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function contextWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.ContextEntity storage ce)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.CONTEXT) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        ce.slot := keccak256(ptr, 0x40)\n      }\n    } else {\n      revert(\"Illegal CID Slot\");\n    }\n  }\n\n  function contextTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.ContextEntity storage ce, bool result)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.CONTEXT) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        ce.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        ce.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function realmReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.RealmEntity storage re)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.REALM) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        re.slot := keccak256(ptr, 0x40)\n      }\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\n      revert(\"RID Not Found\");\n    } else {\n      revert(\"Illeagl RID Slot\");\n    }\n  }\n\n  function realmTryReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.RealmEntity storage re, bool result)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.REALM) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        re.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function realmWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.RealmEntity storage re)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.REALM) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        let slot := keccak256(ptr, 0x40)\n        re.slot := slot\n      }\n    } else {\n      revert(\"Illeagl RID Slot\");\n    }\n  }\n\n  function realmTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.RealmEntity storage re, bool result)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.REALM) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        re.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function domainReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.DomainEntity storage de)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.DOMAIN) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        de.slot := keccak256(ptr, 0x40)\n      }\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\n      revert(\"DID Not Found\");\n    } else {\n      revert(\"Illegal DID Slot\");\n    }\n  }\n\n  function domainTryReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.DomainEntity storage de, bool result)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.DOMAIN) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        de.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        de.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function domainWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.DomainEntity storage de)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.DOMAIN) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        de.slot := keccak256(ptr, 0x40)\n      }\n    } else {\n      revert(\"Illegal DID Slot\");\n    }\n  }\n\n  function domainTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.DomainEntity storage de, bool result)\n  {\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.DOMAIN) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(data.slot, 1))\n        de.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        de.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function memberReadSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.MemberEntity storage me)\n  {\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.MEMBER) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(data.slot, 0))\n        me.slot := keccak256(ptr, 0x40)\n      }\n    } else if (ba.atype == IACLCommons.AgentType.NONE) {\n      revert(\"MID Not Found\");\n    } else {\n      revert(\"Illegal MID Slot\");\n    }\n  }\n\n  function memberTryReadSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.MemberEntity storage me, bool result)\n  {\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.MEMBER) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(data.slot, 0))\n        me.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        me.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function memberWriteSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.MemberEntity storage me)\n  {\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.MEMBER) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(data.slot, 0))\n        me.slot := keccak256(ptr, 0x40)\n      }\n    } else {\n      revert(\"Illegal MID Slot\");\n    }\n  }\n\n  function memberTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.MemberEntity storage me, bool result)\n  {\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.MEMBER) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(data.slot, 0))\n        me.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        me.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function roleReadSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.RoleEntity storage re)\n  {\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.ROLE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(data.slot, 0))\n        re.slot := keccak256(ptr, 0x40)\n      }\n    } else if (ba.atype == IACLCommons.AgentType.NONE) {\n      revert(\"RoleId Not Found\");\n    } else {\n      revert(\"Illegal RoleId Slot\");\n    }\n  }\n\n  function roleTryReadSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.RoleEntity storage re, bool result)\n  {\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.ROLE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(data.slot, 0))\n        re.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function roleWriteSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.RoleEntity storage re)\n  {\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.ROLE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(data.slot, 0))\n        let slot := keccak256(ptr, 0x40)\n        re.slot := slot\n      }\n    } else {\n      revert(\"Illegal RoleId Slot\");\n    }\n  }\n\n  function roleTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.RoleEntity storage re, bool result)\n  {\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.ROLE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(data.slot, 0))\n        let slot := keccak256(ptr, 0x40)\n        re.slot := slot\n      }\n      result = true;\n    } else {\n      assembly {\n        re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function typeReadSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.TypeEntity storage te)\n  {\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.TYPE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(data.slot, 0))\n        te.slot := keccak256(ptr, 0x40)\n      }\n    } else if (ba.atype == IACLCommons.AgentType.NONE) {\n      revert(\"TID Not Found\");\n    } else {\n      revert(\"Illegal TID Slot\");\n    }\n  }\n\n  function typeTryReadSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.TypeEntity storage te, bool result)\n  {\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.TYPE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(data.slot, 0))\n        te.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        te.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n\n  function typeWriteSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.TypeEntity storage te)\n  {\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.TYPE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(data.slot, 0))\n        te.slot := keccak256(ptr, 0x40)\n      }\n    } else {\n      revert(\"Illegal TID Slot\");\n    }\n  }\n\n  function typeTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.TypeEntity storage te, bool result)\n  {\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.TYPE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(data.slot, 0))\n        te.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n    } else {\n      assembly {\n        te.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n      }\n      result = false;\n    }\n  }\n}\n"
    },
    "src/contracts/lib/acl/LACLCommons.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./LACLUtils.sol\";\nimport \"./LACLStorage.sol\";\nimport \"./LProfileStorage.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../../acl/IACLCommons.sol\";\nimport \"../../acl/IACLGenerals.sol\";\nimport \"../../acl/IACLManager.sol\";\nimport \"../../acl/ACLStorage.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../utils/IERC165.sol\";\nimport \"../../acl/IACL.sol\";\nimport \"../../acl/agent/IRoleManagement.sol\";\nimport \"../../acl/profile/IProfileACL.sol\";\nimport \"../../acl/profile/IProfileACLGenerals.sol\";\nimport \"../../acl/profile/IProfileManagement.sol\";\n\n/**\n * @title ACL Commons Library\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nlibrary LACLCommons {\n  using LProfileStorage for IACLCommons.ProfileEntity;\n  using LACLStorage for ACLStorage.DataCollection;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  string public constant LIB_NAME = \"LACLCommons\";\n  string public constant LIB_VERSION = \"3.0.0\";\n\n  bytes32 public constant LIVELY_VERSE_LIVELY_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_MASTER\"));\n  bytes32 public constant LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_SYSTEM_MASTER\"));\n  bytes32 public constant LIVELY_VERSE_ANONYMOUS_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_ANONYMOUS\"));\n  bytes32 public constant LIVELY_VERSE_ANY_TYPE_ID = keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_ANY\"));\n  bytes32 public constant LIVELY_VERSE_SCOPE_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_SCOPE_MASTER\"));\n  bytes32 public constant LIVELY_VERSE_MEMBER_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_MEMBER_MASTER\"));\n  bytes32 public constant LIVELY_VERSE_TYPE_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_TYPE_MASTER\"));\n  bytes32 public constant LIVELY_VERSE_POLICY_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_POLICY_MASTER\"));\n  bytes32 public constant LIVELY_VERSE_PROFILE_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_PROFILE_MASTER\"));\n\n  // Universe Scope ID\n  bytes32 private constant LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID = keccak256(abi.encodePacked(\"UNIVERSE.LIVELY_VERSE\"));\n\n  // General Roles ID\n  bytes32 public constant LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_VERSE.LIVELY_MASTER_ADMIN\"));\n  bytes32 public constant LIVELY_VERSE_SYSTEM_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_VERSE.LIVELY_SYSTEM_MASTER_ADMIN\"));\n  bytes32 public constant LIVELY_VERSE_SCOPE_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_VERSE.LIVELY_SCOPE_MASTER_ADMIN\"));\n  bytes32 public constant LIVELY_VERSE_TYPE_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_VERSE.LIVELY_TYPE_MASTER_ADMIN\"));\n  bytes32 public constant LIVELY_VERSE_MEMBER_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_VERSE.LIVELY_MEMBER_MASTER_ADMIN\"));\n  bytes32 public constant LIVELY_VERSE_POLICY_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_VERSE.LIVELY_POLICY_MASTER_ADMIN\"));\n  bytes32 public constant LIVELY_VERSE_PROFILE_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_VERSE.LIVELY_PROFILE_MASTER_ADMIN\"));\n\n  // Profile Commons\n  bytes32 public constant LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_PROFILE.LIVELY_MASTER\"));\n  bytes32 public constant LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_PROFILE.LIVELY_SYSTEM_MASTER\"));\n  bytes32 public constant LIVELY_PROFILE_ANY_TYPE_ID = keccak256(abi.encodePacked(\"TYPE.LIVELY_PROFILE.LIVELY_ANY\"));\n  bytes32 public constant LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_PROFILE.LIVELY_MASTER_ADMIN\"));\n  bytes32 public constant LIVELY_PROFILE_SYSTEM_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_PROFILE.LIVELY_SYSTEM_MASTER_ADMIN\"));\n  bytes32 public constant LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID =\n    keccak256(abi.encodePacked(\"UNIVERSE.LIVELY_PROFILE\"));\n\n  // ACL Type\n  bytes32 public constant LIVELY_VERSE_LIVELY_GUARD_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_GUARD.MASTER\"));\n\n  function registerProxyFacet(ACLStorage.DataCollection storage data, address implementation) external {\n    data.facetSet.add(address(this));\n    IACLCommons.FacetEntity storage facetEntity = data.facets[address(this)];\n    facetEntity.subjectId = implementation;\n    data.selectors[IProxy.upgradeTo.selector] = address(this);\n    data.selectors[IProxy.setSafeModeStatus.selector] = address(this);\n    data.selectors[IProxy.setUpdatabilityStatus.selector] = address(this);\n    data.selectors[IProxy.setLocalAdmin.selector] = address(this);\n    data.selectors[IProxy.setAccessControlManager.selector] = address(this);\n    data.selectors[IProxy.contractName.selector] = address(this);\n    data.selectors[IProxy.contractVersion.selector] = address(this);\n    data.selectors[IProxy.accessControlManager.selector] = address(this);\n    data.selectors[IProxy.subjectAddress.selector] = address(this);\n    data.selectors[IProxy.safeModeStatus.selector] = address(this);\n    data.selectors[IProxy.updatabilityStatus.selector] = address(this);\n    data.selectors[IProxy.localAdmin.selector] = address(this);\n    data.selectors[IProxy.domainSeparator.selector] = address(this);\n    data.selectors[IProxy.initVersion.selector] = address(this);\n    data.selectors[IProxy.withdrawBalance.selector] = address(this);\n    data.selectors[IERC165.supportsInterface.selector] = address(this);\n    data.selectors[IACLManager.aclRegisterFacet.selector] = address(this);\n    data.selectors[IACLManager.aclUpgradeFacet.selector] = address(this);\n    data.selectors[IACLManager.aclGetFacets.selector] = address(this);\n    data.selectors[IACLManager.aclGetFacet.selector] = address(this);\n    data.selectors[IACLManager.aclHasSelector.selector] = address(this);\n    data.selectors[IACLManager.aclGetFacetInfo.selector] = address(this);\n    data.selectors[IERC1822Proxiable.proxiableUUID.selector] = address(this);\n    data.selectors[bytes4(keccak256(\"initialize(string,string)\"))] = address(this);\n    data.selectors[bytes4(keccak256(\"initACL(address,address,address,address)\"))] = address(this);\n    data.selectors[bytes4(keccak256(\"getFirstInit()\"))] = address(this);\n    data.selectors[bytes4(keccak256(\"getLibrary()\"))] = address(this);\n  }\n\n  function aclRegisterFacet(ACLStorage.DataCollection storage data, IACLManager.FacetRegisterRequest calldata request)\n    external\n    returns (bool)\n  {\n    require(!data.facetSet.contains(request.facetId), \"Facet Already Exist\");\n    for (uint256 j = 0; j < request.selectors.length; j++) {\n      require(data.selectors[request.selectors[j]] == address(0), \"Illegal Selector\");\n      data.selectors[request.selectors[j]] = request.facetId;\n    }\n    data.facetSet.add(request.facetId);\n    IACLCommons.FacetEntity storage facetEntity = data.facets[request.facetId];\n    facetEntity.subjectId = request.subjectId;\n\n    return true;\n  }\n\n  function initACLAgents(\n    ACLStorage.DataCollection storage data,\n    address livelyAdmin,\n    address systemAdmin\n  ) public {\n    _initACLAgents(data, livelyAdmin, systemAdmin);\n  }\n\n  function checkAdminAccess(\n    ACLStorage.DataCollection storage data,\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) external view returns (IACL.AdminAccessStatus) {\n    return _doCheckAdminAccess(data, adminId, memberId, functionId);\n  }\n\n  function getCheckUpdateRequestScope(\n    ACLStorage.DataCollection storage data,\n    bytes32 requestScopeId,\n    bytes32 senderScopeId,\n    IACLCommons.ScopeType senderScopeType\n  ) external returns (IACLCommons.BaseScope storage) {\n    // checking requested type scope\n    IACLCommons.BaseScope storage requestedScope = data.scopes[requestScopeId];\n    require(requestedScope.stype != IACLCommons.ScopeType.NONE, \"Scope Not Found\");\n    require(requestedScope.acstat > IACLCommons.ActivityStatus.DELETED, \"Scope Deleted\");\n\n    // increase referred count to target scope\n    requestedScope.referredByAgent += 1;\n\n    require(requestedScope.stype <= senderScopeType, \"Illegal ScopeType\");\n    if (requestedScope.stype == senderScopeType) {\n      require(requestScopeId == senderScopeId, \"Illegal Scope\");\n    } else {\n      require(IACLGenerals(address(this)).isScopesCompatible(senderScopeId, requestScopeId), \"Illegal Scope\");\n    }\n\n    return requestedScope;\n  }\n\n  function profileCheckAdmin(\n    ACLStorage.DataCollection storage data,\n    bytes32 profileId,\n    address account\n  ) external view returns (bool) {\n    IACLCommons.ProfileEntity storage profileEntity = data.profiles[profileId];\n    if (profileEntity.acstat == IACLCommons.ActivityStatus.NONE) return false;\n\n    bytes32 profileAdminId = profileEntity.adminId;\n    IACLCommons.AgentType agentType = data.agents[profileAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (agentType == IACLCommons.AgentType.ROLE) {\n      (IACLCommons.RoleEntity storage roleEntity, bool result) = data.roleTryReadSlot(profileAdminId);\n      if (!result) return false;\n\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = data.typeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == profileAdminId;\n    } else if (agentType == IACLCommons.AgentType.TYPE) {\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = data.typeTryReadSlot(profileAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function profileUpdateOwnerAccount(\n    ACLStorage.DataCollection storage data,\n    IACLCommons.ProfileEntity storage profileEntity,\n    IProfileManagement.ProfileUpdateOwnerAccountRequest calldata request\n  ) external returns (bool) {\n    // disable profile owner\n    bytes32 ownerId = LACLUtils.accountGenerateId(profileEntity.owner);\n    bytes32 newOwnerId = LACLUtils.accountGenerateId(request.newOwner);\n\n    // check new ownerId\n    require(profileEntity.agents[newOwnerId].acstat == IACLCommons.ActivityStatus.NONE, \"Already Exists\");\n\n    // remove old owner\n    IACLCommons.ProfileMemberEntity storage profileMemberEntity = profileEntity.profileMemberReadSlot(ownerId);\n    profileMemberEntity.ba.acstat = IACLCommons.ActivityStatus.DISABLED;\n    profileMemberEntity.ba.alstat = IACLCommons.AlterabilityStatus.DISABLED;\n    profileEntity.admins.remove(ownerId);\n\n    // remove from profileAccount\n    IACLCommons.ProfileAccount storage profileAccount = data.profileAccounts[profileEntity.owner];\n    for (uint256 j = 0; j < profileAccount.profiles.length; j++) {\n      if (profileAccount.profiles[j] == request.profileId) {\n        if (profileAccount.profiles.length > 1) {\n          if (j < profileAccount.profiles.length - 1)\n            profileAccount.profiles[j] = profileAccount.profiles[profileAccount.profiles.length - 1];\n          profileAccount.profiles.pop();\n        } else {\n          profileAccount.profiles.pop();\n          delete profileAccount.profiles;\n        }\n        break;\n      }\n    }\n\n    // add profile's new owner\n    _doCreateUpdateProfileAccount(data, request.profileId, request.newOwner);\n\n    // Create Owner Member\n    IACLCommons.ProfileMemberEntity storage ownerMember = profileEntity.profileMemberWriteSlot(newOwnerId);\n    ownerMember.account = request.newOwner;\n    ownerMember.typeLimit = profileEntity.limits.typeLimit;\n    ownerMember.callLimit = uint16(profileEntity.limits.profileCallLimit);\n    ownerMember.registerLimits = profileEntity.registerLimits;\n    ownerMember.ba.adminId = LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID;\n    ownerMember.ba.atype = IACLCommons.AgentType.MEMBER;\n    ownerMember.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    ownerMember.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n    ownerMember.types.add(LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID);\n\n    profileEntity.owner = request.newOwner;\n    profileEntity.admins.add(newOwnerId);\n\n    // update profile lively master type\n    IACLCommons.TypeEntity storage livelyMasterType = profileEntity.profileTypeReadSlot(\n      LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID\n    );\n    delete livelyMasterType.members[ownerId];\n    livelyMasterType.members[newOwnerId] = LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID;\n\n    return true;\n  }\n\n  function createUpdateProfileAccount(\n    ACLStorage.DataCollection storage data,\n    bytes32 profileId,\n    address memberAddress\n  ) external {\n    _doCreateUpdateProfileAccount(data, profileId, memberAddress);\n  }\n\n  function profileRegister(\n    ACLStorage.DataCollection storage data,\n    IProfileManagement.ProfileRegisterRequest calldata request,\n    bytes32 signerId,\n    bytes32 profileId,\n    bytes32 functionId\n  ) external returns (bytes32) {\n    // fetch scope type and scope id of sender\n    (IACLCommons.ScopeType signerScopeType, bytes32 signerScopeId) = _doGetScopeFromType(\n      data,\n      LIVELY_VERSE_PROFILE_MASTER_TYPE_ID,\n      signerId\n    );\n    require(\n      signerScopeType == IACLCommons.ScopeType.UNIVERSE && signerScopeId == LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID,\n      \"Illegal Scope\"\n    );\n    require(request.limits.typeLimit >= 1, \"Illegal TypeLimit\");\n\n    _doCreateUpdateProfileAccount(data, profileId, request.profileOwner);\n    _doCreateUpdateProfileAccount(data, profileId, request.profileSystemAdmin);\n\n    IACLCommons.ProfileEntity storage profileEntity = data.profiles[profileId];\n    profileEntity.name = request.name;\n    profileEntity.owner = request.profileOwner;\n    profileEntity.acstat = IACLCommons.ActivityStatus.ENABLED;\n    profileEntity.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    profileEntity.registerLimits = request.registerLimits;\n    profileEntity.limits = request.limits;\n    profileEntity.admins.add(LACLUtils.accountGenerateId(request.profileOwner));\n\n    // check adminId\n    if (request.adminId != bytes32(0)) {\n      require(data.agents[request.adminId].atype > IACLCommons.AgentType.MEMBER, \"Illegal Admin AgentType\");\n      (, bytes32 requestAdminScopeId) = _doAgentGetScopeInfo(data, request.adminId);\n      require(requestAdminScopeId == LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Admin Scope\");\n      IACL.AdminAccessStatus adminAccessStatus = _doCheckAdminAccess(\n        data,\n        LIVELY_VERSE_PROFILE_MASTER_TYPE_ID,\n        signerId,\n        functionId\n      );\n      if (adminAccessStatus != IACL.AdminAccessStatus.PERMITTED) revert IACL.SetAdminForbidden(adminAccessStatus);\n      profileEntity.adminId = request.adminId;\n    } else {\n      profileEntity.adminId = LIVELY_VERSE_PROFILE_MASTER_TYPE_ID;\n    }\n\n    _doInitProfile(profileEntity, request.profileOwner, request.profileSystemAdmin);\n    return profileEntity.adminId;\n  }\n\n  function realmGetAdmin(\n    ACLStorage.DataCollection storage data,\n    bytes32 requestScopeAdmin,\n    bytes32 domainId,\n    bytes32 adminId\n  ) external view returns (bytes32 realmAdminId) {\n    // checking requested context admin\n    if (adminId != bytes32(0)) {\n      require(data.agents[adminId].atype > IACLCommons.AgentType.MEMBER, \"Illegal Admin AgentType\");\n\n      (IACLCommons.ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doAgentGetScopeInfo(data, adminId);\n      require(IACLCommons.ScopeType.DOMAIN <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n      if (IACLCommons.ScopeType.DOMAIN == requestAdminScopeType) {\n        require(requestAdminScopeId == domainId, \"Illegal Admin Scope\");\n      } else {\n        require(requestAdminScopeId == LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Admin Scope\");\n      }\n      realmAdminId = adminId;\n    } else {\n      realmAdminId = requestScopeAdmin;\n    }\n  }\n\n  function _doAgentGetScopeInfo(ACLStorage.DataCollection storage data, bytes32 agentId)\n    private\n    view\n    returns (IACLCommons.ScopeType, bytes32)\n  {\n    IACLCommons.AgentType atype = data.agents[agentId].atype;\n    if (atype == IACLCommons.AgentType.ROLE) {\n      IACLCommons.RoleEntity storage roleEntity = data.roleReadSlot(agentId);\n      IACLCommons.BaseScope storage baseScope = data.scopes[roleEntity.scopeId];\n      return (baseScope.stype, roleEntity.scopeId);\n    } else if (atype == IACLCommons.AgentType.TYPE) {\n      IACLCommons.TypeEntity storage typeEntity = data.typeReadSlot(agentId);\n      IACLCommons.BaseScope storage baseScope = data.scopes[typeEntity.scopeId];\n      return (baseScope.stype, typeEntity.scopeId);\n    }\n\n    return (IACLCommons.ScopeType.NONE, bytes32(0));\n  }\n\n  function _doCheckAdminAccess(\n    ACLStorage.DataCollection storage data,\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) private view returns (IACL.AdminAccessStatus) {\n    (IACLCommons.FunctionEntity storage functionEntity, bool res) = data.functionTryReadSlot(functionId);\n    if (!res) return IACL.AdminAccessStatus.FUNCTION_NOT_FOUND;\n\n    IACLCommons.AgentType adminAgentType = data.agents[adminId].atype;\n    if (adminAgentType == IACLCommons.AgentType.ROLE) {\n      (IACLCommons.RoleEntity storage roleEntity, bool result) = data.roleTryReadSlot(adminId);\n      if (!result) return IACL.AdminAccessStatus.ROLE_NOT_FOUND;\n      if (roleEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IACL.AdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN;\n\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = data.typeTryReadSlot(roleEntity.typeId);\n      if (!result1) return IACL.AdminAccessStatus.TYPE_NOT_FOUND;\n      if (typeEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IACL.AdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN;\n\n      if (typeEntity.members[memberId] != adminId) return IACL.AdminAccessStatus.NOT_PERMITTED;\n\n      IACLCommons.PolicyEntity storage policyEntity = data.policies[data.rolePolicyMap[adminId]];\n      if (\n        policyEntity.acstat == IACLCommons.ActivityStatus.ENABLED &&\n        policyEntity.policyCode >= functionEntity.policyCode\n      ) return IACL.AdminAccessStatus.POLICY_FORBIDDEN;\n\n      return IACL.AdminAccessStatus.PERMITTED;\n    } else if (adminAgentType == IACLCommons.AgentType.TYPE) {\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = data.typeTryReadSlot(adminId);\n      if (!result1) return IACL.AdminAccessStatus.TYPE_NOT_FOUND;\n      if (typeEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IACL.AdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN;\n\n      bytes32 roleId = typeEntity.members[memberId];\n      (IACLCommons.RoleEntity storage roleEntity, bool result2) = data.roleTryReadSlot(roleId);\n      if (!result2) return IACL.AdminAccessStatus.ROLE_NOT_FOUND;\n      if (roleEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IACL.AdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN;\n\n      IACLCommons.PolicyEntity storage policyEntity = data.policies[data.rolePolicyMap[roleId]];\n      if (\n        policyEntity.acstat == IACLCommons.ActivityStatus.ENABLED &&\n        policyEntity.policyCode >= functionEntity.policyCode\n      ) return IACL.AdminAccessStatus.POLICY_FORBIDDEN;\n\n      return IACL.AdminAccessStatus.PERMITTED;\n    }\n\n    return IACL.AdminAccessStatus.NOT_PERMITTED;\n  }\n\n  function _doCreateUpdateProfileAccount(\n    ACLStorage.DataCollection storage data,\n    bytes32 profileId,\n    address memberAddress\n  ) private {\n    IACLCommons.ProfileAccount storage profileAccount = data.profileAccounts[memberAddress];\n    if (profileAccount.profiles.length == 0) {\n      IACLCommons.ProfileAccount storage newProfileAccount = data.profileAccounts[memberAddress];\n      newProfileAccount.profiles.push(profileId);\n    } else {\n      require(profileAccount.profiles.length < 16, \"Illegal ProfileAccountLimit\");\n      profileAccount.profiles.push(profileId);\n    }\n  }\n\n  function _doGetScopeFromType(\n    ACLStorage.DataCollection storage data,\n    bytes32 typeId,\n    bytes32 senderId\n  ) private view returns (IACLCommons.ScopeType, bytes32) {\n    IACLCommons.TypeEntity storage agentType = data.typeReadSlot(typeId);\n    bytes32 memberRoleId = agentType.members[senderId];\n    IACLCommons.RoleEntity storage memberAgentRole = data.roleReadSlot(memberRoleId);\n    return (data.scopes[memberAgentRole.scopeId].stype, memberAgentRole.scopeId);\n  }\n\n  function _doInitProfile(\n    IACLCommons.ProfileEntity storage profileEntity,\n    address profileOwner,\n    address profileSystemAdmin\n  ) private {\n    // init Universe Scope\n    IACLCommons.UniverseEntity storage livelyUniverseEntity = profileEntity.profileUniverseWriteSlot(\n      LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID\n    );\n    livelyUniverseEntity.name = \"UNIVERSE.LIVELY_PROFILE\";\n    livelyUniverseEntity.domainLimit = profileEntity.limits.domainLimit;\n    livelyUniverseEntity.bs.acstat = IACLCommons.ActivityStatus.ENABLED;\n    livelyUniverseEntity.bs.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    livelyUniverseEntity.bs.stype = IACLCommons.ScopeType.UNIVERSE;\n    livelyUniverseEntity.bs.adminId = LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID;\n\n    // Create Any Type\n    IACLCommons.TypeEntity storage anyType = profileEntity.profileTypeWriteSlot(LIVELY_PROFILE_ANY_TYPE_ID);\n    anyType.name = \"TYPE.LIVELY_VERSE.LIVELY_ANY\";\n    anyType.roleLimit = 0;\n    anyType.scopeId = LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID;\n    anyType.ba.adminId = LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID;\n    anyType.ba.atype = IACLCommons.AgentType.TYPE;\n    anyType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n    anyType.ba.alstat = IACLCommons.AlterabilityStatus.DISABLED;\n\n    // Create Lively Master Type\n    IACLCommons.TypeEntity storage livelyMasterType = profileEntity.profileTypeWriteSlot(\n      LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID\n    );\n    livelyMasterType.name = \"TYPE.LIVELY_PROFILE.LIVELY_MASTER\";\n    livelyMasterType.roleLimit = profileEntity.limits.typeRoleLimit > 1 ? profileEntity.limits.typeRoleLimit : 1;\n    livelyMasterType.scopeId = LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID;\n    livelyMasterType.ba.adminId = LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID;\n    livelyMasterType.ba.atype = IACLCommons.AgentType.TYPE;\n    livelyMasterType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n    livelyMasterType.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    livelyMasterType.roles.add(LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID);\n\n    // Create Lively Master Admin Role\n    IACLCommons.RoleEntity storage livelyMasterAdminRole = profileEntity.profileRoleWriteSlot(\n      LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID\n    );\n    livelyMasterAdminRole.name = \"ROLE.LIVELY_PROFILE.LIVELY_MASTER_ADMIN\";\n    livelyMasterAdminRole.scopeId = LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID;\n    livelyMasterAdminRole.typeId = LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID;\n    livelyMasterAdminRole.memberLimit = profileEntity.limits.memberLimit > 1 ? profileEntity.limits.memberLimit : 1;\n    livelyMasterAdminRole.memberCount = 1;\n    livelyMasterAdminRole.ba.atype = IACLCommons.AgentType.ROLE;\n    livelyMasterAdminRole.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n    livelyMasterAdminRole.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    livelyMasterAdminRole.ba.adminId = LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID;\n\n    // Create Owner Member\n    bytes32 ownerMemberId = LACLUtils.accountGenerateId(profileOwner);\n    IACLCommons.ProfileMemberEntity storage ownerMember = profileEntity.profileMemberWriteSlot(ownerMemberId);\n    ownerMember.account = profileOwner;\n    ownerMember.typeLimit = profileEntity.limits.typeLimit;\n    ownerMember.callLimit = uint16(profileEntity.limits.profileCallLimit);\n    ownerMember.registerLimits = profileEntity.registerLimits;\n    ownerMember.ba.adminId = LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID;\n    ownerMember.ba.atype = IACLCommons.AgentType.MEMBER;\n    ownerMember.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    ownerMember.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n\n    // bind Lively Master Admin Member to Admin role of Lively,\n    ownerMember.types.add(LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID);\n\n    // bind Lively Master Admin Member to Admin role\n    // livelyMasterType.members[livelyMasterAdminMemberId] = LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID;\n    livelyMasterType.members[ownerMemberId] = LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID;\n\n    _doInitProfileSystemMaster(profileEntity, profileSystemAdmin);\n\n    // update livelyUniverseEntity.bs.referredByAgent\n    livelyUniverseEntity.bs.referredByAgent = 5;\n  }\n\n  function _doInitProfileSystemMaster(IACLCommons.ProfileEntity storage profileEntity, address profileSystemAdmin)\n    private\n  {\n    // Create System Master Type\n    IACLCommons.TypeEntity storage systemMasterType = profileEntity.profileTypeWriteSlot(\n      LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID\n    );\n    systemMasterType.name = \"TYPE.LIVELY_PROFILE.LIVELY_SYSTEM_MASTER\";\n    systemMasterType.roleLimit = profileEntity.limits.typeRoleLimit > 1 ? profileEntity.limits.typeRoleLimit : 1;\n    systemMasterType.scopeId = LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID;\n    systemMasterType.ba.adminId = LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID;\n    systemMasterType.ba.atype = IACLCommons.AgentType.TYPE;\n    systemMasterType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n    systemMasterType.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    systemMasterType.roles.add(LIVELY_PROFILE_SYSTEM_MASTER_ADMIN_ROLE_ID);\n\n    // Create System Master Admin Role\n    IACLCommons.RoleEntity storage systemMasterAdminRole = profileEntity.profileRoleWriteSlot(\n      LIVELY_PROFILE_SYSTEM_MASTER_ADMIN_ROLE_ID\n    );\n    systemMasterAdminRole.name = \"ROLE.LIVELY_PROFILE.LIVELY_SYSTEM_MASTER_ADMIN\";\n    systemMasterAdminRole.scopeId = LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID;\n    systemMasterAdminRole.typeId = LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID;\n    systemMasterAdminRole.memberLimit = profileEntity.limits.memberLimit > 1 ? profileEntity.limits.memberLimit : 1;\n    systemMasterAdminRole.memberCount = 1;\n    systemMasterAdminRole.ba.atype = IACLCommons.AgentType.ROLE;\n    systemMasterAdminRole.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n    systemMasterAdminRole.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    systemMasterAdminRole.ba.adminId = LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID;\n\n    // Create System Master Admin Member\n    bytes32 systemMasterAdminMemberId = LACLUtils.accountGenerateId(profileSystemAdmin);\n    IACLCommons.ProfileMemberEntity storage systemMasterAdminMember = profileEntity.profileMemberWriteSlot(\n      systemMasterAdminMemberId\n    );\n    systemMasterAdminMember.typeLimit = profileEntity.limits.typeLimit;\n    systemMasterAdminMember.callLimit = uint16(profileEntity.limits.profileCallLimit);\n    systemMasterAdminMember.registerLimits = IACLCommons.ProfileRegisterLimit({\n      memberRegisterLimit: 0,\n      roleRegisterLimit: 0,\n      typeRegisterLimit: 0,\n      functionRegisterLimit: profileEntity.registerLimits.functionRegisterLimit,\n      contextRegisterLimit: profileEntity.registerLimits.contextRegisterLimit,\n      realmRegisterLimit: 0,\n      domainRegisterLimit: 0,\n      policyRegisterLimit: 0\n    });\n    systemMasterAdminMember.account = profileSystemAdmin;\n    systemMasterAdminMember.ba.adminId = LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID;\n    systemMasterAdminMember.ba.atype = IACLCommons.AgentType.MEMBER;\n    systemMasterAdminMember.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    systemMasterAdminMember.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n    systemMasterAdminMember.types.add(LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID);\n\n    // bind Lively Master Admin Member to Admin role\n    systemMasterType.members[systemMasterAdminMemberId] = LIVELY_PROFILE_SYSTEM_MASTER_ADMIN_ROLE_ID;\n  }\n\n  function _initACLAgents(\n    ACLStorage.DataCollection storage data,\n    address livelyAdmin,\n    address systemAdmin\n  ) private {\n    // init Universe Scope\n    IACLCommons.UniverseEntity storage livelyUniverseEntity = data.universeWriteSlot(\n      LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID\n    );\n    livelyUniverseEntity.name = \"UNIVERSE.LIVELY_VERSE\";\n    livelyUniverseEntity.domainLimit = type(uint16).max;\n    livelyUniverseEntity.bs.acstat = IACLCommons.ActivityStatus.ENABLED;\n    livelyUniverseEntity.bs.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    livelyUniverseEntity.bs.stype = IACLCommons.ScopeType.UNIVERSE;\n    livelyUniverseEntity.bs.adminId = LIVELY_VERSE_LIVELY_MASTER_TYPE_ID;\n\n    // Create Lively Master Type\n    IACLCommons.TypeEntity storage livelyMasterType = data.typeWriteSlot(LIVELY_VERSE_LIVELY_MASTER_TYPE_ID);\n    livelyMasterType.name = \"TYPE.LIVELY_VERSE.LIVELY_MASTER\";\n    livelyMasterType.roleLimit = type(uint16).max;\n    livelyMasterType.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n    livelyMasterType.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n    livelyMasterType.ba.atype = IACLCommons.AgentType.TYPE;\n    livelyMasterType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n    livelyMasterType.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    livelyMasterType.roles.add(LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID);\n\n    // Create Lively Master Admin Role\n    IACLCommons.RoleEntity storage livelyMasterAdminRole = data.roleWriteSlot(LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID);\n    livelyMasterAdminRole.name = \"ROLE.LIVELY_VERSE.LIVELY_MASTER_ADMIN\";\n    livelyMasterAdminRole.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n    livelyMasterAdminRole.typeId = LIVELY_VERSE_LIVELY_MASTER_TYPE_ID;\n    livelyMasterAdminRole.memberLimit = type(uint24).max;\n    livelyMasterAdminRole.memberCount = 1;\n    livelyMasterAdminRole.ba.atype = IACLCommons.AgentType.ROLE;\n    livelyMasterAdminRole.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n    livelyMasterAdminRole.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    livelyMasterAdminRole.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n\n    // Create Lively Master Admin Member\n    bytes32 livelyMasterAdminMemberId = LACLUtils.accountGenerateId(livelyAdmin);\n    IACLCommons.MemberEntity storage livelyMasterAdminMember = data.memberWriteSlot(livelyMasterAdminMemberId);\n    livelyMasterAdminMember.account = livelyAdmin;\n    livelyMasterAdminMember.limits = IACLCommons.GeneralLimit({\n      memberLimit: type(uint24).max,\n      memberRegisterLimit: type(uint16).max,\n      contextRegisterLimit: type(uint16).max,\n      functionRegisterLimit: type(uint16).max,\n      profileRegisterLimit: type(uint16).max,\n      contextLimit: type(uint16).max,\n      realmLimit: type(uint16).max,\n      domainLimit: type(uint16).max,\n      callLimit: type(uint16).max,\n      typeRoleLimit: type(uint16).max,\n      typeLimit: type(uint16).max,\n      roleRegisterLimit: type(uint8).max,\n      typeRegisterLimit: type(uint8).max,\n      realmRegisterLimit: type(uint8).max,\n      domainRegisterLimit: type(uint8).max,\n      policyRegisterLimit: type(uint8).max,\n      policyRoleLimit: type(uint8).max,\n      functionLimit: type(uint8).max\n    });\n\n    livelyMasterAdminMember.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n    livelyMasterAdminMember.ba.atype = IACLCommons.AgentType.MEMBER;\n    livelyMasterAdminMember.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    livelyMasterAdminMember.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n\n    // bind Lively Master Admin Member to Admin role of Lively, Scope, Type, Member, Profile and Policy types\n    livelyMasterAdminMember.types.add(LIVELY_VERSE_LIVELY_MASTER_TYPE_ID);\n\n    livelyMasterAdminMember.types.add(LIVELY_VERSE_SCOPE_MASTER_TYPE_ID);\n    livelyMasterAdminMember.types.add(LIVELY_VERSE_TYPE_MASTER_TYPE_ID);\n    livelyMasterAdminMember.types.add(LIVELY_VERSE_MEMBER_MASTER_TYPE_ID);\n    livelyMasterAdminMember.types.add(LIVELY_VERSE_POLICY_MASTER_TYPE_ID);\n    livelyMasterAdminMember.types.add(LIVELY_VERSE_PROFILE_MASTER_TYPE_ID);\n    livelyMasterAdminMember.types.add(LIVELY_VERSE_LIVELY_GUARD_MASTER_TYPE_ID);\n\n    // bind Lively Master Admin Member to Admin role\n    livelyMasterType.members[livelyMasterAdminMemberId] = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n\n    {\n      // Create Profile Any Type\n      IACLCommons.TypeEntity storage profileAnyType = data.typeWriteSlot(LIVELY_PROFILE_ANY_TYPE_ID);\n      profileAnyType.name = \"TYPE.LIVELY_VERSE.LIVELY_ANY\";\n      profileAnyType.roleLimit = 0;\n      profileAnyType.scopeId = LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID;\n      profileAnyType.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      profileAnyType.ba.atype = IACLCommons.AgentType.TYPE;\n      profileAnyType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      profileAnyType.ba.alstat = IACLCommons.AlterabilityStatus.DISABLED;\n\n      // Create Profile Lively Master Type\n      IACLCommons.TypeEntity storage profileLivelyMasterType = data.typeWriteSlot(LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID);\n      profileLivelyMasterType.name = \"TYPE.LIVELY_PROFILE.LIVELY_MASTER\";\n      profileLivelyMasterType.roleLimit = 0;\n      profileLivelyMasterType.scopeId = LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID;\n      profileLivelyMasterType.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      profileLivelyMasterType.ba.atype = IACLCommons.AgentType.TYPE;\n      profileLivelyMasterType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      profileLivelyMasterType.ba.alstat = IACLCommons.AlterabilityStatus.DISABLED;\n\n      // Create Profile System Master Type\n      IACLCommons.TypeEntity storage profileSystemMasterType = data.typeWriteSlot(LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID);\n      profileSystemMasterType.name = \"TYPE.LIVELY_PROFILE.LIVELY_SYSTEM_MASTER\";\n      profileSystemMasterType.roleLimit = 0;\n      profileSystemMasterType.scopeId = LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID;\n      profileSystemMasterType.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      profileSystemMasterType.ba.atype = IACLCommons.AgentType.TYPE;\n      profileSystemMasterType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      profileSystemMasterType.ba.alstat = IACLCommons.AlterabilityStatus.DISABLED;\n    }\n\n    {\n      // Create System Master Type\n      IACLCommons.TypeEntity storage systemMasterType = data.typeWriteSlot(LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID);\n      systemMasterType.name = \"TYPE.LIVELY_VERSE.LIVELY_SYSTEM_MASTER\";\n      systemMasterType.roleLimit = type(uint16).max;\n      systemMasterType.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      systemMasterType.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      systemMasterType.ba.atype = IACLCommons.AgentType.TYPE;\n      systemMasterType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      systemMasterType.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      systemMasterType.roles.add(LIVELY_VERSE_SYSTEM_MASTER_ADMIN_ROLE_ID);\n\n      // Create System Master Admin Role\n      IACLCommons.RoleEntity storage systemMasterAdminRole = data.roleWriteSlot(\n        LIVELY_VERSE_SYSTEM_MASTER_ADMIN_ROLE_ID\n      );\n      systemMasterAdminRole.name = \"ROLE.LIVELY_VERSE.LIVELY_SYSTEM_MASTER_ADMIN\";\n      systemMasterAdminRole.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      systemMasterAdminRole.typeId = LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID;\n      systemMasterAdminRole.memberLimit = type(uint24).max;\n      systemMasterAdminRole.memberCount = 1;\n      systemMasterAdminRole.ba.atype = IACLCommons.AgentType.ROLE;\n      systemMasterAdminRole.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      systemMasterAdminRole.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      systemMasterAdminRole.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n\n      // Create System Master Admin Member\n      bytes32 systemMasterAdminMemberId = LACLUtils.accountGenerateId(systemAdmin);\n      IACLCommons.MemberEntity storage systemMasterAdminMember = data.memberWriteSlot(systemMasterAdminMemberId);\n\n      systemMasterAdminMember.limits = IACLCommons.GeneralLimit({\n        memberLimit: 1024,\n        memberRegisterLimit: 0,\n        contextRegisterLimit: 128,\n        functionRegisterLimit: type(uint16).max,\n        profileRegisterLimit: 0,\n        contextLimit: type(uint16).max,\n        realmLimit: 0,\n        domainLimit: 0,\n        callLimit: type(uint16).max,\n        typeRoleLimit: type(uint8).max,\n        typeLimit: type(uint8).max,\n        roleRegisterLimit: 0,\n        typeRegisterLimit: 0,\n        realmRegisterLimit: 0,\n        domainRegisterLimit: 0,\n        policyRegisterLimit: 0,\n        policyRoleLimit: type(uint8).max,\n        functionLimit: type(uint8).max\n      });\n\n      systemMasterAdminMember.account = systemAdmin;\n      systemMasterAdminMember.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      systemMasterAdminMember.ba.atype = IACLCommons.AgentType.MEMBER;\n      systemMasterAdminMember.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      systemMasterAdminMember.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      systemMasterAdminMember.types.add(LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID);\n\n      // bind Lively Master Admin Member to Admin role\n      systemMasterType.members[systemMasterAdminMemberId] = LIVELY_VERSE_SYSTEM_MASTER_ADMIN_ROLE_ID;\n    }\n\n    {\n      // Create Scope Master Type\n      IACLCommons.TypeEntity storage scopeMasterType = data.typeWriteSlot(LIVELY_VERSE_SCOPE_MASTER_TYPE_ID);\n      scopeMasterType.name = \"TYPE.LIVELY_VERSE.LIVELY_SCOPE_MASTER\";\n      scopeMasterType.roleLimit = type(uint16).max;\n      scopeMasterType.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      scopeMasterType.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      scopeMasterType.ba.atype = IACLCommons.AgentType.TYPE;\n      scopeMasterType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      scopeMasterType.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      scopeMasterType.roles.add(LIVELY_VERSE_SCOPE_MASTER_ADMIN_ROLE_ID);\n      scopeMasterType.members[livelyMasterAdminMemberId] = LIVELY_VERSE_SCOPE_MASTER_ADMIN_ROLE_ID;\n\n      // Create Scope Master Admin Role\n      IACLCommons.RoleEntity storage scopeMasterAdminRole = data.roleWriteSlot(LIVELY_VERSE_SCOPE_MASTER_ADMIN_ROLE_ID);\n      scopeMasterAdminRole.name = \"ROLE.LIVELY_VERSE.LIVELY_SCOPE_MASTER_ADMIN\";\n      scopeMasterAdminRole.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      scopeMasterAdminRole.typeId = LIVELY_VERSE_SCOPE_MASTER_TYPE_ID;\n      scopeMasterAdminRole.memberLimit = type(uint24).max;\n      scopeMasterAdminRole.memberCount = 1;\n      scopeMasterAdminRole.ba.atype = IACLCommons.AgentType.ROLE;\n      scopeMasterAdminRole.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      scopeMasterAdminRole.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      scopeMasterAdminRole.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n\n      // Create Type Master Type\n      IACLCommons.TypeEntity storage typeMasterType = data.typeWriteSlot(LIVELY_VERSE_TYPE_MASTER_TYPE_ID);\n      typeMasterType.name = \"TYPE.LIVELY_VERSE.LIVELY_TYPE_MASTER\";\n      typeMasterType.roleLimit = type(uint16).max;\n      typeMasterType.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      typeMasterType.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      typeMasterType.ba.atype = IACLCommons.AgentType.TYPE;\n      typeMasterType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      typeMasterType.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      typeMasterType.roles.add(LIVELY_VERSE_TYPE_MASTER_ADMIN_ROLE_ID);\n      typeMasterType.members[livelyMasterAdminMemberId] = LIVELY_VERSE_TYPE_MASTER_ADMIN_ROLE_ID;\n\n      // Create Type Master Admin Role\n      IACLCommons.RoleEntity storage typeMasterAdminRole = data.roleWriteSlot(LIVELY_VERSE_TYPE_MASTER_ADMIN_ROLE_ID);\n      typeMasterAdminRole.name = \"ROLE.LIVELY_VERSE.LIVELY_TYPE_MASTER_ADMIN\";\n      typeMasterAdminRole.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      typeMasterAdminRole.typeId = LIVELY_VERSE_TYPE_MASTER_TYPE_ID;\n      typeMasterAdminRole.memberLimit = type(uint24).max;\n      typeMasterAdminRole.memberCount = 1;\n      typeMasterAdminRole.ba.atype = IACLCommons.AgentType.ROLE;\n      typeMasterAdminRole.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      typeMasterAdminRole.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      typeMasterAdminRole.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n    }\n\n    {\n      // Create Member Master Type\n      IACLCommons.TypeEntity storage memberMasterType = data.typeWriteSlot(LIVELY_VERSE_MEMBER_MASTER_TYPE_ID);\n      memberMasterType.name = \"TYPE.LIVELY_VERSE.LIVELY_MEMBER_MASTER\";\n      memberMasterType.roleLimit = type(uint16).max;\n      memberMasterType.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      memberMasterType.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      memberMasterType.ba.atype = IACLCommons.AgentType.TYPE;\n      memberMasterType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      memberMasterType.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      memberMasterType.roles.add(LIVELY_VERSE_MEMBER_MASTER_ADMIN_ROLE_ID);\n      memberMasterType.members[livelyMasterAdminMemberId] = LIVELY_VERSE_MEMBER_MASTER_ADMIN_ROLE_ID;\n\n      // Create Member Master Admin Role\n      IACLCommons.RoleEntity storage memberMasterAdminRole = data.roleWriteSlot(\n        LIVELY_VERSE_MEMBER_MASTER_ADMIN_ROLE_ID\n      );\n      memberMasterAdminRole.name = \"ROLE.LIVELY_VERSE.LIVELY_MEMBER_MASTER_ADMIN\";\n      memberMasterAdminRole.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      memberMasterAdminRole.typeId = LIVELY_VERSE_MEMBER_MASTER_TYPE_ID;\n      memberMasterAdminRole.memberLimit = type(uint24).max;\n      memberMasterAdminRole.memberCount = 1;\n      memberMasterAdminRole.ba.atype = IACLCommons.AgentType.ROLE;\n      memberMasterAdminRole.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      memberMasterAdminRole.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      memberMasterAdminRole.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n    }\n\n    {\n      // Create Policy Master Type\n      IACLCommons.TypeEntity storage policyMasterType = data.typeWriteSlot(LIVELY_VERSE_POLICY_MASTER_TYPE_ID);\n      policyMasterType.name = \"TYPE.LIVELY_VERSE.LIVELY_POLICY_MASTER\";\n      policyMasterType.roleLimit = type(uint16).max;\n      policyMasterType.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      policyMasterType.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      policyMasterType.ba.atype = IACLCommons.AgentType.TYPE;\n      policyMasterType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      policyMasterType.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      policyMasterType.roles.add(LIVELY_VERSE_POLICY_MASTER_ADMIN_ROLE_ID);\n      policyMasterType.members[livelyMasterAdminMemberId] = LIVELY_VERSE_POLICY_MASTER_ADMIN_ROLE_ID;\n\n      // Create Policy Master Admin Role\n      IACLCommons.RoleEntity storage policyMasterAdminRole = data.roleWriteSlot(\n        LIVELY_VERSE_POLICY_MASTER_ADMIN_ROLE_ID\n      );\n      policyMasterAdminRole.name = \"ROLE.LIVELY_VERSE.LIVELY_POLICY_MASTER_ADMIN\";\n      policyMasterAdminRole.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      policyMasterAdminRole.typeId = LIVELY_VERSE_POLICY_MASTER_TYPE_ID;\n      policyMasterAdminRole.memberLimit = type(uint24).max;\n      policyMasterAdminRole.memberCount = 1;\n      policyMasterAdminRole.ba.atype = IACLCommons.AgentType.ROLE;\n      policyMasterAdminRole.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      policyMasterAdminRole.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      policyMasterAdminRole.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n\n      // Create Profile Master Type\n      IACLCommons.TypeEntity storage profileMasterType = data.typeWriteSlot(LIVELY_VERSE_PROFILE_MASTER_TYPE_ID);\n      profileMasterType.name = \"TYPE.LIVELY_VERSE.LIVELY_PROFILE_MASTER\";\n      profileMasterType.roleLimit = type(uint16).max;\n      profileMasterType.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      profileMasterType.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      profileMasterType.ba.atype = IACLCommons.AgentType.TYPE;\n      profileMasterType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      profileMasterType.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      profileMasterType.roles.add(LIVELY_VERSE_POLICY_MASTER_ADMIN_ROLE_ID);\n      profileMasterType.members[livelyMasterAdminMemberId] = LIVELY_VERSE_PROFILE_MASTER_ADMIN_ROLE_ID;\n\n      // Create Profile Master Admin Role\n      IACLCommons.RoleEntity storage profileMasterAdminRole = data.roleWriteSlot(\n        LIVELY_VERSE_PROFILE_MASTER_ADMIN_ROLE_ID\n      );\n      profileMasterAdminRole.name = \"ROLE.LIVELY_VERSE.LIVELY_PROFILE_MASTER_ADMIN\";\n      profileMasterAdminRole.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      profileMasterAdminRole.typeId = LIVELY_VERSE_PROFILE_MASTER_TYPE_ID;\n      profileMasterAdminRole.memberLimit = type(uint24).max;\n      profileMasterAdminRole.memberCount = 1;\n      profileMasterAdminRole.ba.atype = IACLCommons.AgentType.ROLE;\n      profileMasterAdminRole.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      profileMasterAdminRole.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n      profileMasterAdminRole.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n    }\n    {\n      // Create Anonymouse  Type\n      IACLCommons.TypeEntity storage anonymousType = data.typeWriteSlot(LIVELY_VERSE_ANONYMOUS_TYPE_ID);\n      anonymousType.name = \"TYPE.LIVELY_VERSE.LIVELY_ANONYMOUS\";\n      anonymousType.roleLimit = 0;\n      anonymousType.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      anonymousType.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      anonymousType.ba.atype = IACLCommons.AgentType.TYPE;\n      anonymousType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      anonymousType.ba.alstat = IACLCommons.AlterabilityStatus.DISABLED;\n\n      // Create Any Type\n      IACLCommons.TypeEntity storage anyType = data.typeWriteSlot(LIVELY_VERSE_ANY_TYPE_ID);\n      anyType.name = \"TYPE.LIVELY_VERSE.LIVELY_ANY\";\n      anyType.roleLimit = 0;\n      anyType.scopeId = LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      anyType.ba.adminId = LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID;\n      anyType.ba.atype = IACLCommons.AgentType.TYPE;\n      anyType.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n      anyType.ba.alstat = IACLCommons.AlterabilityStatus.DISABLED;\n    }\n\n    // update livelyUniverseEntity.bs.referredByAgent\n    livelyUniverseEntity.bs.referredByAgent = 16;\n    livelyUniverseEntity.domains.add(LACLUtils.generateId2(\"DOMAIN.LIVELY_VERSE.LIVELY_GUARD\"));\n  }\n}\n"
    },
    "src/contracts/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin, Sina Tadayon, https://github.com/SinaTadayon\n\npragma solidity 0.8.19;\n\nimport \"../lib/LAddress.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n   * @custom:oz-retyped-from bool\n   */\n  uint16 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private _initializing;\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n   * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n   */\n  modifier initializer() {\n    bool isTopLevelCall = !_initializing;\n    require(\n      (isTopLevelCall && _initialized < 1) || (!LAddress.isContract(address(this)) && _initialized == 1),\n      \"Contract Already Initialized\"\n    );\n    _initialized = 1;\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n   * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n   * used to initialize parent contracts.\n   *\n   * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n   * initialization step. This is essential to configure modules that are added through upgrades and that require\n   * initialization.\n   *\n   * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n   * a contract, executing them in the right order is up to the developer or operator.\n   */\n  modifier reinitializer(uint16 version) {\n    require(!_initializing && _initialized < version, \"Contract Already Initialized\");\n    _initialized = version;\n    _initializing = true;\n    _;\n    _initializing = false;\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n   * {initializer} and {reinitializer} modifiers, directly or indirectly.\n   */\n  modifier onlyInitializing() {\n    require(_initializing, \"Contract Not Initializing\");\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n   * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n   * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n   * through proxies.\n   */\n  function _disableInitializers() internal virtual {\n    require(!_initializing, \"Contract Initializing Invalid\");\n    if (_initialized < type(uint16).max) {\n      _initialized = type(uint16).max;\n    }\n  }\n\n  function _getInitializedCount() internal view returns (uint16) {\n    return _initialized;\n  }\n\n  function _isInitializing() internal view returns (bool) {\n    return _initializing;\n  }\n}\n"
    },
    "src/contracts/proxy/BaseUUPSProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IERC1822.sol\";\nimport \"./IProxy.sol\";\nimport \"./BaseProxy.sol\";\nimport \"./BaseUUPSStorage.sol\";\nimport \"./Initializable.sol\";\nimport \"../lib/LAddress.sol\";\nimport \"../lib/LStorageSlot.sol\";\nimport \"../acl/IACL.sol\";\nimport \"../acl/scope/IContextManagement.sol\";\nimport \"../utils/Message.sol\";\nimport \"../utils/ERC165.sol\";\nimport \"../lib/acl/LACLUtils.sol\";\n\n/**\n * @title Abstract Base UUPS Proxy Contract\n * @author OpenZeppelin, Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nabstract contract BaseUUPSProxy is\n  BaseUUPSStorage,\n  BaseProxy,\n  Initializable,\n  IProxy,\n  IERC1822Proxiable,\n  Message,\n  ERC165\n{\n  /**\n   * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n   * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n   * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n   * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n   * fail.\n   */\n  modifier onlyProxy() {\n    require(address(this) != __self, \"Illegal Call\"); // Illegal Contract Call\n    require(_implementation() == __self, \"Invalid Call\"); // Invalid Proxy Call\n    _;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyLocalAdmin() {\n    require(_getLocalAdmin() == _msgSender(), \"Access Denied\");\n    _;\n  }\n\n  /**\n   * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n   * callable on the implementing contract but not through proxies.\n   */\n  modifier notDelegated() {\n    require(address(this) == __self, \"Illegal Call\"); // Illegal Contract Delegatecall\n    _;\n  }\n\n  modifier safeModeCheck() {\n    require(_sstat == ProxySafeModeStatus.DISABLED, \"Rejected\");\n    _;\n  }\n\n  modifier aclCheck(bytes4 selector) {\n    IACL.AuthorizationStatus status = _hasPermission(selector);\n    if (status != IACL.AuthorizationStatus.PERMITTED) revert IACL.ACLActionForbidden(status);\n    _;\n  }\n\n  function _hasPermission(bytes4 selector) internal returns (IACL.AuthorizationStatus) {\n    return IACL(_accessControlManager).hasAccountAccess(address(this), selector, _msgSender());\n  }\n\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n   */\n\n  constructor() {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n    // set contract Admin (implementation contract)\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = _msgSender();\n\n    // set _isUpgradable and _isSafeMode of contact\n    _ustat = ProxyUpdatabilityStatus.DISABLED;\n    _sstat = ProxySafeModeStatus.ENABLED;\n  }\n\n  function __BASE_UUPS_init(\n    string calldata cname,\n    string calldata cverion,\n    address accessControl\n  ) internal {\n    __BASE_UUPS_init_unchained(cname, cverion, accessControl);\n  }\n\n  function __BASE_UUPS_init_unchained(\n    string calldata cname,\n    string calldata cverion,\n    address accessControl\n  ) internal onlyInitializing {\n    _contractName = cname;\n    _contractVersion = cverion;\n\n    if (accessControl != address(this)) {\n      require(LAddress.isContract(accessControl), \"Illegal Contract\");\n      if (!IERC165(accessControl).supportsInterface(type(IACL).interfaceId)) {\n        revert(\"Illegal ACL\");\n      }\n    } else {\n      if (!supportsInterface(type(IACL).interfaceId)) {\n        revert(\"Not Supported\");\n      }\n    }\n\n    _accessControlManager = accessControl;\n    _ustat = ProxyUpdatabilityStatus.DISABLED;\n    _sstat = ProxySafeModeStatus.DISABLED;\n    _setLocalAdmin(_msgSender());\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return\n      interfaceId == type(IProxy).interfaceId ||\n      interfaceId == type(IERC1822Proxiable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _implementation() internal view override returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit ProxyUpgraded(msg.sender, address(this), newImplementation);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal returns (bytes memory) {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      return LAddress.functionDelegateCall(newImplementation, data, \"Call Failed\"); // delegatecall failed\n    }\n    return new bytes(0);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal returns (bytes memory) {\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n      return new bytes(0);\n    } else {\n      if (IERC1822Proxiable(newImplementation).proxiableUUID() != _IMPLEMENTATION_SLOT) {\n        revert(\"Illegal UUPS\");\n      }\n\n      if (!IERC165(newImplementation).supportsInterface(type(IProxy).interfaceId)) {\n        revert(\"Illegal IProxy\");\n      }\n\n      return _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n\n  /**\n   * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n   * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n   *\n   * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n   * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n   * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n   */\n  function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n    return _IMPLEMENTATION_SLOT;\n  }\n\n  function upgradeTo(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) external virtual onlyProxy returns (bytes memory) {\n    require(_sstat == ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(_ustat == ProxyUpdatabilityStatus.ENABLED, \"Illegal Updatable\");\n    require(LAddress.isContract(newImplementation), \"Illegal Contract\");\n    _authorizeUpgrade(newImplementation);\n    return _upgradeToAndCallUUPS(newImplementation, data, forceCall);\n  }\n\n  /**\n   * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n   * {upgradeTo} and {upgradeToAndCall}.\n   *\n   * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n   *\n   * ```solidity\n   * function _authorizeUpgrade(address) internal override onlyOwner {}\n   * ```\n   */\n  function _authorizeUpgrade(address newImplementation) internal virtual {\n    require(newImplementation != _implementation(), \"Illegal\");\n    IACL.AuthorizationStatus status = _hasPermission(this.upgradeTo.selector);\n    if (status != IACL.AuthorizationStatus.PERMITTED) revert IACL.ACLActionForbidden(status);\n  }\n\n  function localAdmin() external view returns (address) {\n    return _getLocalAdmin();\n  }\n\n  function setLocalAdmin(address newLocalAdmin) external onlyProxy returns (bool) {\n    require(_sstat == ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(_ustat == ProxyUpdatabilityStatus.ENABLED, \"Illegal Updatable\");\n    IACL.AuthorizationStatus status = _hasPermission(this.setLocalAdmin.selector);\n    if (status != IACL.AuthorizationStatus.PERMITTED) revert IACL.ACLActionForbidden(status);\n    require(newLocalAdmin != address(0), \"Invalid\");\n    _setLocalAdmin(newLocalAdmin);\n    return true;\n  }\n\n  /**\n   * @dev Returns the current admin.require(!_isSafeMode, \"Rejected\");\n   */\n  function _getLocalAdmin() internal view returns (address) {\n    return LStorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 admin slot.\n   */\n  function _setLocalAdmin(address newAdmin) internal {\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    emit ProxyLocalAdminUpdated(_msgSender(), address(this), newAdmin);\n  }\n\n  // In each upgrade the initialize requirement must be changed\n  function setSafeModeStatus(ProxySafeModeStatus sstat) external onlyProxy returns (bool) {\n    require(_getInitializedCount() > 0, \"NOT INIT\");\n    IACL.AuthorizationStatus status = _hasPermission(this.setSafeModeStatus.selector);\n    if (status != IACL.AuthorizationStatus.PERMITTED) revert IACL.ACLActionForbidden(status);\n    _sstat = sstat;\n    emit ProxySafeModeUpdated(_msgSender(), address(this), sstat);\n    return true;\n  }\n\n  function setUpdatabilityStatus(ProxyUpdatabilityStatus ustat) external onlyProxy returns (bool) {\n    require(_sstat == ProxySafeModeStatus.DISABLED, \"Rejected\");\n    IACL.AuthorizationStatus status = _hasPermission(this.setUpdatabilityStatus.selector);\n    if (status != IACL.AuthorizationStatus.PERMITTED) revert IACL.ACLActionForbidden(status);\n    _ustat = ustat;\n    emit ProxyUpdatabilityUpdated(_msgSender(), address(this), ustat);\n    return true;\n  }\n\n  function setAccessControlManager(address acl) external onlyProxy returns (bool) {\n    require(_sstat == ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(_ustat == ProxyUpdatabilityStatus.ENABLED, \"Illegal Updatable\");\n    require(acl != address(0) && LAddress.isContract(acl), \"Illegal Contract\");\n\n    if (_accessControlManager != address(0)) {\n      IACL.AuthorizationStatus status = _hasPermission(this.setAccessControlManager.selector);\n      if (status != IACL.AuthorizationStatus.PERMITTED) revert IACL.ACLActionForbidden(status);\n    } else {\n      require(_getLocalAdmin() == _msgSender(), \"Access Denied\");\n    }\n\n    if (!IERC165(acl).supportsInterface(type(IACL).interfaceId)) {\n      revert(\"Illegal ACL\");\n    }\n\n    _accessControlManager = acl;\n    emit ProxyAccessControlUpdated(_msgSender(), address(this), _accessControlManager);\n    return true;\n  }\n\n  function contractName() external view returns (string memory) {\n    return _contractName;\n  }\n\n  function contractVersion() external view returns (string memory) {\n    return _contractVersion;\n  }\n\n  function accessControlManager() external view returns (address) {\n    return _accessControlManager;\n  }\n\n  function subjectAddress() external view returns (address) {\n    return _implementation();\n  }\n\n  function safeModeStatus() external view returns (ProxySafeModeStatus) {\n    return _sstat;\n  }\n\n  function updatabilityStatus() external view returns (ProxyUpdatabilityStatus) {\n    return _ustat;\n  }\n\n  function domainSeparator() external view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          TYPE_HASH,\n          keccak256(abi.encodePacked(_contractName)),\n          keccak256(abi.encodePacked(_contractVersion)),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  function initVersion() external view returns (uint16) {\n    return _getInitializedCount();\n  }\n\n  function withdrawBalance(address recepient) external returns (uint256) {\n    require(_sstat == ProxySafeModeStatus.DISABLED, \"Rejected\");\n    IACL.AuthorizationStatus status = _hasPermission(this.withdrawBalance.selector);\n    if (status != IACL.AuthorizationStatus.PERMITTED) revert IACL.ACLActionForbidden(status);\n    uint256 balance = address(this).balance;\n    payable(recepient).transfer(address(this).balance);\n    return balance;\n  }\n\n  // solhint-disable-next-line\n  receive() external payable override {}\n\n  // solhint-disable-next-line\n  fallback() external payable override {}\n}\n"
    },
    "src/contracts/acl/IACLCommons.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../lib/struct/LEnumerableSet.sol\";\n\n/**\n * @title Access Control Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IACLCommons {\n  enum AgentType {\n    NONE,\n    MEMBER,\n    ROLE,\n    TYPE\n  }\n\n  enum ActivityStatus {\n    NONE,\n    DELETED,\n    DISABLED,\n    ENABLED\n  }\n\n  enum AlterabilityStatus {\n    NONE,\n    DISABLED,\n    UPDATABLE,\n    UPGRADABLE\n  }\n\n  enum ScopeType {\n    NONE,\n    FUNCTION,\n    CONTEXT,\n    REALM,\n    DOMAIN,\n    UNIVERSE\n  }\n\n  enum ActionType {\n    ADD,\n    UPDATE,\n    REMOVE\n  }\n\n  enum PolicyType {\n    UNLOCK, // 0\n    SLOCK, // soft lock, 1 - 63\n    MLOCK, // medium lock, 64 - 127\n    RLOCK, // restrict lock, 128 - 191\n    HLOCK, // hard lock, 192 - 254\n    LOCK // 255\n  }\n\n  struct BaseAgent {\n    bytes32 adminId;\n    AgentType atype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n  }\n\n  struct BaseScope {\n    bytes32 adminId;\n    ScopeType stype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    uint32 referredByAgent;\n  }\n\n  struct PolicyEntity {\n    bytes32 adminId;\n    bytes32 scopeId;\n    string name;\n    uint16 roleLimit;\n    uint8 policyCode;\n    PolicyType ptype;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    LEnumerableSet.Bytes32Set roles;\n  }\n\n  struct FunctionEntity {\n    BaseScope bs;\n    bytes32 agentId;\n    bytes32 contextId;\n    bytes4 selector;\n    uint8 policyCode;\n  }\n\n  struct ContextEntity {\n    BaseScope bs;\n    bytes32 realmId;\n    address contractId;\n    uint8 functionLimit;\n    LEnumerableSet.Bytes32Set functions;\n  }\n\n  struct RealmEntity {\n    BaseScope bs;\n    bytes32 domainId;\n    uint32 contextLimit;\n    string name;\n    LEnumerableSet.Bytes32Set contexts;\n  }\n\n  struct DomainEntity {\n    BaseScope bs;\n    bytes32 universeId;\n    uint16 realmLimit;\n    string name;\n    LEnumerableSet.Bytes32Set realms;\n  }\n\n  struct UniverseEntity {\n    BaseScope bs;\n    uint16 domainLimit;\n    string name;\n    LEnumerableSet.Bytes32Set domains;\n  }\n\n  struct GeneralLimit {\n    uint24 memberLimit;\n    uint16 memberRegisterLimit;\n    uint16 contextRegisterLimit;\n    uint16 functionRegisterLimit;\n    uint16 profileRegisterLimit;\n    uint16 contextLimit;\n    uint16 realmLimit;\n    uint16 domainLimit;\n    uint16 callLimit;\n    uint16 typeRoleLimit;\n    uint16 typeLimit;\n    uint8 roleRegisterLimit;\n    uint8 typeRegisterLimit;\n    uint8 realmRegisterLimit;\n    uint8 domainRegisterLimit;\n    uint8 policyRegisterLimit;\n    uint8 policyRoleLimit;\n    uint8 functionLimit;\n  }\n\n  struct MemberEntity {\n    BaseAgent ba;\n    address account;\n    GeneralLimit limits;\n    LEnumerableSet.Bytes32Set types;\n  }\n\n  struct MemberSignature {\n    address account;\n    uint64 expiredAt;\n    bytes signature;\n  }\n\n  struct RoleEntity {\n    BaseAgent ba;\n    bytes32 scopeId;\n    bytes32 typeId;\n    string name;\n    uint24 memberLimit;\n    uint24 memberCount;\n  }\n\n  struct TypeEntity {\n    BaseAgent ba;\n    bytes32 scopeId;\n    string name;\n    uint16 roleLimit;\n    mapping(bytes32 => bytes32) members;\n    LEnumerableSet.Bytes32Set roles;\n  }\n\n  struct FacetEntity {\n    address subjectId;\n  }\n\n  struct UpdateActivityRequest {\n    bytes32 id;\n    ActivityStatus acstat;\n  }\n\n  struct UpdateAlterabilityRequest {\n    bytes32 id;\n    AlterabilityStatus alstat;\n  }\n\n  struct UpdateAdminRequest {\n    bytes32 id;\n    bytes32 adminId;\n  }\n\n  // used in Policy / Role / Type\n  struct UpdateScopeRequest {\n    bytes32 id;\n    bytes32 scopeId;\n  }\n\n  ////////////////////////////////////////////////////////////////////\n  // Profiles\n\n  struct ProfileMemberSignature {\n    string profileName;\n    address account;\n    uint64 expiredAt;\n    bytes signature;\n  }\n\n  struct ProfileRegisterLimit {\n    uint32 memberRegisterLimit;\n    uint32 roleRegisterLimit;\n    uint32 typeRegisterLimit;\n    uint32 functionRegisterLimit;\n    uint32 contextRegisterLimit;\n    uint16 realmRegisterLimit;\n    uint16 domainRegisterLimit;\n    uint16 policyRegisterLimit;\n  }\n\n  struct ProfileLimit {\n    uint32 profileCallLimit;\n    uint32 contextLimit;\n    uint24 memberLimit;\n    uint16 realmLimit;\n    uint16 domainLimit;\n    uint16 memberCallLimit;\n    uint16 typeRoleLimit;\n    uint16 typeLimit;\n    uint16 policyRoleLimit;\n    uint8 functionLimit;\n  }\n\n  struct ProfileAccount {\n    bytes32[] profiles;\n  }\n\n  struct ProfileEntity {\n    mapping(bytes32 => BaseAgent) agents;\n    mapping(bytes32 => BaseScope) scopes;\n    mapping(bytes32 => PolicyEntity) policies;\n    mapping(bytes32 => bytes32) rolePolicyMap;\n    LEnumerableSet.Bytes32Set admins;\n    bytes32 adminId;\n    string name;\n    address owner;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    ProfileRegisterLimit registerLimits;\n    ProfileLimit limits;\n  }\n\n  struct ProfileMemberEntity {\n    BaseAgent ba;\n    address account;\n    uint16 callLimit;\n    uint16 typeLimit;\n    ProfileRegisterLimit registerLimits;\n    LEnumerableSet.Bytes32Set types;\n  }\n\n  struct ProfileUpdateActivityRequest {\n    bytes32 entityId;\n    ActivityStatus acstat;\n  }\n\n  struct ProfileUpdateAlterabilityRequest {\n    bytes32 entityId;\n    AlterabilityStatus alstat;\n  }\n\n  struct ProfileUpdateAdminRequest {\n    bytes32 entityId;\n    bytes32 adminId;\n  }\n\n  struct ProfileUpdateScopeRequest {\n    bytes32 entityId;\n    bytes32 scopeId;\n  }\n}\n"
    },
    "src/contracts/proxy/BaseUUPSStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IBaseProxy.sol\";\n\n/**\n * @title Abstract Base UUPS Storage Contract\n * @author OpenZeppelin, Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nabstract contract BaseUUPSStorage is IBaseProxy {\n  // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n  bytes32 internal constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n   * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n   */\n  bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  bytes32 public constant TYPE_HASH =\n    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n  address internal immutable __self = address(this);\n\n  string internal _contractName;\n  string internal _contractVersion;\n  address internal _accessControlManager;\n  ProxySafeModeStatus internal _sstat;\n  ProxyUpdatabilityStatus internal _ustat;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[64] private __reserved;\n}\n"
    },
    "src/contracts/proxy/IBaseProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\n/**\n * @title Base Proxy Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IBaseProxy {\n  enum ProxySafeModeStatus {\n    DISABLED,\n    ENABLED\n  }\n\n  enum ProxyUpdatabilityStatus {\n    DISABLED,\n    ENABLED\n  }\n\n  event ProxyUpgraded(address indexed sender, address indexed proxy, address indexed newImplementation);\n}\n"
    },
    "src/contracts/lib/acl/LACLUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../../proxy/IProxy.sol\";\nimport \"../../acl/IACL.sol\";\nimport \"../../acl/IACLCommons.sol\";\nimport \"../../acl/profile/IProfileACL.sol\";\nimport \"../../acl/ACLStorage.sol\";\nimport \"../cryptography/LECDSA.sol\";\n\n/**\n * @title Context Utils Library\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nlibrary LACLUtils {\n  function functionGenerateId(address contractId, bytes4 selector) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(contractId, selector));\n  }\n\n  function accountGenerateId(address account) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(account));\n  }\n\n  function generateId(string calldata name) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(name));\n  }\n\n  function generateId2(string memory name) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(name));\n  }\n\n  function generateHash(string memory name) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(name));\n  }\n\n  function getMemeberSignerAddress(IACLCommons.MemberSignature calldata memberSign, bytes32 msgTypeHash)\n    internal\n    view\n    returns (address)\n  {\n    return\n      getSignerAddress(\n        memberSign.signature,\n        _generateMemberSignMsgHash(msgTypeHash, memberSign.account, memberSign.expiredAt)\n      );\n  }\n\n  function getProfileMemeberSignerAddress(IACLCommons.ProfileMemberSignature calldata memberSign, bytes32 msgTypeHash)\n    internal\n    view\n    returns (address)\n  {\n    return\n      getSignerAddress(\n        memberSign.signature,\n        _generateProfileMemberSignMsgHash(\n          msgTypeHash,\n          generateId(memberSign.profileName),\n          memberSign.account,\n          memberSign.expiredAt\n        )\n      );\n  }\n\n  function _hashTypedDataV4(bytes32 structHash) private view returns (bytes32) {\n    return LECDSA.toTypedDataHash(IProxy(address(this)).domainSeparator(), structHash);\n  }\n\n  function _generateMemberSignMsgHash(\n    bytes32 msgTypeHash,\n    address account,\n    uint256 expiredAt\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(msgTypeHash, account, expiredAt));\n  }\n\n  function _generateProfileMemberSignMsgHash(\n    bytes32 msgTypeHash,\n    bytes32 profileName,\n    address account,\n    uint256 expiredAt\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(msgTypeHash, profileName, account, expiredAt));\n  }\n\n  function getSignerAddress(bytes memory signature, bytes32 structHash) internal view returns (address) {\n    bytes32 msgDigest = _hashTypedDataV4(structHash);\n    (address msgSigner, LECDSA.RecoverError recoverErr) = LECDSA.tryRecover(msgDigest, signature);\n    require(recoverErr == LECDSA.RecoverError.NoError, \"Illegal Signature\");\n    return msgSigner;\n  }\n\n  function generateAuthorizationError(IACL.AuthorizationStatus status) internal pure {\n    if (status == IACL.AuthorizationStatus.UNAUTHORIZED) revert IACL.ACLUnauthorized();\n    else if (status == IACL.AuthorizationStatus.POLICY_FORBIDDEN) revert IACL.ACLPolicyForbidden();\n    else if (status == IACL.AuthorizationStatus.CALL_FORBIDDEN) revert IACL.ACLCallForbidden();\n    else if (status == IACL.AuthorizationStatus.ROLE_SCOPE_FORBIDDEN) revert IACL.ACLRoleScopeForbidden();\n    else if (status == IACL.AuthorizationStatus.MEMBER_NOT_FOUND) revert IACL.ACLMemberNotFound();\n    else if (status == IACL.AuthorizationStatus.ROLE_NOT_FOUND) revert IACL.ACLRoleNotFound();\n    else if (status == IACL.AuthorizationStatus.TYPE_NOT_FOUND) revert IACL.ACLTypeNotFound();\n    else if (status == IACL.AuthorizationStatus.FUNCTION_NOT_FOUND) revert IACL.ACLFunctionNotFound();\n    else if (status == IACL.AuthorizationStatus.CONTEXT_NOT_FOUND) revert IACL.ACLContextNotFound();\n    else if (status == IACL.AuthorizationStatus.REALM_NOT_FOUND) revert IACL.ACLRealmNotFound();\n    else if (status == IACL.AuthorizationStatus.DOMAIN_NOT_FOUND) revert IACL.ACLDomainNotFound();\n    else if (status == IACL.AuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN) revert IACL.ACLMemberActivityForbidden();\n    else if (status == IACL.AuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN) revert IACL.ACLRoleActivityForbidden();\n    else if (status == IACL.AuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN) revert IACL.ACLTypeActivityForbidden();\n    else if (status == IACL.AuthorizationStatus.FUNCTION_ACTIVITY_FORBIDDEN) revert IACL.ACLFunctionActivityForbidden();\n    else if (status == IACL.AuthorizationStatus.CONTEXT_ACTIVITY_FORBIDDEN) revert IACL.ACLContextActivityForbidden();\n    else if (status == IACL.AuthorizationStatus.REALM_ACTIVITY_FORBIDDEN) revert IACL.ACLRealmActivityForbidden();\n    else if (status == IACL.AuthorizationStatus.DOMAIN_ACTIVITY_FORBIDDEN) revert IACL.ACLDomainActivityForbidden();\n    else if (status == IACL.AuthorizationStatus.UNIVERSE_ACTIVITY_FORBIDDEN) revert IACL.ACLUniverseActivityForbidden();\n    else revert(\"Unknown ERR\");\n  }\n\n  function generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus status) internal pure {\n    if (status == IProfileACL.ProfileAuthorizationStatus.UNAUTHORIZED) revert IProfileACL.ProfileACLUnauthorized();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.POLICY_FORBIDDEN)\n      revert IProfileACL.ProfileACLPolicyForbidden();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.PROFILE_CALL_FORBIDDEN)\n      revert IProfileACL.ProfileACLCallForbidden();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.MEMBER_CALL_FORBIDDEN)\n      revert IProfileACL.ProfileACLMemberCallForbidden();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.ROLE_SCOPE_FORBIDDEN)\n      revert IProfileACL.ProfileACLRoleScopeForbidden();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.MEMBER_NOT_FOUND)\n      revert IProfileACL.ProfileACLMemberNotFound();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.ROLE_NOT_FOUND)\n      revert IProfileACL.ProfileACLRoleNotFound();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.TYPE_NOT_FOUND)\n      revert IProfileACL.ProfileACLTypeNotFound();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.FUNCTION_NOT_FOUND)\n      revert IProfileACL.ProfileACLFunctionNotFound();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.CONTEXT_NOT_FOUND)\n      revert IProfileACL.ProfileACLContextNotFound();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.REALM_NOT_FOUND)\n      revert IProfileACL.ProfileACLRealmNotFound();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.DOMAIN_NOT_FOUND)\n      revert IProfileACL.ProfileACLDomainNotFound();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN)\n      revert IProfileACL.ProfileACLMemberActivityForbidden();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN)\n      revert IProfileACL.ProfileACLRoleActivityForbidden();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN)\n      revert IProfileACL.ProfileACLTypeActivityForbidden();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.FUNCTION_ACTIVITY_FORBIDDEN)\n      revert IProfileACL.ProfileACLFunctionActivityForbidden();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.CONTEXT_ACTIVITY_FORBIDDEN)\n      revert IProfileACL.ProfileACLContextActivityForbidden();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.REALM_ACTIVITY_FORBIDDEN)\n      revert IProfileACL.ProfileACLRealmActivityForbidden();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.DOMAIN_ACTIVITY_FORBIDDEN)\n      revert IProfileACL.ProfileACLDomainActivityForbidden();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.UNIVERSE_ACTIVITY_FORBIDDEN)\n      revert IProfileACL.ProfileACLUniverseActivityForbidden();\n    else if (status == IProfileACL.ProfileAuthorizationStatus.PROFILE_ACTIVITY_FORBIDDEN)\n      revert IProfileACL.ProfileACLProfileActivityForbidden();\n    else revert(\"Unknown ERR\");\n  }\n\n  function generateProfileAdminAccessError(IProfileACL.ProfileAdminAccessStatus status) internal pure {\n    if (status == IProfileACL.ProfileAdminAccessStatus.NOT_PERMITTED)\n      revert IProfileACL.ProfileAdminAccessNotPermitted();\n    else if (status == IProfileACL.ProfileAdminAccessStatus.POLICY_FORBIDDEN)\n      revert IProfileACL.ProfileAdminAccessPolicyForbidden();\n    else if (status == IProfileACL.ProfileAdminAccessStatus.ROLE_NOT_FOUND)\n      revert IProfileACL.ProfileAdminAccessRoleNotFound();\n    else if (status == IProfileACL.ProfileAdminAccessStatus.TYPE_NOT_FOUND)\n      revert IProfileACL.ProfileAdminAccessTypeNotFound();\n    else if (status == IProfileACL.ProfileAdminAccessStatus.FUNCTION_NOT_FOUND)\n      revert IProfileACL.ProfileAdminAccessFunctionNotFound();\n    else if (status == IProfileACL.ProfileAdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN)\n      revert IProfileACL.ProfileAdminAccessRoleActivityForbidden();\n    else if (status == IProfileACL.ProfileAdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN)\n      revert IProfileACL.ProfileAdminAccessTypeActivityForbidden();\n    else revert(\"Unknown ERR\");\n  }\n\n  function generateAdminAccessError(IACL.AdminAccessStatus status) internal pure {\n    if (status == IACL.AdminAccessStatus.NOT_PERMITTED) revert IACL.AdminAccessNotPermitted();\n    else if (status == IACL.AdminAccessStatus.POLICY_FORBIDDEN) revert IACL.AdminAccessPolicyForbidden();\n    else if (status == IACL.AdminAccessStatus.ROLE_NOT_FOUND) revert IACL.AdminAccessRoleNotFound();\n    else if (status == IACL.AdminAccessStatus.TYPE_NOT_FOUND) revert IACL.AdminAccessTypeNotFound();\n    else if (status == IACL.AdminAccessStatus.FUNCTION_NOT_FOUND) revert IACL.AdminAccessFunctionNotFound();\n    else if (status == IACL.AdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN) revert IACL.AdminAccessRoleActivityForbidden();\n    else if (status == IACL.AdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN) revert IACL.AdminAccessTypeActivityForbidden();\n    else revert(\"Unknown ERR\");\n  }\n}\n"
    },
    "src/contracts/lib/acl/LProfileStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../../acl/IACLCommons.sol\";\nimport \"../../acl/ACLStorage.sol\";\n\n/**\n * @title ACL Storage Library\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nlibrary LProfileStorage {\n  function profileUniverseReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.UniverseEntity storage ge)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.UNIVERSE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        ge.slot := keccak256(ptr, 0x40)\n      }\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\n      revert(\"GID Not Found\");\n    } else {\n      revert(\"Illeagl GID Slot\");\n    }\n  }\n\n  function profileUniverseWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.UniverseEntity storage ge)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.UNIVERSE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        ge.slot := keccak256(ptr, 0x40)\n      }\n    } else {\n      revert(\"Illegal GID Slot\");\n    }\n  }\n\n  function profileFunctionReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.FunctionEntity storage fe)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.FUNCTION) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        fe.slot := keccak256(ptr, 0x40)\n      }\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\n      revert(\"FID Not Found\");\n    } else {\n      revert(\"Illeagl FID Slot\");\n    }\n  }\n\n  function profileFunctionTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.FunctionEntity storage fe, bool result)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.FUNCTION) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        fe.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (fe, result);\n    }\n    assembly {\n      fe.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileFunctionWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.FunctionEntity storage fe)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.FUNCTION) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        fe.slot := keccak256(ptr, 0x40)\n      }\n    } else {\n      revert(\"Illegal FID Slot\");\n    }\n  }\n\n  function profileFunctionTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.FunctionEntity storage fe, bool result)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.FUNCTION) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        fe.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (fe, result);\n    }\n    assembly {\n      fe.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileContextReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.ContextEntity storage ce)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.CONTEXT) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        ce.slot := keccak256(ptr, 0x40)\n      }\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\n      revert(\"CID Not Found\");\n    } else {\n      revert(\"Illegal CID Slot\");\n    }\n  }\n\n  function profileContextTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.ContextEntity storage ce, bool result)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.CONTEXT) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        ce.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (ce, result);\n    }\n    assembly {\n      ce.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileContextWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.ContextEntity storage ce)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.CONTEXT) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        ce.slot := keccak256(ptr, 0x40)\n      }\n    } else {\n      revert(\"Illegal CID Slot\");\n    }\n  }\n\n  function profileContextTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.ContextEntity storage ce, bool result)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.CONTEXT) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        ce.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (ce, result);\n    }\n    assembly {\n      ce.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileRealmReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.RealmEntity storage re)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.REALM) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        re.slot := keccak256(ptr, 0x40)\n      }\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\n      revert(\"RID Not Found\");\n    } else {\n      revert(\"Illeagl RID Slot\");\n    }\n  }\n\n  function profileRealmTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.RealmEntity storage re, bool result)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.REALM) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        re.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (re, result);\n    }\n    assembly {\n      re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileRealmWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.RealmEntity storage re)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.REALM) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        let slot := keccak256(ptr, 0x40)\n        re.slot := slot\n      }\n    } else {\n      revert(\"Illeagl RID Slot\");\n    }\n  }\n\n  function profileRealmTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.RealmEntity storage re, bool result)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.REALM) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        re.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (re, result);\n    }\n    assembly {\n      re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileDomainReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.DomainEntity storage de)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.DOMAIN) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        de.slot := keccak256(ptr, 0x40)\n      }\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\n      revert(\"DID Not Found\");\n    } else {\n      revert(\"Illegal DID Slot\");\n    }\n  }\n\n  function profileDomainTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.DomainEntity storage de, bool result)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.DOMAIN) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        de.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (de, result);\n    }\n    assembly {\n      de.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileDomainWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.DomainEntity storage de)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.DOMAIN) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        de.slot := keccak256(ptr, 0x40)\n      }\n    } else {\n      revert(\"Illegal DID Slot\");\n    }\n  }\n\n  function profileDomainTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\n    internal\n    view\n    returns (IACLCommons.DomainEntity storage de, bool result)\n  {\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.DOMAIN) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), scopeId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\n        de.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (de, result);\n    }\n    assembly {\n      de.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileMemberReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.ProfileMemberEntity storage me)\n  {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.MEMBER) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\n        me.slot := keccak256(ptr, 0x40)\n      }\n    } else if (ba.atype == IACLCommons.AgentType.NONE) {\n      revert(\"MID Not Found\");\n    } else {\n      revert(\"Illegal MID Slot\");\n    }\n  }\n\n  function profileMemberTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.ProfileMemberEntity storage me, bool result)\n  {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.MEMBER) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\n        me.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (me, result);\n    }\n    assembly {\n      me.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileMemberWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.ProfileMemberEntity storage me)\n  {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.MEMBER) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\n        me.slot := keccak256(ptr, 0x40)\n      }\n    } else {\n      revert(\"Illegal MID Slot\");\n    }\n  }\n\n  function profileMemberTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.ProfileMemberEntity storage me, bool result)\n  {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.MEMBER) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\n        me.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (me, result);\n    }\n    assembly {\n      me.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileRoleReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.RoleEntity storage re)\n  {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.ROLE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\n        re.slot := keccak256(ptr, 0x40)\n      }\n    } else if (ba.atype == IACLCommons.AgentType.NONE) {\n      revert(\"RoleId Not Found\");\n    } else {\n      revert(\"Illegal RoleId Slot\");\n    }\n  }\n\n  function profileRoleTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.RoleEntity storage re, bool result)\n  {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.ROLE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\n        re.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (re, result);\n    }\n    assembly {\n      re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileRoleWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.RoleEntity storage re)\n  {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.ROLE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\n        let slot := keccak256(ptr, 0x40)\n        re.slot := slot\n      }\n    } else {\n      revert(\"Illegal RoleId Slot\");\n    }\n  }\n\n  function profileRoleTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.RoleEntity storage re, bool result)\n  {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.ROLE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\n        let slot := keccak256(ptr, 0x40)\n        re.slot := slot\n      }\n      result = true;\n      return (re, result);\n    }\n    assembly {\n      re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileTypeReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.TypeEntity storage te)\n  {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.TYPE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\n        te.slot := keccak256(ptr, 0x40)\n      }\n    } else if (ba.atype == IACLCommons.AgentType.NONE) {\n      revert(\"TID Not Found\");\n    } else {\n      revert(\"Illegal TID Slot\");\n    }\n  }\n\n  function profileTypeTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.TypeEntity storage te, bool result)\n  {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.TYPE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\n        te.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (te, result);\n    }\n    assembly {\n      te.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n\n  function profileTypeWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.TypeEntity storage te)\n  {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.TYPE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\n        te.slot := keccak256(ptr, 0x40)\n      }\n    } else {\n      revert(\"Illegal TID Slot\");\n    }\n  }\n\n  function profileTypeTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (IACLCommons.TypeEntity storage te, bool result)\n  {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.TYPE) {\n      assembly {\n        let ptr := mload(0x40)\n        mstore(add(ptr, 0x00), agentId)\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\n        te.slot := keccak256(ptr, 0x40)\n      }\n      result = true;\n      return (te, result);\n    }\n    assembly {\n      te.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n    }\n    result = false;\n  }\n}\n"
    },
    "src/contracts/proxy/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IBaseProxy.sol\";\n\n/**\n * @title Base Proxy Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IProxy is IBaseProxy {\n  /**\n   * @dev Emitted when the admin account has changed.\n   */\n  event ProxyLocalAdminUpdated(address indexed sender, address indexed proxy, address newAdmin);\n\n  event ProxyAccessControlUpdated(address indexed sender, address indexed proxy, address acl);\n\n  event ProxySafeModeUpdated(address indexed sender, address indexed proxy, ProxySafeModeStatus sstat);\n\n  event ProxyUpdatabilityUpdated(address indexed sender, address indexed proxy, ProxyUpdatabilityStatus ustat);\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n   */\n  event Initialized(\n    address indexed sender,\n    address indexed proxy,\n    address indexed subject,\n    string name,\n    string version,\n    uint16 initCount\n  );\n\n  function upgradeTo(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) external returns (bytes memory);\n\n  function setSafeModeStatus(ProxySafeModeStatus sstat) external returns (bool);\n\n  function setUpdatabilityStatus(ProxyUpdatabilityStatus ustat) external returns (bool);\n\n  function setLocalAdmin(address newAdmin) external returns (bool);\n\n  function setAccessControlManager(address acl) external returns (bool);\n\n  function withdrawBalance(address recepient) external returns (uint256);\n\n  function contractName() external view returns (string memory);\n\n  function contractVersion() external view returns (string memory);\n\n  function accessControlManager() external view returns (address);\n\n  function subjectAddress() external view returns (address);\n\n  function safeModeStatus() external view returns (ProxySafeModeStatus);\n\n  function updatabilityStatus() external view returns (ProxyUpdatabilityStatus);\n\n  function localAdmin() external view returns (address);\n\n  function domainSeparator() external view returns (bytes32);\n\n  function initVersion() external view returns (uint16);\n}\n"
    },
    "src/contracts/proxy/IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n  /**\n   * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n   * address.\n   *\n   * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n   * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n   * function revert if invoked through a proxy.\n   */\n  function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "src/contracts/utils/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/lib/cryptography/LECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"../LStrings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary LECDSA {\n  enum RecoverError {\n    NoError,\n    InvalidSignature,\n    InvalidSignatureLength,\n    InvalidSignatureS,\n    InvalidSignatureV\n  }\n\n  function _throwError(RecoverError error) private pure {\n    if (error == RecoverError.NoError) {\n      return; // no error: do nothing\n    } else if (error == RecoverError.InvalidSignature) {\n      revert(\"ECDSA: invalid signature\");\n    } else if (error == RecoverError.InvalidSignatureLength) {\n      revert(\"ECDSA: invalid signature length\");\n    } else if (error == RecoverError.InvalidSignatureS) {\n      revert(\"ECDSA: invalid signature 's' value\");\n    } else if (error == RecoverError.InvalidSignatureV) {\n      revert(\"ECDSA: invalid signature 'v' value\");\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature` or error string. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   *\n   * Documentation for signature generation:\n   * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n   * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n   *\n   */\n  function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n    // Check the signature length\n    // - case 65: r,s,v signature (standard)\n    // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n      return tryRecover(hash, v, r, s);\n    } else if (signature.length == 64) {\n      bytes32 r;\n      bytes32 vs;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        vs := mload(add(signature, 0x40))\n      }\n      return tryRecover(hash, r, vs);\n    } else {\n      return (address(0), RecoverError.InvalidSignatureLength);\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature`. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   */\n  function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n   *\n   * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n   */\n  function tryRecover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address, RecoverError) {\n    bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\n    return tryRecover(hash, v, r, s);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n   */\n  function recover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   */\n  function tryRecover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address, RecoverError) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      return (address(0), RecoverError.InvalidSignatureS);\n    }\n    if (v != 27 && v != 28) {\n      return (address(0), RecoverError.InvalidSignatureV);\n    }\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    if (signer == address(0)) {\n      return (address(0), RecoverError.InvalidSignature);\n    }\n\n    return (signer, RecoverError.NoError);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   */\n  function recover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", LStrings.toString(s.length), s));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Typed Data, created from a\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\n   * to the one signed with the\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n   * JSON-RPC method as part of EIP-712.\n   *\n   * See {recover}.\n   */\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n  }\n}\n"
    },
    "src/contracts/lib/LStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev String operations.\n */\nlibrary LStrings {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n   */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n"
    },
    "src/contracts/lib/LAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary LAddress {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  function isContract2(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    uint256 size;\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"SendValue Failed\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-universe-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, \"Call Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Call With Value Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Insufficient Balance For Call\");\n    require(LAddress.isContract(target), \"Illegal Contract Address\");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Static Call Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(LAddress.isContract(target), \"Illegal Contract Address\");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Delegate Call Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory message\n  ) internal returns (bytes memory) {\n    require(LAddress.isContract(target), \"Illegal Contract Address\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return LAddress.verifyCallResult(success, returndata, message);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason using the provided one.\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "src/contracts/proxy/BaseProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title Abstract Base Proxy Contract\n * @dev\n *\n */\nabstract contract BaseProxy {\n  /**\n   * @dev Delegates the current call to `implementation`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _delegate(address implementation) internal virtual {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates the current call to the address returned by `_implementation()`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _fallback() internal virtual {\n    _beforeFallback();\n    _delegate(_implementation());\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  fallback() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n   * is empty.\n   */\n  receive() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n   * call, or as part of the Solidity `fallback` or `receive` functions.\n   *\n   * If overridden should call `super._beforeFallback()`.\n   */\n  function _beforeFallback() internal virtual {}\n}\n"
    },
    "src/contracts/lib/LStorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary LStorageSlot {\n  struct AddressSlot {\n    address value;\n  }\n\n  struct BooleanSlot {\n    bool value;\n  }\n\n  struct Bytes32Slot {\n    bytes32 value;\n  }\n\n  struct Uint256Slot {\n    uint256 value;\n  }\n\n  /**\n   * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n   */\n  function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n   */\n  function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n   */\n  function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n   */\n  function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n}\n"
    },
    "src/contracts/utils/Message.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n\npragma solidity 0.8.19;\n\n/**\n * @title Abstract Message Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nabstract contract Message {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n"
    },
    "src/contracts/utils/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "src/contracts/token/lively/LivelyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Extra.sol\";\nimport \"./IERC20Pause.sol\";\nimport \"./IERC20Lock.sol\";\nimport \"./LivelyStorage.sol\";\nimport \"../asset/IAssetEntity.sol\";\nimport \"../asset/IAssetManagerERC20.sol\";\nimport \"../asset/ERC20/IAssetERC20.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\nimport \"../../lib/token/LTokenERC20.sol\";\nimport \"../../lib/cryptography/LECDSA.sol\";\nimport \"../../lib/LCounters.sol\";\nimport \"../../lib/math/LBasisPointsMath.sol\";\nimport \"../../lib/math/LSafeMath.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\n\n/**\n * @title Lively ERC20 Token Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract LivelyToken is LivelyStorage, BaseUUPSProxy, IERC20, IERC20Extra, IERC20Pause, IERC20Lock {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LCounters for LCounters.Counter;\n  using LBasisPointsMath for uint256;\n  using LSafeMath for uint256;\n\n  struct InitRequest {\n    string contractName;\n    string contractVersion;\n    uint256 taxRateValue;\n    address aclManager;\n  }\n\n  constructor() {}\n\n  function lockToken(LockTokenRequest[] calldata lockRequest) external returns (bytes32[] memory) {\n    _policyInterceptor(this.lockToken.selector, address(0), true, false);\n    uint256 totalAmount = 0;\n    bytes32[] memory lockIds = new bytes32[](lockRequest.length);\n    for (uint256 i = 0; i < lockRequest.length; i++) {\n      require(!_data.pausedList.contains(lockRequest[i].source), \"Suspended\");\n      lockIds[i] = _lockToken(lockRequest[i]);\n      totalAmount += lockRequest[i].amount;\n    }\n\n    return lockIds;\n  }\n\n  function claimToken(bytes32[] calldata lockIds) external returns (uint256) {\n    _policyInterceptor(this.claimToken.selector, _msgSender(), true, true);\n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < lockIds.length; i++) {\n      totalAmount += _claimToken(lockIds[i]);\n    }\n\n    return totalAmount;\n  }\n\n  function unlockToken(UnLockTokenRequest[] calldata unlockRequest) external returns (uint256) {\n    _policyInterceptor(this.unlockToken.selector, address(0), true, false);\n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < unlockRequest.length; i++) {\n      require(!_data.pausedList.contains(unlockRequest[i].account), \"Suspended\");\n      totalAmount += _unlockToken(unlockRequest[i]);\n    }\n\n    return totalAmount;\n  }\n\n  function pause(address account) external {\n    _policyInterceptor(this.pause.selector, address(0), false, false);\n    require(account != address(0), \"Illegal Address\");\n    require(!_data.pausedList.contains(account), \"Already Paused\");\n    _data.pausedList.add(account);\n    emit Paused(_msgSender(), account);\n  }\n\n  function unpause(address account) external {\n    _policyInterceptor(this.unpause.selector, address(0), false, false);\n    require(account != address(0), \"Illegal Address\");\n    require(_data.pausedList.contains(account), \"Not Found\");\n    _data.pausedList.remove(account);\n    emit Unpaused(_msgSender(), account);\n  }\n\n  function pauseAll() external {\n    _policyInterceptor(this.pauseAll.selector, address(0), false, false);\n    _isPaused = true;\n    emit PausedAll(_msgSender());\n  }\n\n  function unpauseAll() external {\n    _policyInterceptor(this.unpauseAll.selector, address(0), false, false);\n    _isPaused = false;\n    emit UnpausedAll(_msgSender());\n  }\n\n  function updateTaxRate(uint256 rate) external returns (bool) {\n    _policyInterceptor(this.updateTaxRate.selector, address(0), false, false);\n    _taxRate = rate;\n    emit TaxRateUpdated(_msgSender(), rate);\n    return true;\n  }\n\n  function updateTaxWhitelist(TaxWhitelistUpdateRequest[] calldata request) external returns (bool) {\n    _policyInterceptor(this.updateTaxWhitelist.selector, address(0), false, false);\n    for (uint256 i = 0; i < request.length; i++) {\n      _updateTaxWhitelist(request[i].account, request[i].isDeleted);\n    }\n    return true;\n  }\n\n  function transfer(address recipient, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.transfer.selector, _msgSender(), true, true);\n    if (_taxRate > 0 && !_data.taxWhitelist.contains(_msgSender())) {\n      _taxTransfer(_msgSender(), recipient, amount);\n    } else {\n      _transfer(_msgSender(), recipient, amount);\n    }\n    return true;\n  }\n\n  function transferFrom(\n    address source,\n    address recipient,\n    uint256 amount\n  ) external returns (bool) {\n    _policyInterceptor(this.transferFrom.selector, source, true, true);\n    return _transferFrom(source, recipient, amount);\n  }\n\n  function batchTransfer(BatchTransferRequest[] calldata request) external returns (bool) {\n    _policyInterceptor(this.batchTransfer.selector, _msgSender(), true, true);\n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < request.length; i++) {\n      totalAmount += request[i].amount;\n      _transfer(_msgSender(), request[i].to, request[i].amount);\n    }\n\n    emit BatchTransfer(_msgSender(), totalAmount);\n    return true;\n  }\n\n  function batchTransferFrom(BatchTransferFromRequest[] calldata request) external returns (bool) {\n    _policyInterceptor(this.batchTransferFrom.selector, address(0), true, false);\n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < request.length; i++) {\n      require(!_data.pausedList.contains(request[i].from), \"Suspended\");\n      totalAmount += request[i].amount;\n      _transferFrom(request[i].from, request[i].to, request[i].amount);\n    }\n\n    emit BatchTransferFrom(_msgSender(), totalAmount);\n    return true;\n  }\n\n  function approve(address spender, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.approve.selector, _msgSender(), true, true);\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.increaseAllowance.selector, _msgSender(), true, true);\n    address owner = _msgSender();\n    uint256 currentAllowance = _allowance(owner, spender) + amount;\n    _approve(owner, spender, currentAllowance);\n    emit ApprovalIncreased(owner, spender, amount);\n    return currentAllowance;\n  }\n\n  function decreaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.decreaseAllowance.selector, _msgSender(), true, true);\n    address owner = _msgSender();\n    _spendAllowance(owner, spender, amount);\n    emit ApprovalDecreased(owner, spender, amount);\n    return _allowance(owner, spender);\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    bytes calldata signature\n  ) external returns (bool) {\n    _policyInterceptor(this.permit.selector, owner, true, true);\n    require(block.timestamp <= deadline, \"Expired\");\n    bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n    bytes32 hash = LECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    address signer = LECDSA.recover(hash, signature);\n\n    require(signer == owner, \"Illegal Signature\");\n    _approve(owner, spender, value);\n    return true;\n  }\n\n  function mint(address account, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.mint.selector, account, true, true);\n    return _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.burn.selector, account, true, true);\n    require(account != address(0), \"Illegal Address\");\n    uint256 accountBalance = _data.accounts[account].balance;\n    require(accountBalance >= amount, \"Illegal Balance\");\n    unchecked {\n      _data.accounts[account].balance = accountBalance - amount;\n      _totalSupply -= amount;\n    }\n\n    emit Burn(_msgSender(), account, amount, _totalSupply);\n    return _totalSupply;\n  }\n\n  function name() external view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() external view returns (string memory) {\n    return _symbol;\n  }\n\n  function totalSupply() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) external view returns (uint256) {\n    return _data.accounts[account].balance;\n  }\n\n  function totalBalanceOf(address account) external view returns (uint256) {\n    return _data.accounts[account].lockBalance + _data.accounts[account].balance;\n  }\n\n  function lockBalanceOf(address account) external view returns (uint256) {\n    return _data.accounts[account].lockBalance;\n  }\n\n  function allowance(address owner, address spender) external view returns (uint256) {\n    return _allowance(owner, spender);\n  }\n\n  function taxRate() external view returns (uint256) {\n    return _taxRate;\n  }\n\n  function taxTreasury() external view returns (address) {\n    return _taxTreasury;\n  }\n\n  function taxWhitelist() external view returns (address[] memory) {\n    return _data.taxWhitelist.values();\n  }\n\n  function nonce(address owner) external view returns (uint256) {\n    return _data.accounts[owner].nonce.current();\n  }\n\n  function isPaused(address account) external view returns (bool) {\n    return account != address(0) && _data.pausedList.contains(account);\n  }\n\n  function isPausedAll() external view returns (bool) {\n    return _isPaused;\n  }\n\n  function pausedAccounts() external view returns (address[] memory) {\n    return _data.pausedList.values();\n  }\n\n  function lockInfo(bytes32 lockId, address account) external view returns (LockInfo memory) {\n    AssetLock storage lock = _data.locks[account][lockId];\n    return\n      LockInfo({\n        amount: lock.amount,\n        lockedAt: lock.lockedAt,\n        claimedAt: lock.claimedAt,\n        source: lock.source,\n        stat: lock.status\n      });\n  }\n\n  function decimals() external pure returns (uint8) {\n    return 18;\n  }\n\n  function initialize(InitRequest calldata request) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(request.contractName, request.contractVersion, request.aclManager);\n\n    _name = \"LIVELY\";\n    _symbol = \"LIV\";\n    _taxRate = request.taxRateValue;\n    _isTokenDistributed = false;\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      request.contractName,\n      request.contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  function _tokensDistributionValidation(address account) private view {\n    require(_data.accounts[account].balance == 0, \"AssetId Already Distributed\");\n  }\n\n  function tokensDistribution(address assetManager, address[7] calldata assets)\n    public\n    safeModeCheck\n    aclCheck(this.tokensDistribution.selector)\n    returns (bool)\n  {\n    require(!_isTokenDistributed, \"Token Already Distributed\");\n\n    if (!IERC165(assetManager).supportsInterface(type(IAssetManagerERC20).interfaceId))\n      revert(\"Illegal IAssetManagerERC20\");\n\n    _mint(_msgSender(), 5_000_000_000 * 10**18); // 5 billion tokens according to tokenomics\n\n    for (uint256 i = 0; i < 7; i++) {\n      if (!IERC165(assets[i]).supportsInterface(type(IAssetEntity).interfaceId)) revert(\"Illegal IAssetEntity\");\n\n      require(IAssetEntity(assets[i]).assetToken() == address(this), \"Illegal Asset Token\");\n      if (\n        keccak256(abi.encodePacked(IAssetEntity(assets[i]).assetName())) ==\n        keccak256(abi.encodePacked(\"LIVELY_AUDIO_VIDEO_PROGRAM_ASSET\"))\n      ) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 500_000_000 * 10**18); // 10%\n      } else if (\n        keccak256(abi.encodePacked(IAssetEntity(assets[i]).assetName())) ==\n        keccak256(abi.encodePacked(\"LIVELY_FOUNDING_TEAM_ASSET\"))\n      ) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 900_000_000 * 10**18); // 18%\n      } else if (\n        keccak256(abi.encodePacked(IAssetEntity(assets[i]).assetName())) ==\n        keccak256(abi.encodePacked(\"LIVELY_TREASURY_ASSET\"))\n      ) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 750_000_000 * 10**18); // 15%\n      } else if (\n        keccak256(abi.encodePacked(IAssetEntity(assets[i]).assetName())) ==\n        keccak256(abi.encodePacked(\"LIVELY_PUBLIC_SALE_ASSET\"))\n      ) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 2_000_000_000 * 10**18); // 40%\n      } else if (\n        keccak256(abi.encodePacked(IAssetEntity(assets[i]).assetName())) ==\n        keccak256(abi.encodePacked(\"LIVELY_VALIDATORS_REWARDS_ASSET\"))\n      ) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 300_000_000 * 10**18); // 6%\n      } else if (\n        keccak256(abi.encodePacked(IAssetEntity(assets[i]).assetName())) ==\n        keccak256(abi.encodePacked(\"LIVELY_CROWD_FOUNDING_ASSET\"))\n      ) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 550_000_000 * 10**18); // 11%\n      } else if (\n        keccak256(abi.encodePacked(IAssetEntity(assets[i]).assetName())) ==\n        keccak256(abi.encodePacked(\"LIVELY_TAX_TREASURY_ASSET\"))\n      ) {\n        require(_taxTreasury == address(0), \"TaxTreasury Already Registered\");\n        _taxTreasury = assets[i];\n      } else {\n        revert(\"Not Supported\");\n      }\n    }\n\n    _isTokenDistributed = true;\n    return true;\n  }\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return\n      interfaceId == type(IERC20).interfaceId ||\n      interfaceId == type(IERC20Extra).interfaceId ||\n      interfaceId == type(IERC20Pause).interfaceId ||\n      interfaceId == type(IERC20Lock).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function getLibrary() public pure returns (address) {\n    return address(LTokenERC20);\n  }\n\n  function _updateTaxWhitelist(address account, bool isDeleted) internal returns (bool) {\n    emit TaxWhitelistUpdated(_msgSender(), account, isDeleted);\n    return LTokenERC20.updateTaxWhitelist(_data, account, isDeleted);\n  }\n\n  function _mint(address account, uint256 amount) internal returns (uint256) {\n    require(account != address(0), \"Illegal Address\");\n    _totalSupply += amount;\n    _data.accounts[account].balance += amount;\n    emit Mint(_msgSender(), account, amount, _totalSupply);\n    return _totalSupply;\n  }\n\n  function _transfer(\n    address src,\n    address dest,\n    uint256 amount\n  ) internal {\n    LTokenERC20.transfer(_data, src, dest, amount);\n    emit Transfer(src, dest, amount);\n  }\n\n  function _taxTransfer(\n    address source,\n    address recipient,\n    uint256 amount\n  ) internal {\n    uint256 tax = amount.mulBP(_taxRate);\n    uint256 tokensToTransfer = amount.sub(tax, \"Illegal Amount\");\n\n    _transfer(source, _taxTreasury, tax);\n    _transfer(source, recipient, tokensToTransfer);\n  }\n\n  function _transferFrom(\n    address source,\n    address recipient,\n    uint256 amount\n  ) internal returns (bool) {\n    address spender = _msgSender();\n    if (_taxRate > 0 && !_data.taxWhitelist.contains(_msgSender())) {\n      _taxTransfer(source, recipient, amount);\n    } else {\n      _transfer(source, recipient, amount);\n    }\n\n    _spendAllowance(source, spender, amount);\n    emit TransferFrom(spender, source, recipient, amount);\n    return true;\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal {\n    require(owner != address(0) && spender != address(0), \"Illegal Address\");\n    _data.allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _spendAllowance(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal {\n    uint256 currentAllowance = _allowance(owner, spender);\n    require(currentAllowance >= amount, \"Illegal Allowance\");\n    unchecked {\n      _approve(owner, spender, currentAllowance - amount);\n    }\n  }\n\n  function _useNonce(address owner) internal returns (uint256 current) {\n    LCounters.Counter storage localNonce = _data.accounts[owner].nonce;\n    current = localNonce.current();\n    localNonce.increment();\n  }\n\n  function _lockToken(LockTokenRequest calldata lockRequest) internal returns (bytes32) {\n    bytes32 lockId = LTokenERC20.lockToken(_data, lockRequest);\n    emit TokenLocked(\n      lockId,\n      _msgSender(),\n      lockRequest.source,\n      lockRequest.dest,\n      lockRequest.claimAt,\n      lockRequest.amount\n    );\n    return lockId;\n  }\n\n  function _claimToken(bytes32 lockId) internal returns (uint256) {\n    uint256 lockAmount = LTokenERC20.claimToken(_data, lockId);\n    emit TokenClaimed(lockId, _msgSender(), _data.locks[_msgSender()][lockId].source, lockAmount);\n    return lockAmount;\n  }\n\n  function _unlockToken(UnLockTokenRequest calldata unlockRequest) internal returns (uint256) {\n    (address srcAccount, uint256 lockAmount) = LTokenERC20.unlockToken(_data, unlockRequest);\n    emit TokenUnlocked(\n      unlockRequest.lockId,\n      _msgSender(),\n      unlockRequest.account,\n      srcAccount,\n      lockAmount,\n      unlockRequest.reason\n    );\n    return lockAmount;\n  }\n\n  function _allowance(address owner, address spender) internal view returns (uint256) {\n    return _data.allowances[owner][spender];\n  }\n\n  function _policyInterceptor(\n    bytes4 funcSelector,\n    address account,\n    bool isCheckingTokenPaused,\n    bool isCheckingAccountPaused\n  ) private safeModeCheck aclCheck(funcSelector) {\n    if (isCheckingTokenPaused) {\n      require(!_isPaused, \"Token Paused\");\n    }\n\n    if (isCheckingAccountPaused) {\n      require(!_data.pausedList.contains(account), \"Suspended\");\n    }\n  }\n}\n"
    },
    "src/contracts/token/lively/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n\npragma solidity 0.8.19;\n\n/**\n * @title ERC20 Token Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IERC20 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "src/contracts/token/lively/IERC20Extra.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\n/**\n * @title ERC20 Token Extra Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IERC20Extra {\n  struct BatchTransferRequest {\n    address to;\n    uint256 amount;\n  }\n\n  struct BatchTransferFromRequest {\n    address from;\n    address to;\n    uint256 amount;\n  }\n\n  struct TaxWhitelistUpdateRequest {\n    address account;\n    bool isDeleted;\n  }\n\n  event ApprovalIncreased(address indexed owner, address indexed spender, uint256 amount);\n\n  event ApprovalDecreased(address indexed owner, address indexed spender, uint256 amount);\n\n  event TransferFrom(address indexed sender, address indexed from, address indexed to, uint256 amount);\n\n  event BatchTransfer(address indexed sender, uint256 totalAmount);\n\n  event BatchTransferFrom(address indexed sender, uint256 totalAmount);\n\n  event TaxRateUpdated(address indexed sender, uint256 rate);\n\n  event TaxWhitelistUpdated(address indexed sender, address indexed account, bool isDeleted);\n\n  event Burn(address indexed sender, address indexed account, uint256 amount, uint256 totalSupply);\n\n  event Mint(address indexed sender, address indexed account, uint256 amount, uint256 totalSupply);\n\n  function increaseAllowance(address spender, uint256 amount) external returns (uint256);\n\n  function decreaseAllowance(address spender, uint256 amount) external returns (uint256);\n\n  function burn(address account, uint256 amount) external returns (uint256);\n\n  function mint(address account, uint256 amount) external returns (uint256);\n\n  function batchTransfer(BatchTransferRequest[] calldata request) external returns (bool);\n\n  function batchTransferFrom(BatchTransferFromRequest[] calldata request) external returns (bool);\n\n  function updateTaxRate(uint256 taxRate) external returns (bool);\n\n  // function updateTaxWhitelist(address account, bool isDeleted) external returns (bool);\n\n  function updateTaxWhitelist(TaxWhitelistUpdateRequest[] calldata request) external returns (bool);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    bytes calldata signature\n  ) external returns (bool);\n\n  function taxRate() external view returns (uint256);\n\n  function taxTreasury() external view returns (address);\n\n  function taxWhitelist() external view returns (address[] memory);\n\n  function nonce(address owner) external view returns (uint256);\n}\n"
    },
    "src/contracts/token/lively/IERC20Pause.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n\npragma solidity 0.8.19;\n\n/**\n * @title ERC20 Token Pause Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IERC20Pause {\n  event Paused(address indexed sender, address indexed account);\n\n  event Unpaused(address indexed sender, address indexed account);\n\n  event PausedAll(address indexed sender);\n\n  event UnpausedAll(address indexed sender);\n\n  function pause(address account) external;\n\n  function unpause(address account) external;\n\n  function pauseAll() external;\n\n  function unpauseAll() external;\n\n  function isPaused(address account) external view returns (bool);\n\n  function isPausedAll() external view returns (bool);\n\n  function pausedAccounts() external view returns (address[] memory);\n}\n"
    },
    "src/contracts/token/lively/IERC20Lock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\n/**\n * @title ERC20 Token Lock Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IERC20Lock {\n  enum LockState {\n    NONE,\n    LOCKED,\n    CLAIMED,\n    UNLOCKED\n  }\n\n  struct LockTokenRequest {\n    address source;\n    address dest;\n    uint256 claimAt;\n    uint256 amount;\n  }\n\n  struct UnLockTokenRequest {\n    bytes32 lockId;\n    address account;\n    string reason;\n  }\n\n  struct LockInfo {\n    uint256 amount;\n    uint128 lockedAt;\n    uint128 claimedAt;\n    address source;\n    LockState stat;\n  }\n\n  event TokenLocked(\n    bytes32 indexed id,\n    address indexed sender,\n    address indexed src,\n    address account,\n    uint256 claimAt,\n    uint256 amount\n  );\n\n  event TokenClaimed(bytes32 indexed id, address indexed sender, address indexed src, uint256 amount);\n\n  event TokenUnlocked(\n    bytes32 indexed id,\n    address indexed sender,\n    address indexed account,\n    address dest,\n    uint256 amount,\n    string reason\n  );\n\n  function lockToken(LockTokenRequest[] calldata lockRequest) external returns (bytes32[] memory);\n\n  function unlockToken(UnLockTokenRequest[] calldata unlockRequest) external returns (uint256);\n\n  function claimToken(bytes32[] calldata lockIds) external returns (uint256);\n\n  function lockInfo(bytes32 lockId, address account) external view returns (LockInfo memory);\n\n  function totalBalanceOf(address account) external view returns (uint256);\n\n  function lockBalanceOf(address account) external view returns (uint256);\n}\n"
    },
    "src/contracts/token/lively/LivelyStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IERC20Lock.sol\";\nimport \"../../proxy/BaseUUPSStorage.sol\";\nimport \"../../lib/LCounters.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\n\n/**\n * @title Abstract Lively ERC20 Token Storage Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nabstract contract LivelyStorage is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LCounters for LCounters.Counter;\n\n  struct AccountInfo {\n    uint256 balance;\n    uint256 lockBalance;\n    LCounters.Counter nonce;\n  }\n\n  struct AssetLock {\n    uint256 amount;\n    uint128 lockedAt;\n    uint128 claimedAt;\n    address source;\n    IERC20Lock.LockState status;\n  }\n\n  struct DataCollection {\n    mapping(address => AccountInfo) accounts;\n    mapping(address => mapping(address => uint256)) allowances;\n    mapping(address => mapping(bytes32 => AssetLock)) locks;\n    LEnumerableSet.AddressSet pausedList;\n    LEnumerableSet.AddressSet taxWhitelist;\n  }\n\n  bytes32 internal constant _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n  string internal _name;\n  string internal _symbol;\n  uint256 internal _totalSupply;\n  uint256 internal _taxRate;\n  address internal _taxTreasury;\n  bool internal _isPaused;\n  bool internal _isTokenDistributed;\n\n  DataCollection internal _data;\n\n  // Note: for next upgrade add new variables after this line\n}\n"
    },
    "src/contracts/token/asset/IAssetEntity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\n/**\n * @title Asset Entity Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IAssetEntity {\n  enum AssetSafeModeStatus {\n    NONE,\n    DISABLED,\n    ENABLED\n  }\n\n  enum AssetType {\n    NONE,\n    ERC20,\n    ERC721,\n    ERC1155\n  }\n\n  struct AssetInitRequest {\n    bytes32 realmId;\n    bytes32 adminId;\n    bytes32 agentId;\n    bytes32 salt;\n    address subjectId;\n    address erc20TokenId;\n    address accessControlId;\n    address assetManagerId;\n    address assetContractId;\n    string contractName;\n    string contractVersion;\n    bytes signature;\n  }\n\n  struct AssetInfo {\n    uint256 balance;\n    string name;\n    string version;\n    address token;\n    address accessControl;\n    uint16 initVersion;\n    AssetType atype;\n    AssetSafeModeStatus status;\n  }\n\n  event AssetInitialized(\n    address indexed sender,\n    address indexed assetId,\n    address indexed tokenId,\n    address assetManagerId,\n    address assetSubjectId\n  );\n\n  event AssetSafeModeUpdated(address indexed sender, address indexed assetId, AssetSafeModeStatus status);\n\n  function assetInitialize(AssetInitRequest calldata request) external returns (bool);\n\n  function assetSetSafeMode(AssetSafeModeStatus status) external returns (bool);\n\n  function assetSafeMode() external view returns (AssetSafeModeStatus);\n\n  function assetType() external view returns (AssetType);\n\n  function assetToken() external view returns (address);\n\n  function assetName() external view returns (string memory);\n\n  function assetVersion() external view returns (string memory);\n\n  function assetAccessControl() external view returns (address);\n\n  function assetInitVersion() external view returns (uint16);\n\n  function assetBalance() external view returns (uint256);\n\n  function assetInfo() external view returns (AssetInfo memory);\n}\n"
    },
    "src/contracts/token/asset/IAssetManagerERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IAssetEntity.sol\";\n\n/**\n * @title Asset Manager ERC20 Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IAssetManagerERC20 {\n  struct AssetCreateRequest {\n    bytes32 adminId;\n    bytes32 agentId;\n    bytes32 realmId;\n    bytes32 salt;\n    address tokenId;\n    address assetId;\n    string assetName;\n    string assetVersion;\n  }\n\n  struct AssetActionRequest {\n    address tokenId;\n    address assetId;\n  }\n\n  struct AssetTokenActionRequest {\n    address tokenId;\n    address assetSubjectId;\n    bytes assetSignature;\n  }\n\n  struct AssetTokenSafeModeRequest {\n    address tokenId;\n    IAssetEntity.AssetSafeModeStatus status;\n  }\n\n  struct TokenInfo {\n    address assetSubjectId;\n    address[] assets;\n    bytes assetSignature;\n  }\n\n  event TokenUpdated(address indexed sender, address indexed tokenId, address indexed assetSubjectId);\n\n  event TokenRegistered(\n    address indexed sender,\n    address indexed tokenId,\n    address indexed assetSubjectId,\n    string tokenName,\n    string tokenSymbol\n  );\n\n  event AssetCreated(address indexed sender, address indexed assetId, address indexed tokenId);\n\n  event AssetRegistered(address indexed sender, address indexed assetId, address indexed tokenId);\n\n  event AssetRemoved(address indexed sender, address indexed assetId, address indexed tokenId);\n\n  function createAsset(AssetCreateRequest[] calldata requests) external returns (bool);\n\n  function registerAsset(AssetActionRequest[] calldata requests) external returns (bool);\n\n  function removeAsset(AssetActionRequest[] calldata requests) external returns (bool);\n\n  function registerToken(AssetTokenActionRequest[] calldata requests) external returns (bool);\n\n  function updateToken(AssetTokenActionRequest[] calldata requests) external returns (bool);\n\n  function setSafeModeAssets(AssetTokenSafeModeRequest[] calldata requests) external returns (bool);\n\n  function getSafeModeAsset(address assetId) external view returns (IAssetEntity.AssetSafeModeStatus);\n\n  function getAllTokens() external view returns (address[] memory);\n\n  function getTokenInfo(address tokenId) external view returns (TokenInfo memory);\n\n  function isAssetExists(address assetId) external view returns (bool);\n\n  function isTokenExists(address tokenId) external view returns (bool);\n\n  function predictAddress(\n    address implementation,\n    bytes32 salt,\n    address deployer\n  ) external view returns (address);\n}\n"
    },
    "src/contracts/token/asset/ERC20/IAssetERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../../lively/IERC20Extra.sol\";\nimport \"../../lively/IERC20Lock.sol\";\n\n/**\n * @title Asset ERC20 Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IAssetERC20 {\n  event AssetERC20Called(address indexed sender, address indexed assetId, bytes4 indexed functionSelector);\n\n  function tokenLock(IERC20Lock.LockTokenRequest[] calldata lockRequests) external returns (bytes32[] memory);\n\n  function tokenTransfer(address to, uint256 amount) external returns (bool);\n\n  function tokenBatchTransfer(IERC20Extra.BatchTransferRequest[] calldata request) external returns (bool);\n\n  function tokenTransferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n\n  function tokenBatchTransferFrom(IERC20Extra.BatchTransferFromRequest[] calldata request) external returns (bool);\n\n  function tokenApprove(address spender, uint256 amount) external returns (bool);\n\n  function tokenIncreaseAllowance(address spender, uint256 amount) external returns (uint256);\n\n  function tokenDecreaseAllowance(address spender, uint256 amount) external returns (uint256);\n}\n"
    },
    "src/contracts/lib/token/LTokenERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n\npragma solidity 0.8.19;\n\nimport \"../../token/lively/IERC20.sol\";\nimport \"../../token/lively/IERC20Extra.sol\";\nimport \"../../token/lively/IERC20Pause.sol\";\nimport \"../../token/lively/IERC20Lock.sol\";\nimport \"../../token/lively/LivelyStorage.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../acl/IACL.sol\";\nimport \"../struct/LEnumerableSet.sol\";\n\n/**\n * @title Token ERC20 Library\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nlibrary LTokenERC20 {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  string public constant LIB_NAME = \"LTokenERC20\";\n  string public constant LIB_VERSION = \"3.0.0\";\n\n  function lockToken(LivelyStorage.DataCollection storage data, IERC20Lock.LockTokenRequest memory lockRequest)\n    external\n    returns (bytes32)\n  {\n    require(\n      lockRequest.source != address(0) && lockRequest.dest != address(0) && lockRequest.source != lockRequest.dest,\n      \"Illegal Source/Dest Address\"\n    );\n    require(lockRequest.claimAt > block.timestamp + 1 days, \"Illegal Timestamp\");\n    require(lockRequest.amount > 0, \"Illegal amount\");\n\n    bytes32 lockId = keccak256(\n      abi.encodePacked(lockRequest.source, lockRequest.dest, lockRequest.claimAt, lockRequest.amount)\n    );\n    require(data.locks[lockRequest.dest][lockId].source == address(0), \"Already Exists\");\n\n    uint256 srcBalance = data.accounts[lockRequest.source].balance;\n    require(srcBalance >= lockRequest.amount, \"Illegal Balance\");\n    unchecked {\n      data.accounts[lockRequest.source].balance = srcBalance - lockRequest.amount;\n    }\n    data.accounts[lockRequest.dest].lockBalance += lockRequest.amount;\n\n    LivelyStorage.AssetLock storage assetLock = data.locks[lockRequest.dest][lockId];\n    assetLock.lockedAt = uint128(block.timestamp);\n    assetLock.claimedAt = uint128(lockRequest.claimAt);\n    assetLock.source = lockRequest.source;\n    assetLock.amount = lockRequest.amount;\n    assetLock.status = IERC20Lock.LockState.LOCKED;\n    return lockId;\n  }\n\n  function claimToken(LivelyStorage.DataCollection storage data, bytes32 lockId) external returns (uint256) {\n    require(lockId != bytes32(0), \"Illegal LockId\");\n    require(data.locks[msg.sender][lockId].source != address(0), \"Not Found\");\n    require(data.locks[msg.sender][lockId].claimedAt < uint128(block.timestamp), \"Illegal Claim\");\n\n    uint256 lockAmount = data.locks[msg.sender][lockId].amount;\n    uint256 lockBalance = data.accounts[msg.sender].lockBalance;\n    require(lockBalance >= lockAmount, \"Illegal Lock Balance\");\n    unchecked {\n      data.accounts[msg.sender].lockBalance = lockBalance - lockAmount;\n    }\n    data.accounts[msg.sender].balance += lockAmount;\n    data.locks[msg.sender][lockId].status = IERC20Lock.LockState.CLAIMED;\n    return lockAmount;\n  }\n\n  function unlockToken(LivelyStorage.DataCollection storage data, IERC20Lock.UnLockTokenRequest calldata unlockRequest)\n    external\n    returns (address, uint256)\n  {\n    require(unlockRequest.lockId != bytes32(0), \"Illegal LockId\");\n    require(data.locks[unlockRequest.account][unlockRequest.lockId].source != address(0), \"LockId Not Found\");\n    require(\n      data.locks[unlockRequest.account][unlockRequest.lockId].status == IERC20Lock.LockState.LOCKED,\n      \"Illegal Lock State\"\n    );\n\n    uint256 lockAmount = data.locks[unlockRequest.account][unlockRequest.lockId].amount;\n    uint256 lockBalance = data.accounts[unlockRequest.account].lockBalance;\n    address srcAccount = data.locks[unlockRequest.account][unlockRequest.lockId].source;\n    require(lockBalance >= lockAmount, \"Illegal Lock Balance\");\n    unchecked {\n      data.accounts[unlockRequest.account].lockBalance = lockBalance - lockAmount;\n    }\n    data.accounts[srcAccount].balance += lockAmount;\n    data.locks[unlockRequest.account][unlockRequest.lockId].status = IERC20Lock.LockState.UNLOCKED;\n    return (srcAccount, lockAmount);\n  }\n\n  function transfer(\n    LivelyStorage.DataCollection storage data,\n    address src,\n    address dest,\n    uint256 amount\n  ) external {\n    require(src != address(0) && dest != address(0) && src != dest, \"Illegal Src/Dest Address\");\n    require(amount > 0, \"Illegal Amount\");\n\n    uint256 srcBalance = data.accounts[src].balance;\n    require(srcBalance >= amount, \"Illegal Balance\");\n    unchecked {\n      data.accounts[src].balance = srcBalance - amount;\n    }\n    data.accounts[dest].balance += amount;\n  }\n\n  function updateTaxWhitelist(\n    LivelyStorage.DataCollection storage data,\n    address account,\n    bool isDeleted\n  ) external returns (bool) {\n    require(account != address(0), \"Illegal Address\");\n    if (isDeleted) {\n      require(data.taxWhitelist.contains(account), \"Not Found\");\n      data.taxWhitelist.remove(account);\n    } else {\n      require(!data.taxWhitelist.contains(account), \"Already Exists\");\n      data.taxWhitelist.add(account);\n    }\n\n    return true;\n  }\n}\n"
    },
    "src/contracts/lib/LCounters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nlibrary LCounters {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    unchecked {\n      counter._value += 1;\n    }\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n    unchecked {\n      counter._value = value - 1;\n    }\n  }\n\n  function reset(Counter storage counter) internal {\n    counter._value = 0;\n  }\n}\n"
    },
    "src/contracts/lib/math/LBasisPointsMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n\npragma solidity 0.8.19;\n\nimport \"./LSafeMath.sol\";\n\n/**\n * @title Basis Points Math Library\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nlibrary LBasisPointsMath {\n  using LSafeMath for uint256;\n\n  uint256 private constant _BASIS_POINTS = 10000;\n\n  function mulBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    return amt.mul(bp).div(_BASIS_POINTS);\n  }\n\n  function divBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    require(bp > 0, \"Illegal Divide Zero\");\n    return amt.mul(_BASIS_POINTS).div(bp);\n  }\n\n  function addBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    if (amt == 0) return 0;\n    if (bp == 0) return amt;\n    return amt.add(mulBP(amt, bp));\n  }\n\n  function subBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    if (amt == 0) return 0;\n    if (bp == 0) return amt;\n    return amt.sub(mulBP(amt, bp));\n  }\n}\n"
    },
    "src/contracts/lib/math/LSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary LSafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, with an overflow flag.\n   */\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      uint256 c = a + b;\n      if (c < a) return (false, 0);\n      return (true, c);\n    }\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n   */\n  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b > a) return (false, 0);\n      return (true, a - b);\n    }\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n   */\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n      // benefit is lost if 'b' is also tested.\n      // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n      if (a == 0) return (true, 0);\n      uint256 c = a * b;\n      if (c / a != b) return (false, 0);\n      return (true, c);\n    }\n  }\n\n  /**\n   * @dev Returns the division of two unsigned integers, with a division by zero flag.\n   */\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b == 0) return (false, 0);\n      return (true, a / b);\n    }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n   */\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b == 0) return (false, 0);\n      return (true, a % b);\n    }\n  }\n\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   *\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   *\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator.\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * reverting when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a % b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {trySub}.\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b <= a, errorMessage);\n      return a - b;\n    }\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b > 0, errorMessage);\n      return a / b;\n    }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * reverting with custom message when dividing by zero.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {tryMod}.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b > 0, errorMessage);\n      return a % b;\n    }\n  }\n}\n"
    },
    "src/contracts/token/asset/AssetManagerStorageERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IAssetManagerERC20.sol\";\nimport \"../../proxy/BaseUUPSStorage.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\n\n/**\n * @title Abstract Asset Manager Storage ERC20 Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nabstract contract AssetManagerStorageERC20 is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  struct TokenData {\n    LEnumerableSet.AddressSet assets;\n    address assetSubjectId;\n    bytes assetSignature;\n  }\n\n  struct DataCollection {\n    mapping(address => TokenData) tokens;\n    LEnumerableSet.AddressSet tokensSet;\n  }\n  DataCollection internal _data;\n\n  // Note: for next upgrade add new variables after this line\n}\n"
    },
    "src/contracts/token/asset/ERC20/AssetERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IAssetERC20.sol\";\nimport \"../IAssetEntity.sol\";\nimport \"../IAssetManagerERC20.sol\";\nimport \"../../lively/IERC20.sol\";\nimport \"../../../proxy/Initializable.sol\";\nimport \"../../../utils/Message.sol\";\nimport \"../../../utils/ERC165.sol\";\nimport \"../../../lib/cryptography/LECDSA.sol\";\nimport \"../../../lib/LAddress.sol\";\nimport \"../../../lib/acl/LACLUtils.sol\";\nimport \"../../../acl/IACL.sol\";\nimport \"../../../acl/IACLGenerals.sol\";\nimport \"../../../acl/agent/IRoleManagement.sol\";\nimport \"../../../acl/scope/IFunctionManagement.sol\";\nimport \"../../../acl/scope/IContextManagement.sol\";\n\n/**\n * @title Asset ERC20 Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract AssetERC20 is Initializable, Message, ERC165, IAssetERC20, IAssetEntity {\n  using LAddress for address;\n\n  address private _accessControlId;\n  address private _erc20TokenId;\n  string private _contractName;\n  string private _contractVersion;\n  AssetSafeModeStatus private _assetSafeModeStatus;\n\n  constructor() {\n    _assetSafeModeStatus = AssetSafeModeStatus.ENABLED;\n  }\n\n  function assetInitialize(AssetInitRequest calldata request) external initializer returns (bool) {\n    if (!IERC165(request.erc20TokenId).supportsInterface(type(IERC20).interfaceId)) revert(\"Illegal ERC20Token\");\n\n    if (!IERC165(request.erc20TokenId).supportsInterface(type(IERC20Extra).interfaceId))\n      revert(\"Illegal ERC20TokenExtra\");\n\n    if (!IERC165(request.erc20TokenId).supportsInterface(type(IERC20Lock).interfaceId))\n      revert(\"Illegal ERC20TokenLock\");\n\n    if (!IERC165(request.accessControlId).supportsInterface(type(IACL).interfaceId)) revert(\"Illegal ACL\");\n\n    if (!IERC165(request.assetManagerId).supportsInterface(type(IAssetManagerERC20).interfaceId))\n      revert(\"Illegal IAssetManagerERC20\");\n\n    _contractName = request.contractName;\n    _contractVersion = request.contractVersion;\n    _erc20TokenId = request.erc20TokenId;\n    _accessControlId = request.accessControlId;\n    _assetSafeModeStatus = AssetSafeModeStatus.DISABLED;\n\n    _createContext(request);\n\n    _createFunctions(request);\n\n    emit AssetInitialized(_msgSender(), address(this), request.erc20TokenId, request.assetManagerId, request.subjectId);\n\n    return true;\n  }\n\n  function _createContext(AssetInitRequest calldata request) internal {\n    IContextManagement.ContextRegisterRequest[]\n      memory contextRequests = new IContextManagement.ContextRegisterRequest[](1);\n    contextRequests[0].realmId = request.realmId;\n    contextRequests[0].adminId = request.adminId;\n    contextRequests[0].salt = request.salt;\n    contextRequests[0].name = request.contractName;\n    contextRequests[0].version = request.contractVersion;\n    contextRequests[0].contractId = request.assetContractId;\n    contextRequests[0].subject = request.subjectId;\n    contextRequests[0].deployer = request.assetManagerId;\n    contextRequests[0].functionLimit = 32;\n    contextRequests[0].acstat = IACLCommons.ActivityStatus.ENABLED;\n    contextRequests[0].alstat = IACLCommons.AlterabilityStatus.UPGRADABLE;\n    contextRequests[0].signature = request.signature;\n\n    IACLCommons.MemberSignature memory memberSignRequest = IACLCommons.MemberSignature({\n      account: address(0),\n      expiredAt: 0,\n      signature: bytes(\"\")\n    });\n\n    IContextManagement(_accessControlId).contextRegister(memberSignRequest, contextRequests);\n  }\n\n  function _createFunctions(AssetInitRequest calldata request) internal {\n    IFunctionManagement.FunctionRequest[] memory functionRequests = new IFunctionManagement.FunctionRequest[](10);\n\n    // assetSafeModeSet\n    functionRequests[0].adminId = request.adminId;\n    functionRequests[0].agentId = request.adminId;\n    functionRequests[0].selector = IAssetEntity.assetSetSafeMode.selector;\n    functionRequests[0].policyCode = 130;\n    functionRequests[0].acstat = IACLCommons.ActivityStatus.ENABLED;\n    functionRequests[0].alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n\n    // tokenLock\n    functionRequests[1].adminId = request.adminId;\n    functionRequests[1].agentId = request.agentId;\n    functionRequests[1].selector = IAssetERC20.tokenLock.selector;\n    functionRequests[1].policyCode = 48;\n    functionRequests[1].acstat = IACLCommons.ActivityStatus.ENABLED;\n    functionRequests[1].alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n\n    // tokenTransfer\n    functionRequests[2].adminId = request.adminId;\n    functionRequests[2].agentId = request.agentId;\n    functionRequests[2].selector = IAssetERC20.tokenTransfer.selector;\n    functionRequests[2].policyCode = 96;\n    functionRequests[2].acstat = IACLCommons.ActivityStatus.ENABLED;\n    functionRequests[2].alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n\n    // tokenBatchTransfer\n    functionRequests[3].adminId = request.adminId;\n    functionRequests[3].agentId = request.agentId;\n    functionRequests[3].selector = IAssetERC20.tokenBatchTransfer.selector;\n    functionRequests[3].policyCode = 99;\n    functionRequests[3].acstat = IACLCommons.ActivityStatus.ENABLED;\n    functionRequests[3].alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n\n    // tokenTransferFrom\n    functionRequests[4].adminId = request.adminId;\n    functionRequests[4].agentId = request.agentId;\n    functionRequests[4].selector = IAssetERC20.tokenTransferFrom.selector;\n    functionRequests[4].policyCode = 110;\n    functionRequests[4].acstat = IACLCommons.ActivityStatus.ENABLED;\n    functionRequests[4].alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n\n    // tokenBatchTransferFrom\n    functionRequests[5].adminId = request.adminId;\n    functionRequests[5].agentId = request.agentId;\n    functionRequests[5].selector = IAssetERC20.tokenBatchTransferFrom.selector;\n    functionRequests[5].policyCode = 116;\n    functionRequests[5].acstat = IACLCommons.ActivityStatus.ENABLED;\n    functionRequests[5].alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n\n    // tokenApprove\n    functionRequests[6].adminId = request.adminId;\n    functionRequests[6].agentId = request.agentId;\n    functionRequests[6].selector = IAssetERC20.tokenApprove.selector;\n    functionRequests[6].policyCode = 150;\n    functionRequests[6].acstat = IACLCommons.ActivityStatus.ENABLED;\n    functionRequests[6].alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n\n    // tokenIncreaseAllowance\n    functionRequests[7].adminId = request.adminId;\n    functionRequests[7].agentId = request.agentId;\n    functionRequests[7].selector = IAssetERC20.tokenIncreaseAllowance.selector;\n    functionRequests[7].policyCode = 160;\n    functionRequests[7].acstat = IACLCommons.ActivityStatus.ENABLED;\n    functionRequests[7].alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n\n    // tokenDecreaseAllowance\n    functionRequests[8].adminId = request.adminId;\n    functionRequests[8].agentId = request.agentId;\n    functionRequests[8].selector = IAssetERC20.tokenDecreaseAllowance.selector;\n    functionRequests[8].policyCode = 160;\n    functionRequests[8].acstat = IACLCommons.ActivityStatus.ENABLED;\n    functionRequests[8].alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n\n    // withdrawBalance\n    functionRequests[9].adminId = request.adminId;\n    functionRequests[9].agentId = request.agentId;\n    functionRequests[9].selector = this.withdrawBalance.selector;\n    functionRequests[9].policyCode = 24;\n    functionRequests[9].acstat = IACLCommons.ActivityStatus.ENABLED;\n    functionRequests[9].alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n\n    IFunctionManagement.FunctionRegisterRequest[] memory requests = new IFunctionManagement.FunctionRegisterRequest[](\n      1\n    );\n    requests[0].signature = request.signature;\n    requests[0].realmId = request.realmId;\n    requests[0].salt = request.salt;\n    requests[0].name = request.contractName;\n    requests[0].version = request.contractVersion;\n    requests[0].subject = request.subjectId;\n    requests[0].deployer = request.assetManagerId;\n    requests[0].contractId = address(0);\n    requests[0].functions = functionRequests;\n\n    IACLCommons.MemberSignature memory memberSignRequest = IACLCommons.MemberSignature({\n      account: address(0),\n      expiredAt: 0,\n      signature: bytes(\"\")\n    });\n\n    IFunctionManagement(_accessControlId).functionRegister(memberSignRequest, requests);\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return\n      interfaceId == type(IAssetEntity).interfaceId ||\n      interfaceId == type(IAssetERC20).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function tokenLock(IERC20Lock.LockTokenRequest[] calldata lockRequests) external returns (bytes32[] memory) {\n    _policyInterceptor(this.tokenLock.selector);\n    for (uint256 i = 0; i < lockRequests.length; i++) {\n      require(lockRequests[i].source == address(this), \"Illegal Address\");\n    }\n\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenLock.selector);\n    return IERC20Lock(_erc20TokenId).lockToken(lockRequests);\n  }\n\n  function tokenTransfer(address to, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.tokenTransfer.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenTransfer.selector);\n    return IERC20(_erc20TokenId).transfer(to, amount);\n  }\n\n  function tokenBatchTransfer(IERC20Extra.BatchTransferRequest[] calldata request) external returns (bool) {\n    _policyInterceptor(this.tokenBatchTransfer.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenBatchTransfer.selector);\n    return IERC20Extra(_erc20TokenId).batchTransfer(request);\n  }\n\n  function tokenTransferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool) {\n    _policyInterceptor(this.tokenTransferFrom.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenTransferFrom.selector);\n    return IERC20(_erc20TokenId).transferFrom(from, to, amount);\n  }\n\n  function tokenBatchTransferFrom(IERC20Extra.BatchTransferFromRequest[] calldata request) external returns (bool) {\n    _policyInterceptor(this.tokenBatchTransferFrom.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenBatchTransferFrom.selector);\n    return IERC20Extra(_erc20TokenId).batchTransferFrom(request);\n  }\n\n  function tokenApprove(address spender, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.tokenApprove.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenApprove.selector);\n    return IERC20(_erc20TokenId).approve(spender, amount);\n  }\n\n  function tokenIncreaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.tokenIncreaseAllowance.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenIncreaseAllowance.selector);\n    return IERC20Extra(_erc20TokenId).increaseAllowance(spender, amount);\n  }\n\n  function tokenDecreaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.tokenDecreaseAllowance.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenDecreaseAllowance.selector);\n    return IERC20Extra(_erc20TokenId).decreaseAllowance(spender, amount);\n  }\n\n  function assetSetSafeMode(AssetSafeModeStatus status) public override returns (bool) {\n    IACL.AuthorizationStatus aclStatus = IACL(_accessControlId).hasAccountAccess(\n      address(this),\n      this.assetSetSafeMode.selector,\n      _msgSender()\n    );\n    if (aclStatus != IACL.AuthorizationStatus.PERMITTED) revert IACL.ACLActionForbidden(aclStatus);\n    require(_getInitializedCount() > 0, \"NOT INIT\");\n    _assetSafeModeStatus = status;\n    emit AssetSafeModeUpdated(_msgSender(), address(this), status);\n    return true;\n  }\n\n  function withdrawBalance(address recepient) public {\n    _policyInterceptor(this.withdrawBalance.selector);\n    payable(recepient).transfer(address(this).balance);\n  }\n\n  function assetSafeMode() external view returns (AssetSafeModeStatus) {\n    return _assetSafeModeStatus;\n  }\n\n  function assetType() external pure returns (AssetType) {\n    return AssetType.ERC20;\n  }\n\n  function assetToken() external view returns (address) {\n    return _erc20TokenId;\n  }\n\n  function assetName() external view returns (string memory) {\n    return _contractName;\n  }\n\n  function assetVersion() external view returns (string memory) {\n    return _contractVersion;\n  }\n\n  function assetAccessControl() external view returns (address) {\n    return _accessControlId;\n  }\n\n  function assetInitVersion() external view returns (uint16) {\n    return _getInitializedCount();\n  }\n\n  function assetBalance() external view returns (uint256) {\n    return IERC20(_erc20TokenId).balanceOf(address(this));\n  }\n\n  function assetInfo() external view returns (AssetInfo memory) {\n    return\n      AssetInfo({\n        balance: IERC20(_erc20TokenId).balanceOf(address(this)),\n        name: _contractName,\n        version: _contractVersion,\n        token: _erc20TokenId,\n        accessControl: _accessControlId,\n        initVersion: _getInitializedCount(),\n        atype: AssetType.ERC20,\n        status: _assetSafeModeStatus\n      });\n  }\n\n  // solhint-disable-next-line\n  receive() external payable {}\n\n  // solhint-disable-next-line\n  fallback() external payable {}\n\n  function balance() public view returns (uint256) {\n    return address(this).balance;\n  }\n\n  function _policyInterceptor(bytes4 funcSelector) private {\n    require(_assetSafeModeStatus == AssetSafeModeStatus.DISABLED, \"Rejected\");\n    IACL.AuthorizationStatus aclStatus = IACL(_accessControlId).hasAccountAccess(\n      address(this),\n      funcSelector,\n      _msgSender()\n    );\n    if (aclStatus != IACL.AuthorizationStatus.PERMITTED) revert IACL.ACLActionForbidden(aclStatus);\n  }\n}\n"
    },
    "src/contracts/test/proxy/BaseUUPSProxyTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.2)\n\npragma solidity 0.8.19;\n\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\nimport \"../../acl/scope/IContextManagement.sol\";\n\n/**\n * @title Base UUPS Proxy Test\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract BaseUUPSProxyTest is BaseUUPSProxy {\n  bytes32 public constant LIVELY_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_SYSTEM_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_SYSTEM_ADMIN_ROLE\"));\n\n  event UpgradeToAnonymous(address indexed sender, address indexed newImplementation);\n  event UpgradeToTester(address indexed sender, address indexed newImplementation);\n\n  // function initialize(\n  //   string calldata domainName,\n  //   string calldata domainVersion,\n  //   string calldata domainRealm,\n  //   bytes memory signature,\n  //   address accessControlManager\n  // ) public onlyLocalAdmin initializer {\n  //   bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n  //   __BASE_UUPS_init(domainName, domainVersion, realm, accessControlManager);\n  //   IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n  //     name: keccak256(abi.encodePacked(domainName)),\n  //     version: keccak256(abi.encodePacked(domainVersion)),\n  //     realm: realm,\n  //     contractId: address(this),\n  //     status: true\n  //   });\n\n  //   IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n  //   rrc[0].role = LIVELY_ADMIN_ROLE;\n  //   rrc[0].isEnabled = true;\n  //   rrc[0].funcSelectors = new bytes4[](2);\n  //   rrc[0].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n  //   rrc[0].funcSelectors[1] = IProxy.setUpgradeStatus.selector;\n\n  //   rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n  //   rrc[1].isEnabled = true;\n  //   rrc[1].funcSelectors = new bytes4[](2);\n  //   rrc[1].funcSelectors[0] = IProxy.setSafeMode.selector;\n  //   rrc[1].funcSelectors[1] = IProxy.upgradeTo.selector;\n  //   IContextManagement(accessControlManager).registerContext(signature, rc, rrc);\n  // }\n\n  // function initializeWithInvalidRealm(\n  //   string calldata domainName,\n  //   string calldata domainVersion,\n  //   string calldata domainRealm,\n  //   bytes memory signature,\n  //   address accessControlManager\n  // ) public onlyLocalAdmin initializer {\n  //   bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n  //   _domainName = keccak256(abi.encodePacked(domainName));\n  //   _domainVersion = keccak256(abi.encodePacked(domainVersion));\n  //   _domainRealm = realm;\n  //   if (accessControlManager == address(0)) {\n  //     _accessControlManager = address(this);\n  //   } else {\n  //     try IERC165(accessControlManager).supportsInterface(type(IAccessControl).interfaceId) returns (bool isSupported) {\n  //       require(isSupported, \"Invalid AccessControlManager\");\n  //     } catch {\n  //       revert(\"Illegal AccessControlManager\");\n  //     }\n  //     _accessControlManager = accessControlManager;\n  //   }\n  //   _isUpgradable = false;\n  //   _isSafeMode = false;\n\n  //   IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n  //     name: keccak256(abi.encodePacked(domainName)),\n  //     version: keccak256(abi.encodePacked(domainVersion)),\n  //     realm: realm,\n  //     contractId: address(this),\n  //     status: true\n  //   });\n\n  //   IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n  //   rrc[0].role = LIVELY_ADMIN_ROLE;\n  //   rrc[0].isEnabled = true;\n  //   rrc[0].funcSelectors = new bytes4[](2);\n  //   rrc[0].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n  //   rrc[0].funcSelectors[1] = IProxy.setUpgradeStatus.selector;\n\n  //   rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n  //   rrc[1].isEnabled = true;\n  //   rrc[1].funcSelectors = new bytes4[](2);\n  //   rrc[1].funcSelectors[0] = IProxy.setSafeMode.selector;\n  //   rrc[1].funcSelectors[1] = IProxy.upgradeTo.selector;\n  //   IContextManagement(accessControlManager).registerContext(signature, rc, rrc);\n  // }\n\n  // function initializeWithInvalidRole(\n  //   string calldata domainName,\n  //   string calldata domainVersion,\n  //   string calldata domainRealm,\n  //   bytes memory signature,\n  //   address accessControlManager\n  // ) public onlyLocalAdmin initializer {\n  //   bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n  //   __BASE_UUPS_init(domainName, domainVersion, realm, accessControlManager);\n\n  //   IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n  //     name: keccak256(abi.encodePacked(domainName)),\n  //     version: keccak256(abi.encodePacked(domainVersion)),\n  //     realm: realm,\n  //     contractId: address(this),\n  //     status: true\n  //   });\n\n  //   IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](1);\n  //   rrc[0].role = keccak256(abi.encodePacked(\"LIVELY_WORLD_ADMIN\"));\n  //   rrc[0].isEnabled = true;\n  //   rrc[0].funcSelectors = new bytes4[](2);\n  //   rrc[0].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n  //   rrc[0].funcSelectors[1] = IProxy.setUpgradeStatus.selector;\n\n  //   IContextManagement(accessControlManager).registerContext(signature, rc, rrc);\n  // }\n\n  // function reInitialize(bytes memory signature) public onlyLocalAdmin reinitializer(2) {\n  //   _domainRealm = keccak256(abi.encodePacked(\"LIVELY_VERSE_REALM\"));\n  //   IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n  //     name: _domainName,\n  //     version: _domainVersion,\n  //     realm: _domainRealm,\n  //     contractId: address(this),\n  //     status: true\n  //   });\n\n  //   IContextManagement.RequestUpdateContext[] memory ruc = new IContextManagement.RequestUpdateContext[](5);\n  //   ruc[0].role = LIVELY_SYSTEM_ADMIN_ROLE;\n  //   ruc[0].updateStatus = IContextManagement.UpdateContextStatus.DISABLE;\n  //   ruc[0].funcSelectors = new bytes4[](1);\n  //   ruc[0].funcSelectors[0] = IProxy.upgradeTo.selector;\n\n  //   ruc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n  //   ruc[1].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n  //   ruc[1].funcSelectors = new bytes4[](1);\n  //   ruc[1].funcSelectors[0] = this.upgradeToAndCall.selector;\n\n  //   ruc[2].role = keccak256(abi.encodePacked(\"TESTER_ROLE\"));\n  //   ruc[2].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n  //   ruc[2].funcSelectors = new bytes4[](1);\n  //   ruc[2].funcSelectors[0] = this.upgradeToTesterRole.selector;\n\n  //   ruc[3].role = keccak256(abi.encodePacked(\"LIVELY_ANONYMOUS_ROLE\"));\n  //   ruc[3].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n  //   ruc[3].funcSelectors = new bytes4[](1);\n  //   ruc[3].funcSelectors[0] = this.upgradeToAnonymousRole.selector;\n\n  //   ruc[4].role = LIVELY_SYSTEM_ADMIN_ROLE;\n  //   ruc[4].updateStatus = IContextManagement.UpdateContextStatus.REMOVE;\n  //   ruc[4].funcSelectors = new bytes4[](1);\n  //   ruc[4].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n\n  //   IContextManagement(_accessControlManager).updateContext(signature, rc, ruc);\n  // }\n\n  // function reInitializeWithInvalidRealm(bytes memory signature) public onlyLocalAdmin reinitializer(2) {\n  //   IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n  //     name: _domainName,\n  //     version: _domainVersion,\n  //     realm: keccak256(abi.encodePacked(\"LIVELY_REALM\")),\n  //     contractId: address(this),\n  //     status: true\n  //   });\n\n  //   IContextManagement.RequestUpdateContext[] memory ruc = new IContextManagement.RequestUpdateContext[](2);\n  //   ruc[0].role = LIVELY_SYSTEM_ADMIN_ROLE;\n  //   ruc[0].updateStatus = IContextManagement.UpdateContextStatus.DISABLE;\n  //   ruc[0].funcSelectors = new bytes4[](1);\n  //   ruc[0].funcSelectors[0] = IProxy.upgradeTo.selector;\n\n  //   ruc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n  //   ruc[1].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n  //   ruc[1].funcSelectors = new bytes4[](1);\n  //   ruc[1].funcSelectors[0] = this.upgradeToAndCall.selector;\n\n  //   IContextManagement(_accessControlManager).updateContext(signature, rc, ruc);\n  // }\n\n  // function reInitializeWithInvalidRole(bytes memory signature) public onlyLocalAdmin reinitializer(2) {\n  //   IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n  //     name: _domainName,\n  //     version: _domainVersion,\n  //     realm: _domainRealm,\n  //     contractId: address(this),\n  //     status: true\n  //   });\n\n  //   IContextManagement.RequestUpdateContext[] memory rrc = new IContextManagement.RequestUpdateContext[](1);\n  //   rrc[0].role = keccak256(abi.encodePacked(\"LIVELY_WORLD_ADMIN\"));\n  //   rrc[0].updateStatus = IContextManagement.UpdateContextStatus.DISABLE;\n  //   rrc[0].funcSelectors = new bytes4[](1);\n  //   rrc[0].funcSelectors[0] = IProxy.upgradeTo.selector;\n\n  //   IContextManagement(_accessControlManager).updateContext(signature, rc, rrc);\n  // }\n\n  // function upgradeToTesterRole(address newImplementation) external virtual onlyProxy {\n  //   require(!_isSafeMode, \"Rejected\");\n  //   require(_isUpgradable, \"Upgrade Rejected\");\n  //   require(_hasPermission(this.upgradeToTesterRole.selector), \"upgradeToTesterRole Forbidden\");\n  //   emit UpgradeToTester(msg.sender, newImplementation);\n  // }\n\n  // function upgradeToAnonymousRole(address newImplementation) external virtual onlyProxy {\n  //   require(!_isSafeMode, \"Rejected\");\n  //   require(_isUpgradable, \"Upgrade Rejected\");\n  //   require(_hasPermission(this.upgradeToAnonymousRole.selector), \"upgradeToAnonymousRole Forbidden\");\n  //   emit UpgradeToAnonymous(msg.sender, newImplementation);\n  // }\n\n  // function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n  //   _authorizeUpgrade(newImplementation);\n  //   _upgradeToAndCallUUPS(newImplementation, data, true);\n  // }\n}\n"
    },
    "src/contracts/test/proxy/UUPSUpgradeableTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"../../proxy/IERC1822.sol\";\nimport \"./ERC1967UpgradeTest.sol\";\nimport \"../../utils/ERC165.sol\";\n\ncontract UUPSUpgradeableTest is IERC1822Proxiable, ERC1967UpgradeTest, ERC165 {\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n  address private immutable __self = address(this);\n\n  modifier onlyProxy() {\n    require(address(this) != __self, \"Function must be called through delegatecall\");\n    require(_getImplementation() == __self, \"Function must be called through active proxy\");\n    _;\n  }\n\n  modifier notDelegated() {\n    require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n    _;\n  }\n\n  function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n    return _IMPLEMENTATION_SLOT;\n  }\n\n  function upgradeTo(address newImplementation) external virtual onlyProxy {\n    _authorizeUpgrade(newImplementation);\n    _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n  }\n\n  function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n    _authorizeUpgrade(newImplementation);\n    _upgradeToAndCallUUPS(newImplementation, data, true);\n  }\n\n  function _authorizeUpgrade(address newImplementation) internal virtual {}\n}\n"
    },
    "src/contracts/test/proxy/ERC1967UpgradeTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n\npragma solidity 0.8.19;\n\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../lib/LAddress.sol\";\nimport \"../../lib/LStorageSlot.sol\";\n\n/**\n * @title ERC1967 Upgrade Test\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nabstract contract ERC1967UpgradeTest {\n  bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n  // invalid\n  bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  event Upgraded(address indexed implementation);\n\n  function _getImplementation() internal view returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    require(LAddress.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      LAddress.functionDelegateCall(newImplementation, data);\n    }\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n      } catch {\n        revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n      }\n      _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Emitted when the admin account has changed.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Returns the current admin.\n   */\n  function _getAdmin() internal view returns (address) {\n    return LStorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 admin slot.\n   */\n  function _setAdmin(address newAdmin) private {\n    require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   *\n   * Emits an {AdminChanged} event.\n   */\n  function _changeAdmin(address newAdmin) internal {\n    emit AdminChanged(_getAdmin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n   * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n   */\n  bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n}\n"
    },
    "src/contracts/token/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"../../utils/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n  /**\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n  /**\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n   */\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n  /**\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n   */\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n  /**\n   * @dev Returns the number of tokens in ``owner``'s account.\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @dev Returns the owner of the `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) external;\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  /**\n   * @dev Transfers `tokenId` token from `from` to `to`.\n   *\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  /**\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n   * The approval is cleared when the token is transferred.\n   *\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n   *\n   * Requirements:\n   *\n   * - The caller must own the token or be an approved operator.\n   * - `tokenId` must exist.\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address to, uint256 tokenId) external;\n\n  /**\n   * @dev Approve or remove `operator` as an operator for the caller.\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n   *\n   * Requirements:\n   *\n   * - The `operator` cannot be the caller.\n   *\n   * Emits an {ApprovalForAll} event.\n   */\n  function setApprovalForAll(address operator, bool _approved) external;\n\n  /**\n   * @dev Returns the account approved for `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function getApproved(uint256 tokenId) external view returns (address operator);\n\n  /**\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n   *\n   * See {setApprovalForAll}\n   */\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "src/contracts/token/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n  /**\n   * @dev Returns the token collection name.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the token collection symbol.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "src/contracts/token/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"../../utils/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n  /**\n   * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n   */\n  event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n  /**\n   * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n   * transfers.\n   */\n  event TransferBatch(\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256[] ids,\n    uint256[] values\n  );\n\n  /**\n   * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n   * `approved`.\n   */\n  event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n  /**\n   * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n   *\n   * If an {URI} event was emitted for `id`, the standard\n   * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n   * returned by {IERC1155MetadataURI-uri}.\n   */\n  event URI(string value, uint256 indexed id);\n\n  /**\n   * @dev Returns the amount of tokens of token type `id` owned by `account`.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   */\n  function balanceOf(address account, uint256 id) external view returns (uint256);\n\n  /**\n   * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n   *\n   * Requirements:\n   *\n   * - `accounts` and `ids` must have the same length.\n   */\n  function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n  /**\n   * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n   *\n   * Emits an {ApprovalForAll} event.\n   *\n   * Requirements:\n   *\n   * - `operator` cannot be the caller.\n   */\n  function setApprovalForAll(address operator, bool approved) external;\n\n  /**\n   * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n   *\n   * See {setApprovalForAll}.\n   */\n  function isApprovedForAll(address account, address operator) external view returns (bool);\n\n  /**\n   * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n   *\n   * Emits a {TransferSingle} event.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n   * - `from` must have a balance of tokens of type `id` of at least `amount`.\n   * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n   * acceptance magic value.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  /**\n   * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n   *\n   * Emits a {TransferBatch} event.\n   *\n   * Requirements:\n   *\n   * - `ids` and `amounts` must have the same length.\n   * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n   * acceptance magic value.\n   */\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "src/contracts/test/acl/LACLManagerTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IDomainManagementTest.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../acl/IACLCommons.sol\";\nimport \"../../acl/IACLGenerals.sol\";\nimport \"../../acl/IACLManager.sol\";\nimport \"../../acl/ACLStorage.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../utils/IERC165.sol\";\nimport \"../../acl/IACL.sol\";\nimport \"../../acl/scope/IContextManagement.sol\";\nimport \"../../acl/scope/IFunctionManagement.sol\";\nimport \"../../acl/scope/IRealmManagement.sol\";\nimport \"../../acl/scope/IUniverseManagement.sol\";\nimport \"../../acl/agent/IMemberManagement.sol\";\nimport \"../../acl/agent/IRoleManagement.sol\";\nimport \"../../acl/agent/ITypeManagement.sol\";\nimport \"../../acl/policy/IPolicyManagement.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title ACL Manager Library\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nlibrary LACLManagerTest {\n  // using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  string public constant LIB_NAME = \"LACLManager\";\n  string public constant LIB_VERSION = \"3.0.1\";\n\n  function registerProxyFacet(ACLStorage.DataCollection storage data, address implementation) external {\n    data.facetSet.add(address(this));\n    IACLCommons.FacetEntity storage facetEntity = data.facets[address(this)];\n    facetEntity.subjectId = implementation;\n    // facetEntity.interfaceId = type(IACLManager).interfaceId;\n    data.selectors[IProxy.upgradeTo.selector] = address(this);\n    data.selectors[IProxy.setSafeModeStatus.selector] = address(this);\n    data.selectors[IProxy.setUpdatabilityStatus.selector] = address(this);\n    data.selectors[IProxy.setLocalAdmin.selector] = address(this);\n    data.selectors[IProxy.setAccessControlManager.selector] = address(this);\n    data.selectors[IProxy.contractName.selector] = address(this);\n    data.selectors[IProxy.contractVersion.selector] = address(this);\n    data.selectors[IProxy.accessControlManager.selector] = address(this);\n    data.selectors[IProxy.subjectAddress.selector] = address(this);\n    data.selectors[IProxy.safeModeStatus.selector] = address(this);\n    data.selectors[IProxy.updatabilityStatus.selector] = address(this);\n    data.selectors[IProxy.localAdmin.selector] = address(this);\n    data.selectors[IProxy.domainSeparator.selector] = address(this);\n    data.selectors[IProxy.initVersion.selector] = address(this);\n    data.selectors[IProxy.withdrawBalance.selector] = address(this);\n    data.selectors[IERC165.supportsInterface.selector] = address(this);\n    data.selectors[IACLManager.aclRegisterFacet.selector] = address(this);\n    data.selectors[IACLManager.aclUpgradeFacet.selector] = address(this);\n    data.selectors[IACLManager.aclGetFacets.selector] = address(this);\n    data.selectors[IERC1822Proxiable.proxiableUUID.selector] = address(this);\n    data.selectors[bytes4(keccak256(\"initialize(string,string)\"))] = address(this);\n    data.selectors[bytes4(keccak256(\"initACL(address,address,address,address)\"))] = address(this);\n    data.selectors[bytes4(keccak256(\"getFirstInit()\"))] = address(this);\n    data.selectors[bytes4(keccak256(\"getLibrary()\"))] = address(this);\n  }\n\n  function aclRegisterFacet(ACLStorage.DataCollection storage data, IACLManager.FacetRegisterRequest calldata request)\n    external\n    returns (bool)\n  {\n    // require(\n    //   request.interfaceId != type(IACL).interfaceId ||\n    //   request.interfaceId != type(IACLGenerals).interfaceId ||\n    //   request.interfaceId != type(IACLManager).interfaceId ||\n    //   request.interfaceId != type(IPolicyManagement).interfaceId ||\n    //   request.interfaceId != type(IFunctionManagement).interfaceId ||\n    //   request.interfaceId != type(IContextManagement).interfaceId ||\n    //   request.interfaceId != type(IRealmManagement).interfaceId ||\n    //   request.interfaceId != type(IDomainManagementTest).interfaceId ||\n    //   request.interfaceId != type(IUniverseManagement).interfaceId ||\n    //   request.interfaceId != type(IMemberManagement).interfaceId ||\n    //   request.interfaceId != type(IRoleManagement).interfaceId ||\n    //   request.interfaceId != type(ITypeManagement).interfaceId,\n    //   \"Illegal InterfaceId\"\n    // );\n\n    require(!data.facetSet.contains(request.facetId), \"Facet Already Exist\");\n    // require(IERC165(request.facetId).supportsInterface(request.interfaceId), \"Illegal Interface\");\n    for (uint256 j = 0; j < request.selectors.length; j++) {\n      require(data.selectors[request.selectors[j]] == address(0), \"Illegal Selector\");\n      data.selectors[request.selectors[j]] = request.facetId;\n    }\n    data.facetSet.add(request.facetId);\n    IACLCommons.FacetEntity storage facetEntity = data.facets[request.facetId];\n    facetEntity.subjectId = request.subjectId;\n    // facetEntity.interfaceId = request.interfaceId;\n\n    return true;\n  }\n}\n"
    },
    "src/contracts/test/acl/IDomainManagementTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\n/**\n * @title Domain Management Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\n\nimport \"../../acl/IACLCommons.sol\";\n\ninterface IDomainManagementTest is IACLCommons {\n  struct DomainRegisterRequest {\n    bytes32 adminId;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  struct DomainUpdateRealmLimitRequest {\n    bytes32 domainId;\n    uint16 realmLimit;\n  }\n\n  struct DomainInfo {\n    bytes32 adminId;\n    uint16 realmLimit;\n    uint16 realmCount;\n    uint32 referredByAgent;\n    ScopeType stype;\n    AgentType adminType;\n    ActivityStatus acstat;\n    AlterabilityStatus alstat;\n    string name;\n  }\n\n  event DomainRegistered(address indexed sender, bytes32 indexed domainId, bytes32 indexed adminId);\n\n  event DomainAdminUpdated(address indexed sender, bytes32 indexed domainId, bytes32 indexed adminId);\n\n  event DomainRealmLimitUpdated(address indexed sender, bytes32 indexed domainId, uint32 realmLimit);\n\n  event DomainActivityUpdated(address indexed sender, bytes32 indexed domainId, ActivityStatus acstat);\n\n  event DomainAlterabilityUpdated(address indexed sender, bytes32 indexed domainId, AlterabilityStatus alstat);\n\n  event DomainAgentLimitUpdated(address indexed sender, bytes32 indexed domainId, uint32 agentLimit);\n\n  function domainRegister2(DomainRegisterRequest[] calldata requests) external returns (bool);\n\n  function domainUpdateActivityStatus(UpdateActivityRequest[] calldata requests) external returns (bool);\n\n  function domainUpdateAlterabilityStatus(UpdateAlterabilityRequest[] calldata requests) external returns (bool);\n\n  function domainUpdateAdmin(UpdateAdminRequest[] calldata requests) external returns (bool);\n\n  function domainUpdateRealmLimit(DomainUpdateRealmLimitRequest[] calldata requests) external returns (bool);\n\n  function domainCheckId(bytes32 domainId) external view returns (bool);\n\n  function domainCheckName(string calldata domainName) external view returns (bool);\n\n  function domainCheckAdmin(bytes32 domainId, address account) external view returns (bool);\n\n  function domainHasFunction(bytes32 domainId, bytes32 functionId) external view returns (bool);\n\n  function domainHasContext(bytes32 domainId, bytes32 contextId) external view returns (bool);\n\n  function domainHasRealm(bytes32 domainId, bytes32 realmId) external view returns (bool);\n\n  function domainGetRealms(bytes32 domainId) external view returns (bytes32[] memory);\n\n  function domainGetInfo(bytes32 domainId) external view returns (DomainInfo memory);\n}\n"
    },
    "src/contracts/test/proxy/ERC1967ProxyTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n\npragma solidity 0.8.19;\n\nimport \"../../proxy/BaseProxy.sol\";\nimport \"./ERC1967UpgradeTest.sol\";\n\n/**\n * @title ERC1967 Proxy Test\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ERC1967ProxyTest is BaseProxy, ERC1967UpgradeTest {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    _upgradeToAndCall(_logic, _data, false);\n  }\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _implementation() internal view virtual override returns (address impl) {\n    return ERC1967UpgradeTest._getImplementation();\n  }\n}\n"
    },
    "src/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IBaseProxy.sol\";\nimport \"./BaseProxy.sol\";\nimport \"./IERC1822.sol\";\nimport \"./IProxy.sol\";\nimport \"./BaseUUPSStorage.sol\";\nimport \"../lib/LAddress.sol\";\nimport \"../lib/LStorageSlot.sol\";\nimport \"../utils/IERC165.sol\";\n\n/**\n * @title Proxy Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract Proxy is BaseUUPSStorage, BaseProxy {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address logic, bytes memory data) payable {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = msg.sender;\n    _sstat = ProxySafeModeStatus.ENABLED;\n    _ustat = ProxyUpdatabilityStatus.DISABLED;\n    _upgradeToAndCallUUPS(logic, data, false);\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view override returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) private {\n    _setImplementation(newImplementation);\n    emit ProxyUpgraded(msg.sender, address(this), _implementation());\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) private returns (bytes memory) {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      return LAddress.functionDelegateCall(newImplementation, data);\n    }\n    return new bytes(0);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) private returns (bytes memory) {\n    require(LAddress.isContract(newImplementation), \"Illegal Contract\");\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n      return new bytes(0);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"Invalid UUPS\");\n      } catch {\n        revert(\"Illegal UUPS\");\n      }\n\n      try IERC165(newImplementation).supportsInterface(type(IProxy).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid IProxy\");\n      } catch {\n        revert(\"Illegal IProxy\");\n      }\n      return _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n}\n"
    },
    "src/contracts/utils/MulticallUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"../lib/LAddress.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n */\nabstract contract Multicall {\n  /**\n   * @dev Receives and executes a batch of function calls on this contract.\n   */\n  function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i < data.length; i++) {\n      results[i] = _functionDelegateCall(address(this), data[i]);\n    }\n    return results;\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   */\n  function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n    require(LAddress.isContract(target), \"Address: delegate call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return LAddress.verifyCallResult(success, returndata, \"Address: Call Failed\");\n  }\n}\n"
    },
    "src/contracts/test/acl/ACLManagerTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IDomainManagementTest.sol\";\nimport \"../../acl/IACL.sol\";\nimport \"../../acl/ACLStorage.sol\";\nimport \"../../acl/IACLManager.sol\";\nimport \"../../acl/scope/IContextManagement.sol\";\nimport \"../../acl/scope/IFunctionManagement.sol\";\nimport \"../../acl/scope/IRealmManagement.sol\";\nimport \"../../acl/scope/IUniverseManagement.sol\";\nimport \"../../acl/agent/IMemberManagement.sol\";\nimport \"../../acl/agent/IRoleManagement.sol\";\nimport \"../../acl/agent/ITypeManagement.sol\";\nimport \"../../acl/policy/IPolicyManagement.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../test/acl/LACLManagerTest.sol\";\nimport \"../../proxy/Initializable.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Access Control Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ACLManagerTest is ACLStorage, BaseUUPSProxy, IACLManager {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function reInitialize(string calldata contractVersion) public onlyProxy onlyLocalAdmin reinitializer(2) {\n    _contractVersion = contractVersion;\n  }\n\n  function getFirstInit() public view returns (bool) {\n    return _firstInit;\n  }\n\n  function aclGetFacet(bytes4 selector) external view returns (address) {\n    return _data.selectors[selector];\n  }\n\n  function aclHasSelector(bytes4 selector) external view returns (bool) {\n    return _data.selectors[selector] != address(0);\n  }\n\n  function aclGetFacetInfo(address facetId) external view returns (FacetInfo memory) {\n    FacetEntity storage facetEntity = _data.facets[facetId];\n    return\n      FacetInfo({\n        subjectId: facetEntity.subjectId\n        // interfaceId: facetEntity.interfaceId\n      });\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n    return\n      interfaceId == type(IACL).interfaceId ||\n      interfaceId == type(IACLGenerals).interfaceId ||\n      interfaceId == type(IACLManager).interfaceId ||\n      interfaceId == type(IPolicyManagement).interfaceId ||\n      interfaceId == type(IFunctionManagement).interfaceId ||\n      interfaceId == type(IContextManagement).interfaceId ||\n      interfaceId == type(IRealmManagement).interfaceId ||\n      interfaceId == type(IDomainManagementTest).interfaceId ||\n      interfaceId == type(IUniverseManagement).interfaceId ||\n      interfaceId == type(IMemberManagement).interfaceId ||\n      interfaceId == type(IRoleManagement).interfaceId ||\n      interfaceId == type(ITypeManagement).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function aclRegisterFacet(FacetRegisterRequest[] calldata requests) external onlyProxy returns (bool) {\n    if (_firstInit) {\n      require(_getLocalAdmin() == _msgSender(), \"Forbidden\");\n      return _doAclRegisterFacet(requests);\n    } else {\n      require(_hasPermission(this.aclRegisterFacet.selector) == IACL.AuthorizationStatus.PERMITTED, \"Access Denied\");\n      return _doAclRegisterFacet(requests);\n    }\n  }\n\n  function _doAclRegisterFacet(FacetRegisterRequest[] calldata requests) internal returns (bool) {\n    for (uint256 i = 0; i < requests.length; i++) {\n      LACLManagerTest.aclRegisterFacet(_data, requests[i]);\n      emit ACLFacetRegistered(\n        _msgSender(),\n        requests[i].facetId,\n        requests[i].subjectId\n        // requests[i].interfaceId\n      );\n    }\n    if (_data.facetSet.length() >= 11) _firstInit = false;\n    return true;\n  }\n\n  function aclUpgradeFacet(FacetUpgradeRequest[] calldata requests)\n    external\n    onlyProxy\n    aclCheck(this.aclUpgradeFacet.selector)\n    returns (bool)\n  {\n    for (uint256 i = 0; i < requests.length; i++) {\n      require(_data.facetSet.contains(requests[i].facetId), \"Facet Not Found\");\n\n      FacetEntity storage facetEntity = _data.facets[requests[i].facetId];\n      require(requests[i].subjectId != address(0) && facetEntity.subjectId != requests[i].subjectId, \"Illegal Upgrade\");\n\n      facetEntity.subjectId = requests[i].subjectId;\n      // if(requests[i].interfaceId != bytes4(0) && facetEntity.interfaceId != requests[i].interfaceId) {\n      //   require(IERC165(requests[i].facetId).supportsInterface(requests[i].interfaceId), \"Illegal Interface\");\n      //   facetEntity.interfaceId = requests[i].interfaceId;\n      // }\n\n      for (uint256 j = 0; j < requests[i].functions.length; j++) {\n        if (requests[i].functions[j].action == ActionType.REMOVE) {\n          for (uint256 z = 0; z < requests[i].functions[j].selectors.length; z++) {\n            require(_data.selectors[requests[i].functions[j].selectors[z]] != address(0), \"Selector Not Found\");\n            delete _data.selectors[requests[i].functions[j].selectors[z]];\n            emit ACLFacetFunctionUpgraded(\n              msg.sender,\n              requests[i].facetId,\n              requests[i].functions[j].selectors[z],\n              ActionType.REMOVE\n            );\n          }\n        } else if (requests[i].functions[j].action == ActionType.ADD) {\n          for (uint256 z = 0; z < requests[i].functions[j].selectors.length; z++) {\n            require(_data.selectors[requests[i].functions[j].selectors[z]] == address(0), \"Illegal Selector\");\n            _data.selectors[requests[i].functions[j].selectors[z]] = requests[i].facetId;\n            emit ACLFacetFunctionUpgraded(\n              msg.sender,\n              requests[i].facetId,\n              requests[i].functions[j].selectors[z],\n              ActionType.ADD\n            );\n          }\n        }\n      }\n      emit ACLFacetUpgraded(_msgSender(), requests[i].facetId, requests[i].subjectId);\n    }\n    return true;\n  }\n\n  function aclGetFacets() public view returns (address[] memory) {\n    return _data.facetSet.values();\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LACLManagerTest);\n  }\n}\n"
    },
    "src/contracts/test/acl/DomainManagerTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IDomainManagementTest.sol\";\nimport \"../../acl/IACL.sol\";\nimport \"../../acl/ACLStorage.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Domain Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract DomainManagerTest is ACLStorage, BaseUUPSProxy, IDomainManagementTest {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function reInitialize(string calldata contractVersion) public onlyProxy onlyLocalAdmin reinitializer(2) {\n    _contractVersion = contractVersion;\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IDomainManagementTest).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  // called by account that member of VERSE SCOPE MASTER TYPE\n  function domainRegister2(DomainRegisterRequest[] calldata requests) external returns (bool) {\n    bytes32 functionId = _accessPermission(IDomainManagementTest.domainRegister2.selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(msg.sender);\n\n    // fetch scope type and scope id of sender\n    bytes32 senderScopeId = _doGetMemberScopeInfoFromType(_LIVELY_VERSE_SCOPE_MASTER_TYPE_ID, senderId);\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      bytes32 newDomainId = LACLUtils.generateId(requests[i].name);\n      require(_data.scopes[newDomainId].stype == ScopeType.NONE, \"Already Exist\");\n      require(\n        requests[i].acstat > ActivityStatus.NONE && requests[i].alstat > AlterabilityStatus.NONE,\n        \"Illegal Activity/Alterability\"\n      );\n\n      // check sender scopes\n      UniverseEntity storage livelyUniverseEntity = _data.universeReadSlot(_LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID);\n      require(senderScopeId == _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Universe Scope\");\n      require(livelyUniverseEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Universe Updatable\");\n      require(livelyUniverseEntity.domainLimit > livelyUniverseEntity.domains.length(), \"Illegal Domain Register\");\n\n      // check access admin universe\n      require(_doCheckAdminAccess(livelyUniverseEntity.bs.adminId, senderId, functionId), \"Forbidden\");\n\n      livelyUniverseEntity.domains.add(newDomainId);\n\n      // create new domain entity\n      DomainEntity storage newDomain = _data.domainWriteSlot(newDomainId);\n      newDomain.bs.stype = ScopeType.DOMAIN;\n      newDomain.bs.acstat = requests[i].acstat;\n      newDomain.bs.alstat = requests[i].alstat;\n      newDomain.name = requests[i].name;\n      newDomain.realmLimit = 10;\n\n      // checking requested domain admin\n      if (requests[i].adminId != bytes32(0)) {\n        require(_data.agents[requests[i].adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n        bytes32 requestAdminScopeId = _doAgentGetScopeInfo(requests[i].adminId);\n        require(requestAdminScopeId == _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Admin Scope\");\n        newDomain.bs.adminId = requests[i].adminId;\n      } else {\n        newDomain.bs.adminId = livelyUniverseEntity.bs.adminId;\n      }\n\n      emit DomainRegistered(msg.sender, newDomainId, requests[i].adminId);\n    }\n\n    return true;\n  }\n\n  function domainUpdateActivityStatus(UpdateActivityRequest[] calldata requests) external returns (bool) {\n    bytes32 functionId = _accessPermission(IDomainManagementTest.domainUpdateActivityStatus.selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(msg.sender);\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = _data.domainReadSlot(requests[i].id);\n      require(domainEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Domain Updatable\");\n      require(_doCheckAdminAccess(domainEntity.bs.adminId, senderId, functionId), \"Forbidden\");\n      require(requests[i].acstat > ActivityStatus.NONE, \"Illegal Activity\");\n      emit DomainActivityUpdated(msg.sender, requests[i].id, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function domainUpdateAlterabilityStatus(UpdateAlterabilityRequest[] calldata requests) external returns (bool) {\n    bytes32 functionId = _accessPermission(IDomainManagementTest.domainUpdateAlterabilityStatus.selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(msg.sender);\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = _data.domainReadSlot(requests[i].id);\n      // require(domainEntity.bs.acstat > ActivityStatus.DISABLED, \"Domain Disabled\");\n      require(_doCheckAdminAccess(domainEntity.bs.adminId, senderId, functionId), \"Forbidden\");\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      domainEntity.bs.alstat = requests[i].alstat;\n      emit DomainAlterabilityUpdated(msg.sender, requests[i].id, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function domainUpdateAdmin(UpdateAdminRequest[] calldata requests) external returns (bool) {\n    bytes32 functionId = _accessPermission(IDomainManagementTest.domainUpdateAdmin.selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(msg.sender);\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = _doGetEntityAndCheckAdminAccess(requests[i].id, senderId, functionId);\n\n      // checking requested domain admin\n      if (requests[i].adminId != bytes32(0)) {\n        require(_data.agents[requests[i].adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n        bytes32 requestAdminScopeId = _doAgentGetScopeInfo(requests[i].adminId);\n        require(requestAdminScopeId == _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Admin Scope\");\n        domainEntity.bs.adminId = requests[i].adminId;\n      } else {\n        domainEntity.bs.adminId = _data.scopes[_LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID].adminId;\n      }\n\n      emit DomainAdminUpdated(msg.sender, requests[i].id, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function domainUpdateRealmLimit(DomainUpdateRealmLimitRequest[] calldata requests) external returns (bool) {\n    bytes32 functionId = _accessPermission(IDomainManagementTest.domainUpdateRealmLimit.selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(msg.sender);\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = _doGetEntityAndCheckAdminAccess(requests[i].domainId, senderId, functionId);\n      domainEntity.realmLimit = requests[i].realmLimit;\n      emit DomainRealmLimitUpdated(msg.sender, requests[i].domainId, requests[i].realmLimit);\n    }\n    return true;\n  }\n\n  function domainCheckId(bytes32 domainId) external view returns (bool) {\n    return _data.scopes[domainId].stype == ScopeType.DOMAIN;\n  }\n\n  function domainCheckName(string calldata domainName) external view returns (bool) {\n    return _data.scopes[LACLUtils.generateId(domainName)].stype == ScopeType.DOMAIN;\n  }\n\n  function domainCheckAdmin(bytes32 domainId, address account) external view returns (bool) {\n    (DomainEntity storage domainEntity, bool result) = _data.domainTryReadSlot(domainId);\n    if (!result) return false;\n\n    bytes32 domainAdminId = domainEntity.bs.adminId;\n    AgentType agentType = _data.agents[domainAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (agentType == AgentType.ROLE) {\n      return _doRoleHasMember(domainAdminId, memberId);\n    } else if (agentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(domainAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function _doRoleHasMember(bytes32 roleId, bytes32 memberId) internal view returns (bool) {\n    (RoleEntity storage roleEntity, bool result) = _data.roleTryReadSlot(roleId);\n    if (!result) return false;\n\n    (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(roleEntity.typeId);\n    if (!result1) return false;\n\n    return typeEntity.members[memberId] != bytes32(0);\n  }\n\n  function domainHasFunction(bytes32 domainId, bytes32 functionId) external view returns (bool) {\n    (FunctionEntity storage fe, bool result) = _data.functionTryReadSlot(functionId);\n    if (!result) return false;\n\n    (ContextEntity storage ce, bool result1) = _data.contextTryReadSlot(fe.contextId);\n    if (!result1) return false;\n\n    (RealmEntity storage re, bool result2) = _data.realmTryReadSlot(ce.realmId);\n    if (!result2) return false;\n\n    return re.domainId == domainId;\n  }\n\n  function domainHasContext(bytes32 domainId, bytes32 contextId) external view returns (bool) {\n    (ContextEntity storage ce, bool result1) = _data.contextTryReadSlot(contextId);\n    if (!result1) return false;\n\n    (RealmEntity storage re, bool result2) = _data.realmTryReadSlot(ce.realmId);\n    if (!result2) return false;\n\n    return re.domainId == domainId;\n  }\n\n  function domainHasRealm(bytes32 domainId, bytes32 realmId) external view returns (bool) {\n    (DomainEntity storage de, bool result) = _data.domainTryReadSlot(domainId);\n    if (!result) return false;\n    return de.realms.contains(realmId);\n  }\n\n  function domainGetRealms(bytes32 domainId) external view returns (bytes32[] memory) {\n    (DomainEntity storage de, bool result) = _data.domainTryReadSlot(domainId);\n    if (!result) return new bytes32[](0);\n    return de.realms.values();\n  }\n\n  function domainGetInfo(bytes32 domainId) external view returns (DomainInfo memory) {\n    (DomainEntity storage de, bool result) = _data.domainTryReadSlot(domainId);\n    if (!result) {\n      return\n        DomainInfo({\n          adminId: bytes32(0),\n          realmLimit: 0,\n          realmCount: 0,\n          referredByAgent: 0,\n          stype: ScopeType.NONE,\n          adminType: AgentType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE,\n          name: \"\"\n        });\n    }\n\n    return\n      DomainInfo({\n        adminId: de.bs.adminId,\n        realmLimit: de.realmLimit,\n        realmCount: uint16(de.realms.length()),\n        referredByAgent: de.bs.referredByAgent,\n        adminType: _data.agents[de.bs.adminId].atype,\n        stype: de.bs.stype,\n        acstat: de.bs.acstat,\n        alstat: de.bs.alstat,\n        name: de.name\n      });\n  }\n\n  function _doCheckAdminAccess(\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) internal view returns (bool) {\n    (FunctionEntity storage functionEntity, bool res) = _data.functionTryReadSlot(functionId);\n    if (!res) return false;\n\n    AgentType adminAgentType = _data.agents[adminId].atype;\n    if (adminAgentType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result) = _data.roleTryReadSlot(adminId);\n      if (!result || roleEntity.ba.acstat != ActivityStatus.ENABLED) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(roleEntity.typeId);\n      if (!result1 || typeEntity.ba.acstat != ActivityStatus.ENABLED) return false;\n\n      if (typeEntity.members[memberId] != adminId) return false;\n\n      PolicyEntity storage policyEntity = _data.policies[_data.rolePolicyMap[adminId]];\n      if (policyEntity.acstat == ActivityStatus.ENABLED && policyEntity.policyCode >= functionEntity.policyCode)\n        return false;\n\n      return true;\n    } else if (adminAgentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(adminId);\n      if (!result1 || typeEntity.ba.acstat != ActivityStatus.ENABLED) return false;\n\n      bytes32 roleId = typeEntity.members[memberId];\n      (RoleEntity storage roleEntity, bool result2) = _data.roleTryReadSlot(roleId);\n      if (!result2 || roleEntity.ba.acstat != ActivityStatus.ENABLED) return false;\n\n      PolicyEntity storage policyEntity = _data.policies[_data.rolePolicyMap[roleId]];\n      if (policyEntity.acstat == ActivityStatus.ENABLED && policyEntity.policyCode >= functionEntity.policyCode)\n        return false;\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function _doAgentGetScopeInfo(bytes32 agentId) internal view returns (bytes32) {\n    AgentType atype = _data.agents[agentId].atype;\n    if (atype == AgentType.ROLE) {\n      RoleEntity storage roleEntity = _data.roleReadSlot(agentId);\n      return roleEntity.scopeId;\n    } else if (atype == AgentType.TYPE) {\n      TypeEntity storage typeEntity = _data.typeReadSlot(agentId);\n      return typeEntity.scopeId;\n    }\n\n    return bytes32(0);\n  }\n\n  function _accessPermission(bytes4 selector) internal returns (bytes32) {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(msg.sender);\n    IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, senderId);\n    if (status != IACL.AuthorizationStatus.PERMITTED) LACLUtils.generateAuthorizationError(status);\n    return functionId;\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    bytes32 domainId,\n    bytes32 senderId,\n    bytes32 functionId\n  ) internal view returns (DomainEntity storage) {\n    DomainEntity storage domainEntity = _data.domainReadSlot(domainId);\n    require(domainEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    require(_doCheckAdminAccess(domainEntity.bs.adminId, senderId, functionId), \"Forbidden\");\n    return domainEntity;\n  }\n\n  function _doGetMemberScopeInfoFromType(bytes32 typeId, bytes32 senderId) internal view returns (bytes32) {\n    TypeEntity storage agentAdminType = _data.typeReadSlot(typeId);\n    bytes32 memberRoleId = agentAdminType.members[senderId];\n    RoleEntity storage memberAgentRole = _data.roleReadSlot(memberRoleId);\n    return memberAgentRole.scopeId;\n  }\n}\n"
    },
    "src/contracts/acl/ACLProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../proxy/IBaseProxy.sol\";\nimport \"../proxy/BaseProxy.sol\";\nimport \"../proxy/IERC1822.sol\";\nimport \"../proxy/IProxy.sol\";\nimport \"../lib/LAddress.sol\";\nimport \"../lib/LStorageSlot.sol\";\nimport \"../utils/IERC165.sol\";\nimport \"./ACLStorage.sol\";\n\n/**\n * @title Proxy Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ACLProxy is ACLStorage, BaseProxy {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address logic, bytes memory data) payable {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = msg.sender;\n    _sstat = ProxySafeModeStatus.ENABLED;\n    _ustat = ProxyUpdatabilityStatus.DISABLED;\n    _upgradeToAndCallUUPS(logic, data, false);\n  }\n\n  function _fallback() internal override {\n    address facetId = _data.selectors[msg.sig];\n    address subjectId = _data.facets[facetId].subjectId;\n    if (facetId == address(0)) {\n      _delegate(_implementation());\n    } else {\n      _delegate(subjectId);\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view override returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) private {\n    _setImplementation(newImplementation);\n    emit ProxyUpgraded(msg.sender, address(this), _implementation());\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) private returns (bytes memory) {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      return LAddress.functionDelegateCall(newImplementation, data);\n    }\n    return new bytes(0);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) private returns (bytes memory) {\n    require(LAddress.isContract(newImplementation), \"Illegal Contract\");\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n      return new bytes(0);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"Invalid UUPS\");\n      } catch {\n        revert(\"Illegal UUPS\");\n      }\n\n      try IERC165(newImplementation).supportsInterface(type(IProxy).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid IProxy\");\n      } catch {\n        revert(\"Illegal IProxy\");\n      }\n      return _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n}\n"
    },
    "src/contracts/lib/acl/LProfileRolePolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./LACLUtils.sol\";\nimport \"./LProfileStorage.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../../acl/IACLCommons.sol\";\nimport \"../../acl/profile/IProfileACLGenerals.sol\";\nimport \"../../acl/profile/IProfileManagement.sol\";\nimport \"../../acl/ACLStorage.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../utils/IERC165.sol\";\nimport \"../../acl/profile/IProfileACL.sol\";\nimport \"../../acl/profile/agent/IProfileRoleManagement.sol\";\nimport \"../../acl/profile/policy/IProfilePolicyManagement.sol\";\n\n/**\n * @title Profile Commons Library\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nlibrary LProfileRolePolicy {\n  using LProfileStorage for IACLCommons.ProfileEntity;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  string public constant LIB_NAME = \"LProfileRolePolicy\";\n  string public constant LIB_VERSION = \"3.0.0\";\n\n  bytes32 public constant LIVELY_VERSE_ANONYMOUS_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_ANONYMOUS\"));\n  bytes32 public constant LIVELY_VERSE_ANY_TYPE_ID = keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_ANY\"));\n\n  bytes32 public constant LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_PROFILE.LIVELY_MASTER\"));\n  bytes32 public constant LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_PROFILE.LIVELY_SYSTEM_MASTER\"));\n  bytes32 public constant LIVELY_PROFILE_ANY_TYPE_ID = keccak256(abi.encodePacked(\"TYPE.LIVELY_PROFILE.LIVELY_ANY\"));\n  bytes32 public constant LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID =\n    keccak256(abi.encodePacked(\"UNIVERSE.LIVELY_PROFILE\"));\n  bytes32 public constant LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_PROFILE.LIVELY_MASTER_ADMIN\"));\n  bytes32 public constant LIVELY_PROFILE_SYSTEM_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_PROFILE.LIVELY_SYSTEM_MASTER_ADMIN\"));\n\n  function profileCheckAdminAccess(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) external view returns (IProfileACL.ProfileAdminAccessStatus) {\n    return _doProfileCheckAdminAccess(profileEntity, functionEntity, adminId, senderId);\n  }\n\n  function profileAgentGetScopeInfo(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    external\n    view\n    returns (IACLCommons.ScopeType, bytes32)\n  {\n    return _doAgentGetScopeInfo(profileEntity, agentId);\n  }\n\n  function profileCheckMemberForRoleRegister(\n    IACLCommons.ProfileEntity storage profileEntity,\n    uint16 requestLength,\n    bytes32 senderId\n  ) external {\n    IACLCommons.ProfileMemberEntity storage profileMemberEntity = profileEntity.profileMemberReadSlot(senderId);\n    require(profileMemberEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Member Updatable\");\n    require(profileEntity.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Profile Updatable\");\n    unchecked {\n      require(\n        int32(profileMemberEntity.registerLimits.roleRegisterLimit) - int16(requestLength) >= 0,\n        \"Illegal Member RoleRegisterLimit\"\n      );\n      require(\n        int32(profileEntity.registerLimits.roleRegisterLimit) - int16(requestLength) >= 0,\n        \"Illegal Profile RoleRegisterLimit\"\n      );\n      profileMemberEntity.registerLimits.roleRegisterLimit -= requestLength;\n      profileEntity.registerLimits.roleRegisterLimit -= requestLength;\n    }\n  }\n\n  function profileCheckMemberForPolicyRegister(\n    IACLCommons.ProfileEntity storage profileEntity,\n    uint16 requestLength,\n    bytes32 senderId\n  ) external {\n    // check profile and type limitations and update it\n    IACLCommons.ProfileMemberEntity storage profileMemberEntity = profileEntity.profileMemberReadSlot(senderId);\n    require(profileMemberEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Member Updatable\");\n    require(profileEntity.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Profile Updatable\");\n    unchecked {\n      require(\n        int32(uint32(profileMemberEntity.registerLimits.policyRegisterLimit)) - int16(requestLength) >= 0,\n        \"Illegal Member PolicyRegisterLimit\"\n      );\n      require(\n        int32(uint32(profileEntity.registerLimits.policyRegisterLimit)) - int16(requestLength) >= 0,\n        \"Illegal Profile PolicyRegisterLimit\"\n      );\n      profileMemberEntity.registerLimits.policyRegisterLimit -= requestLength;\n      profileEntity.registerLimits.policyRegisterLimit -= requestLength;\n    }\n  }\n\n  function profileRoleRegister(\n    IProfileRoleManagement.ProfileRoleRegisterRequest calldata request,\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 profileId,\n    bytes32 senderId\n  ) external returns (bytes32, bytes32) {\n    bytes32 newRoleId = LACLUtils.generateId(request.name);\n    require(profileEntity.agents[newRoleId].atype == IACLCommons.AgentType.NONE, \"Already Exist\");\n    require(\n      request.typeId != LIVELY_VERSE_ANONYMOUS_TYPE_ID && request.typeId != LIVELY_PROFILE_ANY_TYPE_ID,\n      \"Illegal Type\"\n    );\n\n    // check type\n    IACLCommons.TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(request.typeId);\n    require(typeEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Type Updatable\");\n    require(typeEntity.roles.length() < typeEntity.roleLimit, \"Illegal Register\");\n\n    {\n      // check access\n      IProfileACL.ProfileAdminAccessStatus status = _doProfileCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        typeEntity.ba.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    }\n\n    // check and get requested scope type\n    IACLCommons.ScopeType requestScopeType = _doProfileRoleCheckRequestScope(\n      profileEntity,\n      request.scopeId,\n      typeEntity.scopeId,\n      profileId\n    );\n\n    // add role to type\n    typeEntity.roles.add(newRoleId);\n\n    // create role entity\n    IACLCommons.RoleEntity storage newRole = profileEntity.profileRoleWriteSlot(newRoleId);\n    newRole.ba.atype = IACLCommons.AgentType.ROLE;\n    newRole.ba.acstat = IACLCommons.ActivityStatus.ENABLED;\n    newRole.ba.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    newRole.name = request.name;\n    newRole.scopeId = request.scopeId;\n    newRole.memberLimit = request.memberLimit >= 0\n      ? uint24(uint32(request.memberLimit))\n      : profileEntity.limits.memberLimit;\n    newRole.typeId = request.typeId;\n    newRole.ba.adminId = _doProfileGetRoleAdmin(\n      profileEntity,\n      requestScopeType,\n      typeEntity.ba.adminId,\n      request.scopeId,\n      request.adminId,\n      profileId\n    );\n\n    return (newRoleId, newRole.ba.adminId);\n  }\n\n  function profilePolicyRegister(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IProfilePolicyManagement.ProfilePolicyRegisterRequest calldata request,\n    bytes32 profileId,\n    IACLCommons.ScopeType senderScopeType,\n    bytes32 senderScopeId\n  ) external returns (bytes32) {\n    bytes32 newPolicyId = LACLUtils.generateId(request.name);\n    require(profileEntity.policies[newPolicyId].acstat == IACLCommons.ActivityStatus.NONE, \"Already Exist\");\n\n    // // checking requested type scope\n    IACLCommons.BaseScope storage requestedScope = _doProfilePolicyCheckRequestScope(\n      profileEntity,\n      request.scopeId,\n      senderScopeId,\n      senderScopeType,\n      profileId\n    );\n\n    // create policy entity\n    IACLCommons.PolicyEntity storage policyEntity = profileEntity.policies[newPolicyId];\n    policyEntity.ptype = _doProfileGetPolicyType(request.policyCode);\n    policyEntity.policyCode = request.policyCode;\n    policyEntity.acstat = IACLCommons.ActivityStatus.ENABLED;\n    policyEntity.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    policyEntity.name = request.name;\n    policyEntity.scopeId = request.scopeId;\n    policyEntity.roleLimit = request.roleLimit >= 0\n      ? uint16(uint24(request.roleLimit))\n      : profileEntity.limits.policyRoleLimit;\n    policyEntity.adminId = _doProfileGetPolicyAdmin(\n      profileEntity,\n      requestedScope.stype,\n      requestedScope.adminId,\n      request.scopeId,\n      request.adminId,\n      profileId\n    );\n    return newPolicyId;\n  }\n\n  function profileGetPolicyAdmin(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId,\n    bytes32 profileId\n  ) external view returns (bytes32 policyAdminId) {\n    return _doProfileGetPolicyAdmin(profileEntity, requestScopeType, requestScopeAdmin, scopeId, adminId, profileId);\n  }\n\n  function profilePolicyUpdateScope(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IProfilePolicyManagement.ProfileUpdateScopeRequest calldata request,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 profileId,\n    bytes32 senderId\n  ) external {\n    IACLCommons.ScopeType senderScopeType;\n    bytes32 senderScopeId;\n    IACLCommons.PolicyEntity storage policyEntity = _doProfileGetPolicyAndCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      request.entityId,\n      senderId\n    );\n\n    IACLCommons.AgentType adminAgentType = profileEntity.agents[policyEntity.adminId].atype;\n    if (adminAgentType == IACLCommons.AgentType.ROLE) {\n      IACLCommons.RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(policyEntity.adminId);\n      senderScopeId = roleEntity.scopeId;\n      senderScopeType = profileEntity.scopes[roleEntity.scopeId].stype;\n    } else {\n      IACLCommons.TypeEntity storage agentType = profileEntity.profileTypeReadSlot(policyEntity.adminId);\n      bytes32 memberRoleId = agentType.members[senderId];\n      IACLCommons.RoleEntity storage memberAgentRole = profileEntity.profileRoleReadSlot(memberRoleId);\n      senderScopeType = profileEntity.scopes[memberAgentRole.scopeId].stype;\n      senderScopeId = memberAgentRole.scopeId;\n    }\n\n    IACLCommons.BaseScope storage requestScope = _doProfilePolicyCheckRequestScope(\n      profileEntity,\n      request.scopeId,\n      senderScopeId,\n      senderScopeType,\n      profileId\n    );\n    IACLCommons.BaseScope storage currentScope = profileEntity.scopes[policyEntity.scopeId];\n    if (policyEntity.roles.length() > 0) {\n      require(requestScope.stype > currentScope.stype, \"Illegal ScopeType\");\n      require(\n        IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, request.scopeId, policyEntity.scopeId),\n        \"Illegal Scope\"\n      );\n    }\n\n    require(currentScope.referredByAgent > 0, \"Illeagl Referred\");\n    unchecked {\n      currentScope.referredByAgent -= 1;\n    }\n\n    policyEntity.scopeId = request.scopeId;\n  }\n\n  function profilePolicyAddRoles(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.PolicyEntity storage policyEntity,\n    bytes32 profileId,\n    bytes32 policyId,\n    bytes32 roleId,\n    IACLCommons.ScopeType policyScopeType\n  ) external {\n    require(profileEntity.rolePolicyMap[roleId] == bytes32(0), \"Already Exist\");\n    require(policyEntity.adminId != roleId, \"Illegal Role\");\n    require(policyEntity.roleLimit > policyEntity.roles.length(), \"Illegal Limit\");\n    IACLCommons.RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(roleId);\n\n    IACLCommons.ScopeType roleScopeType = profileEntity.scopes[roleEntity.scopeId].stype;\n    require(roleScopeType <= policyScopeType, \"Illegal Role ScopeType\");\n    if (roleScopeType == policyScopeType) {\n      require(roleEntity.scopeId == policyEntity.scopeId, \"Illegal Role Scope\");\n    } else {\n      require(\n        IProfileACLGenerals(address(this)).profileIsScopesCompatible(\n          profileId,\n          policyEntity.scopeId,\n          roleEntity.scopeId\n        ),\n        \"Illegal Role Scope\"\n      );\n    }\n\n    profileEntity.rolePolicyMap[roleId] = policyId;\n    policyEntity.roles.add(roleId);\n  }\n\n  function profilePolicyCheckAdmin(\n    ACLStorage.DataCollection storage data,\n    bytes32 profileId,\n    bytes32 policyId,\n    address account\n  ) external view returns (bool) {\n    IACLCommons.ProfileEntity storage profileEntity = data.profiles[profileId];\n    if (profileEntity.acstat == IACLCommons.ActivityStatus.NONE) return false;\n\n    IACLCommons.PolicyEntity storage policyEntity = profileEntity.policies[policyId];\n    if (policyEntity.adminId == bytes32(0)) return false;\n\n    bytes32 policyAdminId = policyEntity.adminId;\n    IACLCommons.AgentType agentType = profileEntity.agents[policyAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (agentType == IACLCommons.AgentType.ROLE) {\n      (IACLCommons.RoleEntity storage roleEntity, bool result) = profileEntity.profileRoleTryReadSlot(policyAdminId);\n      if (!result) return false;\n\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(\n        roleEntity.typeId\n      );\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == policyAdminId;\n    } else if (agentType == IACLCommons.AgentType.TYPE) {\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(policyAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n    return true;\n  }\n\n  function profilePolicyGetInfo(\n    ACLStorage.DataCollection storage data,\n    bytes32 profileId,\n    bytes32 policyId\n  ) external view returns (IProfilePolicyManagement.ProfilePolicyInfo memory) {\n    IACLCommons.ProfileEntity storage profileEntity = data.profiles[profileId];\n    if (\n      profileEntity.policies[policyId].acstat == IACLCommons.ActivityStatus.NONE ||\n      profileEntity.acstat == IACLCommons.ActivityStatus.NONE\n    ) {\n      return\n        IProfilePolicyManagement.ProfilePolicyInfo({\n          adminId: bytes32(0),\n          scopeId: bytes32(0),\n          name: \"\",\n          roleLimit: 0,\n          roleCount: 0,\n          policyCode: 0,\n          adminType: IACLCommons.AgentType.NONE,\n          scopeType: IACLCommons.ScopeType.NONE,\n          ptype: IACLCommons.PolicyType.UNLOCK,\n          acstat: IACLCommons.ActivityStatus.NONE,\n          alstat: IACLCommons.AlterabilityStatus.NONE\n        });\n    }\n\n    return\n      IProfilePolicyManagement.ProfilePolicyInfo({\n        adminId: profileEntity.policies[policyId].adminId,\n        scopeId: profileEntity.policies[policyId].scopeId,\n        name: profileEntity.policies[policyId].name,\n        roleLimit: profileEntity.policies[policyId].roleLimit,\n        roleCount: uint16(profileEntity.policies[policyId].roles.length()),\n        policyCode: profileEntity.policies[policyId].policyCode,\n        adminType: profileEntity.agents[profileEntity.policies[policyId].adminId].atype,\n        scopeType: profileEntity.scopes[profileEntity.policies[policyId].scopeId].stype,\n        ptype: profileEntity.policies[policyId].ptype,\n        acstat: profileEntity.policies[policyId].acstat,\n        alstat: profileEntity.policies[policyId].alstat\n      });\n  }\n\n  function profilePolicyUpdateAlterabilityStatus(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IProfilePolicyManagement.ProfileUpdateAlterabilityRequest calldata request,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 senderId\n  ) external {\n    IACLCommons.PolicyEntity storage policyEntity = profileEntity.policies[request.entityId];\n    require(policyEntity.adminId != bytes32(0), \"Not Found\");\n    IProfileACL.ProfileAdminAccessStatus status = _doProfileCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      policyEntity.adminId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    require(request.alstat != IACLCommons.AlterabilityStatus.NONE, \"Illegal Alterability\");\n    policyEntity.alstat = request.alstat;\n  }\n\n  function profileGetPolicyType(uint8 policyCode) external pure returns (IACLCommons.PolicyType) {\n    return _doProfileGetPolicyType(policyCode);\n  }\n\n  function profileRoleGetInfo(\n    ACLStorage.DataCollection storage data,\n    bytes32 profileId,\n    bytes32 roleId\n  ) external view returns (IProfileRoleManagement.ProfileRoleInfo memory) {\n    IACLCommons.ProfileEntity storage profileEntity = data.profiles[profileId];\n    (IACLCommons.RoleEntity storage roleEntity, bool result) = profileEntity.profileRoleTryReadSlot(roleId);\n    if (!result || profileEntity.acstat == IACLCommons.ActivityStatus.NONE) {\n      return\n        IProfileRoleManagement.ProfileRoleInfo({\n          scopeId: bytes32(0),\n          typeId: bytes32(0),\n          adminId: bytes32(0),\n          memberLimit: 0,\n          memberCount: 0,\n          adminType: IACLCommons.AgentType.NONE,\n          atype: IACLCommons.AgentType.NONE,\n          acstat: IACLCommons.ActivityStatus.NONE,\n          alstat: IACLCommons.AlterabilityStatus.NONE,\n          name: \"\"\n        });\n    }\n    return\n      IProfileRoleManagement.ProfileRoleInfo({\n        scopeId: roleEntity.scopeId,\n        typeId: roleEntity.typeId,\n        adminId: roleEntity.ba.adminId,\n        memberLimit: roleEntity.memberLimit,\n        memberCount: roleEntity.memberCount,\n        adminType: profileEntity.agents[roleEntity.ba.adminId].atype,\n        atype: roleEntity.ba.atype,\n        acstat: roleEntity.ba.acstat,\n        alstat: roleEntity.ba.alstat,\n        name: roleEntity.name\n      });\n  }\n\n  function profileRoleHasAccount(\n    ACLStorage.DataCollection storage data,\n    bytes32 profileId,\n    bytes32 roleId,\n    address account\n  ) external view returns (bool) {\n    IACLCommons.ProfileEntity storage profileEntity = data.profiles[profileId];\n    if (profileEntity.acstat == IACLCommons.ActivityStatus.NONE) return false;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    (IACLCommons.RoleEntity storage roleEntity, bool result) = profileEntity.profileRoleTryReadSlot(roleId);\n    if (!result) return false;\n\n    (IACLCommons.TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(roleEntity.typeId);\n    if (!result1) return false;\n\n    return typeEntity.members[memberId] != bytes32(0);\n  }\n\n  function profileRoleCheckAdmin(\n    ACLStorage.DataCollection storage data,\n    bytes32 profileId,\n    bytes32 roleId,\n    address account\n  ) external view returns (bool) {\n    IACLCommons.ProfileEntity storage profileEntity = data.profiles[profileId];\n    if (profileEntity.acstat == IACLCommons.ActivityStatus.NONE) return false;\n    if (profileEntity.agents[roleId].atype != IACLCommons.AgentType.ROLE) return false;\n\n    bytes32 roleAdminId = profileEntity.agents[roleId].adminId;\n    IACLCommons.AgentType adminAgenType = profileEntity.agents[roleAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (adminAgenType == IACLCommons.AgentType.ROLE) {\n      (IACLCommons.RoleEntity storage roleEntity, bool result) = profileEntity.profileRoleTryReadSlot(roleAdminId);\n      if (!result) return false;\n\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(\n        roleEntity.typeId\n      );\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == roleAdminId;\n    } else if (adminAgenType == IACLCommons.AgentType.TYPE) {\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(roleAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function profileRoleUpdateScope(\n    IProfileRoleManagement.ProfileUpdateScopeRequest calldata request,\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 profileId,\n    bytes32 senderId\n  ) external returns (bool) {\n    IACLCommons.RoleEntity storage roleEntity = _doProfileGetRoleEntityAndCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      request.entityId,\n      senderId\n    );\n    IACLCommons.TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(roleEntity.typeId);\n    _doProfileRoleCheckRequestScope(profileEntity, request.scopeId, typeEntity.scopeId, profileId);\n    IACLCommons.BaseScope storage oldScope = profileEntity.scopes[roleEntity.scopeId];\n    require(oldScope.referredByAgent > 0, \"Illeagl Referred\");\n    unchecked {\n      oldScope.referredByAgent -= 1;\n    }\n    roleEntity.scopeId = request.scopeId;\n\n    return true;\n  }\n\n  function profileGetRoleEntityAndCheckAdminAccess(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 roleId,\n    bytes32 senderId\n  ) external view returns (IACLCommons.RoleEntity storage) {\n    return _doProfileGetRoleEntityAndCheckAdminAccess(profileEntity, functionEntity, roleId, senderId);\n  }\n\n  function updateProfileAccount(\n    ACLStorage.DataCollection storage data,\n    IACLCommons.ProfileMemberEntity storage profileMemberEntity,\n    bytes32 profileId,\n    bytes32 typeId,\n    bool isRevoke\n  ) external {\n    return _updateProfileAccount(data, profileMemberEntity, profileId, typeId, isRevoke);\n  }\n\n  function profileGetRoleAdmin(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId,\n    bytes32 profileId\n  ) external view returns (bytes32 roleAdminId) {\n    return _doProfileGetRoleAdmin(profileEntity, requestScopeType, requestScopeAdmin, scopeId, adminId, profileId);\n  }\n\n  function _doProfileGetPolicyAndCheckAdminAccess(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 policyId,\n    bytes32 memberId\n  ) private view returns (IACLCommons.PolicyEntity storage) {\n    IACLCommons.PolicyEntity storage policyEntity = profileEntity.policies[policyId];\n    require(policyEntity.adminId != bytes32(0), \"Not Found\");\n    require(policyEntity.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IProfileACL.ProfileAdminAccessStatus status = _doProfileCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      policyEntity.adminId,\n      memberId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    return policyEntity;\n  }\n\n  function _doProfileGetPolicyAdmin(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId,\n    bytes32 profileId\n  ) private view returns (bytes32 policyAdminId) {\n    // checking requested type admin\n    if (adminId != bytes32(0)) {\n      require(profileEntity.agents[adminId].atype == IACLCommons.AgentType.ROLE, \"Illegal Admin AgentType\");\n      (IACLCommons.ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doAgentGetScopeInfo(\n        profileEntity,\n        adminId\n      );\n      require(requestScopeType <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n      if (requestScopeType == requestAdminScopeType) {\n        require(requestAdminScopeId == scopeId, \"Illegal Admin Scope\");\n      } else {\n        require(\n          IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, requestAdminScopeId, scopeId),\n          \"Illegal Admin Scope\"\n        );\n      }\n      policyAdminId = adminId;\n    } else {\n      policyAdminId = requestScopeAdmin;\n    }\n  }\n\n  function _doProfileGetPolicyType(uint8 policyCode) private pure returns (IACLCommons.PolicyType) {\n    if (policyCode == 0) {\n      return IACLCommons.PolicyType.UNLOCK;\n    } else if (policyCode <= 63) {\n      return IACLCommons.PolicyType.SLOCK;\n    } else if (policyCode <= 127) {\n      return IACLCommons.PolicyType.MLOCK;\n    } else if (policyCode <= 191) {\n      return IACLCommons.PolicyType.RLOCK;\n    } else if (policyCode <= 254) {\n      return IACLCommons.PolicyType.HLOCK;\n    } else {\n      return IACLCommons.PolicyType.LOCK;\n    }\n  }\n\n  function _doProfileGetRoleEntityAndCheckAdminAccess(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 roleId,\n    bytes32 senderId\n  ) private view returns (IACLCommons.RoleEntity storage) {\n    IACLCommons.RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(roleId);\n    require(roleEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n\n    // check access admin role\n    IProfileACL.ProfileAdminAccessStatus status = _doProfileCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      roleEntity.ba.adminId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    return roleEntity;\n  }\n\n  function _updateProfileAccount(\n    ACLStorage.DataCollection storage data,\n    IACLCommons.ProfileMemberEntity storage profileMemberEntity,\n    bytes32 profileId,\n    bytes32 typeId,\n    bool isRevoke\n  ) private {\n    IACLCommons.ProfileAccount storage profileAccount = data.profileAccounts[profileMemberEntity.account];\n    require(profileAccount.profiles.length > 0, \"ProfileAccount Not Found\");\n    bool findFlag = false;\n    for (uint256 i = 0; i < profileAccount.profiles.length; i++) {\n      if (profileAccount.profiles[i] == profileId) {\n        findFlag = true;\n        if (!isRevoke) {\n          if (\n            (profileMemberEntity.types.contains(LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID) ||\n              profileMemberEntity.types.contains(LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID)) &&\n            (typeId == LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID || typeId == LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID)\n          ) {\n            revert(\"Illegal GrantMemberType\");\n          }\n        } else {\n          if (profileAccount.profiles.length > 1) {\n            if (i < profileAccount.profiles.length - 1)\n              profileAccount.profiles[i] = profileAccount.profiles[profileAccount.profiles.length - 1];\n            profileAccount.profiles.pop();\n          } else {\n            profileAccount.profiles.pop();\n            delete profileAccount.profiles;\n          }\n        }\n        break;\n      }\n    }\n\n    require(findFlag, \"Illegal ProfileAccount\");\n  }\n\n  function _doProfileGetRoleAdmin(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId,\n    bytes32 profileId\n  ) private view returns (bytes32 roleAdminId) {\n    // checking requested type admin\n    if (adminId != bytes32(0)) {\n      require(profileEntity.agents[adminId].atype > IACLCommons.AgentType.MEMBER, \"Illegal Admin AgentType\");\n      (IACLCommons.ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doAgentGetScopeInfo(\n        profileEntity,\n        adminId\n      );\n      require(requestScopeType <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n      if (requestScopeType == requestAdminScopeType) {\n        require(requestAdminScopeId == scopeId, \"Illegal Admin Scope\");\n      } else {\n        require(\n          IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, requestAdminScopeId, scopeId),\n          \"Illegal Admin Scope\"\n        );\n      }\n      roleAdminId = adminId;\n    } else {\n      roleAdminId = requestScopeAdmin;\n    }\n  }\n\n  function _doProfileRoleCheckRequestScope(\n    IACLCommons.ProfileEntity storage profileEntity,\n    bytes32 requestScopeId,\n    bytes32 typeScopeId,\n    bytes32 profileId\n  ) private returns (IACLCommons.ScopeType) {\n    // checking requested role scope\n    IACLCommons.BaseScope storage requestScope = profileEntity.scopes[requestScopeId];\n    require(requestScope.stype != IACLCommons.ScopeType.NONE, \"Scope Not Found\");\n    require(requestScope.acstat > IACLCommons.ActivityStatus.DELETED, \"Scope Deleted\");\n\n    // increase referred count to target scope\n    requestScope.referredByAgent += 1;\n\n    // checking requested role type scope with role scope\n    IACLCommons.ScopeType typeScopeType = profileEntity.scopes[typeScopeId].stype;\n    require(typeScopeType >= requestScope.stype, \"Illegal ScopeType\");\n    if (typeScopeType == requestScope.stype) {\n      require(typeScopeId == requestScopeId, \"Illegal Scope\");\n    } else {\n      require(\n        IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, typeScopeId, requestScopeId),\n        \"Illegal Scope\"\n      );\n    }\n\n    return requestScope.stype;\n  }\n\n  function _doProfilePolicyCheckRequestScope(\n    IACLCommons.ProfileEntity storage profileEntity,\n    bytes32 requestScopeId,\n    bytes32 senderScopeId,\n    IACLCommons.ScopeType senderScopeType,\n    bytes32 profileId\n  ) private returns (IACLCommons.BaseScope storage) {\n    // checking requested type scope\n    IACLCommons.BaseScope storage requestScope = profileEntity.scopes[requestScopeId];\n    require(requestScope.stype != IACLCommons.ScopeType.NONE, \"Scope Not Found\");\n    require(requestScope.acstat > IACLCommons.ActivityStatus.DELETED, \"Deleted\");\n\n    // increase referred count to target scope\n    requestScope.referredByAgent += 1;\n\n    require(requestScope.stype <= senderScopeType, \"Illegal ScopeType\");\n    if (requestScope.stype == senderScopeType) {\n      require(requestScopeId == senderScopeId, \"Illegal Scope\");\n    } else {\n      require(\n        IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, senderScopeId, requestScopeId),\n        \"Illegal Scope\"\n      );\n    }\n\n    return requestScope;\n  }\n\n  function _doProfileCheckAdminAccess(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) private view returns (IProfileACL.ProfileAdminAccessStatus) {\n    // owners always access to all entities to modify those\n    if (profileEntity.admins.contains(senderId)) return IProfileACL.ProfileAdminAccessStatus.PERMITTED;\n\n    IACLCommons.AgentType adminAgentType = profileEntity.agents[adminId].atype;\n    if (adminAgentType == IACLCommons.AgentType.ROLE) {\n      (IACLCommons.RoleEntity storage roleEntity, bool result) = profileEntity.profileRoleTryReadSlot(adminId);\n      if (!result) return IProfileACL.ProfileAdminAccessStatus.ROLE_NOT_FOUND;\n      if (roleEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IProfileACL.ProfileAdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN;\n\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(\n        roleEntity.typeId\n      );\n      if (!result1) return IProfileACL.ProfileAdminAccessStatus.TYPE_NOT_FOUND;\n      if (typeEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IProfileACL.ProfileAdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN;\n\n      if (typeEntity.members[senderId] != adminId) return IProfileACL.ProfileAdminAccessStatus.NOT_PERMITTED;\n\n      IACLCommons.PolicyEntity storage policyEntity = profileEntity.policies[profileEntity.rolePolicyMap[adminId]];\n      if (\n        policyEntity.acstat == IACLCommons.ActivityStatus.ENABLED &&\n        policyEntity.policyCode >= functionEntity.policyCode\n      ) return IProfileACL.ProfileAdminAccessStatus.POLICY_FORBIDDEN;\n\n      return IProfileACL.ProfileAdminAccessStatus.PERMITTED;\n    } else if (adminAgentType == IACLCommons.AgentType.TYPE) {\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(adminId);\n      if (!result1) return IProfileACL.ProfileAdminAccessStatus.TYPE_NOT_FOUND;\n      if (typeEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IProfileACL.ProfileAdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN;\n\n      bytes32 roleId = typeEntity.members[senderId];\n      (IACLCommons.RoleEntity storage roleEntity, bool result2) = profileEntity.profileRoleTryReadSlot(roleId);\n      if (!result2) return IProfileACL.ProfileAdminAccessStatus.ROLE_NOT_FOUND;\n      if (roleEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IProfileACL.ProfileAdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN;\n\n      IACLCommons.PolicyEntity storage policyEntity = profileEntity.policies[profileEntity.rolePolicyMap[roleId]];\n      if (\n        policyEntity.acstat == IACLCommons.ActivityStatus.ENABLED &&\n        policyEntity.policyCode >= functionEntity.policyCode\n      ) return IProfileACL.ProfileAdminAccessStatus.POLICY_FORBIDDEN;\n\n      return IProfileACL.ProfileAdminAccessStatus.PERMITTED;\n    }\n\n    return IProfileACL.ProfileAdminAccessStatus.NOT_PERMITTED;\n  }\n\n  function _doAgentGetScopeInfo(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    private\n    view\n    returns (IACLCommons.ScopeType, bytes32)\n  {\n    IACLCommons.AgentType atype = profileEntity.agents[agentId].atype;\n    if (atype == IACLCommons.AgentType.ROLE) {\n      IACLCommons.RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(agentId);\n      IACLCommons.BaseScope storage baseScope = profileEntity.scopes[roleEntity.scopeId];\n      return (baseScope.stype, roleEntity.scopeId);\n    } else if (atype == IACLCommons.AgentType.TYPE) {\n      IACLCommons.TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(agentId);\n      IACLCommons.BaseScope storage baseScope = profileEntity.scopes[typeEntity.scopeId];\n      return (baseScope.stype, typeEntity.scopeId);\n    }\n\n    return (IACLCommons.ScopeType.NONE, bytes32(0));\n  }\n}\n"
    },
    "src/contracts/acl/profile/policy/ProfilePolicyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IProfilePolicyManagement.sol\";\nimport \"../IProfileACL.sol\";\nimport \"../IProfileACLGenerals.sol\";\nimport \"../ProfileAccessControl.sol\";\nimport \"../scope/IProfileFunctionManagement.sol\";\nimport \"../agent/IProfileRoleManagement.sol\";\nimport \"../agent/IProfileTypeManagement.sol\";\nimport \"../../ACLStorage.sol\";\nimport \"../../../proxy/IProxy.sol\";\nimport \"../../../lib/acl/LACLUtils.sol\";\nimport \"../../../lib/acl/LProfileRolePolicy.sol\";\nimport \"../../../lib/acl/LProfileStorage.sol\";\nimport \"../../../lib/acl/LACLStorage.sol\";\nimport \"../../../lib/struct/LEnumerableSet.sol\";\nimport \"../../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Profile Policy Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ProfilePolicyManager is ACLStorage, BaseUUPSProxy, IProfilePolicyManagement {\n  using LACLStorage for DataCollection;\n  using LProfileStorage for ProfileEntity;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IProfilePolicyManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  // called by members of Policy Master type\n  function profilePolicyRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfilePolicyRegisterRequest[] calldata requests\n  ) external returns (bool) {\n    (ProfileEntity storage profileEntity, , bytes32 profileId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IProfilePolicyManagement.profilePolicyRegister.selector\n    );\n\n    // check profile and type limitations and update it\n    LProfileRolePolicy.profileCheckMemberForPolicyRegister(profileEntity, uint16(requests.length), senderId);\n\n    (ScopeType senderScopeType, bytes32 senderScopeId) = _getMemberPolicyScopeInfo(profileEntity, sender);\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      _doProfilePolicyRegister(requests[i], profileEntity, senderScopeType, senderScopeId, profileId, sender);\n    }\n    return true;\n  }\n\n  // called by policy admin\n  function profilePolicyAddRoles(\n    ProfileMemberSignature calldata memberSign,\n    ProfilePolicyAddRolesRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfilePolicyManagement.profilePolicyAddRoles.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].policyId,\n        senderId\n      );\n      _doprofilePolicyAddRoles(profileEntity, policyEntity, requests[i], profileId, sender);\n    }\n    return true;\n  }\n\n  // called by policy admin\n  function profilePolicyRemoveRoles(\n    ProfileMemberSignature calldata memberSign,\n    ProfilePolicyRemoveRolesRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfilePolicyManagement.profilePolicyRemoveRoles.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].policyId,\n        senderId\n      );\n      for (uint256 j = 0; j < requests[i].roles.length && j < 32; j++) {\n        require(policyEntity.roles.contains(requests[i].roles[j]), \"Not Found\");\n        delete profileEntity.rolePolicyMap[requests[i].roles[j]];\n        policyEntity.roles.remove(requests[i].roles[j]);\n        emit ProfilePolicyRoleRemoved(sender, profileId, requests[i].policyId, requests[i].roles[j]);\n      }\n    }\n    return true;\n  }\n\n  function profilePolicyUpdateCodes(\n    ProfileMemberSignature calldata memberSign,\n    ProfilePolicyUpdateCodeRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfilePolicyManagement.profilePolicyUpdateCodes.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].policyId,\n        senderId\n      );\n      policyEntity.policyCode = requests[i].policyCode;\n      policyEntity.ptype = _doGetPolicyType(requests[i].policyCode);\n      emit ProfilePolicyCodeUpdated(\n        sender,\n        profileId,\n        requests[i].policyId,\n        requests[i].policyCode,\n        policyEntity.ptype\n      );\n    }\n    return true;\n  }\n\n  function profilePolicyUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfilePolicyManagement.profilePolicyUpdateAdmin.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].entityId,\n        senderId\n      );\n      policyEntity.adminId = _getPolicyAdmin(\n        profileEntity,\n        profileEntity.scopes[policyEntity.scopeId].stype,\n        profileEntity.scopes[policyEntity.scopeId].adminId,\n        policyEntity.scopeId,\n        requests[i].adminId,\n        profileId\n      );\n      require(!policyEntity.roles.contains(policyEntity.adminId), \"Illegal Admin Id\");\n      emit ProfilePolicyAdminUpdated(sender, profileId, requests[i].entityId, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function profilePolicyUpdateScope(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateScopeRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfilePolicyManagement.profilePolicyUpdateScope.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      LProfileRolePolicy.profilePolicyUpdateScope(profileEntity, requests[i], functionEntity, profileId, senderId);\n      emit ProfilePolicyScopeUpdated(sender, profileId, requests[i].entityId, requests[i].scopeId);\n    }\n    return true;\n  }\n\n  function profilePolicyUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfilePolicyManagement.profilePolicyUpdateActivityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].entityId,\n        senderId\n      );\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      policyEntity.acstat = requests[i].acstat;\n      emit ProfilePolicyActivityUpdated(sender, profileId, requests[i].entityId, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function profilePolicyUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfilePolicyManagement.profilePolicyUpdateAlterabilityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      LProfileRolePolicy.profilePolicyUpdateAlterabilityStatus(profileEntity, requests[i], functionEntity, senderId);\n      emit ProfilePolicyAlterabilityUpdated(sender, profileId, requests[i].entityId, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function profilePolicyUpdateRoleLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfilePolicyUpdateRoleLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfilePolicyManagement.profilePolicyUpdateRoleLimit.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].policyId,\n        senderId\n      );\n      require(requests[i].roleLimit > policyEntity.roles.length(), \"Illegal Limit\");\n      policyEntity.roleLimit = requests[i].roleLimit;\n      emit ProfilePolicyRoleLimitUpdated(sender, profileId, requests[i].policyId, requests[i].roleLimit);\n    }\n    return true;\n  }\n\n  function profilePolicyRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata policies)\n    external\n    returns (bool)\n  {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfilePolicyManagement.profilePolicyRemove.selector);\n    for (uint256 i = 0; i < policies.length; i++) {\n      PolicyEntity storage policyEntity = profileEntity.policies[policies[i]];\n      require(policyEntity.adminId != bytes32(0), \"Not Found\");\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        policyEntity.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      require(policyEntity.roles.length() == 0, \"Illegal Remove\");\n\n      BaseScope storage policyScope = profileEntity.scopes[policyEntity.scopeId];\n      require(policyScope.referredByAgent > 0, \"Illeagl Referred\");\n      unchecked {\n        policyScope.referredByAgent -= 1;\n      }\n\n      delete policyEntity.adminId;\n      delete policyEntity.scopeId;\n      delete policyEntity.name;\n      delete policyEntity.roleLimit;\n      delete policyEntity.policyCode;\n      delete policyEntity.ptype;\n      delete policyEntity.acstat;\n      delete policyEntity.alstat;\n      delete policyEntity.roles;\n\n      emit ProfilePolicyRemoved(sender, profileId, policies[i]);\n    }\n    return true;\n  }\n\n  function profilePolicyCheckId(bytes32 profileId, bytes32 policyId) external view returns (bool) {\n    return _data.profiles[profileId].policies[policyId].adminId != bytes32(0);\n  }\n\n  function profilePolicyCheckName(bytes32 profileId, string calldata policyName) external view returns (bool) {\n    return _data.profiles[profileId].policies[LACLUtils.generateId(policyName)].adminId != bytes32(0);\n  }\n\n  function profilePolicyCheckAdmin(\n    bytes32 profileId,\n    bytes32 policyId,\n    address account\n  ) external view returns (bool) {\n    return LProfileRolePolicy.profilePolicyCheckAdmin(_data, profileId, policyId, account);\n  }\n\n  function profilePolicyCheckAccess(\n    bytes32 profileId,\n    bytes32 policyId,\n    bytes32 functionId\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    return _doCheckAccessPolicy(profileEntity, policyId, functionId);\n  }\n\n  function profilePolicyCheckRoleAccess(\n    bytes32 profileId,\n    bytes32 roleId,\n    bytes32 functionId\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    return _doCheckAccessPolicy(profileEntity, profileEntity.rolePolicyMap[roleId], functionId);\n  }\n\n  function _doCheckAccessPolicy(\n    ProfileEntity storage profileEntity,\n    bytes32 policyId,\n    bytes32 functionId\n  ) internal view returns (bool) {\n    (FunctionEntity storage functionEntity, bool result) = profileEntity.profileFunctionTryReadSlot(functionId);\n    if (!result) return false;\n\n    PolicyEntity storage policyEntity = profileEntity.policies[policyId];\n    if (policyEntity.acstat != ActivityStatus.ENABLED) return false;\n    if (policyEntity.policyCode >= functionEntity.policyCode) return false;\n\n    return true;\n  }\n\n  function profilePolicyCheckRole(bytes32 profileId, bytes32 roleId) external view returns (bool) {\n    return _data.profiles[profileId].rolePolicyMap[roleId] != bytes32(0);\n  }\n\n  function profilePolicyHasRole(\n    bytes32 profileId,\n    bytes32 policyId,\n    bytes32 roleId\n  ) external view returns (bool) {\n    return _data.profiles[profileId].rolePolicyMap[roleId] == policyId;\n  }\n\n  function profilePolicyGetInfoByRole(bytes32 profileId, bytes32 roleId)\n    external\n    view\n    returns (ProfilePolicyInfo memory)\n  {\n    return _doPolicyGetInfo(profileId, _data.profiles[profileId].rolePolicyMap[roleId]);\n  }\n\n  function profilePolicyGetInfo(bytes32 profileId, bytes32 policyId) external view returns (ProfilePolicyInfo memory) {\n    return _doPolicyGetInfo(profileId, policyId);\n  }\n\n  function _doPolicyGetInfo(bytes32 profileId, bytes32 policyId) internal view returns (ProfilePolicyInfo memory) {\n    return LProfileRolePolicy.profilePolicyGetInfo(_data, profileId, policyId);\n  }\n\n  function profilePolicyGetRoles(bytes32 profileId, bytes32 policyId) external view returns (bytes32[] memory) {\n    if (_data.profiles[profileId].policies[policyId].adminId == bytes32(0)) return new bytes32[](0);\n    return _data.profiles[profileId].policies[policyId].roles.values();\n  }\n\n  function _doGetPolicyType(uint8 policyCode) internal pure returns (PolicyType) {\n    return LProfileRolePolicy.profileGetPolicyType(policyCode);\n  }\n\n  function _doCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) internal view returns (IProfileACL.ProfileAdminAccessStatus) {\n    return LProfileRolePolicy.profileCheckAdminAccess(profileEntity, functionEntity, adminId, senderId);\n  }\n\n  function _accessPermission(ProfileMemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      ProfileEntity storage,\n      FunctionEntity storage,\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(bytes(memberSign.profileName).length > 0, \"Illegal ProfileName\");\n\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getProfileMemeberSignerAddress(memberSign, PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    bytes32 profileId = LACLUtils.generateId(memberSign.profileName);\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n\n    ProfileAccessControl(payable(address(this))).profileAclHasMemberAccess(profileId, functionId, senderId);\n\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    FunctionEntity storage functionEntity = _data.functionReadSlot(functionId);\n    return (profileEntity, functionEntity, profileId, senderId, signer);\n  }\n\n  function _getMemberPolicyScopeInfo(ProfileEntity storage profileEntity, address account)\n    internal\n    view\n    returns (ScopeType, bytes32)\n  {\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n    TypeEntity storage policyMasterType = profileEntity.profileTypeReadSlot(_LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID);\n    bytes32 senderRoleId = policyMasterType.members[memberId];\n    RoleEntity storage senderPolicyRole = profileEntity.profileRoleReadSlot(senderRoleId);\n    return (profileEntity.scopes[senderPolicyRole.scopeId].stype, senderPolicyRole.scopeId);\n  }\n\n  function _getPolicyAdmin(\n    ProfileEntity storage profileEntity,\n    ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId,\n    bytes32 profileId\n  ) internal view returns (bytes32 policyAdminId) {\n    return\n      LProfileRolePolicy.profileGetPolicyAdmin(\n        profileEntity,\n        requestScopeType,\n        requestScopeAdmin,\n        scopeId,\n        adminId,\n        profileId\n      );\n  }\n\n  function _doGetPolicyAndCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 policyId,\n    bytes32 memberId\n  ) internal view returns (PolicyEntity storage) {\n    PolicyEntity storage policyEntity = profileEntity.policies[policyId];\n    require(policyEntity.adminId != bytes32(0), \"Not Found\");\n    require(policyEntity.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      policyEntity.adminId,\n      memberId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    return policyEntity;\n  }\n\n  function _doprofilePolicyAddRoles(\n    ProfileEntity storage profileEntity,\n    PolicyEntity storage policyEntity,\n    ProfilePolicyAddRolesRequest calldata request,\n    bytes32 profileId,\n    address sender\n  ) internal {\n    ScopeType policyScopeType = profileEntity.scopes[policyEntity.scopeId].stype;\n    for (uint256 j = 0; j < request.roles.length; j++) {\n      LProfileRolePolicy.profilePolicyAddRoles(\n        profileEntity,\n        policyEntity,\n        profileId,\n        request.policyId,\n        request.roles[j],\n        policyScopeType\n      );\n      emit ProfilePolicyRoleAdded(sender, profileId, request.policyId, request.roles[j]);\n    }\n  }\n\n  function _doProfilePolicyRegister(\n    ProfilePolicyRegisterRequest calldata request,\n    ProfileEntity storage profileEntity,\n    ScopeType senderScopeType,\n    bytes32 senderScopeId,\n    bytes32 profileId,\n    address sender\n  ) internal {\n    bytes32 newPolicyId = LProfileRolePolicy.profilePolicyRegister(\n      profileEntity,\n      request,\n      profileId,\n      senderScopeType,\n      senderScopeId\n    );\n    emit ProfilePolicyRegistered(sender, profileId, newPolicyId, request.scopeId, request.adminId, request.policyCode);\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LProfileRolePolicy);\n  }\n}\n"
    },
    "src/contracts/acl/profile/ProfileAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./policy/IProfilePolicyManagement.sol\";\nimport \"./IProfileACL.sol\";\nimport \"./IProfileACLGenerals.sol\";\nimport \"./scope/IProfileFunctionManagement.sol\";\nimport \"./agent/IProfileRoleManagement.sol\";\nimport \"./agent/IProfileTypeManagement.sol\";\nimport \"../ACLStorage.sol\";\nimport \"../IACL.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\nimport \"../../lib/acl/LProfileStorage.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Profile AccessControl Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ProfileAccessControl is ACLStorage, BaseUUPSProxy, IProfileACLGenerals, IProfileACL {\n  using LACLStorage for DataCollection;\n  using LProfileStorage for ProfileEntity;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return\n      interfaceId == type(IProfileACL).interfaceId ||\n      interfaceId == type(IProfileACLGenerals).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function profileHasAccess(bytes32 profileId, bytes32 functionId) external returns (ProfileAuthorizationStatus) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat != ActivityStatus.ENABLED) return ProfileAuthorizationStatus.PROFILE_ACTIVITY_FORBIDDEN;\n    (FunctionEntity storage functionEntity, bool result) = profileEntity.profileFunctionTryReadSlot(functionId);\n    if (!result) return ProfileAuthorizationStatus.FUNCTION_NOT_FOUND;\n    return _doProfileHasAccess(profileEntity, LACLUtils.accountGenerateId(msg.sender), functionEntity);\n  }\n\n  function profileHasMemberAccess(\n    bytes32 profileId,\n    bytes32 functionId,\n    bytes32 memberId\n  ) external returns (ProfileAuthorizationStatus) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat != ActivityStatus.ENABLED) return ProfileAuthorizationStatus.PROFILE_ACTIVITY_FORBIDDEN;\n    (FunctionEntity storage functionEntity, bool result) = profileEntity.profileFunctionTryReadSlot(functionId);\n    if (!result) return ProfileAuthorizationStatus.FUNCTION_NOT_FOUND;\n    return _doProfileHasAccess(profileEntity, memberId, functionEntity);\n  }\n\n  function profileHasCSAccess(\n    bytes32 profileId,\n    address contractId,\n    bytes4 selector\n  ) external returns (ProfileAuthorizationStatus) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat != ActivityStatus.ENABLED) return ProfileAuthorizationStatus.PROFILE_ACTIVITY_FORBIDDEN;\n    bytes32 functionId = LACLUtils.functionGenerateId(contractId, selector);\n    (FunctionEntity storage functionEntity, bool result) = profileEntity.profileFunctionTryReadSlot(functionId);\n    if (!result) return ProfileAuthorizationStatus.FUNCTION_NOT_FOUND;\n    return _doProfileHasAccess(profileEntity, LACLUtils.accountGenerateId(msg.sender), functionEntity);\n  }\n\n  function profileHasAccountAccess(\n    bytes32 profileId,\n    address contractId,\n    bytes4 selector,\n    address accountId\n  ) external returns (ProfileAuthorizationStatus) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat != ActivityStatus.ENABLED) return ProfileAuthorizationStatus.PROFILE_ACTIVITY_FORBIDDEN;\n    bytes32 functionId = LACLUtils.functionGenerateId(contractId, selector);\n    bytes32 memberId = LACLUtils.accountGenerateId(accountId);\n    (FunctionEntity storage functionEntity, bool result) = profileEntity.profileFunctionTryReadSlot(functionId);\n    if (!result) return ProfileAuthorizationStatus.FUNCTION_NOT_FOUND;\n    return _doProfileHasAccess(profileEntity, memberId, functionEntity);\n  }\n\n  function profileAclHasMemberAccess(\n    bytes32 profileId,\n    bytes32 functionId,\n    bytes32 memberId\n  ) public {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.PROFILE_ACTIVITY_FORBIDDEN);\n    (FunctionEntity storage functionEntity, bool result) = _data.functionTryReadSlot(functionId);\n    if (!result) LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.FUNCTION_NOT_FOUND);\n    _doAclHasAccess(profileEntity, memberId, functionEntity);\n  }\n\n  function _doProfileHasAccess(\n    ProfileEntity storage profileEntity,\n    bytes32 memberId,\n    FunctionEntity storage functionEntity\n  ) internal returns (ProfileAuthorizationStatus) {\n    if (profileEntity.limits.profileCallLimit > 0) {\n      unchecked {\n        profileEntity.limits.profileCallLimit -= 1;\n      }\n    } else {\n      return ProfileAuthorizationStatus.PROFILE_CALL_FORBIDDEN;\n    }\n\n    AgentType atype = profileEntity.agents[functionEntity.agentId].atype;\n    if (atype == AgentType.ROLE) {\n      // check member activation\n      (ProfileMemberEntity storage profileMemberEntity, bool result0) = profileEntity.profileMemberTryReadSlot(\n        memberId\n      );\n      if (!result0) return ProfileAuthorizationStatus.MEMBER_NOT_FOUND;\n      if (profileMemberEntity.ba.acstat != ActivityStatus.ENABLED)\n        return ProfileAuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN;\n      if (profileEntity.owner != profileMemberEntity.account) {\n        if (profileMemberEntity.callLimit > 0) {\n          unchecked {\n            profileMemberEntity.callLimit -= 1;\n          }\n        } else {\n          return ProfileAuthorizationStatus.MEMBER_CALL_FORBIDDEN;\n        }\n      }\n\n      // check role activation\n      (RoleEntity storage roleEntity, bool result1) = profileEntity.profileRoleTryReadSlot(functionEntity.agentId);\n      if (!result1) return ProfileAuthorizationStatus.ROLE_NOT_FOUND;\n      if (roleEntity.ba.acstat != ActivityStatus.ENABLED) return ProfileAuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN;\n      if (\n        profileEntity.scopes[roleEntity.scopeId].stype == ScopeType.FUNCTION &&\n        roleEntity.scopeId != functionEntity.agentId\n      ) return ProfileAuthorizationStatus.ROLE_SCOPE_FORBIDDEN;\n\n      // check type activation\n      (TypeEntity storage typeEntity, bool result2) = profileEntity.profileTypeTryReadSlot(roleEntity.typeId);\n      if (!result2) return ProfileAuthorizationStatus.TYPE_NOT_FOUND;\n      if (typeEntity.ba.acstat != ActivityStatus.ENABLED) return ProfileAuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN;\n\n      // check memberId with agentId role\n      if (typeEntity.members[memberId] != functionEntity.agentId) return ProfileAuthorizationStatus.UNAUTHORIZED;\n\n      // check policy activation\n      PolicyEntity storage policyEntity = profileEntity.policies[profileEntity.rolePolicyMap[functionEntity.agentId]];\n      if (policyEntity.acstat == ActivityStatus.ENABLED && policyEntity.policyCode >= functionEntity.policyCode)\n        return ProfileAuthorizationStatus.POLICY_FORBIDDEN;\n    } else if (atype == AgentType.TYPE) {\n      if (functionEntity.agentId == _LIVELY_PROFILE_ANY_TYPE_ID) {\n        (ProfileMemberEntity storage profileMemberEntity, bool result0) = profileEntity.profileMemberTryReadSlot(\n          memberId\n        );\n        if (!result0) return ProfileAuthorizationStatus.MEMBER_NOT_FOUND;\n        if (profileMemberEntity.ba.acstat != ActivityStatus.ENABLED)\n          return ProfileAuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN;\n        if (profileEntity.owner != profileMemberEntity.account) {\n          if (profileMemberEntity.callLimit > 0) {\n            unchecked {\n              profileMemberEntity.callLimit -= 1;\n            }\n          } else {\n            return ProfileAuthorizationStatus.MEMBER_CALL_FORBIDDEN;\n          }\n        }\n      } else if (functionEntity.agentId != _LIVELY_VERSE_ANONYMOUS_TYPE_ID) {\n        // check member activation\n        (ProfileMemberEntity storage profileMemberEntity, bool result0) = profileEntity.profileMemberTryReadSlot(\n          memberId\n        );\n        if (!result0) return ProfileAuthorizationStatus.MEMBER_NOT_FOUND;\n        if (profileMemberEntity.ba.acstat != ActivityStatus.ENABLED)\n          return ProfileAuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN;\n        if (profileEntity.owner != profileMemberEntity.account) {\n          if (profileMemberEntity.callLimit > 0) {\n            unchecked {\n              profileMemberEntity.callLimit -= 1;\n            }\n          } else {\n            return ProfileAuthorizationStatus.MEMBER_CALL_FORBIDDEN;\n          }\n        }\n\n        // check type activation\n        (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(functionEntity.agentId);\n        if (!result1) return ProfileAuthorizationStatus.TYPE_NOT_FOUND;\n        if (typeEntity.ba.acstat != ActivityStatus.ENABLED) return ProfileAuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN;\n\n        // check role activation\n        bytes32 roleId = typeEntity.members[memberId];\n        (RoleEntity storage roleEntity, bool result2) = profileEntity.profileRoleTryReadSlot(roleId);\n        if (!result2) return ProfileAuthorizationStatus.ROLE_NOT_FOUND;\n        if (roleEntity.ba.acstat != ActivityStatus.ENABLED) return ProfileAuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN;\n        if (\n          profileEntity.scopes[roleEntity.scopeId].stype == ScopeType.FUNCTION &&\n          roleEntity.scopeId != functionEntity.agentId\n        ) return ProfileAuthorizationStatus.ROLE_SCOPE_FORBIDDEN;\n\n        // check policy activation\n        PolicyEntity storage policyEntity = profileEntity.policies[profileEntity.rolePolicyMap[roleId]];\n        if (policyEntity.acstat == ActivityStatus.ENABLED && policyEntity.policyCode >= functionEntity.policyCode)\n          return ProfileAuthorizationStatus.POLICY_FORBIDDEN;\n      }\n    } else if (atype <= AgentType.MEMBER) {\n      return ProfileAuthorizationStatus.UNAUTHORIZED;\n    }\n\n    // check function activity\n    if (functionEntity.bs.acstat != ActivityStatus.ENABLED)\n      return ProfileAuthorizationStatus.FUNCTION_ACTIVITY_FORBIDDEN;\n\n    // check context activity\n    (ContextEntity storage contextEntity, bool res1) = profileEntity.profileContextTryReadSlot(\n      functionEntity.contextId\n    );\n    if (!res1) return ProfileAuthorizationStatus.CONTEXT_NOT_FOUND;\n    if (contextEntity.bs.acstat != ActivityStatus.ENABLED) return ProfileAuthorizationStatus.CONTEXT_ACTIVITY_FORBIDDEN;\n\n    // check realm activity\n    (RealmEntity storage realmEntity, bool res2) = profileEntity.profileRealmTryReadSlot(contextEntity.realmId);\n    if (!res2) return ProfileAuthorizationStatus.REALM_NOT_FOUND;\n    if (realmEntity.bs.acstat != ActivityStatus.ENABLED) return ProfileAuthorizationStatus.REALM_ACTIVITY_FORBIDDEN;\n\n    // check domain activity\n    (DomainEntity storage domainEntity, bool res3) = profileEntity.profileDomainTryReadSlot(realmEntity.domainId);\n    if (!res3) return ProfileAuthorizationStatus.DOMAIN_NOT_FOUND;\n    if (domainEntity.bs.acstat != ActivityStatus.ENABLED) return ProfileAuthorizationStatus.DOMAIN_ACTIVITY_FORBIDDEN;\n\n    // check universe activity\n    UniverseEntity storage universeEntity = profileEntity.profileUniverseReadSlot(\n      _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID\n    );\n    if (universeEntity.bs.acstat != ActivityStatus.ENABLED)\n      return ProfileAuthorizationStatus.UNIVERSE_ACTIVITY_FORBIDDEN;\n\n    return ProfileAuthorizationStatus.PERMITTED;\n  }\n\n  function _doAclHasAccess(\n    ProfileEntity storage profileEntity,\n    bytes32 memberId,\n    FunctionEntity storage functionEntity\n  ) internal {\n    if (profileEntity.limits.profileCallLimit > 0) {\n      unchecked {\n        profileEntity.limits.profileCallLimit -= 1;\n      }\n    } else {\n      LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.PROFILE_CALL_FORBIDDEN);\n    }\n\n    AgentType atype = profileEntity.agents[functionEntity.agentId].atype;\n\n    if (atype == AgentType.ROLE) {\n      // check member activation\n      (ProfileMemberEntity storage profileMemberEntity, bool result0) = profileEntity.profileMemberTryReadSlot(\n        memberId\n      );\n      if (!result0) LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.MEMBER_NOT_FOUND);\n      if (profileMemberEntity.ba.acstat != ActivityStatus.ENABLED)\n        LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN);\n      if (profileEntity.owner != profileMemberEntity.account) {\n        if (profileMemberEntity.callLimit > 0) {\n          unchecked {\n            profileMemberEntity.callLimit -= 1;\n          }\n        } else {\n          LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.MEMBER_CALL_FORBIDDEN);\n        }\n      }\n\n      // check role activation\n      (RoleEntity storage roleEntity, bool result1) = profileEntity.profileRoleTryReadSlot(functionEntity.agentId);\n      if (!result1) LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.ROLE_NOT_FOUND);\n      if (roleEntity.ba.acstat != ActivityStatus.ENABLED)\n        LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN);\n      // if(profileEntity.scopes[roleEntity.scopeId].stype == ScopeType.FUNCTION && roleEntity.scopeId != functionEntity.agentId)\n      //   LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.ROLE_SCOPE_FORBIDDEN);\n\n      // check type activation\n      (TypeEntity storage typeEntity, bool result2) = profileEntity.profileTypeTryReadSlot(roleEntity.typeId);\n      if (!result2) LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.TYPE_NOT_FOUND);\n      if (typeEntity.ba.acstat != ActivityStatus.ENABLED)\n        LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN);\n\n      // check memberId with agentId role\n      if (typeEntity.members[memberId] != functionEntity.agentId)\n        LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.UNAUTHORIZED);\n\n      // check policy activation\n      PolicyEntity storage policyEntity = profileEntity.policies[profileEntity.rolePolicyMap[functionEntity.agentId]];\n      if (policyEntity.acstat == ActivityStatus.ENABLED && policyEntity.policyCode >= functionEntity.policyCode)\n        LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.POLICY_FORBIDDEN);\n    } else if (atype == AgentType.TYPE) {\n      if (functionEntity.agentId == _LIVELY_PROFILE_ANY_TYPE_ID) {\n        (ProfileMemberEntity storage profileMemberEntity, bool result0) = profileEntity.profileMemberTryReadSlot(\n          memberId\n        );\n        if (!result0) LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.MEMBER_NOT_FOUND);\n        if (profileMemberEntity.ba.acstat != ActivityStatus.ENABLED)\n          LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN);\n        if (profileEntity.owner != profileMemberEntity.account) {\n          if (profileMemberEntity.callLimit > 0) {\n            unchecked {\n              profileMemberEntity.callLimit -= 1;\n            }\n          } else {\n            LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.MEMBER_CALL_FORBIDDEN);\n          }\n        }\n      } else if (functionEntity.agentId != _LIVELY_VERSE_ANONYMOUS_TYPE_ID) {\n        // check member activation\n        (ProfileMemberEntity storage profileMemberEntity, bool result0) = profileEntity.profileMemberTryReadSlot(\n          memberId\n        );\n        if (!result0) LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.MEMBER_NOT_FOUND);\n        if (profileMemberEntity.ba.acstat != ActivityStatus.ENABLED)\n          LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN);\n        if (profileEntity.owner != profileMemberEntity.account) {\n          if (profileMemberEntity.callLimit > 0) {\n            unchecked {\n              profileMemberEntity.callLimit -= 1;\n            }\n          } else {\n            LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.MEMBER_CALL_FORBIDDEN);\n          }\n        }\n\n        // check type activation\n        (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(functionEntity.agentId);\n        if (!result1) LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.TYPE_NOT_FOUND);\n        if (typeEntity.ba.acstat != ActivityStatus.ENABLED)\n          LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN);\n\n        // check role activation\n        bytes32 roleId = typeEntity.members[memberId];\n        (RoleEntity storage roleEntity, bool result2) = profileEntity.profileRoleTryReadSlot(roleId);\n        if (!result2) LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.ROLE_NOT_FOUND);\n        if (roleEntity.ba.acstat != ActivityStatus.ENABLED)\n          LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN);\n        // if(profileEntity.scopes[roleEntity.scopeId].stype == ScopeType.FUNCTION && roleEntity.scopeId != functionEntity.agentId)\n        //   LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.ROLE_SCOPE_FORBIDDEN);\n\n        // check policy activation\n        PolicyEntity storage policyEntity = profileEntity.policies[profileEntity.rolePolicyMap[roleId]];\n        if (policyEntity.acstat == ActivityStatus.ENABLED && policyEntity.policyCode >= functionEntity.policyCode)\n          LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.POLICY_FORBIDDEN);\n      }\n    } else if (atype <= AgentType.MEMBER) {\n      LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.UNAUTHORIZED);\n    }\n\n    // check function activity\n    if (functionEntity.bs.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.FUNCTION_ACTIVITY_FORBIDDEN);\n\n    // check context activity\n    (ContextEntity storage contextEntity, bool res1) = _data.contextTryReadSlot(functionEntity.contextId);\n    if (!res1) LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.CONTEXT_NOT_FOUND);\n    if (contextEntity.bs.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.CONTEXT_ACTIVITY_FORBIDDEN);\n\n    // check realm activity\n    (RealmEntity storage realmEntity, bool res2) = _data.realmTryReadSlot(contextEntity.realmId);\n    if (!res2) LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.REALM_NOT_FOUND);\n    if (realmEntity.bs.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.REALM_ACTIVITY_FORBIDDEN);\n\n    // check domain activity\n    (DomainEntity storage domainEntity, bool res3) = _data.domainTryReadSlot(realmEntity.domainId);\n    if (!res3) LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.DOMAIN_NOT_FOUND);\n    if (domainEntity.bs.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.DOMAIN_ACTIVITY_FORBIDDEN);\n\n    // check universe activity\n    UniverseEntity storage universeEntity = _data.universeReadSlot(_LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID);\n    if (universeEntity.bs.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.UNIVERSE_ACTIVITY_FORBIDDEN);\n  }\n\n  // Anonymouse type\n  function profileAnonymousType() external pure returns (bytes32) {\n    return _LIVELY_VERSE_ANONYMOUS_TYPE_ID;\n  }\n\n  // Any type\n  function profileAnyType() external pure returns (bytes32) {\n    return _LIVELY_PROFILE_ANY_TYPE_ID;\n  }\n\n  // system admin type\n  function profileSystemMasterType() external pure returns (bytes32) {\n    return _LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID;\n  }\n\n  // admin type\n  function profileMasterType() external pure returns (bytes32) {\n    return _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID;\n  }\n\n  function profileUniverseScope() external pure returns (bytes32) {\n    return _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID;\n  }\n\n  // general\n  function profileIsAgentExist(bytes32 profileId, bytes32 agentId) external view returns (bool) {\n    return _data.profiles[profileId].agents[agentId].atype != AgentType.NONE;\n  }\n\n  function profileIsScopeExist(bytes32 profileId, bytes32 scopeId) external view returns (bool) {\n    return _data.profiles[profileId].scopes[scopeId].stype != ScopeType.NONE;\n  }\n\n  function profileScopeBaseInfo(bytes32 profileId, bytes32 scopeId) external view returns (BaseScope memory) {\n    return _data.profiles[profileId].scopes[scopeId];\n  }\n\n  function profileAgentBaseInfo(bytes32 profileId, bytes32 agentId) external view returns (BaseAgent memory) {\n    return _data.profiles[profileId].agents[agentId];\n  }\n\n  function profileIsScopesCompatible(\n    bytes32 profileId,\n    bytes32 destScopeId,\n    bytes32 srcScopeId\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    return _doProfileScopesCompatible(profileEntity, destScopeId, srcScopeId);\n  }\n\n  function _doProfileScopesCompatible(\n    ProfileEntity storage profileEntity,\n    bytes32 destScopeId,\n    bytes32 srcScopeId\n  ) internal view returns (bool) {\n    ScopeType destScopeType = profileEntity.scopes[destScopeId].stype;\n    ScopeType srcScopeType = profileEntity.scopes[srcScopeId].stype;\n    if (destScopeType == ScopeType.NONE || srcScopeType == ScopeType.NONE) return false;\n    if (destScopeType == ScopeType.UNIVERSE) return true;\n\n    if (destScopeType == ScopeType.CONTEXT && srcScopeType == ScopeType.FUNCTION) {\n      ContextEntity storage ce = profileEntity.profileContextReadSlot(destScopeId);\n      return ce.functions.contains(srcScopeId);\n    } else if (destScopeType == ScopeType.REALM && srcScopeType == ScopeType.FUNCTION) {\n      FunctionEntity storage fe = profileEntity.profileFunctionReadSlot(srcScopeId);\n      RealmEntity storage re = profileEntity.profileRealmReadSlot(destScopeId);\n      return re.contexts.contains(fe.contextId);\n    } else if (destScopeType == ScopeType.DOMAIN && srcScopeType == ScopeType.FUNCTION) {\n      FunctionEntity storage fe = profileEntity.profileFunctionReadSlot(srcScopeId);\n      ContextEntity storage ce = profileEntity.profileContextReadSlot(fe.contextId);\n      DomainEntity storage de = profileEntity.profileDomainReadSlot(destScopeId);\n      return de.realms.contains(ce.realmId);\n    } else if (destScopeType == ScopeType.REALM && srcScopeType == ScopeType.CONTEXT) {\n      RealmEntity storage re = profileEntity.profileRealmReadSlot(destScopeId);\n      return re.contexts.contains(srcScopeId);\n    } else if (destScopeType == ScopeType.DOMAIN && srcScopeType == ScopeType.CONTEXT) {\n      ContextEntity storage ce = profileEntity.profileContextReadSlot(srcScopeId);\n      DomainEntity storage de = profileEntity.profileDomainReadSlot(destScopeId);\n      return de.realms.contains(ce.realmId);\n    } else if (destScopeType == ScopeType.DOMAIN && srcScopeType == ScopeType.REALM) {\n      DomainEntity storage de = profileEntity.profileDomainReadSlot(destScopeId);\n      return de.realms.contains(srcScopeId);\n    }\n\n    return false;\n  }\n}\n"
    },
    "src/contracts/test/acl/ProfileMemberManagerTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../../acl/profile/IProfileACL.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\n\ncontract ProfileMemberManagerTest {\n  address private _accessControlManager;\n\n  constructor(address accessControlManager) {\n    _accessControlManager = accessControlManager;\n  }\n\n  // Note: called by any admin of role\n  function profileMemberRegisterTest(bytes32 profileId) external returns (bool) {\n    bytes32 functionId = LACLUtils.functionGenerateId(address(this), this.profileMemberRegisterTest.selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(msg.sender);\n\n    IProfileACL.ProfileAuthorizationStatus status = IProfileACL(_accessControlManager).profileHasMemberAccess(\n      profileId,\n      functionId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAuthorizationStatus.PERMITTED) LACLUtils.generateProfileAuthorizationError(status);\n\n    return true;\n  }\n}\n"
    },
    "src/contracts/lib/acl/LProfileCommons.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./LACLUtils.sol\";\nimport \"./LProfileStorage.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../../acl/IACLCommons.sol\";\nimport \"../../acl/profile/ProfileAccessControl.sol\";\nimport \"../../acl/profile/IProfileACLGenerals.sol\";\nimport \"../../acl/profile/IProfileManagement.sol\";\nimport \"../../acl/ACLStorage.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../utils/IERC165.sol\";\nimport \"../../acl/profile/IProfileACL.sol\";\nimport \"../../acl/profile/scope/IProfileContextManagement.sol\";\nimport \"../../acl/profile/scope/IProfileFunctionManagement.sol\";\nimport \"../../acl/profile/scope/IProfileRealmManagement.sol\";\nimport \"../../acl/profile/scope/IProfileDomainManagement.sol\";\nimport \"../../acl/profile/agent/IProfileMemberManagement.sol\";\n\n/**\n * @title Profile Commons Library\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nlibrary LProfileCommons {\n  using LProfileStorage for IACLCommons.ProfileEntity;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  string public constant LIB_NAME = \"LProfileCommons\";\n  string public constant LIB_VERSION = \"3.0.0\";\n\n  bytes32 public constant LIVELY_VERSE_ANONYMOUS_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_ANONYMOUS\"));\n  bytes32 public constant LIVELY_VERSE_ANY_TYPE_ID = keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_ANY\"));\n\n  bytes32 public constant LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_PROFILE.LIVELY_MASTER\"));\n  bytes32 public constant LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_PROFILE.LIVELY_SYSTEM_MASTER\"));\n  bytes32 public constant LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID =\n    keccak256(abi.encodePacked(\"UNIVERSE.LIVELY_PROFILE\"));\n  bytes32 public constant LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_PROFILE.LIVELY_MASTER_ADMIN\"));\n  bytes32 public constant LIVELY_PROFILE_SYSTEM_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_PROFILE.LIVELY_SYSTEM_MASTER_ADMIN\"));\n\n  function profileCheckAdminAccess(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) external view returns (IProfileACL.ProfileAdminAccessStatus) {\n    return _doProfileCheckAdminAccess(profileEntity, functionEntity, adminId, senderId);\n  }\n\n  function profileAgentGetScopeInfo(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    external\n    view\n    returns (IACLCommons.ScopeType, bytes32)\n  {\n    return _doGetAgentScopeInfo(profileEntity, agentId);\n  }\n\n  function profileRegisterContext(\n    ACLStorage.DataCollection storage data,\n    IProfileContextManagement.ProfileContextRegisterRequest calldata request,\n    bytes32 profileId,\n    address contractId,\n    address signer\n  ) external returns (bytes32) {\n    bytes32 functionId = LACLUtils.functionGenerateId(\n      data.selectors[IProfileContextManagement.profileContextRegister.selector],\n      IProfileContextManagement.profileContextRegister.selector\n    );\n    bytes32 signerId = LACLUtils.accountGenerateId(signer);\n    bytes32 newContextId = LACLUtils.accountGenerateId(contractId);\n\n    {\n      IACLCommons.ProfileEntity storage profileEntity = data.profiles[profileId];\n      ProfileAccessControl(payable(address(this))).profileAclHasMemberAccess(profileId, functionId, signerId);\n      require(profileEntity.scopes[newContextId].stype == IACLCommons.ScopeType.NONE, \"Already Exist\");\n\n      // check profile and type limitations and update it\n      IACLCommons.ProfileMemberEntity storage profileMemberEntity = profileEntity.profileMemberReadSlot(signerId);\n      require(profileMemberEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Member Updatable\");\n      require(profileEntity.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Profile Updatable\");\n      require(profileMemberEntity.registerLimits.contextRegisterLimit > 0, \"Illegal Member ContextRegisterLimit\");\n      require(profileEntity.registerLimits.contextRegisterLimit > 0, \"Illegal Profile ContextRegisterLimit\");\n      unchecked {\n        profileMemberEntity.registerLimits.contextRegisterLimit -= 1;\n        profileEntity.registerLimits.contextRegisterLimit -= 1;\n      }\n\n      // check realm\n      IACLCommons.RealmEntity storage realmEntity = profileEntity.profileRealmReadSlot(request.realmId);\n      require(realmEntity.bs.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Realm Updatable\");\n      require(realmEntity.contextLimit > realmEntity.contexts.length(), \"Illegal Register\");\n\n      // check system scope\n      require(_doCheckContextSystemScope(profileEntity, request.realmId, signerId, profileId), \"Forbidden\");\n\n      // add context to realm\n      realmEntity.contexts.add(newContextId);\n\n      // create new context\n      IACLCommons.ContextEntity storage newContext = profileEntity.profileContextWriteSlot(newContextId);\n      newContext.realmId = request.realmId;\n      newContext.contractId = contractId;\n      newContext.functionLimit = request.functionLimit >= 0\n        ? uint8(uint16(request.functionLimit))\n        : profileEntity.limits.functionLimit;\n      newContext.bs.stype = IACLCommons.ScopeType.CONTEXT;\n      newContext.bs.acstat = IACLCommons.ActivityStatus.ENABLED;\n      newContext.bs.alstat = IACLCommons.AlterabilityStatus.UPGRADABLE;\n      newContext.bs.adminId = _doGetContextAdmin(\n        profileEntity,\n        request,\n        profileId,\n        newContextId,\n        realmEntity.bs.adminId\n      );\n    }\n\n    return newContextId;\n  }\n\n  function profileCheckMemberForDomainRegister(\n    IACLCommons.ProfileEntity storage profileEntity,\n    uint16 requestLength,\n    bytes32 senderId\n  ) external {\n    // check profile and type limitations and update it\n    IACLCommons.ProfileMemberEntity storage profileMemberEntity = profileEntity.profileMemberReadSlot(senderId);\n    require(profileMemberEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Member Updatable\");\n    require(profileEntity.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Profile Updatable\");\n    unchecked {\n      require(\n        int32(uint32(profileMemberEntity.registerLimits.domainRegisterLimit)) - int16(requestLength) >= 0,\n        \"Illegal Member DomainRegisterLimit\"\n      );\n      require(\n        int32(uint32(profileEntity.registerLimits.domainRegisterLimit)) - int16(requestLength) >= 0,\n        \"Illegal Profile DomainRegisterLimit\"\n      );\n      profileMemberEntity.registerLimits.domainRegisterLimit -= requestLength;\n      profileEntity.registerLimits.domainRegisterLimit -= requestLength;\n    }\n  }\n\n  function profileCheckMemberForFunctionRegister(\n    IACLCommons.ProfileEntity storage profileEntity,\n    uint16 requestLength,\n    bytes32 signerId\n  ) external {\n    // check profile and type limitations and update it\n    IACLCommons.ProfileMemberEntity storage profileMemberEntity = profileEntity.profileMemberReadSlot(signerId);\n    require(profileMemberEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Member Updatable\");\n    require(profileEntity.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Profile Updatable\");\n    unchecked {\n      require(\n        int32(profileMemberEntity.registerLimits.functionRegisterLimit) - int16(requestLength) >= 0,\n        \"Illegal Member FunctionRegisterLimit\"\n      );\n      require(\n        int32(profileEntity.registerLimits.functionRegisterLimit) - int16(requestLength) >= 0,\n        \"Illegal Profile FunctionRegisterLimit\"\n      );\n      profileMemberEntity.registerLimits.functionRegisterLimit -= requestLength;\n      profileEntity.registerLimits.functionRegisterLimit -= requestLength;\n    }\n  }\n\n  function profileCheckMemberForRealmRegister(\n    IACLCommons.ProfileEntity storage profileEntity,\n    uint16 requestLength,\n    bytes32 senderId\n  ) external {\n    // check profile and realm limitations and update it\n    IACLCommons.ProfileMemberEntity storage profileMemberEntity = profileEntity.profileMemberReadSlot(senderId);\n    require(profileMemberEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Member Updatable\");\n    require(profileEntity.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Profile Updatable\");\n    unchecked {\n      require(\n        int32(uint32(profileMemberEntity.registerLimits.realmRegisterLimit)) - int16(requestLength) >= 0,\n        \"Illegal Member RealmRegisterLimit\"\n      );\n      require(\n        int32(uint32(profileEntity.registerLimits.realmRegisterLimit)) - int16(requestLength) >= 0,\n        \"Illegal Profile MemberRegisterLimit\"\n      );\n      profileMemberEntity.registerLimits.realmRegisterLimit -= requestLength;\n      profileEntity.registerLimits.realmRegisterLimit -= requestLength;\n    }\n  }\n\n  function profileCheckMemberForMemberRegister(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.ProfileMemberEntity storage,\n    uint16 requestLength,\n    bytes32 senderId\n  ) external {\n    // check profile and member limitations and update it\n    IACLCommons.ProfileMemberEntity storage profileMemberEntity = profileEntity.profileMemberReadSlot(senderId);\n    require(profileMemberEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Member Updatable\");\n    require(profileEntity.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Profile Updatable\");\n    unchecked {\n      require(\n        int32(profileMemberEntity.registerLimits.memberRegisterLimit) - int16(requestLength) >= 0,\n        \"Illegal Member MemberRegisterLimit\"\n      );\n      require(\n        int32(profileEntity.registerLimits.memberRegisterLimit) - int16(requestLength) >= 0,\n        \"Illegal Profile MemberRegisterLimit\"\n      );\n      profileMemberEntity.registerLimits.memberRegisterLimit -= requestLength;\n      profileEntity.registerLimits.memberRegisterLimit -= requestLength;\n    }\n  }\n\n  function profileDomainRegister(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IProfileDomainManagement.ProfileDomainRegisterRequest calldata request,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 senderId\n  ) external returns (bytes32) {\n    bytes32 newDomainId = LACLUtils.generateId(request.name);\n    require(profileEntity.scopes[newDomainId].stype == IACLCommons.ScopeType.NONE, \"Already Exist\");\n\n    // check sender scopes\n    IACLCommons.UniverseEntity storage livelyUniverseEntity = profileEntity.profileUniverseReadSlot(\n      LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID\n    );\n\n    require(livelyUniverseEntity.bs.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Universe Updatable\");\n    require(livelyUniverseEntity.domainLimit > livelyUniverseEntity.domains.length(), \"Illegal Register\");\n\n    // check access admin universe\n    IProfileACL.ProfileAdminAccessStatus status = _doProfileCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      livelyUniverseEntity.bs.adminId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n    // add domain to universe\n    livelyUniverseEntity.domains.add(newDomainId);\n\n    // create new domain entity\n    IACLCommons.DomainEntity storage newDomain = profileEntity.profileDomainWriteSlot(newDomainId);\n    newDomain.bs.stype = IACLCommons.ScopeType.DOMAIN;\n    newDomain.bs.acstat = IACLCommons.ActivityStatus.ENABLED;\n    newDomain.bs.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    newDomain.name = request.name;\n    newDomain.universeId = LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID;\n    newDomain.realmLimit = request.realmLimit >= 0\n      ? uint16(uint24(request.realmLimit))\n      : profileEntity.limits.realmLimit;\n\n    // checking requested domain admin\n    if (request.adminId != bytes32(0)) {\n      require(profileEntity.agents[request.adminId].atype > IACLCommons.AgentType.MEMBER, \"Illegal Admin AgentType\");\n      bytes32 requestAdminScopeId = _doDomainAgentGetScopeInfo(profileEntity, request.adminId);\n      require(requestAdminScopeId == LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Admin Scope\");\n      newDomain.bs.adminId = request.adminId;\n    } else {\n      newDomain.bs.adminId = livelyUniverseEntity.bs.adminId;\n    }\n\n    return newDomainId;\n  }\n\n  function profileRealmRegister(\n    IProfileRealmManagement.ProfileRealmRegisterRequest calldata request,\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 senderId,\n    IACLCommons.ScopeType memberScopeType,\n    bytes32 memberScopeId\n  ) external returns (bytes32) {\n    bytes32 newRealmId = LACLUtils.generateId(request.name);\n    require(profileEntity.scopes[newRealmId].stype == IACLCommons.ScopeType.NONE, \"Already Exist\");\n\n    // check sender scopes\n    require(memberScopeType >= IACLCommons.ScopeType.DOMAIN, \"Illegal ScopeType\");\n    if (memberScopeType == IACLCommons.ScopeType.DOMAIN) {\n      require(memberScopeId == request.domainId, \"Illegal Domain Scope\");\n    } else {\n      require(memberScopeId == LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Universe Scope\");\n    }\n\n    IACLCommons.DomainEntity storage domainEntity = profileEntity.profileDomainReadSlot(request.domainId);\n    require(domainEntity.bs.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Domain Updatable\");\n    require(domainEntity.realmLimit > domainEntity.realms.length(), \"Illegal Register\");\n\n    // check access admin realm\n    IProfileACL.ProfileAdminAccessStatus status = _doProfileCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      domainEntity.bs.adminId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n    // add to domain\n    domainEntity.realms.add(newRealmId);\n\n    // create new realm entity\n    IACLCommons.RealmEntity storage newRealm = profileEntity.profileRealmWriteSlot(newRealmId);\n    newRealm.bs.stype = IACLCommons.ScopeType.REALM;\n    newRealm.bs.acstat = IACLCommons.ActivityStatus.ENABLED;\n    newRealm.bs.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    newRealm.name = request.name;\n    newRealm.domainId = request.domainId;\n    newRealm.contextLimit = request.contextLimit >= 0\n      ? uint32(uint64(request.contextLimit))\n      : profileEntity.limits.contextLimit;\n    newRealm.bs.adminId = _getProfileRealmAdmin(\n      profileEntity,\n      domainEntity.bs.adminId,\n      request.domainId,\n      request.adminId\n    );\n\n    return newRealmId;\n  }\n\n  function profileGetAndCheckRequestScope(\n    IACLCommons.ProfileEntity storage profileEntity,\n    bytes32 requestScopeId,\n    bytes32 senderScopeId,\n    IACLCommons.ScopeType senderScopeType,\n    bytes32 profileId\n  ) external view returns (IACLCommons.BaseScope storage) {\n    return _doProfileGetAndCheckRequestScope(profileEntity, requestScopeId, senderScopeId, senderScopeType, profileId);\n  }\n\n  function profileFunctionRegistration(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IProfileFunctionManagement.ProfileFunctionRequest calldata functionRequest,\n    bytes32 profileId,\n    bytes32 contextId\n  ) external returns (bytes32) {\n    IACLCommons.ContextEntity storage contextEntity = profileEntity.profileContextReadSlot(contextId);\n    require(contextEntity.bs.alstat == IACLCommons.AlterabilityStatus.UPGRADABLE, \"Illegal Upgrade\");\n    require(contextEntity.functionLimit > contextEntity.functions.length(), \"Illegal Limit\");\n\n    bytes32 newFunctionId = LACLUtils.functionGenerateId(contextEntity.contractId, functionRequest.selector);\n\n    require(profileEntity.scopes[newFunctionId].stype == IACLCommons.ScopeType.NONE, \"Already Exist\");\n\n    _doCheckAgentId(profileEntity, profileId, functionRequest.agentId, contextId);\n    IACLCommons.FunctionEntity storage functionEntity = profileEntity.profileFunctionWriteSlot(newFunctionId);\n    functionEntity.bs.stype = IACLCommons.ScopeType.FUNCTION;\n    functionEntity.contextId = contextId;\n    functionEntity.agentId = functionRequest.agentId;\n    functionEntity.policyCode = functionRequest.policyCode;\n    functionEntity.selector = functionRequest.selector;\n    functionEntity.bs.acstat = IACLCommons.ActivityStatus.ENABLED;\n    functionEntity.bs.alstat = IACLCommons.AlterabilityStatus.UPDATABLE;\n    functionEntity.bs.adminId = _doGetAndCheckFunctionAdmin(\n      profileEntity,\n      contextEntity.bs.adminId,\n      contextId,\n      functionRequest.adminId,\n      profileId\n    );\n\n    // add function to context\n    contextEntity.functions.add(newFunctionId);\n\n    return newFunctionId;\n  }\n\n  function profileGetAndCheckFunctionAdmin(\n    IACLCommons.ProfileEntity storage profileEntity,\n    bytes32 contextAdminId,\n    bytes32 contextId,\n    bytes32 adminId,\n    bytes32 profileId\n  ) external view returns (bytes32 functionAdminId) {\n    return _doGetAndCheckFunctionAdmin(profileEntity, contextAdminId, contextId, adminId, profileId);\n  }\n\n  function profileMemberGetInfo(\n    ACLStorage.DataCollection storage data,\n    bytes32 profileId,\n    bytes32 memberId\n  ) external view returns (IProfileMemberManagement.ProfileMemberInfo memory) {\n    IACLCommons.ProfileEntity storage profileEntity = data.profiles[profileId];\n    (IACLCommons.ProfileMemberEntity storage member, bool result) = profileEntity.profileMemberTryReadSlot(memberId);\n    if (!result || profileEntity.acstat == IACLCommons.ActivityStatus.NONE) {\n      return\n        IProfileMemberManagement.ProfileMemberInfo({\n          adminId: bytes32(0),\n          account: address(0),\n          typeLimit: 0,\n          typeCount: 0,\n          callLimit: 0,\n          registerLimit: IACLCommons.ProfileRegisterLimit({\n            memberRegisterLimit: 0,\n            roleRegisterLimit: 0,\n            typeRegisterLimit: 0,\n            functionRegisterLimit: 0,\n            contextRegisterLimit: 0,\n            realmRegisterLimit: 0,\n            domainRegisterLimit: 0,\n            policyRegisterLimit: 0\n          }),\n          adminType: IACLCommons.AgentType.NONE,\n          atype: IACLCommons.AgentType.NONE,\n          acstat: IACLCommons.ActivityStatus.NONE,\n          alstat: IACLCommons.AlterabilityStatus.NONE\n        });\n    }\n\n    return\n      IProfileMemberManagement.ProfileMemberInfo({\n        adminId: member.ba.adminId,\n        account: member.account,\n        typeLimit: member.typeLimit,\n        typeCount: uint16(member.types.length()),\n        callLimit: member.callLimit,\n        registerLimit: IACLCommons.ProfileRegisterLimit({\n          memberRegisterLimit: member.registerLimits.memberRegisterLimit,\n          roleRegisterLimit: member.registerLimits.roleRegisterLimit,\n          typeRegisterLimit: member.registerLimits.typeRegisterLimit,\n          functionRegisterLimit: member.registerLimits.functionRegisterLimit,\n          contextRegisterLimit: member.registerLimits.contextRegisterLimit,\n          realmRegisterLimit: member.registerLimits.realmRegisterLimit,\n          domainRegisterLimit: member.registerLimits.domainRegisterLimit,\n          policyRegisterLimit: member.registerLimits.policyRegisterLimit\n        }),\n        adminType: profileEntity.agents[member.ba.adminId].atype,\n        atype: member.ba.atype,\n        acstat: member.ba.acstat,\n        alstat: member.ba.alstat\n      });\n  }\n\n  function profileMemberCheckAdmin(\n    ACLStorage.DataCollection storage data,\n    bytes32 profileId,\n    bytes32 memberId,\n    address account\n  ) external view returns (bool) {\n    IACLCommons.ProfileEntity storage profileEntity = data.profiles[profileId];\n    if (profileEntity.acstat == IACLCommons.ActivityStatus.NONE) return false;\n    if (profileEntity.agents[memberId].atype != IACLCommons.AgentType.MEMBER) return false;\n\n    bytes32 memberAdminId = profileEntity.agents[memberId].adminId;\n    IACLCommons.AgentType adminAgenType = profileEntity.agents[memberAdminId].atype;\n    bytes32 accountId = LACLUtils.accountGenerateId(account);\n\n    if (adminAgenType == IACLCommons.AgentType.ROLE) {\n      (IACLCommons.RoleEntity storage roleEntity, bool result) = profileEntity.profileRoleTryReadSlot(memberAdminId);\n      if (!result) return false;\n\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(\n        roleEntity.typeId\n      );\n      if (!result1) return false;\n\n      return typeEntity.members[accountId] == memberAdminId;\n    } else if (adminAgenType == IACLCommons.AgentType.TYPE) {\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(memberAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[accountId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function updateProfileAccount(\n    ACLStorage.DataCollection storage data,\n    IACLCommons.ProfileMemberEntity storage profileMemberEntity,\n    bytes32 profileId,\n    bytes32 typeId,\n    bool isRevoke\n  ) external {\n    return _updateProfileAccount(data, profileMemberEntity, profileId, typeId, isRevoke);\n  }\n\n  function _updateProfileAccount(\n    ACLStorage.DataCollection storage data,\n    IACLCommons.ProfileMemberEntity storage profileMemberEntity,\n    bytes32 profileId,\n    bytes32 typeId,\n    bool isRevoke\n  ) private {\n    IACLCommons.ProfileAccount storage profileAccount = data.profileAccounts[profileMemberEntity.account];\n    require(profileAccount.profiles.length > 0, \"ProfileAccount Not Found\");\n    bool findFlag = false;\n    for (uint256 i = 0; i < profileAccount.profiles.length; i++) {\n      if (profileAccount.profiles[i] == profileId) {\n        findFlag = true;\n        if (!isRevoke) {\n          if (\n            (profileMemberEntity.types.contains(LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID) ||\n              profileMemberEntity.types.contains(LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID)) &&\n            (typeId == LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID || typeId == LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID)\n          ) {\n            revert(\"Illegal GrantMemberType\");\n          }\n        } else {\n          if (profileAccount.profiles.length > 1) {\n            if (i < profileAccount.profiles.length - 1)\n              profileAccount.profiles[i] = profileAccount.profiles[profileAccount.profiles.length - 1];\n            profileAccount.profiles.pop();\n          } else {\n            profileAccount.profiles.pop();\n            delete profileAccount.profiles;\n          }\n        }\n        break;\n      }\n    }\n\n    require(findFlag, \"Illegal ProfileAccount\");\n  }\n\n  function _doProfileGetAndCheckRequestScope(\n    IACLCommons.ProfileEntity storage profileEntity,\n    bytes32 requestScopeId,\n    bytes32 senderScopeId,\n    IACLCommons.ScopeType senderScopeType,\n    bytes32 profileId\n  ) private view returns (IACLCommons.BaseScope storage) {\n    // checking requested type scope\n    IACLCommons.BaseScope storage requestedScope = profileEntity.scopes[requestScopeId];\n    require(requestedScope.stype != IACLCommons.ScopeType.NONE, \"Scope Not Found\");\n    require(requestedScope.acstat > IACLCommons.ActivityStatus.DELETED, \"Deleted\");\n\n    require(requestedScope.stype <= senderScopeType, \"Illegal ScopeType\");\n    if (requestedScope.stype == senderScopeType) {\n      require(requestScopeId == senderScopeId, \"Illegal Scope\");\n    } else {\n      require(\n        IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, senderScopeId, requestScopeId),\n        \"Illegal Scope\"\n      );\n    }\n\n    return requestedScope;\n  }\n\n  function _getProfileRealmAdmin(\n    IACLCommons.ProfileEntity storage profileEntity,\n    bytes32 requestScopeAdmin,\n    bytes32 domainId,\n    bytes32 adminId\n  ) private view returns (bytes32 realmAdminId) {\n    // checking requested context admin\n    if (adminId != bytes32(0)) {\n      require(profileEntity.agents[adminId].atype > IACLCommons.AgentType.MEMBER, \"Illegal Admin AgentType\");\n\n      (IACLCommons.ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doGetAgentScopeInfo(\n        profileEntity,\n        adminId\n      );\n      require(IACLCommons.ScopeType.DOMAIN <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n      if (IACLCommons.ScopeType.DOMAIN == requestAdminScopeType) {\n        require(requestAdminScopeId == domainId, \"Illegal Admin Scope\");\n      } else {\n        require(requestAdminScopeId == LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Admin Scope\");\n      }\n      realmAdminId = adminId;\n    } else {\n      realmAdminId = requestScopeAdmin;\n    }\n  }\n\n  function _doProfileCheckAdminAccess(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IACLCommons.FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) private view returns (IProfileACL.ProfileAdminAccessStatus) {\n    // owners always access to all entities to modify those\n    if (profileEntity.admins.contains(senderId)) return IProfileACL.ProfileAdminAccessStatus.PERMITTED;\n\n    IACLCommons.AgentType adminAgentType = profileEntity.agents[adminId].atype;\n    if (adminAgentType == IACLCommons.AgentType.ROLE) {\n      (IACLCommons.RoleEntity storage roleEntity, bool result) = profileEntity.profileRoleTryReadSlot(adminId);\n      if (!result) return IProfileACL.ProfileAdminAccessStatus.ROLE_NOT_FOUND;\n      if (roleEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IProfileACL.ProfileAdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN;\n\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(\n        roleEntity.typeId\n      );\n      if (!result1) return IProfileACL.ProfileAdminAccessStatus.TYPE_NOT_FOUND;\n      if (typeEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IProfileACL.ProfileAdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN;\n\n      if (typeEntity.members[senderId] != adminId) return IProfileACL.ProfileAdminAccessStatus.NOT_PERMITTED;\n\n      IACLCommons.PolicyEntity storage policyEntity = profileEntity.policies[profileEntity.rolePolicyMap[adminId]];\n      if (\n        policyEntity.acstat == IACLCommons.ActivityStatus.ENABLED &&\n        policyEntity.policyCode >= functionEntity.policyCode\n      ) return IProfileACL.ProfileAdminAccessStatus.POLICY_FORBIDDEN;\n\n      return IProfileACL.ProfileAdminAccessStatus.PERMITTED;\n    } else if (adminAgentType == IACLCommons.AgentType.TYPE) {\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(adminId);\n      if (!result1) return IProfileACL.ProfileAdminAccessStatus.TYPE_NOT_FOUND;\n      if (typeEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IProfileACL.ProfileAdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN;\n\n      bytes32 roleId = typeEntity.members[senderId];\n      (IACLCommons.RoleEntity storage roleEntity, bool result2) = profileEntity.profileRoleTryReadSlot(roleId);\n      if (!result2) return IProfileACL.ProfileAdminAccessStatus.ROLE_NOT_FOUND;\n      if (roleEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IProfileACL.ProfileAdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN;\n\n      IACLCommons.PolicyEntity storage policyEntity = profileEntity.policies[profileEntity.rolePolicyMap[roleId]];\n      if (\n        policyEntity.acstat == IACLCommons.ActivityStatus.ENABLED &&\n        policyEntity.policyCode >= functionEntity.policyCode\n      ) return IProfileACL.ProfileAdminAccessStatus.POLICY_FORBIDDEN;\n\n      return IProfileACL.ProfileAdminAccessStatus.PERMITTED;\n    }\n\n    return IProfileACL.ProfileAdminAccessStatus.NOT_PERMITTED;\n  }\n\n  function _doGetContextAdmin(\n    IACLCommons.ProfileEntity storage profileEntity,\n    IProfileContextManagement.ProfileContextRegisterRequest calldata request,\n    bytes32 profileId,\n    bytes32 scopeId,\n    bytes32 realmAdminId\n  ) private view returns (bytes32 contextAdminId) {\n    // checking requested context admin\n    if (request.adminId != bytes32(0)) {\n      require(profileEntity.agents[request.adminId].atype > IACLCommons.AgentType.MEMBER, \"Illegal Admin AgentType\");\n      (IACLCommons.ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doGetAgentScopeInfo(\n        profileEntity,\n        request.adminId\n      );\n      require(IACLCommons.ScopeType.REALM <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n      if (IACLCommons.ScopeType.REALM == requestAdminScopeType) {\n        require(requestAdminScopeId == request.realmId, \"Illegal Admin Scope\");\n      } else {\n        require(\n          IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, requestAdminScopeId, scopeId),\n          \"Illegal Admin Scope\"\n        );\n      }\n      contextAdminId = request.adminId;\n    } else {\n      contextAdminId = realmAdminId;\n    }\n  }\n\n  function _doGetAgentScopeInfo(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    private\n    view\n    returns (IACLCommons.ScopeType, bytes32)\n  {\n    IACLCommons.AgentType atype = profileEntity.agents[agentId].atype;\n    if (atype == IACLCommons.AgentType.ROLE) {\n      IACLCommons.RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(agentId);\n      IACLCommons.BaseScope storage baseScope = profileEntity.scopes[roleEntity.scopeId];\n      return (baseScope.stype, roleEntity.scopeId);\n    } else if (atype == IACLCommons.AgentType.TYPE) {\n      IACLCommons.TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(agentId);\n      IACLCommons.BaseScope storage baseScope = profileEntity.scopes[typeEntity.scopeId];\n      return (baseScope.stype, typeEntity.scopeId);\n    }\n\n    return (IACLCommons.ScopeType.NONE, bytes32(0));\n  }\n\n  function _doCheckContextSystemScope(\n    IACLCommons.ProfileEntity storage profileEntity,\n    bytes32 scopeId,\n    bytes32 memberId,\n    bytes32 profileId\n  ) private view returns (bool) {\n    IACLCommons.TypeEntity storage systemType = profileEntity.profileTypeReadSlot(LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID);\n    bytes32 memberRoleId = systemType.members[memberId];\n    IACLCommons.RoleEntity storage memberSystemRole = profileEntity.profileRoleReadSlot(memberRoleId);\n    if (profileEntity.scopes[memberSystemRole.scopeId].stype < IACLCommons.ScopeType.REALM) return false;\n    if (memberSystemRole.scopeId == scopeId) {\n      return true;\n    }\n\n    return IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, memberSystemRole.scopeId, scopeId);\n  }\n\n  function _doCheckAgentId(\n    IACLCommons.ProfileEntity storage profileEntity,\n    bytes32 profileId,\n    bytes32 agentId,\n    bytes32 contextId\n  ) private view {\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\n    require(ba.atype > IACLCommons.AgentType.MEMBER, \"Illegal AgentId\");\n\n    (IACLCommons.ScopeType requestAgentScopeType, bytes32 requestAgentScopeId) = _doGetAgentScopeInfo(\n      profileEntity,\n      agentId\n    );\n    require(IACLCommons.ScopeType.CONTEXT <= requestAgentScopeType, \"Illegal Agent ScopeType\");\n    if (IACLCommons.ScopeType.CONTEXT == requestAgentScopeType) {\n      require(requestAgentScopeId == contextId, \"Illegal Agent Scope\");\n    } else {\n      require(\n        IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, requestAgentScopeId, contextId),\n        \"Illegal Agent Scope\"\n      );\n    }\n  }\n\n  function _doGetAndCheckFunctionAdmin(\n    IACLCommons.ProfileEntity storage profileEntity,\n    bytes32 contextAdminId,\n    bytes32 contextId,\n    bytes32 requestAdminId,\n    bytes32 profileId\n  ) private view returns (bytes32 functionAdminId) {\n    // checking requested functionAdmin admin\n    if (requestAdminId != bytes32(0)) {\n      require(profileEntity.agents[requestAdminId].atype > IACLCommons.AgentType.MEMBER, \"Illegal Admin AgentType\");\n\n      (IACLCommons.ScopeType requestAdminFuncType, bytes32 requestAdminFuncId) = _doGetAgentScopeInfo(\n        profileEntity,\n        requestAdminId\n      );\n      require(IACLCommons.ScopeType.CONTEXT <= requestAdminFuncType, \"Illegal Admin ScopeType\");\n\n      if (IACLCommons.ScopeType.CONTEXT == requestAdminFuncType) {\n        require(requestAdminFuncId == contextAdminId, \"Illegal Admin Scope\");\n      } else {\n        require(\n          IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, requestAdminFuncId, contextId),\n          \"Illegal Admin Scope\"\n        );\n      }\n      functionAdminId = requestAdminId;\n    } else {\n      functionAdminId = contextAdminId;\n    }\n  }\n\n  function _doDomainAgentGetScopeInfo(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\n    private\n    view\n    returns (bytes32)\n  {\n    IACLCommons.AgentType atype = profileEntity.agents[agentId].atype;\n    if (atype == IACLCommons.AgentType.ROLE) {\n      IACLCommons.RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(agentId);\n      return roleEntity.scopeId;\n    } else if (atype == IACLCommons.AgentType.TYPE) {\n      IACLCommons.TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(agentId);\n      return typeEntity.scopeId;\n    }\n\n    return bytes32(0);\n  }\n}\n"
    },
    "src/contracts/acl/profile/agent/ProfileTypeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IProfileMemberManagement.sol\";\nimport \"./IProfileTypeManagement.sol\";\nimport \"../IProfileACL.sol\";\nimport \"../IProfileACLGenerals.sol\";\nimport \"../ProfileAccessControl.sol\";\nimport \"../scope/IProfileFunctionManagement.sol\";\nimport \"../../ACLStorage.sol\";\nimport \"../../../lib/acl/LProfileStorage.sol\";\nimport \"../../../lib/acl/LACLStorage.sol\";\nimport \"../../../lib/acl/LACLUtils.sol\";\nimport \"../../../lib/acl/LProfileCommons.sol\";\nimport \"../../../lib/struct/LEnumerableSet.sol\";\nimport \"../../../proxy/IProxy.sol\";\nimport \"../../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Profile ACL Type Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ProfileTypeManager is ACLStorage, BaseUUPSProxy, IProfileTypeManagement {\n  using LACLStorage for DataCollection;\n  using LProfileStorage for ProfileEntity;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IProfileTypeManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  function profileTypeRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileTypeRegisterRequest[] calldata requests\n  ) external returns (bool) {\n    (ProfileEntity storage profileEntity, , bytes32 profileId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IProfileTypeManagement.profileTypeRegister.selector\n    );\n\n    // check profile and type limitations and update it\n    ProfileMemberEntity storage profileMemberEntity = profileEntity.profileMemberReadSlot(senderId);\n    require(profileMemberEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Member Updatable\");\n    require(profileEntity.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Profile Updatable\");\n    require(\n      int32(profileMemberEntity.registerLimits.typeRegisterLimit) - int16(uint16(requests.length)) >= 0,\n      \"Illegal Member TypeRegisterLimit\"\n    );\n    require(\n      int32(profileEntity.registerLimits.typeRegisterLimit) - int16(uint16(requests.length)) >= 0,\n      \"Illegal Profile TypeRegisterLimit\"\n    );\n    profileMemberEntity.registerLimits.typeRegisterLimit -= uint16(requests.length);\n    unchecked {\n      profileEntity.registerLimits.typeRegisterLimit -= uint16(requests.length);\n    }\n\n    // fetch scope type and scope id of sender\n    (ScopeType senderScopeType, bytes32 senderScopeId) = _doGetMemberScopeInfoFromType(\n      profileEntity,\n      _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID,\n      senderId\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      _doProfileTypeRegister(requests[i], profileEntity, profileId, senderScopeType, senderScopeId, sender);\n    }\n    return true;\n  }\n\n  function profileTypeUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileTypeManagement.profileTypeUpdateAdmin.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      TypeEntity storage typeEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].entityId,\n        senderId\n      );\n\n      // checking requested type admin\n      typeEntity.ba.adminId = _getTypeAdmin(\n        profileEntity,\n        profileEntity.scopes[typeEntity.scopeId].stype,\n        profileEntity.scopes[typeEntity.scopeId].adminId,\n        typeEntity.scopeId,\n        requests[i].adminId,\n        profileId\n      );\n\n      emit ProfileTypeAdminUpdated(sender, profileId, requests[i].entityId, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function profileTypeUpdateScope(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateScopeRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileTypeManagement.profileTypeUpdateScope.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      _doTypeUpdateScope(requests[i], profileEntity, functionEntity, profileId, senderId, sender);\n    }\n    return true;\n  }\n\n  function profileTypeUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileTypeManagement.profileTypeUpdateActivityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      require(requests[i].entityId != _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID, \"Illegal Type\");\n\n      TypeEntity storage typeEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].entityId,\n        senderId\n      );\n\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      typeEntity.ba.acstat = requests[i].acstat;\n      emit ProfileTypeActivityUpdated(sender, profileId, requests[i].entityId, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function profileTypeUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileTypeManagement.profileTypeUpdateAlterabilityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(requests[i].entityId);\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        typeEntity.ba.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      typeEntity.ba.alstat = requests[i].alstat;\n      emit ProfileTypeAlterabilityUpdated(sender, profileId, requests[i].entityId, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function profileTypeUpdateRoleLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileTypeUpdateRoleLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileTypeManagement.profileTypeUpdateRoleLimit.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      TypeEntity storage typeEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].typeId,\n        senderId\n      );\n      require(requests[i].roleLimit > typeEntity.roles.length(), \"Illegal Limit\");\n      typeEntity.roleLimit = requests[i].roleLimit;\n      emit ProfileTypeRoleLimitUpdated(sender, profileId, requests[i].typeId, requests[i].roleLimit);\n    }\n    return true;\n  }\n\n  function profileTypeRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata types)\n    external\n    returns (bool)\n  {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileTypeManagement.profileTypeRemove.selector);\n    for (uint256 i = 0; i < types.length; i++) {\n      TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(types[i]);\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        typeEntity.ba.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n      require(typeEntity.roles.length() == 0, \"Illegal Remove\");\n\n      BaseScope storage typeScope = profileEntity.scopes[typeEntity.scopeId];\n      require(typeScope.referredByAgent > 0, \"Illeagl Referred\");\n      unchecked {\n        typeScope.referredByAgent -= 1;\n      }\n\n      delete typeEntity.ba;\n      delete typeEntity.scopeId;\n      delete typeEntity.name;\n      delete typeEntity.roleLimit;\n      delete typeEntity.roles;\n\n      emit ProfileTypeRemoved(sender, profileId, types[i]);\n    }\n    return true;\n  }\n\n  function profileTypeCheckId(bytes32 profileId, bytes32 typeId) external view returns (bool) {\n    return _data.profiles[profileId].agents[typeId].atype == AgentType.TYPE;\n  }\n\n  function profileTypeCheckName(bytes32 profileId, string calldata typeName) external view returns (bool) {\n    return _data.profiles[profileId].agents[keccak256(abi.encodePacked(typeName))].atype == AgentType.TYPE;\n  }\n\n  function profileTypeCheckAdmin(\n    bytes32 profileId,\n    bytes32 typeId,\n    address account\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    if (profileEntity.agents[typeId].atype != AgentType.TYPE) return false;\n\n    bytes32 typeAdminId = profileEntity.agents[typeId].adminId;\n    AgentType adminAgentType = profileEntity.agents[typeAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (adminAgentType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result) = profileEntity.profileRoleTryReadSlot(typeAdminId);\n      if (!result) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == typeAdminId;\n    } else if (adminAgentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(typeAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function profileTypeHasAccount(\n    bytes32 profileId,\n    bytes32 typeId,\n    address account\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    (TypeEntity storage te, bool result) = profileEntity.profileTypeTryReadSlot(typeId);\n    if (!result) return false;\n    return te.members[LACLUtils.accountGenerateId(account)] != bytes32(0);\n  }\n\n  function profileTypeHasRole(\n    bytes32 profileId,\n    bytes32 typeId,\n    bytes32 roleId\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    (TypeEntity storage te, bool result) = profileEntity.profileTypeTryReadSlot(typeId);\n    if (!result) return false;\n    return te.roles.contains(roleId);\n  }\n\n  function profileTypeGetRoles(bytes32 profileId, bytes32 typeId) external view returns (bytes32[] memory) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return new bytes32[](0);\n    (TypeEntity storage te, bool result) = profileEntity.profileTypeTryReadSlot(typeId);\n    if (!result) return new bytes32[](0);\n    return te.roles.values();\n  }\n\n  function profileTypeGetInfo(bytes32 profileId, bytes32 typeId) external view returns (ProfileTypeInfo memory) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    (TypeEntity storage te, bool result) = profileEntity.profileTypeTryReadSlot(typeId);\n    if (!result || profileEntity.acstat == ActivityStatus.NONE) {\n      return\n        ProfileTypeInfo({\n          scopeId: bytes32(0),\n          adminId: bytes32(0),\n          roleLimit: 0,\n          roleCount: 0,\n          adminType: AgentType.NONE,\n          atype: AgentType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE,\n          name: \"\"\n        });\n    }\n\n    return\n      ProfileTypeInfo({\n        scopeId: te.scopeId,\n        adminId: te.ba.adminId,\n        roleLimit: te.roleLimit,\n        roleCount: uint16(te.roles.length()),\n        adminType: profileEntity.agents[te.ba.adminId].atype,\n        atype: te.ba.atype,\n        acstat: te.ba.acstat,\n        alstat: te.ba.alstat,\n        name: te.name\n      });\n  }\n\n  function _doAgentGetScopeInfo(ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (ScopeType, bytes32)\n  {\n    AgentType atype = profileEntity.agents[agentId].atype;\n    if (atype == AgentType.ROLE) {\n      RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(agentId);\n      BaseScope storage baseScope = profileEntity.scopes[roleEntity.scopeId];\n      return (baseScope.stype, roleEntity.scopeId);\n    } else if (atype == AgentType.TYPE) {\n      TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(agentId);\n      BaseScope storage baseScope = profileEntity.scopes[typeEntity.scopeId];\n      return (baseScope.stype, typeEntity.scopeId);\n    }\n\n    return (ScopeType.NONE, bytes32(0));\n  }\n\n  function _doCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) internal view returns (IProfileACL.ProfileAdminAccessStatus) {\n    return LProfileCommons.profileCheckAdminAccess(profileEntity, functionEntity, adminId, senderId);\n  }\n\n  function _accessPermission(ProfileMemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      ProfileEntity storage,\n      FunctionEntity storage,\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(bytes(memberSign.profileName).length > 0, \"Illegal ProfileName\");\n\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getProfileMemeberSignerAddress(memberSign, PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    bytes32 profileId = LACLUtils.generateId(memberSign.profileName);\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n\n    ProfileAccessControl(payable(address(this))).profileAclHasMemberAccess(profileId, functionId, senderId);\n\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    FunctionEntity storage functionEntity = _data.functionReadSlot(functionId);\n    return (profileEntity, functionEntity, profileId, senderId, signer);\n  }\n\n  function _getTypeAdmin(\n    ProfileEntity storage profileEntity,\n    ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId,\n    bytes32 profileId\n  ) internal view returns (bytes32 typeAdminId) {\n    // checking requested type admin\n    if (adminId != bytes32(0)) {\n      require(profileEntity.agents[adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n      (ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doAgentGetScopeInfo(profileEntity, adminId);\n      require(requestScopeType <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n      if (requestScopeType == requestAdminScopeType) {\n        require(requestAdminScopeId == scopeId, \"Illegal Admin Scope\");\n      } else {\n        require(\n          IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, requestAdminScopeId, scopeId),\n          \"Illegal Admin Scope\"\n        );\n      }\n      typeAdminId = adminId;\n    } else {\n      typeAdminId = requestScopeAdmin;\n    }\n  }\n\n  function _doGetMemberScopeInfoFromType(\n    ProfileEntity storage profileEntity,\n    bytes32 typeId,\n    bytes32 senderId\n  ) internal view returns (ScopeType, bytes32) {\n    TypeEntity storage agentType = profileEntity.profileTypeReadSlot(typeId);\n    bytes32 memberRoleId = agentType.members[senderId];\n    RoleEntity storage memberAgentRole = profileEntity.profileRoleReadSlot(memberRoleId);\n    return (profileEntity.scopes[memberAgentRole.scopeId].stype, memberAgentRole.scopeId);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 typeId,\n    bytes32 senderId\n  ) internal view returns (TypeEntity storage) {\n    TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(typeId);\n    require(typeEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      typeEntity.ba.adminId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    return typeEntity;\n  }\n\n  function _getAndCheckRequestScope(\n    ProfileEntity storage profileEntity,\n    bytes32 requestScopeId,\n    bytes32 senderScopeId,\n    ScopeType senderScopeType,\n    bytes32 profileId\n  ) internal returns (BaseScope storage) {\n    // checking requested type scope\n    BaseScope storage requestedScope = profileEntity.scopes[requestScopeId];\n    require(requestedScope.stype != ScopeType.NONE, \"Not Found\");\n    require(requestedScope.acstat > ActivityStatus.DELETED, \"Scope Deleted\");\n\n    // increase referred count to target scope\n    requestedScope.referredByAgent += 1;\n\n    // check sender scope with request scope\n    require(senderScopeType >= requestedScope.stype, \"Illegal Sender ScopeType\");\n    if (senderScopeType == requestedScope.stype) {\n      require(senderScopeId == requestScopeId, \"Illegal Sender Scope\");\n    } else {\n      require(\n        IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, senderScopeId, requestScopeId),\n        \"Illegal Admin Scope\"\n      );\n    }\n\n    return requestedScope;\n  }\n\n  function _doProfileTypeRegister(\n    ProfileTypeRegisterRequest calldata typeRequest,\n    ProfileEntity storage profileEntity,\n    bytes32 profileId,\n    ScopeType senderScopeType,\n    bytes32 senderScopeId,\n    address sender\n  ) internal {\n    bytes32 newTypeId = LACLUtils.generateId(typeRequest.name);\n    require(profileEntity.agents[newTypeId].atype == AgentType.NONE, \"Already Exist\");\n\n    // checking requested type scope\n    BaseScope storage requestedScope = _getAndCheckRequestScope(\n      profileEntity,\n      typeRequest.scopeId,\n      senderScopeId,\n      senderScopeType,\n      profileId\n    );\n\n    // create new type\n    TypeEntity storage newType = profileEntity.profileTypeWriteSlot(newTypeId);\n    newType.ba.atype = AgentType.TYPE;\n    newType.ba.acstat = ActivityStatus.ENABLED;\n    newType.ba.alstat = AlterabilityStatus.UPDATABLE;\n    newType.scopeId = typeRequest.scopeId;\n    newType.roleLimit = typeRequest.roleLimit >= 0\n      ? uint16(uint24(typeRequest.roleLimit))\n      : profileEntity.limits.typeRoleLimit;\n    newType.name = typeRequest.name;\n    newType.ba.adminId = _getTypeAdmin(\n      profileEntity,\n      requestedScope.stype,\n      requestedScope.adminId,\n      typeRequest.scopeId,\n      typeRequest.adminId,\n      profileId\n    );\n\n    emit ProfileTypeRegistered(sender, profileId, newTypeId, typeRequest.scopeId, typeRequest.adminId);\n  }\n\n  function _doTypeUpdateScope(\n    ProfileUpdateScopeRequest calldata request,\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 profileId,\n    bytes32 senderId,\n    address sender\n  ) internal {\n    ScopeType senderScopeType;\n    bytes32 senderScopeId;\n\n    TypeEntity storage typeEntity = _doGetEntityAndCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      request.entityId,\n      senderId\n    );\n\n    AgentType adminAgentType = profileEntity.agents[typeEntity.ba.adminId].atype;\n    if (adminAgentType == AgentType.ROLE) {\n      RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(typeEntity.ba.adminId);\n      senderScopeId = roleEntity.scopeId;\n      senderScopeType = profileEntity.scopes[roleEntity.scopeId].stype;\n    } else {\n      TypeEntity storage agentType = profileEntity.profileTypeReadSlot(typeEntity.ba.adminId);\n      bytes32 memberRoleId = agentType.members[senderId];\n      RoleEntity storage memberAgentRole = profileEntity.profileRoleReadSlot(memberRoleId);\n      senderScopeType = profileEntity.scopes[memberAgentRole.scopeId].stype;\n      senderScopeId = memberAgentRole.scopeId;\n    }\n\n    BaseScope storage requestScope = _getAndCheckRequestScope(\n      profileEntity,\n      request.scopeId,\n      senderScopeId,\n      senderScopeType,\n      profileId\n    );\n    BaseScope storage currentScope = profileEntity.scopes[typeEntity.scopeId];\n    if (typeEntity.roles.length() > 0) {\n      require(requestScope.stype > currentScope.stype, \"Illegal ScopeType\");\n      require(\n        IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, request.scopeId, typeEntity.scopeId),\n        \"Illegal Scope\"\n      );\n    }\n    require(currentScope.referredByAgent > 0, \"Illeagl Referred\");\n    unchecked {\n      currentScope.referredByAgent -= 1;\n    }\n    typeEntity.scopeId = request.scopeId;\n    emit ProfileTypeScopeUpdated(sender, profileId, request.entityId, request.scopeId);\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LProfileCommons);\n  }\n}\n"
    },
    "src/contracts/acl/profile/scope/ProfileFunctionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IProfileFunctionManagement.sol\";\nimport \"../IProfileACL.sol\";\nimport \"../IProfileACLGenerals.sol\";\nimport \"../ProfileAccessControl.sol\";\nimport \"../../ACLStorage.sol\";\nimport \"../../../lib/acl/LProfileStorage.sol\";\nimport \"../../../lib/acl/LACLStorage.sol\";\nimport \"../../../lib/cryptography/LECDSA.sol\";\nimport \"../../../lib/struct/LEnumerableSet.sol\";\nimport \"../../../lib/acl/LACLUtils.sol\";\nimport \"../../../lib/acl/LProfileCommons.sol\";\nimport \"../../../lib/proxy/LClones.sol\";\nimport \"../../../proxy/IProxy.sol\";\nimport \"../../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Function Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ProfileFunctionManager is ACLStorage, BaseUUPSProxy, IProfileFunctionManagement {\n  using LACLStorage for DataCollection;\n  using LProfileStorage for ProfileEntity;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LClones for address;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IProfileFunctionManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  function profileFunctionRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileFunctionRegisterRequest[] calldata requests\n  ) external returns (bool) {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(bytes(memberSign.profileName).length > 0, \"Illegal ProfileName\");\n    bytes32 profileId = LACLUtils.generateId(memberSign.profileName);\n\n    address signer;\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getProfileMemeberSignerAddress(memberSign, PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      address contractId;\n      if (requests[i].contractId == address(0)) {\n        if (memberSign.signature.length == 0) {\n          if (requests[i].signature.length > 0) {\n            signer = _doGetSignerAddress(\n              requests[i].signature,\n              _getPredictContextMessageHash(profileId, requests[i].deployer, requests[i].subject, requests[i].realmId)\n            );\n          } else {\n            signer = msg.sender;\n          }\n        }\n\n        contractId = requests[i].subject.predictDeterministicAddress(requests[i].salt, requests[i].deployer);\n      } else {\n        if (memberSign.signature.length == 0) {\n          if (requests[i].signature.length > 0) {\n            bytes32 structHash = _getContextMessageHash(\n              profileId,\n              requests[i].contractId,\n              LACLUtils.generateHash(requests[i].name),\n              LACLUtils.generateHash(requests[i].version),\n              requests[i].realmId\n            );\n            signer = _doGetSignerAddress(requests[i].signature, structHash);\n          } else {\n            signer = msg.sender;\n          }\n        }\n        contractId = requests[i].contractId;\n      }\n\n      bytes32 contextId = LACLUtils.accountGenerateId(contractId);\n      bytes32 signerId = LACLUtils.accountGenerateId(signer);\n\n      ProfileEntity storage profileEntity = _data.profiles[profileId];\n      {\n        address functionFacetId = _data.selectors[IProfileFunctionManagement.profileFunctionRegister.selector];\n        bytes32 functionId = LACLUtils.functionGenerateId(\n          functionFacetId,\n          IProfileFunctionManagement.profileFunctionRegister.selector\n        );\n        ProfileAccessControl(payable(address(this))).profileAclHasMemberAccess(profileId, functionId, signerId);\n      }\n\n      LProfileCommons.profileCheckMemberForFunctionRegister(\n        profileEntity,\n        uint16(requests[i].functions.length),\n        signerId\n      );\n\n      // check access system scope\n      require(_doCheckSystemScope(profileEntity, contextId, signerId, profileId), \"Forbidden\");\n\n      _doProfileFunctionRegister(profileEntity, requests[i], profileId, contextId, signer);\n    }\n    return true;\n  }\n\n  function profileFunctionUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileFunctionManagement.profileFunctionUpdateAdmin.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      FunctionEntity storage functionData = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].entityId,\n        senderId\n      );\n      functionData.bs.adminId = _doGetAndCheckFunctionAdmin(\n        profileEntity,\n        profileEntity.scopes[functionEntity.contextId].adminId,\n        functionData.contextId,\n        requests[i].adminId,\n        profileId\n      );\n      emit ProfileFunctionAdminUpdated(sender, profileId, requests[i].entityId, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function profileFunctionUpdateAgent(\n    ProfileMemberSignature calldata memberSign,\n    ProfileFunctionUpdateAgentRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileFunctionManagement.profileFunctionUpdateAgent.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      FunctionEntity storage functionData = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].functionId,\n        senderId\n      );\n      _doCheckAgentId(profileEntity, profileId, requests[i].agentId, functionData.contextId);\n      functionData.agentId = requests[i].agentId;\n      emit ProfileFunctionAgentUpdated(sender, profileId, requests[i].functionId, requests[i].agentId);\n    }\n    return true;\n  }\n\n  function profileFunctionUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileFunctionManagement.profileFunctionUpdateActivityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      FunctionEntity storage functionData = profileEntity.profileFunctionReadSlot(requests[i].entityId);\n      require(functionData.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        functionData.bs.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      functionData.bs.acstat = requests[i].acstat;\n      emit ProfileFunctionActivityUpdated(sender, profileId, requests[i].entityId, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function profileFunctionUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileFunctionManagement.profileFunctionUpdateAlterabilityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      FunctionEntity storage functionData = profileEntity.profileFunctionReadSlot(requests[i].entityId);\n      require(functionData.bs.acstat > ActivityStatus.DELETED, \"Function Deleted\");\n\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        functionData.bs.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      functionData.bs.alstat = requests[i].alstat;\n      emit ProfileFunctionAlterabilityUpdated(sender, profileId, requests[i].entityId, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function profileFunctionUpdatePolicyCode(\n    ProfileMemberSignature calldata memberSign,\n    ProfileFunctionUpdatePolicyRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileFunctionManagement.profileFunctionUpdatePolicyCode.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      FunctionEntity storage functionEntityData = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].functionId,\n        senderId\n      );\n      functionEntityData.policyCode = requests[i].policyCode;\n      emit ProfileFunctionPolicyUpdated(sender, profileId, requests[i].functionId, requests[i].policyCode);\n    }\n    return true;\n  }\n\n  function profileFunctionRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata functions)\n    external\n    returns (bool)\n  {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileFunctionManagement.profileFunctionRemove.selector);\n    for (uint256 i = 0; i < functions.length; i++) {\n      FunctionEntity storage functionEntityReq = profileEntity.profileFunctionReadSlot(functions[i]);\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        functionEntityReq.bs.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      if (functionEntityReq.bs.referredByAgent == 0) {\n        ContextEntity storage contextEntity = profileEntity.profileContextReadSlot(functionEntityReq.contextId);\n        require(contextEntity.bs.alstat == AlterabilityStatus.UPGRADABLE, \"Illegal Context Upgradable\");\n        contextEntity.functions.remove(functions[i]);\n\n        delete functionEntityReq.bs;\n        delete functionEntityReq.agentId;\n        delete functionEntityReq.contextId;\n        delete functionEntityReq.selector;\n        delete functionEntityReq.policyCode;\n        emit ProfileFunctionRemoved(sender, profileId, functions[i], false);\n      } else {\n        // Note: It's very important to prevent infinity lock state\n        require(functionEntityReq.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n        functionEntityReq.bs.acstat = ActivityStatus.DELETED;\n        emit ProfileFunctionRemoved(sender, profileId, functions[i], true);\n      }\n    }\n    return true;\n  }\n\n  function profileFunctionCheckId(bytes32 profileId, bytes32 functionId) external view returns (bool) {\n    return _data.profiles[profileId].scopes[functionId].stype == ScopeType.FUNCTION;\n  }\n\n  function profileFunctionCheckSelector(\n    bytes32 profileId,\n    address contractId,\n    bytes4 selector\n  ) external view returns (bool) {\n    return\n      _data.profiles[profileId].scopes[LACLUtils.functionGenerateId(contractId, selector)].stype == ScopeType.FUNCTION;\n  }\n\n  function profileFunctionCheckAdmin(\n    bytes32 profileId,\n    bytes32 functionId,\n    address account\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    (FunctionEntity storage fe, bool result) = profileEntity.profileFunctionTryReadSlot(functionId);\n    if (!result) return false;\n\n    return _doFunctionCheckAccount(profileEntity, fe.bs.adminId, account);\n  }\n\n  function profileFunctionCheckAgent(\n    bytes32 profileId,\n    bytes32 functionId,\n    address account\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    (FunctionEntity storage fe, bool result) = profileEntity.profileFunctionTryReadSlot(functionId);\n    if (!result) return false;\n\n    return _doFunctionCheckAccount(profileEntity, fe.agentId, account);\n  }\n\n  function _doFunctionCheckAccount(\n    ProfileEntity storage profileEntity,\n    bytes32 agentId,\n    address account\n  ) internal view returns (bool) {\n    AgentType agentType = profileEntity.agents[agentId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (agentType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result) = profileEntity.profileRoleTryReadSlot(agentId);\n      if (!result) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == agentId;\n    } else if (agentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(agentId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function profileFunctionGetInfo(bytes32 profileId, bytes32 functionId)\n    external\n    view\n    returns (ProfileFunctionInfo memory)\n  {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    (FunctionEntity storage fe, bool result) = profileEntity.profileFunctionTryReadSlot(functionId);\n    if (!result || profileEntity.acstat == ActivityStatus.NONE) {\n      return\n        ProfileFunctionInfo({\n          adminId: bytes32(0),\n          agentId: bytes32(0),\n          contextId: bytes32(0),\n          selector: bytes4(0),\n          referredByAgent: 0,\n          stype: ScopeType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE,\n          adminType: AgentType.NONE,\n          agentType: AgentType.NONE,\n          policyCode: 0\n        });\n    }\n\n    return\n      ProfileFunctionInfo({\n        adminId: fe.bs.adminId,\n        agentId: fe.agentId,\n        contextId: fe.contextId,\n        selector: fe.selector,\n        referredByAgent: fe.bs.referredByAgent,\n        stype: fe.bs.stype,\n        acstat: fe.bs.acstat,\n        alstat: fe.bs.alstat,\n        adminType: profileEntity.agents[fe.bs.adminId].atype,\n        agentType: profileEntity.agents[fe.agentId].atype,\n        policyCode: fe.policyCode\n      });\n  }\n\n  function _doGetAgentScopeInfo(ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (ScopeType, bytes32)\n  {\n    AgentType atype = profileEntity.agents[agentId].atype;\n    if (atype == AgentType.ROLE) {\n      RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(agentId);\n      BaseScope storage baseScope = profileEntity.scopes[roleEntity.scopeId];\n      return (baseScope.stype, roleEntity.scopeId);\n    } else if (atype == AgentType.TYPE) {\n      TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(agentId);\n      BaseScope storage baseScope = profileEntity.scopes[typeEntity.scopeId];\n      return (baseScope.stype, typeEntity.scopeId);\n    }\n\n    return (ScopeType.NONE, bytes32(0));\n  }\n\n  function _doCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) internal view returns (IProfileACL.ProfileAdminAccessStatus) {\n    return LProfileCommons.profileCheckAdminAccess(profileEntity, functionEntity, adminId, senderId);\n  }\n\n  function _accessPermission(ProfileMemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      ProfileEntity storage,\n      FunctionEntity storage,\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(bytes(memberSign.profileName).length > 0, \"Illegal ProfileName\");\n\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getProfileMemeberSignerAddress(memberSign, PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    bytes32 profileId = LACLUtils.generateId(memberSign.profileName);\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n\n    ProfileAccessControl(payable(address(this))).profileAclHasMemberAccess(profileId, functionId, senderId);\n\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    FunctionEntity storage functionEntity = _data.functionReadSlot(functionId);\n    return (profileEntity, functionEntity, profileId, senderId, signer);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 fId,\n    bytes32 senderId\n  ) internal view returns (FunctionEntity storage) {\n    FunctionEntity storage functionEntityData = profileEntity.profileFunctionReadSlot(fId);\n    require(functionEntityData.bs.acstat > ActivityStatus.DELETED, \"Function Deleted\");\n    require(functionEntityData.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      functionEntityData.bs.adminId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    return functionEntityData;\n  }\n\n  function _doGetAndCheckFunctionAdmin(\n    ProfileEntity storage profileEntity,\n    bytes32 contextAdminId,\n    bytes32 contextId,\n    bytes32 adminId,\n    bytes32 profileId\n  ) internal view returns (bytes32 functionAdminId) {\n    return\n      LProfileCommons.profileGetAndCheckFunctionAdmin(profileEntity, contextAdminId, contextId, adminId, profileId);\n  }\n\n  function _getContextMessageHash(\n    bytes32 profileId,\n    address contractId,\n    bytes32 name,\n    bytes32 version,\n    bytes32 realmId\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(PROFILE_CTX_MESSAGE_TYPEHASH, profileId, contractId, name, version, realmId));\n  }\n\n  function _doCheckAgentId(\n    ProfileEntity storage profileEntity,\n    bytes32 profileId,\n    bytes32 agentId,\n    bytes32 contextId\n  ) internal view {\n    BaseAgent storage ba = profileEntity.agents[agentId];\n    require(ba.atype > AgentType.MEMBER, \"Illegal AgentId\");\n\n    (ScopeType requestAgentScopeType, bytes32 requestAgentScopeId) = _doGetAgentScopeInfo(profileEntity, agentId);\n    require(ScopeType.CONTEXT <= requestAgentScopeType, \"Illegal Agent ScopeType\");\n    if (ScopeType.CONTEXT == requestAgentScopeType) {\n      require(requestAgentScopeId == contextId, \"Illegal Agent Scope\");\n    } else {\n      require(\n        IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, requestAgentScopeId, contextId),\n        \"Illegal Agent Scope\"\n      );\n    }\n  }\n\n  function _doGetSignerAddress(bytes memory signature, bytes32 structHash) internal view returns (address) {\n    bytes32 msgDigest = _hashTypedDataV4(structHash);\n    (address msgSigner, LECDSA.RecoverError recoverErr) = LECDSA.tryRecover(msgDigest, signature);\n    require(recoverErr == LECDSA.RecoverError.NoError, \"Illegal Signature\");\n    return msgSigner;\n  }\n\n  function _getPredictContextMessageHash(\n    bytes32 profileId,\n    address deployer,\n    address subject,\n    bytes32 realmId\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(PROFILE_PREDICT_CTX_MESSAGE_TYPEHASH, profileId, deployer, subject, realmId));\n  }\n\n  function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {\n    return LECDSA.toTypedDataHash(IProxy(address(this)).domainSeparator(), structHash);\n  }\n\n  function _doCheckSystemScope(\n    IACLCommons.ProfileEntity storage profileEntity,\n    bytes32 scopeId,\n    bytes32 memberId,\n    bytes32 profileId\n  ) private view returns (bool) {\n    IACLCommons.TypeEntity storage systemType = profileEntity.profileTypeReadSlot(\n      _LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID\n    );\n    bytes32 memberRoleId = systemType.members[memberId];\n    IACLCommons.RoleEntity storage memberSystemRole = profileEntity.profileRoleReadSlot(memberRoleId);\n    if (profileEntity.scopes[memberSystemRole.scopeId].stype < IACLCommons.ScopeType.CONTEXT) return false;\n    if (memberSystemRole.scopeId == scopeId) {\n      return true;\n    }\n\n    return IProfileACLGenerals(address(this)).profileIsScopesCompatible(profileId, memberSystemRole.scopeId, scopeId);\n  }\n\n  function _doProfileFunctionRegister(\n    ProfileEntity storage profileEntity,\n    ProfileFunctionRegisterRequest calldata request,\n    bytes32 profileId,\n    bytes32 contextId,\n    address signer\n  ) internal {\n    for (uint256 j = 0; j < request.functions.length; j++) {\n      bytes32 functionId = LProfileCommons.profileFunctionRegistration(\n        profileEntity,\n        request.functions[j],\n        profileId,\n        contextId\n      );\n      emit ProfileFunctionRegistered(\n        signer,\n        profileId,\n        contextId,\n        functionId,\n        request.functions[j].adminId,\n        request.functions[j].agentId\n      );\n    }\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LProfileCommons);\n  }\n}\n"
    },
    "src/contracts/lib/proxy/LClones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n */\nlibrary LClones {\n  /**\n   * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n   *\n   * This function uses the create opcode, which should never revert.\n   */\n  function clone(address implementation) internal returns (address instance) {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(ptr, 0x14), shl(0x60, implementation))\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      instance := create(0, ptr, 0x37)\n    }\n    require(instance != address(0), \"ERC1167: create failed\");\n  }\n\n  /**\n   * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n   *\n   * This function uses the create2 opcode and a `salt` to deterministically deploy\n   * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n   * the clones cannot be deployed twice at the same address.\n   */\n  function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(ptr, 0x14), shl(0x60, implementation))\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      instance := create2(0, ptr, 0x37, salt)\n    }\n    require(instance != address(0), \"ERC1167: create2 failed\");\n  }\n\n  /**\n   * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n   */\n  function predictDeterministicAddress(\n    address implementation,\n    bytes32 salt,\n    address deployer\n  ) internal pure returns (address predicted) {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(ptr, 0x14), shl(0x60, implementation))\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n      mstore(add(ptr, 0x38), shl(0x60, deployer))\n      mstore(add(ptr, 0x4c), salt)\n      mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n      predicted := keccak256(add(ptr, 0x37), 0x55)\n    }\n  }\n\n  /**\n   * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n   */\n  function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n    return predictDeterministicAddress(implementation, salt, address(this));\n  }\n}\n"
    },
    "src/contracts/token/asset/AssetManagerERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IAssetManagerERC20.sol\";\nimport \"./IAssetEntity.sol\";\nimport \"./AssetManagerStorageERC20.sol\";\nimport \"../lively/IERC20.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\nimport \"../../lib/proxy/LClones.sol\";\n\n/**\n * @title Asset Manager ERC20 Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\n\ncontract AssetManagerERC20 is AssetManagerStorageERC20, BaseUUPSProxy, IAssetManagerERC20 {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LClones for address;\n\n  struct InitRequest {\n    string contractName;\n    string contractVersion;\n    address aclManager;\n  }\n\n  constructor() {}\n\n  function initialize(InitRequest calldata request) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(request.contractName, request.contractVersion, request.aclManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      request.contractName,\n      request.contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IAssetManagerERC20).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  function registerToken(AssetTokenActionRequest[] calldata requests) external returns (bool) {\n    _policyInterceptor(this.registerToken.selector);\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      require(!_data.tokensSet.contains(requests[i].tokenId), \"Already Registered\");\n      require(requests[i].assetSignature.length > 0, \"Illegal Signature\");\n\n      if (!IERC165(requests[i].tokenId).supportsInterface(type(IERC20).interfaceId)) revert(\"Illegal ERC20\");\n\n      if (!IERC165(requests[i].assetSubjectId).supportsInterface(type(IAssetEntity).interfaceId))\n        revert(\"Illegal IAssetEntity\");\n\n      string memory tokenName = IERC20(requests[i].tokenId).name();\n      string memory tokenSymbol = IERC20(requests[i].tokenId).symbol();\n      _data.tokensSet.add(requests[i].tokenId);\n      TokenData storage tokenData = _data.tokens[requests[i].tokenId];\n      tokenData.assetSubjectId = requests[i].assetSubjectId;\n      tokenData.assetSignature = requests[i].assetSignature;\n\n      emit TokenRegistered(_msgSender(), requests[i].tokenId, requests[i].assetSubjectId, tokenName, tokenSymbol);\n    }\n    return true;\n  }\n\n  function updateToken(AssetTokenActionRequest[] calldata requests) external returns (bool) {\n    _policyInterceptor(this.updateToken.selector);\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      require(_data.tokensSet.contains(requests[i].tokenId), \"Not Found\");\n\n      if (!IERC165(requests[i].assetSubjectId).supportsInterface(type(IAssetEntity).interfaceId))\n        revert(\"Illegal IAssetEntity\");\n\n      require(requests[i].assetSignature.length > 0, \"Illegal Signature\");\n      _data.tokens[requests[i].tokenId].assetSubjectId = requests[i].assetSubjectId;\n      _data.tokens[requests[i].tokenId].assetSignature = requests[i].assetSignature;\n      emit TokenUpdated(_msgSender(), requests[i].tokenId, requests[i].assetSubjectId);\n    }\n    return true;\n  }\n\n  function createAsset(AssetCreateRequest[] calldata requests) external returns (bool) {\n    _policyInterceptor(this.createAsset.selector);\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      require(bytes(requests[i].assetName).length > 0, \"Illegal Name\");\n      require(bytes(requests[i].assetVersion).length > 0, \"Illegal Version\");\n      require(requests[i].tokenId != address(0), \"Illegal TokenId\");\n      require(_data.tokensSet.contains(requests[i].tokenId), \"TokenId Not Found\");\n\n      address newAsset = requests[i].assetId;\n      TokenData storage tokenData = _data.tokens[requests[i].tokenId];\n      require(\n        !tokenData.assets.contains(tokenData.assetSubjectId.predictDeterministicAddress(requests[i].salt)),\n        \"Already Exists\"\n      );\n\n      IAssetEntity.AssetInitRequest memory initRequest = IAssetEntity.AssetInitRequest({\n        contractName: requests[i].assetName,\n        contractVersion: requests[i].assetVersion,\n        realmId: requests[i].realmId,\n        erc20TokenId: requests[i].tokenId,\n        accessControlId: _accessControlManager,\n        assetManagerId: address(this),\n        assetContractId: newAsset,\n        adminId: requests[i].adminId,\n        agentId: requests[i].agentId,\n        salt: requests[i].salt,\n        subjectId: tokenData.assetSubjectId,\n        signature: tokenData.assetSignature\n      });\n\n      if (newAsset == address(0)) {\n        newAsset = tokenData.assetSubjectId.cloneDeterministic(requests[i].salt);\n      }\n\n      IAssetEntity(payable(newAsset)).assetInitialize(initRequest);\n      tokenData.assets.add(newAsset);\n\n      emit AssetCreated(_msgSender(), newAsset, requests[i].tokenId);\n    }\n    return true;\n  }\n\n  function registerAsset(AssetActionRequest[] calldata requests) external returns (bool) {\n    _policyInterceptor(this.registerAsset.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      require(requests[i].assetId != address(0), \"Illegal AssetId\");\n\n      if (!IERC165(requests[i].assetId).supportsInterface(type(IAssetEntity).interfaceId))\n        revert(\"Illegal IAssetEntity\");\n\n      require(_data.tokensSet.contains(requests[i].tokenId), \"Not Found\");\n\n      TokenData storage tokenData = _data.tokens[requests[i].tokenId];\n      require(!tokenData.assets.contains(requests[i].assetId), \"Already Registered\");\n\n      tokenData.assets.add(requests[i].assetId);\n      if (IAssetEntity(requests[i].assetId).assetSafeMode() == IAssetEntity.AssetSafeModeStatus.ENABLED) {\n        IAssetEntity(requests[i].assetId).assetSetSafeMode(IAssetEntity.AssetSafeModeStatus.DISABLED);\n      }\n      emit AssetRegistered(_msgSender(), requests[i].assetId, requests[i].tokenId);\n    }\n    return true;\n  }\n\n  function removeAsset(AssetActionRequest[] calldata requests) external returns (bool) {\n    _policyInterceptor(this.removeAsset.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      require(requests[i].assetId != address(0), \"Illegal AssetId\");\n      require(_data.tokensSet.contains(requests[i].tokenId), \"TokenId Not Found\");\n\n      TokenData storage tokenData = _data.tokens[requests[i].tokenId];\n      require(tokenData.assets.contains(requests[i].assetId), \"AssetId Not Found\");\n\n      tokenData.assets.remove(requests[i].assetId);\n      if (IAssetEntity(requests[i].assetId).assetSafeMode() == IAssetEntity.AssetSafeModeStatus.DISABLED) {\n        IAssetEntity(requests[i].assetId).assetSetSafeMode(IAssetEntity.AssetSafeModeStatus.ENABLED);\n      }\n      emit AssetRemoved(_msgSender(), requests[i].assetId, requests[i].tokenId);\n    }\n    return true;\n  }\n\n  function setSafeModeAssets(AssetTokenSafeModeRequest[] calldata requests) external returns (bool) {\n    _policyInterceptor(this.setSafeModeAssets.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      require(_data.tokensSet.contains(requests[i].tokenId), \"Not Found\");\n      TokenData storage tokenData = _data.tokens[requests[i].tokenId];\n      for (uint256 j = 0; j < tokenData.assets.length(); j++) {\n        IAssetEntity(tokenData.assets.at(j)).assetSetSafeMode(requests[i].status);\n      }\n    }\n    return true;\n  }\n\n  function getSafeModeAsset(address assetId) external view returns (IAssetEntity.AssetSafeModeStatus) {\n    return IAssetEntity(assetId).assetSafeMode();\n  }\n\n  function getAllTokens() external view returns (address[] memory) {\n    return _data.tokensSet.values();\n  }\n\n  function getTokenInfo(address tokenId) external view returns (TokenInfo memory) {\n    TokenData storage tokenData = _data.tokens[tokenId];\n    return\n      TokenInfo({\n        assetSubjectId: tokenData.assetSubjectId,\n        assets: tokenData.assets.values(),\n        assetSignature: tokenData.assetSignature\n      });\n  }\n\n  function isAssetExists(address assetId) external view returns (bool) {\n    return _data.tokens[IAssetEntity(assetId).assetToken()].assets.contains(assetId);\n  }\n\n  function isTokenExists(address tokenId) external view returns (bool) {\n    return _data.tokensSet.contains(tokenId);\n  }\n\n  function predictAddress(\n    address implementation,\n    bytes32 salt,\n    address deployer\n  ) external pure returns (address) {\n    return implementation.predictDeterministicAddress(salt, deployer);\n  }\n\n  function _policyInterceptor(bytes4 funcSelector) private safeModeCheck aclCheck(funcSelector) {}\n}\n"
    },
    "src/contracts/acl/profile/ProfileManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\npragma solidity 0.8.19;\n\nimport \"./IProfileACL.sol\";\nimport \"./IProfileACLGenerals.sol\";\nimport \"./IProfileManagement.sol\";\nimport \"./scope/IProfileFunctionManagement.sol\";\nimport \"./agent/IProfileRoleManagement.sol\";\nimport \"./agent/IProfileTypeManagement.sol\";\nimport \"../ACLStorage.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\nimport \"../../lib/acl/LProfileStorage.sol\";\nimport \"../../lib/acl/LACLCommons.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../lib/cryptography/LECDSA.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Profile AccessControl Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ProfileManager is ACLStorage, BaseUUPSProxy, IProfileManagement {\n  using LProfileStorage for ProfileEntity;\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IProfileManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  function profileRegister(MemberSignature calldata memberSign, ProfileRegisterRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IProfileManagement.profileRegister.selector\n    );\n\n    // update member profile register limit\n    MemberEntity storage memberEntity = _data.memberReadSlot(senderId);\n    require(\n      int32(uint32(memberEntity.limits.profileRegisterLimit)) - int16(uint16(requests.length)) >= 0,\n      \"Illegal RegisterLimit\"\n    );\n    unchecked {\n      memberEntity.limits.profileRegisterLimit -= uint16(requests.length);\n    }\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      _doProfileRegister(requests[i], sender, senderId, functionId);\n    }\n    return true;\n  }\n\n  function profileUpdateLimits(MemberSignature calldata memberSign, ProfileUpdateLimitsRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IProfileManagement.profileUpdateLimits.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      ProfileEntity storage profileEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].profileId,\n        senderId,\n        functionId\n      );\n      profileEntity.limits = requests[i].limits;\n      profileEntity.registerLimits = requests[i].registerLimits;\n      emit ProfileLimitsUpdated(sender, requests[i].profileId, requests[i].limits, requests[i].registerLimits);\n    }\n    return true;\n  }\n\n  function profileUpdateOwnerAccount(\n    MemberSignature calldata memberSign,\n    ProfileUpdateOwnerAccountRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IProfileManagement.profileUpdateOwnerAccount.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      ProfileEntity storage profileEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].profileId,\n        senderId,\n        functionId\n      );\n      address profileOwner = profileEntity.owner;\n      LACLCommons.profileUpdateOwnerAccount(_data, profileEntity, requests[i]);\n      emit ProfileOwnerAccountUpdated(sender, requests[i].profileId, profileOwner, requests[i].newOwner);\n    }\n    return true;\n  }\n\n  function profileUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IProfileManagement.profileUpdateActivityStatus.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      ProfileEntity storage profileEntity = _doGetEntityAndCheckAdminAccess(requests[i].id, senderId, functionId);\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      profileEntity.acstat = requests[i].acstat;\n      emit ProfileActivityUpdated(sender, requests[i].id, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function profileUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IProfileManagement.profileUpdateAlterabilityStatus.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      ProfileEntity storage profileEntity = _data.profiles[requests[i].id];\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(profileEntity.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      profileEntity.alstat = requests[i].alstat;\n      emit ProfileAlterabilityUpdated(sender, requests[i].id, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function profileUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IProfileManagement.profileUpdateAdmin.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      ProfileEntity storage profileEntity = _doGetEntityAndCheckAdminAccess(requests[i].id, senderId, functionId);\n\n      // checking requested domain admin\n      if (requests[i].adminId != bytes32(0)) {\n        require(_data.agents[requests[i].adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n        bytes32 requestAdminScopeId = _doAgentGetScopeInfo(requests[i].adminId);\n        require(requestAdminScopeId == _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Admin Scope\");\n        profileEntity.adminId = requests[i].adminId;\n      } else {\n        profileEntity.adminId = _LIVELY_VERSE_PROFILE_MASTER_TYPE_ID;\n      }\n\n      emit ProfileAdminUpdated(sender, requests[i].id, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function profileCheckId(bytes32 profileId) external view returns (bool) {\n    return _data.profiles[profileId].acstat != ActivityStatus.NONE;\n  }\n\n  function profileCheckName(string calldata name) external view returns (bool) {\n    return _data.profiles[LACLUtils.generateId(name)].acstat != ActivityStatus.NONE;\n  }\n\n  function profileCheckOwner(bytes32 profileId, address account) external view returns (bool) {\n    return _data.profiles[profileId].owner == account;\n  }\n\n  function profileCheckProfileAdmin(bytes32 profileId, address account) external view returns (bool) {\n    return _data.profiles[profileId].admins.contains(LACLUtils.accountGenerateId(account));\n  }\n\n  function profileCheckProfileSystemAdmin(bytes32 profileId, address account) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    (ProfileMemberEntity storage profileMemberEntity, bool result) = profileEntity.profileMemberTryReadSlot(\n      LACLUtils.accountGenerateId(account)\n    );\n    if (!result) return false;\n    return profileMemberEntity.types.contains(_LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID);\n  }\n\n  function profileCheckAdmin(bytes32 profileId, address account) external view returns (bool) {\n    return LACLCommons.profileCheckAdmin(_data, profileId, account);\n  }\n\n  function profileGetProfileAccount(address account) external view returns (bytes32[] memory) {\n    return _data.profileAccounts[account].profiles;\n  }\n\n  function profileGetAdmins(bytes32 profileId) external view returns (bytes32[] memory) {\n    return _data.profiles[profileId].admins.values();\n  }\n\n  function profileGetInfo(bytes32 profileId) external view returns (ProfileInfo memory) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) {\n      return\n        ProfileInfo({\n          name: \"\",\n          adminId: bytes32(0),\n          owner: address(0),\n          registerLimits: ProfileRegisterLimit({\n            memberRegisterLimit: 0,\n            roleRegisterLimit: 0,\n            typeRegisterLimit: 0,\n            functionRegisterLimit: 0,\n            contextRegisterLimit: 0,\n            realmRegisterLimit: 0,\n            domainRegisterLimit: 0,\n            policyRegisterLimit: 0\n          }),\n          limits: ProfileLimit({\n            profileCallLimit: 0,\n            contextLimit: 0,\n            memberLimit: 0,\n            functionLimit: 0,\n            realmLimit: 0,\n            domainLimit: 0,\n            memberCallLimit: 0,\n            typeRoleLimit: 0,\n            typeLimit: 0,\n            policyRoleLimit: 0\n          }),\n          adminType: AgentType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE\n        });\n    }\n\n    return\n      ProfileInfo({\n        name: profileEntity.name,\n        adminId: profileEntity.adminId,\n        owner: profileEntity.owner,\n        registerLimits: profileEntity.registerLimits,\n        limits: profileEntity.limits,\n        adminType: _data.agents[profileEntity.adminId].atype,\n        acstat: profileEntity.acstat,\n        alstat: profileEntity.alstat\n      });\n  }\n\n  function _doCheckAdminAccess(\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) internal view returns (IACL.AdminAccessStatus) {\n    return LACLCommons.checkAdminAccess(_data, adminId, memberId, functionId);\n  }\n\n  function _accessPermission(MemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getMemeberSignerAddress(memberSign, MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n    IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, senderId);\n    if (status != IACL.AuthorizationStatus.PERMITTED) LACLUtils.generateAuthorizationError(status);\n    return (functionId, senderId, signer);\n  }\n\n  function _doAgentGetScopeInfo(bytes32 agentId) internal view returns (bytes32) {\n    AgentType atype = _data.agents[agentId].atype;\n    if (atype == AgentType.ROLE) {\n      RoleEntity storage roleEntity = _data.roleReadSlot(agentId);\n      return roleEntity.scopeId;\n    } else if (atype == AgentType.TYPE) {\n      TypeEntity storage typeEntity = _data.typeReadSlot(agentId);\n      return typeEntity.scopeId;\n    }\n\n    return bytes32(0);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    bytes32 profileId,\n    bytes32 senderId,\n    bytes32 functionId\n  ) internal view returns (ProfileEntity storage) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    require(profileEntity.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(profileEntity.adminId, senderId, functionId);\n    if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n    return profileEntity;\n  }\n\n  function _doProfileRegister(\n    ProfileRegisterRequest calldata request,\n    address sender,\n    bytes32 senderId,\n    bytes32 functionId\n  ) internal {\n    bytes32 profileId = LACLUtils.generateId(request.name);\n    require(_data.profiles[profileId].acstat == ActivityStatus.NONE, \"Already Exist\");\n    bytes32 adminId = LACLCommons.profileRegister(_data, request, senderId, profileId, functionId);\n\n    emit ProfileRegistered(\n      sender,\n      profileId,\n      request.profileOwner,\n      request.profileSystemAdmin,\n      adminId,\n      request.registerLimits,\n      request.limits\n    );\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LACLCommons);\n  }\n}\n"
    },
    "src/contracts/utils/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"../lib/cryptography/LECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n */\nabstract contract EIP712 {\n  /* solhint-disable var-name-mixedcase */\n  // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n  // invalidate the cached domain separator if the chain id changes.\n  bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n  uint256 private immutable _CACHED_CHAIN_ID;\n  address private immutable _CACHED_THIS;\n\n  bytes32 private immutable _HASHED_NAME;\n  bytes32 private immutable _HASHED_VERSION;\n  bytes32 private immutable _TYPE_HASH;\n\n  /* solhint-enable var-name-mixedcase */\n\n  /**\n   * @dev Initializes the domain separator and parameter caches.\n   *\n   * The meaning of `name` and `version` is specified in\n   * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n   *\n   * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n   * - `version`: the current major version of the signing domain.\n   *\n   * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n   * contract upgrade].\n   */\n  constructor(string memory name, string memory version) {\n    bytes32 hashedName = keccak256(bytes(name));\n    bytes32 hashedVersion = keccak256(bytes(version));\n    bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    _HASHED_NAME = hashedName;\n    _HASHED_VERSION = hashedVersion;\n    _CACHED_CHAIN_ID = block.chainid;\n    _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n    _CACHED_THIS = address(this);\n    _TYPE_HASH = typeHash;\n  }\n\n  /**\n   * @dev Returns the domain separator for the current chain.\n   */\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n      return _CACHED_DOMAIN_SEPARATOR;\n    } else {\n      return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n    }\n  }\n\n  function _buildDomainSeparator(\n    bytes32 typeHash,\n    bytes32 nameHash,\n    bytes32 versionHash\n  ) private view returns (bytes32) {\n    return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n  }\n\n  /**\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n   * function returns the hash of the fully encoded EIP712 message for this domain.\n   *\n   * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n   *\n   * ```solidity\n   * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n   *     keccak256(\"Mail(address to,string contents)\"),\n   *     mailTo,\n   *     keccak256(bytes(mailContents))\n   * )));\n   * address signer = ECDSA.recover(digest, signature);\n   * ```\n   */\n  function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n    return LECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n}\n"
    },
    "src/contracts/lib/cryptography/LSignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"./LECDSA.sol\";\nimport \"../LAddress.sol\";\nimport \"../../utils/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n */\nlibrary LSignatureChecker {\n  /**\n   * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n   * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n   *\n   * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n   * change through time. It could return true at block N and false at block N+1 (or the opposite).\n   */\n  function isValidSignatureNow(\n    address signer,\n    bytes32 hash,\n    bytes memory signature\n  ) internal view returns (bool) {\n    (address recovered, LECDSA.RecoverError error) = LECDSA.tryRecover(hash, signature);\n    if (error == LECDSA.RecoverError.NoError && recovered == signer) {\n      return true;\n    }\n\n    (bool success, bytes memory result) = signer.staticcall(\n      abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n    );\n    return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\n  }\n}\n"
    },
    "src/contracts/utils/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n  /**\n   * @dev Should return whether the signature provided is valid for the provided data\n   * @param hash      Hash of the data to be signed\n   * @param signature Signature byte array associated with _data\n   */\n  function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "src/contracts/acl/scope/FunctionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IFunctionManagement.sol\";\nimport \"../IACL.sol\";\nimport \"../IACLGenerals.sol\";\nimport \"../ACLStorage.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../lib/acl/LACLAgentScope.sol\";\nimport \"../../lib/cryptography/LECDSA.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\nimport \"../../lib/proxy/LClones.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Function Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract FunctionManager is ACLStorage, BaseUUPSProxy, IFunctionManagement {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LClones for address;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IFunctionManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  function functionRegister(MemberSignature calldata memberSign, FunctionRegisterRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getMemeberSignerAddress(memberSign, MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      address contractId;\n      if (requests[i].contractId == address(0)) {\n        if (memberSign.signature.length == 0) {\n          if (requests[i].signature.length > 0) {\n            signer = LACLUtils.getSignerAddress(\n              requests[i].signature,\n              _getPredictContextMessageHash(requests[i].deployer, requests[i].subject, requests[i].realmId)\n            );\n          } else {\n            signer = msg.sender;\n          }\n        }\n\n        contractId = requests[i].subject.predictDeterministicAddress(requests[i].salt, requests[i].deployer);\n      } else {\n        if (memberSign.signature.length == 0) {\n          if (requests[i].signature.length > 0) {\n            bytes32 structHash = _getContextMessageHash(\n              requests[i].contractId,\n              LACLUtils.generateHash(requests[i].name),\n              LACLUtils.generateHash(requests[i].version),\n              requests[i].realmId\n            );\n            signer = LACLUtils.getSignerAddress(requests[i].signature, structHash);\n          } else {\n            signer = msg.sender;\n          }\n        }\n        contractId = requests[i].contractId;\n      }\n\n      bytes32 contextId = LACLUtils.accountGenerateId(contractId);\n      bytes32 signerId = LACLUtils.accountGenerateId(signer);\n\n      address functionFacetId = _data.selectors[IFunctionManagement.functionRegister.selector];\n      bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, IFunctionManagement.functionRegister.selector);\n      IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, signerId);\n      if (status != IACL.AuthorizationStatus.PERMITTED) LACLUtils.generateAuthorizationError(status);\n\n      // update member function register limit\n      MemberEntity storage memberEntity = _data.memberReadSlot(signerId);\n      require(\n        int32(uint32(memberEntity.limits.functionRegisterLimit)) - int16(uint16(requests[i].functions.length)) >= 0,\n        \"Illegal RegisterLimit\"\n      );\n      unchecked {\n        memberEntity.limits.functionRegisterLimit -= uint16(requests[i].functions.length);\n      }\n\n      ContextEntity storage contextEntity = _data.contextReadSlot(contextId);\n      require(contextEntity.bs.alstat == AlterabilityStatus.UPGRADABLE, \"Illegal Upgrade\");\n      require(contextEntity.functionLimit > contextEntity.functions.length(), \"Illegal Limit\");\n\n      // check access system scope\n      require(_doCheckSystemScope(contextId, signerId), \"Forbidden\");\n\n      for (uint256 j = 0; j < requests[i].functions.length; j++) {\n        _doFunctionRegistration(contextEntity, requests[i].functions[j], signer, contextId);\n      }\n    }\n    return true;\n  }\n\n  function functionUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IFunctionManagement.functionUpdateAdmin.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      FunctionEntity storage functionEntity = _doGetEntityAndCheckAdminAccess(requests[i].id, senderId, functionId);\n      functionEntity.bs.adminId = _doGetAndCheckFunctionAdmin(\n        _data.scopes[functionEntity.contextId].adminId,\n        functionEntity.contextId,\n        requests[i].adminId\n      );\n      emit FunctionAdminUpdated(sender, requests[i].id, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function functionUpdateAgent(MemberSignature calldata memberSign, FunctionUpdateAgentRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IFunctionManagement.functionUpdateAgent.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      FunctionEntity storage functionEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].functionId,\n        senderId,\n        functionId\n      );\n      _doCheckAgentId(requests[i].agentId, functionEntity.contextId);\n      functionEntity.agentId = requests[i].agentId;\n      emit FunctionAgentUpdated(sender, requests[i].functionId, requests[i].agentId);\n    }\n    return true;\n  }\n\n  function functionUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IFunctionManagement.functionUpdateActivityStatus.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      FunctionEntity storage functionEntity = _data.functionReadSlot(requests[i].id);\n      require(functionEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(functionEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      functionEntity.bs.acstat = requests[i].acstat;\n      emit FunctionActivityUpdated(sender, requests[i].id, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function functionUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IFunctionManagement.functionUpdateAlterabilityStatus.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      FunctionEntity storage functionEntity = _data.functionReadSlot(requests[i].id);\n      require(functionEntity.bs.acstat > ActivityStatus.DELETED, \"Function Deleted\");\n\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(functionEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      functionEntity.bs.alstat = requests[i].alstat;\n      emit FunctionAlterabilityUpdated(sender, requests[i].id, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function functionUpdatePolicyCode(\n    MemberSignature calldata memberSign,\n    FunctionUpdatePolicyRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IFunctionManagement.functionUpdatePolicyCode.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      FunctionEntity storage functionEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].functionId,\n        senderId,\n        functionId\n      );\n      functionEntity.policyCode = requests[i].policyCode;\n      emit FunctionPolicyUpdated(sender, requests[i].functionId, requests[i].policyCode);\n    }\n    return true;\n  }\n\n  function functionRemove(MemberSignature calldata memberSign, bytes32[] calldata functions) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IFunctionManagement.functionRemove.selector\n    );\n\n    for (uint256 i = 0; i < functions.length; i++) {\n      FunctionEntity storage functionEntity = _data.functionReadSlot(functions[i]);\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(functionEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      if (functionEntity.bs.referredByAgent == 0) {\n        ContextEntity storage contextEntity = _data.contextReadSlot(functionEntity.contextId);\n        require(contextEntity.bs.alstat == AlterabilityStatus.UPGRADABLE, \"Illegal Context Upgradable\");\n        contextEntity.functions.remove(functions[i]);\n\n        delete functionEntity.bs;\n        delete functionEntity.agentId;\n        delete functionEntity.contextId;\n        delete functionEntity.selector;\n        delete functionEntity.policyCode;\n        emit FunctionRemoved(sender, functions[i], false);\n      } else {\n        // Note: It's very important to prevent infinity lock state\n        require(functionEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n        functionEntity.bs.acstat = ActivityStatus.DELETED;\n        emit FunctionRemoved(sender, functions[i], true);\n      }\n    }\n    return true;\n  }\n\n  function functionCheckId(bytes32 functionId) external view returns (bool) {\n    return _data.scopes[functionId].stype == ScopeType.FUNCTION;\n  }\n\n  function functionCheckSelector(address contractId, bytes4 selector) external view returns (bool) {\n    return _data.scopes[LACLUtils.functionGenerateId(contractId, selector)].stype == ScopeType.FUNCTION;\n  }\n\n  function functionCheckAdmin(bytes32 functionId, address account) external view returns (bool) {\n    (FunctionEntity storage fe, bool result) = _data.functionTryReadSlot(functionId);\n    if (!result) return false;\n\n    return _doFunctionCheckAccount(fe.bs.adminId, account);\n  }\n\n  function functionCheckAgent(bytes32 functionId, address account) external view returns (bool) {\n    (FunctionEntity storage fe, bool result) = _data.functionTryReadSlot(functionId);\n    if (!result) return false;\n\n    return _doFunctionCheckAccount(fe.agentId, account);\n  }\n\n  function _doFunctionCheckAccount(bytes32 agentId, address account) internal view returns (bool) {\n    AgentType agentType = _data.agents[agentId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (agentType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result) = _data.roleTryReadSlot(agentId);\n      if (!result) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == agentId;\n    } else if (agentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(agentId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function functionGetInfo(bytes32 functionId) external view returns (FunctionInfo memory) {\n    (FunctionEntity storage fe, bool result) = _data.functionTryReadSlot(functionId);\n    if (!result) {\n      return\n        FunctionInfo({\n          adminId: bytes32(0),\n          agentId: bytes32(0),\n          contextId: bytes32(0),\n          selector: bytes4(0),\n          referredByAgent: 0,\n          stype: ScopeType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE,\n          adminType: AgentType.NONE,\n          agentType: AgentType.NONE,\n          policyCode: 0\n        });\n    }\n\n    return\n      FunctionInfo({\n        adminId: fe.bs.adminId,\n        agentId: fe.agentId,\n        contextId: fe.contextId,\n        selector: fe.selector,\n        referredByAgent: fe.bs.referredByAgent,\n        stype: fe.bs.stype,\n        acstat: fe.bs.acstat,\n        alstat: fe.bs.alstat,\n        adminType: _data.agents[fe.bs.adminId].atype,\n        agentType: _data.agents[fe.agentId].atype,\n        policyCode: fe.policyCode\n      });\n  }\n\n  function _doGetAgentScopeInfo(bytes32 agentId) internal view returns (ScopeType, bytes32) {\n    return LACLAgentScope.getAgentScopeInfo(_data, agentId);\n  }\n\n  function _doCheckSystemScope(bytes32 scopeId, bytes32 memberId) internal view returns (bool) {\n    TypeEntity storage systemType = _data.typeReadSlot(_LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID);\n    bytes32 memberRoleId = systemType.members[memberId];\n    RoleEntity storage memberSystemRole = _data.roleReadSlot(memberRoleId);\n    if (_data.scopes[memberSystemRole.scopeId].stype < ScopeType.CONTEXT) return false;\n    if (memberSystemRole.scopeId == scopeId) {\n      return true;\n    }\n\n    return IACLGenerals(address(this)).isScopesCompatible(memberSystemRole.scopeId, scopeId);\n  }\n\n  function _doCheckAdminAccess(\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) internal view returns (IACL.AdminAccessStatus) {\n    return LACLAgentScope.checkAdminAccess(_data, adminId, memberId, functionId);\n  }\n\n  function _accessPermission(MemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getMemeberSignerAddress(memberSign, MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n    IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, senderId);\n    if (status != IACL.AuthorizationStatus.PERMITTED) {\n      if (\n        status == IACL.AuthorizationStatus.FUNCTION_ACTIVITY_FORBIDDEN &&\n        IFunctionManagement.functionUpdateActivityStatus.selector == selector\n      ) {\n        return (functionId, senderId, signer);\n      }\n      LACLUtils.generateAuthorizationError(status);\n    }\n    return (functionId, senderId, signer);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    bytes32 fId,\n    bytes32 senderId,\n    bytes32 functionId\n  ) internal view returns (FunctionEntity storage) {\n    FunctionEntity storage functionEntity = _data.functionReadSlot(fId);\n    require(functionEntity.bs.acstat > ActivityStatus.DELETED, \"Function Deleted\");\n    require(functionEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(functionEntity.bs.adminId, senderId, functionId);\n    if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n    return functionEntity;\n  }\n\n  function _doFunctionRegistration(\n    ContextEntity storage context,\n    FunctionRequest calldata functionRequest,\n    address signer,\n    bytes32 contextId\n  ) internal {\n    bytes32 newFunctionId = LACLUtils.functionGenerateId(context.contractId, functionRequest.selector);\n    require(_data.scopes[newFunctionId].stype == ScopeType.NONE, \"Already Exist\");\n    require(\n      functionRequest.acstat > ActivityStatus.DELETED && functionRequest.alstat > AlterabilityStatus.NONE,\n      \"Illegal Activity/Alterability\"\n    );\n\n    if (\n      functionRequest.agentId != _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID &&\n      functionRequest.agentId != _LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID &&\n      functionRequest.agentId != _LIVELY_PROFILE_ANY_TYPE_ID\n    ) {\n      _doCheckAgentId(functionRequest.agentId, contextId);\n    }\n    FunctionEntity storage functionEntity = _data.functionWriteSlot(newFunctionId);\n    functionEntity.bs.stype = ScopeType.FUNCTION;\n    functionEntity.contextId = contextId;\n    functionEntity.agentId = functionRequest.agentId;\n    functionEntity.policyCode = functionRequest.policyCode;\n    functionEntity.selector = functionRequest.selector;\n    functionEntity.bs.acstat = functionRequest.acstat;\n    functionEntity.bs.alstat = functionRequest.alstat;\n    functionEntity.bs.adminId = _doGetAndCheckFunctionAdmin(context.bs.adminId, contextId, functionRequest.adminId);\n\n    // add function to context\n    context.functions.add(newFunctionId);\n\n    emit FunctionRegistered(signer, contextId, newFunctionId, functionRequest.adminId, functionRequest.agentId);\n  }\n\n  function _doGetAndCheckFunctionAdmin(\n    bytes32 contextAdminId,\n    bytes32 contextId,\n    bytes32 adminId\n  ) internal view returns (bytes32 functionAdminId) {\n    return LACLAgentScope.getAndCheckFunctionAdmin(_data, contextAdminId, contextId, adminId);\n  }\n\n  function _getContextMessageHash(\n    address contractId,\n    bytes32 name,\n    bytes32 version,\n    bytes32 realmId\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(CTX_MESSAGE_TYPEHASH, contractId, name, version, realmId));\n  }\n\n  function _doCheckAgentId(bytes32 agentId, bytes32 contextId) internal view {\n    BaseAgent storage ba = _data.agents[agentId];\n    require(ba.atype > AgentType.MEMBER, \"Illegal AgentId\");\n\n    (ScopeType requestAgentScopeType, bytes32 requestAgentScopeId) = _doGetAgentScopeInfo(agentId);\n    require(ScopeType.CONTEXT <= requestAgentScopeType, \"Illegal Agent ScopeType\");\n    if (ScopeType.CONTEXT == requestAgentScopeType) {\n      require(requestAgentScopeId == contextId, \"Illegal Agent Scope\");\n    } else {\n      require(IACLGenerals(address(this)).isScopesCompatible(requestAgentScopeId, contextId), \"Illegal Agent Scope\");\n    }\n  }\n\n  function _getPredictContextMessageHash(\n    address deployer,\n    address subject,\n    bytes32 realmId\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(PREDICT_CTX_MESSAGE_TYPEHASH, deployer, subject, realmId));\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LACLAgentScope);\n  }\n}\n"
    },
    "src/contracts/lib/acl/LACLAgentScope.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./LACLUtils.sol\";\nimport \"./LACLStorage.sol\";\nimport \"./LProfileStorage.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../../acl/IACLCommons.sol\";\nimport \"../../acl/IACLGenerals.sol\";\nimport \"../../acl/IACLManager.sol\";\nimport \"../../acl/ACLStorage.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../utils/IERC165.sol\";\nimport \"../../acl/IACL.sol\";\nimport \"../../acl/agent/IRoleManagement.sol\";\nimport \"../../acl/agent/IMemberManagement.sol\";\nimport \"../../acl/scope/IFunctionManagement.sol\";\nimport \"../../acl/policy/IPolicyManagement.sol\";\nimport \"../../acl/profile/IProfileACL.sol\";\nimport \"../../acl/profile/IProfileACLGenerals.sol\";\n\n/**\n * @title ACL Commons Library\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nlibrary LACLAgentScope {\n  using LProfileStorage for IACLCommons.ProfileEntity;\n  using LACLStorage for ACLStorage.DataCollection;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  string public constant LIB_NAME = \"LACLAgentScope\";\n  string public constant LIB_VERSION = \"3.0.0\";\n\n  bytes32 public constant LIVELY_VERSE_ANONYMOUS_TYPE_ID =\n    keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_ANONYMOUS\"));\n  bytes32 public constant LIVELY_VERSE_ANY_TYPE_ID = keccak256(abi.encodePacked(\"TYPE.LIVELY_VERSE.LIVELY_ANY\"));\n\n  bytes32 public constant LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID =\n    keccak256(abi.encodePacked(\"ROLE.LIVELY_VERSE.LIVELY_MASTER_ADMIN\"));\n\n  function checkAdminAccess(\n    ACLStorage.DataCollection storage data,\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) external view returns (IACL.AdminAccessStatus) {\n    return _doCheckAdminAccess(data, adminId, memberId, functionId);\n  }\n\n  function aclRegisterRole(\n    ACLStorage.DataCollection storage data,\n    IRoleManagement.RoleRegisterRequest calldata request,\n    bytes32 functionId,\n    bytes32 senderId,\n    uint24 memberLimit\n  ) external returns (bytes32, bytes32) {\n    bytes32 newRoleId = LACLUtils.generateId(request.name);\n    require(data.agents[newRoleId].atype == IACLCommons.AgentType.NONE, \"Role Already Exist\");\n    require(\n      request.acstat > IACLCommons.ActivityStatus.DELETED && request.alstat > IACLCommons.AlterabilityStatus.NONE,\n      \"Illegal Activity/Alterability\"\n    );\n    require(\n      request.typeId != LIVELY_VERSE_ANONYMOUS_TYPE_ID && request.typeId != LIVELY_VERSE_ANY_TYPE_ID,\n      \"Illegal Type\"\n    );\n\n    // check type\n    IACLCommons.TypeEntity storage typeEntity = data.typeReadSlot(request.typeId);\n    require(typeEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Type Updatable\");\n    require(typeEntity.roles.length() < typeEntity.roleLimit, \"Illegal Register\");\n\n    // check access\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(data, typeEntity.ba.adminId, senderId, functionId);\n    if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n    // check and get requested scope type\n    IACLCommons.ScopeType requestScopeType = _doRoleCheckRequestScope(data, request.scopeId, typeEntity.scopeId);\n\n    // add role to type\n    typeEntity.roles.add(newRoleId);\n\n    // create role entity\n    IACLCommons.RoleEntity storage newRole = data.roleWriteSlot(newRoleId);\n    newRole.ba.atype = IACLCommons.AgentType.ROLE;\n    newRole.ba.acstat = request.acstat;\n    newRole.ba.alstat = request.alstat;\n    newRole.name = request.name;\n    newRole.scopeId = request.scopeId;\n    newRole.memberLimit = request.memberLimit >= 0 ? uint24(uint32(request.memberLimit)) : memberLimit;\n    newRole.typeId = request.typeId;\n    newRole.ba.adminId = _getRoleAdmin(data, requestScopeType, typeEntity.ba.adminId, request.scopeId, request.adminId);\n\n    return (newRoleId, newRole.ba.adminId);\n  }\n\n  function getPolicyAdmin(\n    ACLStorage.DataCollection storage data,\n    IACLCommons.ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId\n  ) external view returns (bytes32 policyAdminId) {\n    // checking requested type admin\n    if (adminId != bytes32(0)) {\n      require(data.agents[adminId].atype == IACLCommons.AgentType.ROLE, \"Illegal Admin AgentType\");\n      (IACLCommons.ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doGetAgentScopeInfo(data, adminId);\n      require(requestScopeType <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n      if (requestScopeType == requestAdminScopeType) {\n        require(requestAdminScopeId == scopeId, \"Illegal Admin Scope\");\n      } else {\n        require(IACLGenerals(address(this)).isScopesCompatible(requestAdminScopeId, scopeId), \"Illegal Admin Scope\");\n      }\n      policyAdminId = adminId;\n    } else {\n      policyAdminId = requestScopeAdmin;\n    }\n  }\n\n  function getPolicyAndCheckAdminAccess(\n    ACLStorage.DataCollection storage data,\n    bytes32 policyId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) external view returns (IACLCommons.PolicyEntity storage) {\n    return _doGetPolicyAndCheckAdminAccess(data, policyId, memberId, functionId);\n  }\n\n  function getCheckUpdateRequestScope(\n    ACLStorage.DataCollection storage data,\n    bytes32 requestScopeId,\n    bytes32 senderScopeId,\n    IACLCommons.ScopeType senderScopeType\n  ) external returns (IACLCommons.BaseScope storage) {\n    return _getCheckUpdateRequestScope(data, requestScopeId, senderScopeId, senderScopeType);\n  }\n\n  function _getCheckUpdateRequestScope(\n    ACLStorage.DataCollection storage data,\n    bytes32 requestScopeId,\n    bytes32 senderScopeId,\n    IACLCommons.ScopeType senderScopeType\n  ) private returns (IACLCommons.BaseScope storage) {\n    // checking requested type scope\n    IACLCommons.BaseScope storage requestedScope = data.scopes[requestScopeId];\n    require(requestedScope.stype != IACLCommons.ScopeType.NONE, \"Scope Not Found\");\n    require(requestedScope.acstat > IACLCommons.ActivityStatus.DELETED, \"Scope Deleted\");\n\n    // increase referred count to target scope\n    requestedScope.referredByAgent += 1;\n\n    require(requestedScope.stype <= senderScopeType, \"Illegal ScopeType\");\n    if (requestedScope.stype == senderScopeType) {\n      require(requestScopeId == senderScopeId, \"Illegal Scope\");\n    } else {\n      require(IACLGenerals(address(this)).isScopesCompatible(senderScopeId, requestScopeId), \"Illegal Scope\");\n    }\n\n    return requestedScope;\n  }\n\n  function roleCheckRequestScope(\n    ACLStorage.DataCollection storage data,\n    bytes32 requestScopeId,\n    bytes32 typeScopeId\n  ) external returns (IACLCommons.ScopeType) {\n    return _doRoleCheckRequestScope(data, requestScopeId, typeScopeId);\n  }\n\n  function _doGetPolicyAndCheckAdminAccess(\n    ACLStorage.DataCollection storage data,\n    bytes32 policyId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) private view returns (IACLCommons.PolicyEntity storage) {\n    IACLCommons.PolicyEntity storage policyEntity = data.policies[policyId];\n    require(policyEntity.adminId != bytes32(0), \"Not Found\");\n    require(policyEntity.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(data, policyEntity.adminId, memberId, functionId);\n    if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n    return policyEntity;\n  }\n\n  function _doRoleCheckRequestScope(\n    ACLStorage.DataCollection storage data,\n    bytes32 requestScopeId,\n    bytes32 typeScopeId\n  ) private returns (IACLCommons.ScopeType) {\n    // checking requested role scope\n    IACLCommons.BaseScope storage requestScope = data.scopes[requestScopeId];\n    require(requestScope.stype != IACLCommons.ScopeType.NONE, \"Scope Not Found\");\n    require(requestScope.acstat > IACLCommons.ActivityStatus.DELETED, \"Scope Deleted\");\n\n    // increase referred count to target scope\n    requestScope.referredByAgent += 1;\n\n    // checking requested role type scope with role scope\n    IACLCommons.ScopeType typeScopeType = data.scopes[typeScopeId].stype;\n    require(typeScopeType >= requestScope.stype, \"Illegal ScopeType\");\n    if (typeScopeType == requestScope.stype) {\n      require(typeScopeId == requestScopeId, \"Illegal Scope\");\n    } else {\n      require(IACLGenerals(address(this)).isScopesCompatible(typeScopeId, requestScopeId), \"Illegal Scope\");\n    }\n\n    return requestScope.stype;\n  }\n\n  function updatePolicyScope(\n    ACLStorage.DataCollection storage data,\n    IPolicyManagement.UpdateScopeRequest calldata request,\n    bytes32 functionId,\n    bytes32 senderId\n  ) external {\n    IACLCommons.ScopeType senderScopeType;\n    bytes32 senderScopeId;\n    IACLCommons.PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(\n      data,\n      request.id,\n      senderId,\n      functionId\n    );\n    IACLCommons.AgentType adminAgentType = data.agents[policyEntity.adminId].atype;\n    if (adminAgentType == IACLCommons.AgentType.ROLE) {\n      IACLCommons.RoleEntity storage roleEntity = data.roleReadSlot(policyEntity.adminId);\n      senderScopeId = roleEntity.scopeId;\n      senderScopeType = data.scopes[roleEntity.scopeId].stype;\n    } else {\n      IACLCommons.TypeEntity storage agentType = data.typeReadSlot(policyEntity.adminId);\n      bytes32 memberRoleId = agentType.members[senderId];\n      IACLCommons.RoleEntity storage memberAgentRole = data.roleReadSlot(memberRoleId);\n      senderScopeType = data.scopes[memberAgentRole.scopeId].stype;\n      senderScopeId = memberAgentRole.scopeId;\n    }\n\n    IACLCommons.BaseScope storage requestScope = _getCheckUpdateRequestScope(\n      data,\n      request.scopeId,\n      senderScopeId,\n      senderScopeType\n    );\n    IACLCommons.BaseScope storage currentScope = data.scopes[policyEntity.scopeId];\n    if (policyEntity.roles.length() > 0) {\n      require(requestScope.stype > currentScope.stype, \"Illegal ScopeType\");\n      require(IACLGenerals(address(this)).isScopesCompatible(request.scopeId, policyEntity.scopeId), \"Illegal Scope\");\n    }\n    require(currentScope.referredByAgent > 0, \"Illeagl Referred\");\n    unchecked {\n      currentScope.referredByAgent -= 1;\n    }\n    policyEntity.scopeId = request.scopeId;\n  }\n\n  function getAgentScopeInfo(ACLStorage.DataCollection storage data, bytes32 agentId)\n    external\n    view\n    returns (IACLCommons.ScopeType, bytes32)\n  {\n    return _doGetAgentScopeInfo(data, agentId);\n  }\n\n  function getRoleAdmin(\n    ACLStorage.DataCollection storage data,\n    IACLCommons.ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId\n  ) external view returns (bytes32 roleAdminId) {\n    return _getRoleAdmin(data, requestScopeType, requestScopeAdmin, scopeId, adminId);\n  }\n\n  function checkMemberRegisterLimits(\n    IACLCommons.MemberEntity storage memberEntity,\n    IACLCommons.GeneralLimit calldata limits\n  ) external view {\n    require(memberEntity.limits.memberRegisterLimit >= limits.memberRegisterLimit, \"Illegal MemberRegisterLimit\");\n    require(memberEntity.limits.contextRegisterLimit >= limits.contextRegisterLimit, \"Illegal ContextRegisterLimit\");\n    require(memberEntity.limits.functionRegisterLimit >= limits.functionRegisterLimit, \"Illegal FunctionRegisterLimit\");\n    require(memberEntity.limits.profileRegisterLimit >= limits.profileRegisterLimit, \"Illegal ProfileRegisterLimit\");\n    require(memberEntity.limits.roleRegisterLimit >= limits.roleRegisterLimit, \"Illegal RoleRegisterLimit\");\n    require(memberEntity.limits.typeRegisterLimit >= limits.typeRegisterLimit, \"Illegal TypeRegisterLimit\");\n    require(memberEntity.limits.realmRegisterLimit >= limits.realmRegisterLimit, \"Illegal RealmRegisterLimit\");\n    require(memberEntity.limits.domainRegisterLimit >= limits.domainRegisterLimit, \"Illegal DomainRegisterLimit\");\n    require(memberEntity.limits.policyRegisterLimit >= limits.policyRegisterLimit, \"Illegal PolicyRegisterLimit\");\n    require(memberEntity.limits.memberLimit >= limits.memberLimit, \"Illegal MemberLimit\");\n    require(memberEntity.limits.contextLimit >= limits.contextLimit, \"Illegal ContextLimit\");\n    require(memberEntity.limits.realmLimit >= limits.realmLimit, \"Illegal RealmLimit\");\n    require(memberEntity.limits.domainLimit >= limits.domainLimit, \"Illegal DomainLimit\");\n    require(memberEntity.limits.callLimit >= limits.callLimit, \"Illegal CallLimit\");\n    require(memberEntity.limits.typeRoleLimit >= limits.typeRoleLimit, \"Illegal TypeRoleLimit\");\n    require(memberEntity.limits.typeLimit >= limits.typeLimit, \"Illegal TypeLimit\");\n    require(memberEntity.limits.policyRoleLimit >= limits.policyRoleLimit, \"Illegal PolicyRoleLimit\");\n    require(memberEntity.limits.functionLimit >= limits.functionLimit, \"Illegal FunctionLimit\");\n  }\n\n  function _doCheckAdminAccess(\n    ACLStorage.DataCollection storage data,\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) private view returns (IACL.AdminAccessStatus) {\n    (IACLCommons.FunctionEntity storage functionEntity, bool res) = data.functionTryReadSlot(functionId);\n    if (!res) return IACL.AdminAccessStatus.FUNCTION_NOT_FOUND;\n\n    IACLCommons.AgentType adminAgentType = data.agents[adminId].atype;\n    if (adminAgentType == IACLCommons.AgentType.ROLE) {\n      (IACLCommons.RoleEntity storage roleEntity, bool result) = data.roleTryReadSlot(adminId);\n      if (!result) return IACL.AdminAccessStatus.ROLE_NOT_FOUND;\n      if (roleEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IACL.AdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN;\n\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = data.typeTryReadSlot(roleEntity.typeId);\n      if (!result1) return IACL.AdminAccessStatus.TYPE_NOT_FOUND;\n      if (typeEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IACL.AdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN;\n\n      if (typeEntity.members[memberId] != adminId) return IACL.AdminAccessStatus.NOT_PERMITTED;\n\n      IACLCommons.PolicyEntity storage policyEntity = data.policies[data.rolePolicyMap[adminId]];\n      if (\n        policyEntity.acstat == IACLCommons.ActivityStatus.ENABLED &&\n        policyEntity.policyCode >= functionEntity.policyCode\n      ) return IACL.AdminAccessStatus.POLICY_FORBIDDEN;\n\n      return IACL.AdminAccessStatus.PERMITTED;\n    } else if (adminAgentType == IACLCommons.AgentType.TYPE) {\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = data.typeTryReadSlot(adminId);\n      if (!result1) return IACL.AdminAccessStatus.TYPE_NOT_FOUND;\n      if (typeEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IACL.AdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN;\n\n      bytes32 roleId = typeEntity.members[memberId];\n      (IACLCommons.RoleEntity storage roleEntity, bool result2) = data.roleTryReadSlot(roleId);\n      if (!result2) return IACL.AdminAccessStatus.ROLE_NOT_FOUND;\n      if (roleEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\n        return IACL.AdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN;\n\n      IACLCommons.PolicyEntity storage policyEntity = data.policies[data.rolePolicyMap[roleId]];\n      if (\n        policyEntity.acstat == IACLCommons.ActivityStatus.ENABLED &&\n        policyEntity.policyCode >= functionEntity.policyCode\n      ) return IACL.AdminAccessStatus.POLICY_FORBIDDEN;\n\n      return IACL.AdminAccessStatus.PERMITTED;\n    }\n\n    return IACL.AdminAccessStatus.NOT_PERMITTED;\n  }\n\n  function _getRoleAdmin(\n    ACLStorage.DataCollection storage data,\n    IACLCommons.ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId\n  ) private view returns (bytes32 roleAdminId) {\n    // checking requested type admin\n    if (adminId != bytes32(0)) {\n      require(data.agents[adminId].atype > IACLCommons.AgentType.MEMBER, \"Illegal Admin AgentType\");\n      (IACLCommons.ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doGetAgentScopeInfo(data, adminId);\n      require(requestScopeType <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n      if (requestScopeType == requestAdminScopeType) {\n        require(requestAdminScopeId == scopeId, \"Illegal Admin Scope\");\n      } else {\n        require(IACLGenerals(address(this)).isScopesCompatible(requestAdminScopeId, scopeId), \"Illegal Admin Scope\");\n      }\n      roleAdminId = adminId;\n    } else {\n      roleAdminId = requestScopeAdmin;\n    }\n  }\n\n  function getAndCheckFunctionAdmin(\n    ACLStorage.DataCollection storage data,\n    bytes32 contextAdminId,\n    bytes32 contextId,\n    bytes32 adminId\n  ) external view returns (bytes32 functionAdminId) {\n    return _doGetAndCheckFunctionAdmin(data, contextAdminId, contextId, adminId);\n  }\n\n  function _doGetAgentScopeInfo(ACLStorage.DataCollection storage data, bytes32 agentId)\n    private\n    view\n    returns (IACLCommons.ScopeType, bytes32)\n  {\n    IACLCommons.AgentType atype = data.agents[agentId].atype;\n    if (atype == IACLCommons.AgentType.ROLE) {\n      IACLCommons.RoleEntity storage roleEntity = data.roleReadSlot(agentId);\n      IACLCommons.BaseScope storage baseScope = data.scopes[roleEntity.scopeId];\n      return (baseScope.stype, roleEntity.scopeId);\n    } else if (atype == IACLCommons.AgentType.TYPE) {\n      IACLCommons.TypeEntity storage typeEntity = data.typeReadSlot(agentId);\n      IACLCommons.BaseScope storage baseScope = data.scopes[typeEntity.scopeId];\n      return (baseScope.stype, typeEntity.scopeId);\n    }\n\n    return (IACLCommons.ScopeType.NONE, bytes32(0));\n  }\n\n  function _doGetAndCheckFunctionAdmin(\n    ACLStorage.DataCollection storage data,\n    bytes32 contextAdminId,\n    bytes32 contextId,\n    bytes32 requestAdminId\n  ) private view returns (bytes32 functionAdminId) {\n    // checking requested functionAdmin admin\n    if (requestAdminId != bytes32(0)) {\n      require(data.agents[requestAdminId].atype > IACLCommons.AgentType.MEMBER, \"Illegal Admin AgentType\");\n\n      (IACLCommons.ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doGetAgentScopeInfo(\n        data,\n        requestAdminId\n      );\n      require(IACLCommons.ScopeType.CONTEXT <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n      if (IACLCommons.ScopeType.CONTEXT == requestAdminScopeType) {\n        require(requestAdminScopeId == contextAdminId, \"Illegal Admin Scope\");\n      } else {\n        require(IACLGenerals(address(this)).isScopesCompatible(requestAdminScopeId, contextId), \"Illegal Admin Scope\");\n      }\n      functionAdminId = requestAdminId;\n    } else {\n      functionAdminId = contextAdminId;\n    }\n  }\n}\n"
    },
    "src/contracts/acl/profile/scope/ProfileUniverseManger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IProfileUniverseManagement.sol\";\nimport \"../IProfileACL.sol\";\nimport \"../IProfileACLGenerals.sol\";\nimport \"../ProfileAccessControl.sol\";\nimport \"../../ACLStorage.sol\";\nimport \"../../../lib/acl/LProfileStorage.sol\";\nimport \"../../../lib/acl/LACLStorage.sol\";\nimport \"../../../lib/acl/LACLUtils.sol\";\nimport \"../../../lib/acl/LProfileCommons.sol\";\nimport \"../../../lib/struct/LEnumerableSet.sol\";\nimport \"../../../proxy/IProxy.sol\";\nimport \"../../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Profile Universe Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ProfileUniverseManager is ACLStorage, BaseUUPSProxy, IProfileUniverseManagement {\n  using LACLStorage for DataCollection;\n  using LProfileStorage for ProfileEntity;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IProfileUniverseManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  function profileUniverseUpdateActivityStatus(ProfileMemberSignature calldata memberSign, ActivityStatus acstat)\n    external\n    returns (bool)\n  {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermissionActivity(memberSign, IProfileUniverseManagement.profileUniverseUpdateActivityStatus.selector);\n    UniverseEntity storage universeEntity = _doGetEntityAndCheckAdminAccess(profileEntity, functionEntity, senderId);\n    require(acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n    universeEntity.bs.acstat = acstat;\n    emit ProfileUniverseActivityUpdated(sender, profileId, _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID, acstat);\n    return true;\n  }\n\n  function profileUniverseUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    AlterabilityStatus alstat\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileUniverseManagement.profileUniverseUpdateAlterabilityStatus.selector);\n    UniverseEntity storage universeEntity = profileEntity.profileUniverseReadSlot(\n      _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID\n    );\n    IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      universeEntity.bs.adminId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    require(alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n    universeEntity.bs.alstat = alstat;\n    emit ProfileUniverseAlterabilityUpdated(sender, profileId, _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID, alstat);\n    return true;\n  }\n\n  function profileUniverseUpdateAdmin(ProfileMemberSignature calldata memberSign, bytes32 adminId)\n    external\n    returns (bool)\n  {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileUniverseManagement.profileUniverseUpdateAdmin.selector);\n    UniverseEntity storage universeEntity = _doGetEntityAndCheckAdminAccess(profileEntity, functionEntity, senderId);\n    require(adminId != universeEntity.bs.adminId && adminId != bytes32(0), \"Illegal AdminId\");\n    BaseAgent storage adminBaseAgent = profileEntity.agents[adminId];\n    require(adminBaseAgent.atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n    if (adminBaseAgent.atype == AgentType.ROLE) {\n      TypeEntity storage profileAdminType = profileEntity.profileTypeReadSlot(_LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID);\n      require(profileAdminType.roles.contains(adminId), \"Not Found\");\n    } else {\n      require(_LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID == adminId, \"Illegal Admin\");\n    }\n\n    universeEntity.bs.adminId = adminId;\n    emit ProfileUniverseAdminUpdated(sender, profileId, _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID, adminId);\n\n    return true;\n  }\n\n  function profileUniverseUpdateDomainLimit(ProfileMemberSignature calldata memberSign, uint16 domainLimit)\n    external\n    returns (bool)\n  {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileUniverseManagement.profileUniverseUpdateDomainLimit.selector);\n    UniverseEntity storage universeEntity = _doGetEntityAndCheckAdminAccess(profileEntity, functionEntity, senderId);\n    require(domainLimit > universeEntity.domains.length(), \"Illegal Limit\");\n    universeEntity.domainLimit = domainLimit;\n    emit ProfileUniverseDomainLimitUpdated(sender, profileId, _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID, domainLimit);\n    return true;\n  }\n\n  function profileUniverseCheckAdmin(bytes32 profileId, address account) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n    TypeEntity storage profileAdminType = profileEntity.profileTypeReadSlot(_LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID);\n    return profileAdminType.members[memberId] != bytes32(0);\n  }\n\n  function profileUniverseGetDomains(bytes32 profileId) external view returns (bytes32[] memory) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return new bytes32[](0);\n    UniverseEntity storage universeEntity = profileEntity.profileUniverseReadSlot(\n      _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID\n    );\n    return universeEntity.domains.values();\n  }\n\n  function profileUniverseGetInfo(bytes32 profileId) external view returns (ProfileUniverseInfo memory) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    UniverseEntity storage universeEntity = profileEntity.profileUniverseReadSlot(\n      _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID\n    );\n\n    if (profileEntity.acstat == ActivityStatus.NONE) {\n      return\n        ProfileUniverseInfo({\n          id: bytes32(0),\n          adminId: bytes32(0),\n          domainLimit: 0,\n          domainCount: 0,\n          referredByAgent: 0,\n          stype: ScopeType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE,\n          adminType: AgentType.NONE\n        });\n    }\n\n    return\n      ProfileUniverseInfo({\n        id: _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID,\n        adminId: universeEntity.bs.adminId,\n        domainLimit: universeEntity.domainLimit,\n        domainCount: uint16(universeEntity.domains.length()),\n        referredByAgent: universeEntity.bs.referredByAgent,\n        stype: universeEntity.bs.stype,\n        adminType: profileEntity.agents[universeEntity.bs.adminId].atype,\n        acstat: universeEntity.bs.acstat,\n        alstat: universeEntity.bs.alstat\n      });\n  }\n\n  function _doCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) internal view returns (IProfileACL.ProfileAdminAccessStatus) {\n    return LProfileCommons.profileCheckAdminAccess(profileEntity, functionEntity, adminId, senderId);\n  }\n\n  function _accessPermission(ProfileMemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      ProfileEntity storage,\n      FunctionEntity storage,\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(bytes(memberSign.profileName).length > 0, \"Illegal ProfileName\");\n\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getProfileMemeberSignerAddress(memberSign, PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    bytes32 profileId = LACLUtils.generateId(memberSign.profileName);\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n\n    ProfileAccessControl(payable(address(this))).profileAclHasMemberAccess(profileId, functionId, senderId);\n\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    FunctionEntity storage functionEntity = _data.functionReadSlot(functionId);\n    return (profileEntity, functionEntity, profileId, senderId, signer);\n  }\n\n  function _accessPermissionActivity(ProfileMemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      ProfileEntity storage,\n      FunctionEntity storage,\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(bytes(memberSign.profileName).length > 0, \"Illegal ProfileName\");\n\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getProfileMemeberSignerAddress(memberSign, PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    bytes32 profileId = LACLUtils.generateId(memberSign.profileName);\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat != ActivityStatus.ENABLED) {\n      LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.PROFILE_ACTIVITY_FORBIDDEN);\n    }\n\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n\n    (FunctionEntity storage functionEntity, bool res) = _data.functionTryReadSlot(functionId);\n    if (!res) LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.FUNCTION_NOT_FOUND);\n\n    _doAclHasAccess(profileEntity, functionEntity, senderId);\n    return (profileEntity, functionEntity, profileId, senderId, signer);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 senderId\n  ) internal view returns (UniverseEntity storage) {\n    UniverseEntity storage universeEntity = profileEntity.profileUniverseReadSlot(\n      _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID\n    );\n    require(universeEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      universeEntity.bs.adminId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    return universeEntity;\n  }\n\n  function _doAclHasAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 memberId\n  ) internal {\n    if (profileEntity.limits.profileCallLimit > 0) {\n      unchecked {\n        profileEntity.limits.profileCallLimit -= 1;\n      }\n    } else {\n      LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.PROFILE_CALL_FORBIDDEN);\n    }\n\n    AgentType atype = profileEntity.agents[functionEntity.agentId].atype;\n\n    if (atype == AgentType.ROLE) {\n      // check member activation\n      (ProfileMemberEntity storage profileMemberEntity, bool result0) = profileEntity.profileMemberTryReadSlot(\n        memberId\n      );\n      if (!result0)\n        LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.MEMBER_NOT_FOUND);\n      if (profileMemberEntity.ba.acstat != ActivityStatus.ENABLED)\n        LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN);\n      if (profileEntity.owner != profileMemberEntity.account) {\n        if (profileMemberEntity.callLimit > 0) {\n          unchecked {\n            profileMemberEntity.callLimit -= 1;\n          }\n        } else {\n          LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.MEMBER_CALL_FORBIDDEN);\n        }\n      }\n\n      // check role activation\n      (RoleEntity storage roleEntity, bool result1) = profileEntity.profileRoleTryReadSlot(functionEntity.agentId);\n      if (!result1) LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.ROLE_NOT_FOUND);\n      if (roleEntity.ba.acstat != ActivityStatus.ENABLED)\n        LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN);\n      // if(profileEntity.scopes[roleEntity.scopeId].stype == ScopeType.FUNCTION && roleEntity.scopeId != functionEntity.agentId)\n      //   LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.ROLE_SCOPE_FORBIDDEN);\n\n      // check type activation\n      (TypeEntity storage typeEntity, bool result2) = profileEntity.profileTypeTryReadSlot(roleEntity.typeId);\n      if (!result2) LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.TYPE_NOT_FOUND);\n      if (typeEntity.ba.acstat != ActivityStatus.ENABLED)\n        LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN);\n\n      // check memberId with agentId role\n      if (typeEntity.members[memberId] != functionEntity.agentId)\n        LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.UNAUTHORIZED);\n\n      // check policy activation\n      PolicyEntity storage policyEntity = profileEntity.policies[profileEntity.rolePolicyMap[functionEntity.agentId]];\n      if (policyEntity.acstat == ActivityStatus.ENABLED && policyEntity.policyCode >= functionEntity.policyCode)\n        LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.POLICY_FORBIDDEN);\n    } else if (atype == AgentType.TYPE) {\n      if (functionEntity.agentId == _LIVELY_PROFILE_ANY_TYPE_ID) {\n        (ProfileMemberEntity storage profileMemberEntity, bool result0) = profileEntity.profileMemberTryReadSlot(\n          memberId\n        );\n        if (!result0)\n          LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.MEMBER_NOT_FOUND);\n        if (profileMemberEntity.ba.acstat != ActivityStatus.ENABLED)\n          LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN);\n        if (profileEntity.owner != profileMemberEntity.account) {\n          if (profileMemberEntity.callLimit > 0) {\n            unchecked {\n              profileMemberEntity.callLimit -= 1;\n            }\n          } else {\n            LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.MEMBER_CALL_FORBIDDEN);\n          }\n        }\n      } else if (functionEntity.agentId != _LIVELY_VERSE_ANONYMOUS_TYPE_ID) {\n        _doCheckTypeAccess(profileEntity, functionEntity, memberId);\n      }\n    } else if (atype <= AgentType.MEMBER) {\n      LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.UNAUTHORIZED);\n    }\n\n    // check function activity\n    if (functionEntity.bs.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.FUNCTION_ACTIVITY_FORBIDDEN);\n\n    // check context activity\n    (ContextEntity storage contextEntity, bool res1) = _data.contextTryReadSlot(functionEntity.contextId);\n    if (!res1) LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.CONTEXT_NOT_FOUND);\n    if (contextEntity.bs.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.CONTEXT_ACTIVITY_FORBIDDEN);\n\n    // check realm activity\n    (RealmEntity storage realmEntity, bool res2) = _data.realmTryReadSlot(contextEntity.realmId);\n    if (!res2) LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.REALM_NOT_FOUND);\n    if (realmEntity.bs.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.REALM_ACTIVITY_FORBIDDEN);\n\n    // check domain activity\n    (DomainEntity storage domainEntity, bool res3) = _data.domainTryReadSlot(realmEntity.domainId);\n    if (!res3) LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.DOMAIN_NOT_FOUND);\n    if (domainEntity.bs.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.DOMAIN_ACTIVITY_FORBIDDEN);\n\n    // check universe activity\n    UniverseEntity storage universeEntity = _data.universeReadSlot(_LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID);\n    if (universeEntity.bs.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateAuthorizationError(IACL.AuthorizationStatus.UNIVERSE_ACTIVITY_FORBIDDEN);\n  }\n\n  function _doCheckTypeAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 memberId\n  ) internal {\n    // check member activation\n    (ProfileMemberEntity storage profileMemberEntity, bool result0) = profileEntity.profileMemberTryReadSlot(memberId);\n    if (!result0) LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.MEMBER_NOT_FOUND);\n    if (profileMemberEntity.ba.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN);\n    if (profileEntity.owner != profileMemberEntity.account) {\n      if (profileMemberEntity.callLimit > 0) {\n        unchecked {\n          profileMemberEntity.callLimit -= 1;\n        }\n      } else {\n        LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.MEMBER_CALL_FORBIDDEN);\n      }\n    }\n\n    // check type activation\n    (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(functionEntity.agentId);\n    if (!result1) LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.TYPE_NOT_FOUND);\n    if (typeEntity.ba.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN);\n\n    // check role activation\n    bytes32 roleId = typeEntity.members[memberId];\n    (RoleEntity storage roleEntity, bool result2) = profileEntity.profileRoleTryReadSlot(roleId);\n    if (!result2) LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.ROLE_NOT_FOUND);\n    if (roleEntity.ba.acstat != ActivityStatus.ENABLED)\n      LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN);\n    // if(profileEntity.scopes[roleEntity.scopeId].stype == ScopeType.FUNCTION && roleEntity.scopeId != functionEntity.agentId)\n    //   LACLUtils.generateProfileAuthorizationError(ProfileAuthorizationStatus.ROLE_SCOPE_FORBIDDEN);\n\n    // check policy activation\n    PolicyEntity storage policyEntity = profileEntity.policies[profileEntity.rolePolicyMap[roleId]];\n    if (policyEntity.acstat == ActivityStatus.ENABLED && policyEntity.policyCode >= functionEntity.policyCode)\n      LACLUtils.generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus.POLICY_FORBIDDEN);\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LProfileCommons);\n  }\n}\n"
    },
    "src/contracts/acl/profile/scope/ProfileRealmManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IProfileRealmManagement.sol\";\nimport \"../IProfileACL.sol\";\nimport \"../IProfileACLGenerals.sol\";\nimport \"../ProfileAccessControl.sol\";\nimport \"../../ACLStorage.sol\";\nimport \"../../../lib/acl/LProfileStorage.sol\";\nimport \"../../../lib/acl/LACLStorage.sol\";\nimport \"../../../lib/acl/LACLUtils.sol\";\nimport \"../../../lib/acl/LProfileCommons.sol\";\nimport \"../../../lib/struct/LEnumerableSet.sol\";\nimport \"../../../proxy/IProxy.sol\";\nimport \"../../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Profile Realm Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ProfileRealmManager is ACLStorage, BaseUUPSProxy, IProfileRealmManagement {\n  using LACLStorage for DataCollection;\n  using LProfileStorage for ProfileEntity;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IProfileRealmManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  function profileRealmRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRealmRegisterRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRealmManagement.profileRealmRegister.selector);\n    LProfileCommons.profileCheckMemberForRealmRegister(profileEntity, uint16(requests.length), senderId);\n\n    // fetch scope type and scope id of sender\n    (ScopeType memberScopeType, bytes32 memberScopeId) = _doGetMemberScopeInfoFromType(\n      profileEntity,\n      _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID,\n      senderId\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      _doProfileRealmRegister(\n        requests[i],\n        profileEntity,\n        functionEntity,\n        profileId,\n        senderId,\n        sender,\n        memberScopeType,\n        memberScopeId\n      );\n    }\n    return true;\n  }\n\n  function profileRealmUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRealmManagement.profileRealmUpdateAdmin.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      RealmEntity storage realmEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].entityId,\n        senderId\n      );\n\n      // checking requested type admin\n      if (requests[i].adminId != bytes32(0)) {\n        require(profileEntity.agents[requests[i].adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n        (ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doAgentGetScopeInfo(\n          profileEntity,\n          requests[i].adminId\n        );\n        require(ScopeType.REALM <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n        if (ScopeType.REALM == requestAdminScopeType) {\n          require(requestAdminScopeId == requests[i].entityId, \"Illegal Admin Scope\");\n        } else {\n          require(\n            IProfileACLGenerals(address(this)).profileIsScopesCompatible(\n              profileId,\n              requestAdminScopeId,\n              requests[i].entityId\n            ),\n            \"Illegal Admin Scope\"\n          );\n        }\n        realmEntity.bs.adminId = requests[i].adminId;\n      } else {\n        realmEntity.bs.adminId = profileEntity.scopes[realmEntity.domainId].adminId;\n      }\n\n      emit ProfileRealmAdminUpdated(sender, profileId, requests[i].entityId, requests[i].adminId);\n    }\n\n    return true;\n  }\n\n  function profileRealmMoveContext(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRealmMoveContextRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRealmManagement.profileRealmMoveContext.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      _doProfileRealmMoveContext(requests[i], profileEntity, functionEntity, profileId, senderId, sender);\n    }\n    return true;\n  }\n\n  function profileRealmUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRealmManagement.profileRealmUpdateActivityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      RealmEntity storage realmEntity = profileEntity.profileRealmReadSlot(requests[i].entityId);\n\n      require(realmEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        realmEntity.bs.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      realmEntity.bs.acstat = requests[i].acstat;\n      emit ProfileRealmActivityUpdated(sender, profileId, requests[i].entityId, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function profileRealmUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRealmManagement.profileRealmUpdateAlterabilityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      RealmEntity storage realmEntity = profileEntity.profileRealmReadSlot(requests[i].entityId);\n      require(realmEntity.bs.acstat > ActivityStatus.DELETED, \"Realm Deleted\");\n\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        realmEntity.bs.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      realmEntity.bs.alstat = requests[i].alstat;\n      emit ProfileRealmAlterabilityUpdated(sender, profileId, requests[i].entityId, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function profileRealmUpdateContextLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRealmUpdateContextLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRealmManagement.profileRealmUpdateContextLimit.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      RealmEntity storage realmEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].realmId,\n        senderId\n      );\n      require(requests[i].contextLimit > realmEntity.contexts.length(), \"Illegal Limit\");\n      realmEntity.contextLimit = requests[i].contextLimit;\n      emit ProfileRealmContextLimitUpdated(sender, profileId, requests[i].realmId, requests[i].contextLimit);\n    }\n    return true;\n  }\n\n  function profileRealmRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata realms)\n    external\n    returns (bool)\n  {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRealmManagement.profileRealmRemove.selector);\n    for (uint256 i = 0; i < realms.length; i++) {\n      RealmEntity storage realmEntity = profileEntity.profileRealmReadSlot(realms[i]);\n\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        realmEntity.bs.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      require(realmEntity.contexts.length() == 0, \"Illegal Remove\");\n      if (realmEntity.bs.referredByAgent == 0) {\n        // check domain\n        DomainEntity storage domainEntity = profileEntity.profileDomainReadSlot(realmEntity.domainId);\n        require(domainEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Domain Updatable\");\n        domainEntity.realms.remove(realms[i]);\n\n        delete realmEntity.bs;\n        delete realmEntity.domainId;\n        delete realmEntity.contextLimit;\n        delete realmEntity.name;\n        delete realmEntity.contexts;\n        emit ProfileRealmRemoved(sender, profileId, realms[i], false);\n      } else {\n        require(realmEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n        realmEntity.bs.acstat = ActivityStatus.DELETED;\n        emit ProfileRealmRemoved(sender, profileId, realms[i], true);\n      }\n    }\n    return true;\n  }\n\n  function profileRealmCheckId(bytes32 profileId, bytes32 realmId) external view returns (bool) {\n    return _data.profiles[profileId].scopes[realmId].stype == ScopeType.REALM;\n  }\n\n  function profileRealmCheckName(bytes32 profileId, string calldata realmName) external view returns (bool) {\n    return _data.profiles[profileId].scopes[LACLUtils.generateId(realmName)].stype == ScopeType.REALM;\n  }\n\n  function profileRealmCheckAdmin(\n    bytes32 profileId,\n    bytes32 realmId,\n    address account\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    (RealmEntity storage realmEntity, bool result) = profileEntity.profileRealmTryReadSlot(realmId);\n    if (!result) return false;\n\n    bytes32 realmAdminId = realmEntity.bs.adminId;\n    AgentType agentType = profileEntity.agents[realmAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (agentType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result0) = profileEntity.profileRoleTryReadSlot(realmAdminId);\n      if (!result0) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == realmAdminId;\n    } else if (agentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(realmAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function profileRealmHasFunction(\n    bytes32 profileId,\n    bytes32 realmId,\n    bytes32 functionId\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n\n    (FunctionEntity storage fe, bool result) = profileEntity.profileFunctionTryReadSlot(functionId);\n    if (!result) return false;\n\n    (ContextEntity storage ce, bool result1) = profileEntity.profileContextTryReadSlot(fe.contextId);\n    if (!result1) return false;\n\n    return ce.realmId == realmId;\n  }\n\n  function profileRealmHasContext(\n    bytes32 profileId,\n    bytes32 realmId,\n    bytes32 contextId\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n\n    (RealmEntity storage re, bool result) = profileEntity.profileRealmTryReadSlot(realmId);\n    if (!result) return false;\n    return re.contexts.contains(contextId);\n  }\n\n  function profileRealmGetContexts(bytes32 profileId, bytes32 realmId) external view returns (bytes32[] memory) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return new bytes32[](0);\n\n    (RealmEntity storage re, bool result) = profileEntity.profileRealmTryReadSlot(realmId);\n    if (!result) return new bytes32[](0);\n    return re.contexts.values();\n  }\n\n  function profileRealmGetInfo(bytes32 profileId, bytes32 realmId) external view returns (ProfileRealmInfo memory) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    (RealmEntity storage re, bool result) = profileEntity.profileRealmTryReadSlot(realmId);\n    if (!result || profileEntity.acstat == ActivityStatus.NONE) {\n      return\n        ProfileRealmInfo({\n          domainId: bytes32(0),\n          adminId: bytes32(0),\n          contextLimit: 0,\n          contextCount: 0,\n          referredByAgent: 0,\n          stype: ScopeType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE,\n          adminType: AgentType.NONE,\n          name: \"\"\n        });\n    }\n\n    return\n      ProfileRealmInfo({\n        domainId: re.domainId,\n        adminId: re.bs.adminId,\n        contextLimit: re.contextLimit,\n        contextCount: uint32(re.contexts.length()),\n        referredByAgent: re.bs.referredByAgent,\n        stype: re.bs.stype,\n        acstat: re.bs.acstat,\n        alstat: re.bs.alstat,\n        adminType: profileEntity.agents[re.bs.adminId].atype,\n        name: re.name\n      });\n  }\n\n  function _doAgentGetScopeInfo(ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (ScopeType, bytes32)\n  {\n    AgentType atype = profileEntity.agents[agentId].atype;\n    if (atype == AgentType.ROLE) {\n      RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(agentId);\n      BaseScope storage baseScope = profileEntity.scopes[roleEntity.scopeId];\n      return (baseScope.stype, roleEntity.scopeId);\n    } else if (atype == AgentType.TYPE) {\n      TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(agentId);\n      BaseScope storage baseScope = profileEntity.scopes[typeEntity.scopeId];\n      return (baseScope.stype, typeEntity.scopeId);\n    }\n\n    return (ScopeType.NONE, bytes32(0));\n  }\n\n  function _doCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) internal view returns (IProfileACL.ProfileAdminAccessStatus) {\n    return LProfileCommons.profileCheckAdminAccess(profileEntity, functionEntity, adminId, senderId);\n  }\n\n  function _accessPermission(ProfileMemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      ProfileEntity storage,\n      FunctionEntity storage,\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(bytes(memberSign.profileName).length > 0, \"Illegal ProfileName\");\n\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getProfileMemeberSignerAddress(memberSign, PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    bytes32 profileId = LACLUtils.generateId(memberSign.profileName);\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n\n    ProfileAccessControl(payable(address(this))).profileAclHasMemberAccess(profileId, functionId, senderId);\n\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    FunctionEntity storage functionEntity = _data.functionReadSlot(functionId);\n    return (profileEntity, functionEntity, profileId, senderId, signer);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 realmId,\n    bytes32 senderId\n  ) internal view returns (RealmEntity storage) {\n    RealmEntity storage realmEntity = profileEntity.profileRealmReadSlot(realmId);\n    require(realmEntity.bs.acstat > ActivityStatus.DELETED, \"Realm Deleted\");\n    require(realmEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      realmEntity.bs.adminId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    return realmEntity;\n  }\n\n  function _doGetMemberScopeInfoFromType(\n    ProfileEntity storage profileEntity,\n    bytes32 typeId,\n    bytes32 senderId\n  ) internal view returns (ScopeType, bytes32) {\n    TypeEntity storage agentAdminType = profileEntity.profileTypeReadSlot(typeId);\n    bytes32 memberRoleId = agentAdminType.members[senderId];\n    RoleEntity storage memberAgentRole = profileEntity.profileRoleReadSlot(memberRoleId);\n    return (profileEntity.scopes[memberAgentRole.scopeId].stype, memberAgentRole.scopeId);\n  }\n\n  function _doProfileRealmRegister(\n    ProfileRealmRegisterRequest calldata request,\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 profileId,\n    bytes32 senderId,\n    address sender,\n    ScopeType memberScopeType,\n    bytes32 memberScopeId\n  ) internal {\n    bytes32 newRealmId = LProfileCommons.profileRealmRegister(\n      request,\n      profileEntity,\n      functionEntity,\n      senderId,\n      memberScopeType,\n      memberScopeId\n    );\n    emit ProfileRealmRegistered(sender, profileId, newRealmId, request.domainId, request.adminId);\n  }\n\n  function _doProfileRealmMoveContext(\n    ProfileRealmMoveContextRequest calldata request,\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 profileId,\n    bytes32 senderId,\n    address sender\n  ) internal {\n    RealmEntity storage realmEntity = _doGetEntityAndCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      request.realmId,\n      senderId\n    );\n    require(realmEntity.contexts.contains(request.contextId), \"Context Not Found\");\n    RealmEntity storage targetRealmEntity = _doGetEntityAndCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      request.targetRealmId,\n      senderId\n    );\n\n    ContextEntity storage contextEntity = profileEntity.profileContextReadSlot(request.contextId);\n    require(contextEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    require(contextEntity.bs.referredByAgent == 0, \"Illegal Referred\");\n\n    (, bytes32 contextAdminScopeId) = _doAgentGetScopeInfo(profileEntity, contextEntity.bs.adminId);\n    require(\n      IProfileACLGenerals(address(this)).profileIsScopesCompatible(\n        profileId,\n        contextAdminScopeId,\n        request.targetRealmId\n      ),\n      \"Illegal Admin Scope\"\n    );\n\n    require(targetRealmEntity.contextLimit > targetRealmEntity.contexts.length(), \"Illegal Move\");\n    realmEntity.contexts.remove(request.contextId);\n    targetRealmEntity.contexts.add(request.contextId);\n    contextEntity.realmId = request.targetRealmId;\n    emit ProfileRealmContextMoved(sender, profileId, request.realmId, request.contextId, request.targetRealmId);\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LProfileCommons);\n  }\n}\n"
    },
    "src/contracts/acl/profile/scope/ProfileDomainManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IProfileDomainManagement.sol\";\nimport \"../IProfileACL.sol\";\nimport \"../IProfileACLGenerals.sol\";\nimport \"../ProfileAccessControl.sol\";\nimport \"../../ACLStorage.sol\";\nimport \"../../../lib/acl/LProfileStorage.sol\";\nimport \"../../../lib/acl/LACLStorage.sol\";\nimport \"../../../lib/acl/LACLUtils.sol\";\nimport \"../../../lib/acl/LProfileCommons.sol\";\nimport \"../../../lib/struct/LEnumerableSet.sol\";\nimport \"../../../proxy/IProxy.sol\";\nimport \"../../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Profile Domain Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ProfileDomainManager is ACLStorage, BaseUUPSProxy, IProfileDomainManagement {\n  using LACLStorage for DataCollection;\n  using LProfileStorage for ProfileEntity;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IProfileDomainManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  // called by account that member of VERSE SCOPE MASTER TYPE\n  function profileDomainRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileDomainRegisterRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileDomainManagement.profileDomainRegister.selector);\n\n    // check profile and domain limitations and update it\n    LProfileCommons.profileCheckMemberForDomainRegister(profileEntity, uint16(requests.length), senderId);\n\n    // fetch scope type and scope id of sender\n    bytes32 senderScopeId = _doGetMemberScopeInfoFromType(\n      profileEntity,\n      _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID,\n      senderId\n    );\n    require(senderScopeId == _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Universe Scope\");\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      bytes32 newDomainId = LProfileCommons.profileDomainRegister(profileEntity, requests[i], functionEntity, senderId);\n      emit ProfileDomainRegistered(sender, profileId, newDomainId, requests[i].adminId);\n    }\n\n    return true;\n  }\n\n  function profileDomainUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileDomainManagement.profileDomainUpdateActivityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = profileEntity.profileDomainReadSlot(requests[i].entityId);\n      require(domainEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        domainEntity.bs.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      domainEntity.bs.acstat = requests[i].acstat;\n      emit ProfileDomainActivityUpdated(sender, profileId, requests[i].entityId, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function profileDomainUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileDomainManagement.profileDomainUpdateAlterabilityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = profileEntity.profileDomainReadSlot(requests[i].entityId);\n      require(domainEntity.bs.acstat > ActivityStatus.DELETED, \"Domain Deleted\");\n\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        domainEntity.bs.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      domainEntity.bs.alstat = requests[i].alstat;\n      emit ProfileDomainAlterabilityUpdated(sender, profileId, requests[i].entityId, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function profileDomainUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileDomainManagement.profileDomainUpdateAdmin.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].entityId,\n        senderId\n      );\n\n      // checking requested domain admin\n      if (requests[i].adminId != bytes32(0)) {\n        require(profileEntity.agents[requests[i].adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n        bytes32 requestAdminScopeId = _doAgentGetScopeInfo(profileEntity, requests[i].adminId);\n        require(requestAdminScopeId == _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Admin Scope\");\n        domainEntity.bs.adminId = requests[i].adminId;\n      } else {\n        domainEntity.bs.adminId = profileEntity.scopes[_LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID].adminId;\n      }\n\n      emit ProfileDomainAdminUpdated(sender, profileId, requests[i].entityId, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function profileDomainMoveRealm(\n    ProfileMemberSignature calldata memberSign,\n    ProfileDomainMoveRealmRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileDomainManagement.profileDomainMoveRealm.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      _doProfileDomainMoveRealm(requests[i], profileEntity, functionEntity, profileId, senderId, sender);\n    }\n    return true;\n  }\n\n  function profileDomainUpdateRealmLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileDomainUpdateRealmLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileDomainManagement.profileDomainUpdateRealmLimit.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].domainId,\n        senderId\n      );\n      require(requests[i].realmLimit > domainEntity.realms.length(), \"Illegal Limit\");\n      domainEntity.realmLimit = requests[i].realmLimit;\n      emit ProfileDomainRealmLimitUpdated(sender, profileId, requests[i].domainId, requests[i].realmLimit);\n    }\n    return true;\n  }\n\n  function profileDomainRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata domains)\n    external\n    returns (bool)\n  {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileDomainManagement.profileDomainRemove.selector);\n    for (uint256 i = 0; i < domains.length; i++) {\n      DomainEntity storage domainEntity = profileEntity.profileDomainReadSlot(domains[i]);\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        domainEntity.bs.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      require(domainEntity.realms.length() == 0, \"Illegal Remove\");\n      if (domainEntity.bs.referredByAgent == 0) {\n        // check universe\n        UniverseEntity storage universeEntity = profileEntity.profileUniverseReadSlot(domainEntity.universeId);\n        require(universeEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Universe Updatable\");\n        universeEntity.domains.remove(domains[i]);\n\n        delete domainEntity.bs;\n        delete domainEntity.universeId;\n        delete domainEntity.realmLimit;\n        delete domainEntity.name;\n        delete domainEntity.realms;\n        emit ProfileDomainRemoved(sender, profileId, domains[i], false);\n      } else {\n        require(domainEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n        domainEntity.bs.acstat = ActivityStatus.DELETED;\n        emit ProfileDomainRemoved(sender, profileId, domains[i], true);\n      }\n    }\n    return true;\n  }\n\n  function profileDomainCheckId(bytes32 profileId, bytes32 domainId) external view returns (bool) {\n    return _data.profiles[profileId].scopes[domainId].stype == ScopeType.DOMAIN;\n  }\n\n  function profileDomainCheckName(bytes32 profileId, string calldata domainName) external view returns (bool) {\n    return _data.profiles[profileId].scopes[LACLUtils.generateId(domainName)].stype == ScopeType.DOMAIN;\n  }\n\n  function profileDomainCheckAdmin(\n    bytes32 profileId,\n    bytes32 domainId,\n    address account\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    (DomainEntity storage domainEntity, bool result) = profileEntity.profileDomainTryReadSlot(domainId);\n    if (!result) return false;\n\n    bytes32 domainAdminId = domainEntity.bs.adminId;\n    AgentType agentType = profileEntity.agents[domainAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (agentType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result0) = profileEntity.profileRoleTryReadSlot(domainAdminId);\n      if (!result0) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == domainAdminId;\n    } else if (agentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(domainAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function profileDomainHasFunction(\n    bytes32 profileId,\n    bytes32 domainId,\n    bytes32 functionId\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    (FunctionEntity storage fe, bool result) = profileEntity.profileFunctionTryReadSlot(functionId);\n    if (!result) return false;\n\n    (ContextEntity storage ce, bool result1) = profileEntity.profileContextTryReadSlot(fe.contextId);\n    if (!result1) return false;\n\n    (RealmEntity storage re, bool result2) = profileEntity.profileRealmTryReadSlot(ce.realmId);\n    if (!result2) return false;\n\n    return re.domainId == domainId;\n  }\n\n  function profileDomainHasContext(\n    bytes32 profileId,\n    bytes32 domainId,\n    bytes32 contextId\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    (ContextEntity storage ce, bool result1) = profileEntity.profileContextTryReadSlot(contextId);\n    if (!result1) return false;\n\n    (RealmEntity storage re, bool result2) = profileEntity.profileRealmTryReadSlot(ce.realmId);\n    if (!result2) return false;\n\n    return re.domainId == domainId;\n  }\n\n  function profileDomainHasRealm(\n    bytes32 profileId,\n    bytes32 domainId,\n    bytes32 realmId\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    (DomainEntity storage de, bool result) = profileEntity.profileDomainTryReadSlot(domainId);\n    if (!result) return false;\n    return de.realms.contains(realmId);\n  }\n\n  function profileDomainGetRealms(bytes32 profileId, bytes32 domainId) external view returns (bytes32[] memory) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return new bytes32[](0);\n    (DomainEntity storage de, bool result) = profileEntity.profileDomainTryReadSlot(domainId);\n    if (!result) return new bytes32[](0);\n    return de.realms.values();\n  }\n\n  function profileDomainGetInfo(bytes32 profileId, bytes32 domainId) external view returns (ProfileDomainInfo memory) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    (DomainEntity storage de, bool result) = profileEntity.profileDomainTryReadSlot(domainId);\n    if (!result || profileEntity.acstat == ActivityStatus.NONE) {\n      return\n        ProfileDomainInfo({\n          adminId: bytes32(0),\n          universeId: bytes32(0),\n          realmLimit: 0,\n          realmCount: 0,\n          referredByAgent: 0,\n          stype: ScopeType.NONE,\n          adminType: AgentType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE,\n          name: \"\"\n        });\n    }\n\n    return\n      ProfileDomainInfo({\n        adminId: de.bs.adminId,\n        universeId: de.universeId,\n        realmLimit: de.realmLimit,\n        realmCount: uint16(de.realms.length()),\n        referredByAgent: de.bs.referredByAgent,\n        adminType: profileEntity.agents[de.bs.adminId].atype,\n        stype: de.bs.stype,\n        acstat: de.bs.acstat,\n        alstat: de.bs.alstat,\n        name: de.name\n      });\n  }\n\n  function _doCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) internal view returns (IProfileACL.ProfileAdminAccessStatus) {\n    return LProfileCommons.profileCheckAdminAccess(profileEntity, functionEntity, adminId, senderId);\n  }\n\n  function _doAgentGetScopeInfo(ProfileEntity storage profileEntity, bytes32 agentId) internal view returns (bytes32) {\n    AgentType atype = profileEntity.agents[agentId].atype;\n    if (atype == AgentType.ROLE) {\n      RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(agentId);\n      return roleEntity.scopeId;\n    } else if (atype == AgentType.TYPE) {\n      TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(agentId);\n      return typeEntity.scopeId;\n    }\n\n    return bytes32(0);\n  }\n\n  function _accessPermission(ProfileMemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      ProfileEntity storage,\n      FunctionEntity storage,\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(bytes(memberSign.profileName).length > 0, \"Illegal ProfileName\");\n\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getProfileMemeberSignerAddress(memberSign, PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    bytes32 profileId = LACLUtils.generateId(memberSign.profileName);\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n\n    ProfileAccessControl(payable(address(this))).profileAclHasMemberAccess(profileId, functionId, senderId);\n\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    FunctionEntity storage functionEntity = _data.functionReadSlot(functionId);\n    return (profileEntity, functionEntity, profileId, senderId, signer);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 domainId,\n    bytes32 senderId\n  ) internal view returns (DomainEntity storage) {\n    DomainEntity storage domainEntity = profileEntity.profileDomainReadSlot(domainId);\n    require(domainEntity.bs.acstat > ActivityStatus.DELETED, \"Domain Deleted\");\n    require(domainEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      domainEntity.bs.adminId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    return domainEntity;\n  }\n\n  // function _doGetRealmEntityAndCheckAdminAccess(\n  //   ProfileEntity storage profileEntity,\n  //   FunctionEntity storage functionEntity,\n  //   bytes32 realmId,\n  //   bytes32 senderId\n  // ) internal view returns (RealmEntity storage) {\n  //   RealmEntity storage realmEntity = profileEntity.profileRealmReadSlot(realmId);\n  //   require(realmEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n  //   IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n  //     profileEntity,\n  //     functionEntity,\n  //     realmEntity.bs.adminId,\n  //     senderId\n  //   );\n  //   if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n  //   return realmEntity;\n  // }\n\n  function _doGetMemberScopeInfoFromType(\n    ProfileEntity storage profileEntity,\n    bytes32 typeId,\n    bytes32 senderId\n  ) internal view returns (bytes32) {\n    TypeEntity storage agentAdminType = profileEntity.profileTypeReadSlot(typeId);\n    bytes32 memberRoleId = agentAdminType.members[senderId];\n    RoleEntity storage memberAgentRole = profileEntity.profileRoleReadSlot(memberRoleId);\n    return memberAgentRole.scopeId;\n  }\n\n  function _doProfileDomainMoveRealm(\n    ProfileDomainMoveRealmRequest calldata request,\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 profileId,\n    bytes32 senderId,\n    address sender\n  ) internal {\n    DomainEntity storage domainEntity = _doGetEntityAndCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      request.domainId,\n      senderId\n    );\n    require(domainEntity.realms.contains(request.realmId), \"Realm Not Found\");\n    DomainEntity storage targetDomainEntity = _doGetEntityAndCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      request.targetDomainId,\n      senderId\n    );\n\n    RealmEntity storage realmEntity = profileEntity.profileRealmReadSlot(request.realmId);\n    require(realmEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    require(realmEntity.bs.referredByAgent == 0, \"Illegal Referred\");\n\n    bytes32 realmAdminScopeId = _doAgentGetScopeInfo(profileEntity, realmEntity.bs.adminId);\n    require(\n      IProfileACLGenerals(address(this)).profileIsScopesCompatible(\n        profileId,\n        realmAdminScopeId,\n        request.targetDomainId\n      ),\n      \"Illegal Admin Scope\"\n    );\n    require(targetDomainEntity.realmLimit > targetDomainEntity.realms.length(), \"Illegal Move\");\n\n    domainEntity.realms.remove(request.realmId);\n    targetDomainEntity.realms.add(request.realmId);\n    realmEntity.domainId = request.targetDomainId;\n    emit ProfileDomainRealmMoved(sender, profileId, request.domainId, request.realmId, request.targetDomainId);\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LProfileCommons);\n  }\n}\n"
    },
    "src/contracts/acl/profile/scope/ProfileContextManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IProfileContextManagement.sol\";\nimport \"../IProfileACL.sol\";\nimport \"../IProfileACLGenerals.sol\";\nimport \"../ProfileAccessControl.sol\";\nimport \"../../ACLStorage.sol\";\nimport \"../../../lib/acl/LProfileStorage.sol\";\nimport \"../../../lib/acl/LACLStorage.sol\";\nimport \"../../../lib/proxy/LClones.sol\";\nimport \"../../../lib/cryptography/LECDSA.sol\";\nimport \"../../../lib/acl/LACLUtils.sol\";\nimport \"../../../lib/acl/LProfileCommons.sol\";\nimport \"../../../lib/struct/LEnumerableSet.sol\";\nimport \"../../../proxy/IProxy.sol\";\nimport \"../../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Profile Context Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ProfileContextManager is ACLStorage, BaseUUPSProxy, IProfileContextManagement {\n  using LACLStorage for DataCollection;\n  using LProfileStorage for ProfileEntity;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LClones for address;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IProfileContextManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  // called by system admin\n  function profileContextRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileContextRegisterRequest[] calldata requests\n  ) external returns (bool) {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(bytes(memberSign.profileName).length > 0, \"Illegal ProfileName\");\n    bytes32 profileId = LACLUtils.generateId(memberSign.profileName);\n\n    address signer;\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getProfileMemeberSignerAddress(memberSign, PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      address contractId;\n      if (requests[i].contractId == address(0)) {\n        if (memberSign.signature.length == 0) {\n          if (requests[i].signature.length > 0) {\n            signer = _doGetSignerAddress(\n              requests[i].signature,\n              _getPredictContextMessageHash(profileId, requests[i].deployer, requests[i].subject, requests[i].realmId)\n            );\n          } else {\n            signer = msg.sender;\n          }\n        }\n\n        contractId = requests[i].subject.predictDeterministicAddress(requests[i].salt, requests[i].deployer);\n      } else {\n        if (memberSign.signature.length == 0) {\n          if (requests[i].signature.length > 0) {\n            bytes32 structHash = _getContextMessageHash(\n              profileId,\n              requests[i].contractId,\n              LACLUtils.generateHash(requests[i].name),\n              LACLUtils.generateHash(requests[i].version),\n              requests[i].realmId\n            );\n            signer = _doGetSignerAddress(requests[i].signature, structHash);\n          } else {\n            signer = msg.sender;\n          }\n        }\n        contractId = requests[i].contractId;\n      }\n\n      bytes32 newContextId = LProfileCommons.profileRegisterContext(_data, requests[i], profileId, contractId, signer);\n\n      emit ProfileContextRegistered(\n        signer,\n        profileId,\n        newContextId,\n        requests[i].realmId,\n        requests[i].adminId,\n        contractId,\n        requests[i].deployer,\n        requests[i].subject\n      );\n    }\n\n    return true;\n  }\n\n  function profileContextUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileContextManagement.profileContextUpdateActivityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      ContextEntity storage contextEntity = profileEntity.profileContextReadSlot(requests[i].entityId);\n      require(contextEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        contextEntity.bs.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      contextEntity.bs.acstat = requests[i].acstat;\n      emit ProfileContextActivityUpdated(sender, profileId, requests[i].entityId, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function profileContextUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileContextManagement.profileContextUpdateAlterabilityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      ContextEntity storage contextEntity = profileEntity.profileContextReadSlot(requests[i].entityId);\n      require(contextEntity.bs.acstat > ActivityStatus.DELETED, \"Context Deleted\");\n\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        contextEntity.bs.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      contextEntity.bs.alstat = requests[i].alstat;\n      emit ProfileContextAlterabilityUpdated(sender, profileId, requests[i].entityId, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function profileContextUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileContextManagement.profileContextUpdateAdmin.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      ContextEntity storage contextEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].entityId,\n        senderId\n      );\n\n      // checking requested type admin\n      if (requests[i].adminId != bytes32(0)) {\n        require(profileEntity.agents[requests[i].adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n        (ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doAgentGetScopeInfo(\n          profileEntity,\n          requests[i].adminId\n        );\n        require(ScopeType.CONTEXT <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n        if (ScopeType.CONTEXT == requestAdminScopeType) {\n          require(requestAdminScopeId == requests[i].entityId, \"Illegal Admin Scope\");\n        } else {\n          require(\n            IProfileACLGenerals(address(this)).profileIsScopesCompatible(\n              profileId,\n              requestAdminScopeId,\n              requests[i].entityId\n            ),\n            \"Illegal Admin Scope\"\n          );\n        }\n        contextEntity.bs.adminId = requests[i].adminId;\n      } else {\n        contextEntity.bs.adminId = profileEntity.scopes[contextEntity.realmId].adminId;\n      }\n\n      emit ProfileContextAdminUpdated(sender, profileId, requests[i].entityId, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function profileContextUpdateFunctionLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileContextUpdateFunctionLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileContextManagement.profileContextUpdateFunctionLimit.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      ContextEntity storage contextEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].contextId,\n        senderId\n      );\n      require(requests[i].functionLimit > contextEntity.functions.length(), \"Illegal Limit\");\n      contextEntity.functionLimit = requests[i].functionLimit;\n      emit ProfileContextFunctionLimitUpdated(sender, profileId, requests[i].contextId, requests[i].functionLimit);\n    }\n    return true;\n  }\n\n  function profileContextRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata contexts)\n    external\n    returns (bool)\n  {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileContextManagement.profileContextRemove.selector);\n    for (uint256 i = 0; i < contexts.length; i++) {\n      ContextEntity storage contextEntity = profileEntity.profileContextReadSlot(contexts[i]);\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        contextEntity.bs.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n      require(contextEntity.functions.length() == 0, \"Illegal Remove\");\n      if (contextEntity.bs.referredByAgent == 0) {\n        // check realm\n        RealmEntity storage realmEntity = profileEntity.profileRealmReadSlot(contextEntity.realmId);\n        require(realmEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Realm Updatable\");\n        realmEntity.contexts.remove(contexts[i]);\n\n        delete contextEntity.bs;\n        delete contextEntity.realmId;\n        delete contextEntity.contractId;\n        delete contextEntity.functionLimit;\n        delete contextEntity.functions;\n        emit ProfileContextRemoved(sender, profileId, contexts[i], false);\n      } else {\n        require(contextEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n        contextEntity.bs.acstat = ActivityStatus.DELETED;\n        emit ProfileContextRemoved(sender, profileId, contexts[i], true);\n      }\n    }\n    return true;\n  }\n\n  function profileContextCheckId(bytes32 profileId, bytes32 contextId) external view returns (bool) {\n    return _data.profiles[profileId].scopes[contextId].stype == ScopeType.CONTEXT;\n  }\n\n  function profileContextCheckAccount(bytes32 profileId, address contractId) external view returns (bool) {\n    return _data.profiles[profileId].scopes[LACLUtils.accountGenerateId(contractId)].stype == ScopeType.CONTEXT;\n  }\n\n  function profileContextCheckAdmin(\n    bytes32 profileId,\n    bytes32 contextId,\n    address account\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    (ContextEntity storage ce, bool result) = profileEntity.profileContextTryReadSlot(contextId);\n    if (!result) return false;\n\n    bytes32 contextAdminId = ce.bs.adminId;\n    AgentType agentType = profileEntity.agents[contextAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (agentType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result0) = profileEntity.profileRoleTryReadSlot(contextAdminId);\n      if (!result0) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == contextAdminId;\n    } else if (agentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = profileEntity.profileTypeTryReadSlot(contextAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function profileContextHasFunction(\n    bytes32 profileId,\n    bytes32 contextId,\n    bytes32 functionId\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    return _doContextHasFunction(profileEntity, contextId, functionId);\n  }\n\n  function profileContextHasSelector(\n    bytes32 profileId,\n    address contractId,\n    bytes4 selector\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    bytes32 contextId = LACLUtils.accountGenerateId(contractId);\n    bytes32 functionId = LACLUtils.functionGenerateId(contractId, selector);\n    return _doContextHasFunction(profileEntity, contextId, functionId);\n  }\n\n  function profileContextGetFunctions(bytes32 profileId, bytes32 contextId) external view returns (bytes32[] memory) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return new bytes32[](0);\n    (ContextEntity storage ce, bool result) = profileEntity.profileContextTryReadSlot(contextId);\n    if (!result) return new bytes32[](0);\n    return ce.functions.values();\n  }\n\n  function profileContextGetInfo(bytes32 profileId, bytes32 contextId)\n    external\n    view\n    returns (ProfileContextInfo memory)\n  {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    (ContextEntity storage ce, bool result) = profileEntity.profileContextTryReadSlot(contextId);\n    if (!result || profileEntity.acstat == ActivityStatus.NONE) {\n      return\n        ProfileContextInfo({\n          realmId: bytes32(0),\n          adminId: bytes32(0),\n          contractId: address(0),\n          functionCount: 0,\n          functionLimit: 0,\n          referredByAgent: 0,\n          adminType: AgentType.NONE,\n          stype: ScopeType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE\n        });\n    }\n\n    return\n      ProfileContextInfo({\n        realmId: ce.realmId,\n        adminId: ce.bs.adminId,\n        contractId: ce.contractId,\n        functionCount: uint8(ce.functions.length()),\n        functionLimit: ce.functionLimit,\n        referredByAgent: ce.bs.referredByAgent,\n        adminType: profileEntity.agents[ce.bs.adminId].atype,\n        stype: ce.bs.stype,\n        acstat: ce.bs.acstat,\n        alstat: ce.bs.alstat\n      });\n  }\n\n  function _doContextHasFunction(\n    ProfileEntity storage profileEntity,\n    bytes32 contextId,\n    bytes32 functionId\n  ) internal view returns (bool) {\n    (ContextEntity storage ce, bool result) = profileEntity.profileContextTryReadSlot(contextId);\n    if (!result) return false;\n    return ce.functions.contains(functionId);\n  }\n\n  function _doCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) internal view returns (IProfileACL.ProfileAdminAccessStatus) {\n    return LProfileCommons.profileCheckAdminAccess(profileEntity, functionEntity, adminId, senderId);\n  }\n\n  function _doAgentGetScopeInfo(ProfileEntity storage profileEntity, bytes32 agentId)\n    internal\n    view\n    returns (ScopeType, bytes32)\n  {\n    return LProfileCommons.profileAgentGetScopeInfo(profileEntity, agentId);\n  }\n\n  function _accessPermission(ProfileMemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      ProfileEntity storage,\n      FunctionEntity storage,\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(bytes(memberSign.profileName).length > 0, \"Illegal ProfileName\");\n\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getProfileMemeberSignerAddress(memberSign, PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    bytes32 profileId = LACLUtils.generateId(memberSign.profileName);\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n\n    ProfileAccessControl(payable(address(this))).profileAclHasMemberAccess(profileId, functionId, senderId);\n\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    FunctionEntity storage functionEntity = _data.functionReadSlot(functionId);\n    return (profileEntity, functionEntity, profileId, senderId, signer);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 contextId,\n    bytes32 senderId\n  ) internal view returns (ContextEntity storage) {\n    ContextEntity storage contextEntity = profileEntity.profileContextReadSlot(contextId);\n    require(contextEntity.bs.acstat > ActivityStatus.DELETED, \"Context Deleted\");\n    require(contextEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      contextEntity.bs.adminId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    return contextEntity;\n  }\n\n  function _doGetSignerAddress(bytes memory signature, bytes32 structHash) internal view returns (address) {\n    bytes32 msgDigest = _hashTypedDataV4(structHash);\n    (address msgSigner, LECDSA.RecoverError recoverErr) = LECDSA.tryRecover(msgDigest, signature);\n    require(recoverErr == LECDSA.RecoverError.NoError, \"Illegal Signature\");\n    return msgSigner;\n  }\n\n  function _getContextMessageHash(\n    bytes32 profileId,\n    address contractId,\n    bytes32 name,\n    bytes32 version,\n    bytes32 realmId\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(PROFILE_CTX_MESSAGE_TYPEHASH, profileId, contractId, name, version, realmId));\n  }\n\n  function _getPredictContextMessageHash(\n    bytes32 profileId,\n    address deployer,\n    address subject,\n    bytes32 realmId\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(PROFILE_PREDICT_CTX_MESSAGE_TYPEHASH, profileId, deployer, subject, realmId));\n  }\n\n  function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {\n    return LECDSA.toTypedDataHash(IProxy(address(this)).domainSeparator(), structHash);\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LProfileCommons);\n  }\n}\n"
    },
    "src/contracts/acl/profile/agent/ProfileRoleManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IProfileRoleManagement.sol\";\nimport \"./IProfileMemberManagement.sol\";\nimport \"./IProfileTypeManagement.sol\";\nimport \"../IProfileACL.sol\";\nimport \"../ProfileAccessControl.sol\";\nimport \"../IProfileACLGenerals.sol\";\nimport \"../scope/IProfileFunctionManagement.sol\";\nimport \"../../ACLStorage.sol\";\nimport \"../../../lib/acl/LProfileStorage.sol\";\nimport \"../../../lib/acl/LACLStorage.sol\";\nimport \"../../../lib/acl/LProfileRolePolicy.sol\";\nimport \"../../../lib/struct/LEnumerableSet.sol\";\nimport \"../../../lib/acl/LACLUtils.sol\";\nimport \"../../../proxy/IProxy.sol\";\nimport \"../../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title ACL Role Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ProfileRoleManager is ACLStorage, BaseUUPSProxy, IProfileRoleManagement {\n  using LACLStorage for DataCollection;\n  using LProfileStorage for ProfileEntity;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IProfileRoleManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  // type admins call roleRegister function\n  function profileRoleRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRoleRegisterRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRoleManagement.profileRoleRegister.selector);\n    LProfileRolePolicy.profileCheckMemberForRoleRegister(profileEntity, uint16(requests.length), senderId);\n    for (uint256 i = 0; i < requests.length; i++) {\n      _doRoleRegister(requests[i], profileEntity, functionEntity, profileId, senderId, sender);\n    }\n    return true;\n  }\n\n  function profileRoleUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRoleManagement.profileRoleUpdateAdmin.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      RoleEntity storage roleEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].entityId,\n        senderId\n      );\n      roleEntity.ba.adminId = _getRoleAdmin(\n        profileEntity,\n        profileEntity.scopes[roleEntity.scopeId].stype,\n        profileEntity.agents[roleEntity.typeId].adminId,\n        roleEntity.scopeId,\n        requests[i].adminId,\n        profileId\n      );\n      emit ProfileRoleAdminUpdated(sender, profileId, requests[i].entityId, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function profileRoleUpdateScope(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateScopeRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRoleManagement.profileRoleUpdateScope.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      LProfileRolePolicy.profileRoleUpdateScope(requests[i], profileEntity, functionEntity, profileId, senderId);\n      emit ProfileRoleScopeUpdated(sender, profileId, requests[i].entityId, requests[i].scopeId);\n    }\n    return true;\n  }\n\n  function profileRoleUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRoleManagement.profileRoleUpdateActivityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      require(requests[i].entityId != LProfileRolePolicy.LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID, \"Illegal Role\");\n\n      RoleEntity storage roleEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].entityId,\n        senderId\n      );\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      roleEntity.ba.acstat = requests[i].acstat;\n      emit ProfileRoleActivityUpdated(sender, profileId, requests[i].entityId, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function profileRoleUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRoleManagement.profileRoleUpdateAlterabilityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      require(requests[i].entityId != LProfileRolePolicy.LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID, \"Illegal Role\");\n\n      RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(requests[i].entityId);\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        roleEntity.ba.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      roleEntity.ba.alstat = requests[i].alstat;\n      emit ProfileRoleAlterabilityUpdated(sender, profileId, requests[i].entityId, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function profileRoleUpdateMemberLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRoleUpdateMemberLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRoleManagement.profileRoleUpdateMemberLimit.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      RoleEntity storage roleEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].roleId,\n        senderId\n      );\n      require(requests[i].memberLimit > roleEntity.memberCount, \"Illegal Limit\");\n      roleEntity.memberLimit = requests[i].memberLimit;\n      emit ProfileRoleMemberLimitUpdated(sender, profileId, requests[i].roleId, requests[i].memberLimit);\n    }\n    return true;\n  }\n\n  function profileRoleGrantMembers(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRoleGrantMembersRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRoleManagement.profileRoleGrantMembers.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      _doProfileRoleGrantMembers(requests[i], profileEntity, functionEntity, profileId, senderId, sender);\n    }\n    return true;\n  }\n\n  function profileRoleRevokeMembers(\n    ProfileMemberSignature calldata memberSign,\n    ProfileRoleRevokeMembersRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRoleManagement.profileRoleRevokeMembers.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      _doProfileRoleRevokeMembers(requests[i], profileEntity, functionEntity, profileId, senderId, sender);\n    }\n    return true;\n  }\n\n  function profileRoleRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata roles)\n    external\n    returns (bool)\n  {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileRoleManagement.profileRoleRemove.selector);\n    for (uint256 i = 0; i < roles.length; i++) {\n      RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(roles[i]);\n\n      // check access admin role\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        roleEntity.ba.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n      require(roleEntity.memberCount == 0, \"Illegal Remove\");\n\n      // check type\n      TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(roleEntity.typeId);\n      require(typeEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Type Updatable\");\n      typeEntity.roles.remove(roles[i]);\n\n      BaseScope storage roleScope = profileEntity.scopes[roleEntity.scopeId];\n      require(roleScope.referredByAgent > 0, \"Illeagl Referred\");\n      unchecked {\n        roleScope.referredByAgent -= 1;\n      }\n\n      delete roleEntity.name;\n      delete roleEntity.memberCount;\n      delete roleEntity.memberLimit;\n      delete roleEntity.typeId;\n      delete roleEntity.scopeId;\n      delete roleEntity.ba;\n\n      emit ProfileRoleRemoved(sender, profileId, roles[i]);\n    }\n    return true;\n  }\n\n  function profileRoleCheckId(bytes32 profileId, bytes32 roleId) external view returns (bool) {\n    return _data.profiles[profileId].agents[roleId].atype == AgentType.ROLE;\n  }\n\n  function profileRoleCheckName(bytes32 profileId, string calldata roleName) external view returns (bool) {\n    return _data.profiles[profileId].agents[keccak256(abi.encodePacked(roleName))].atype == AgentType.ROLE;\n  }\n\n  function profileRoleCheckAdmin(\n    bytes32 profileId,\n    bytes32 roleId,\n    address account\n  ) external view returns (bool) {\n    return LProfileRolePolicy.profileRoleCheckAdmin(_data, profileId, roleId, account);\n  }\n\n  function profileRoleHasAccount(\n    bytes32 profileId,\n    bytes32 roleId,\n    address account\n  ) external view returns (bool) {\n    return LProfileRolePolicy.profileRoleHasAccount(_data, profileId, roleId, account);\n  }\n\n  function profileRoleGetInfo(bytes32 profileId, bytes32 roleId) external view returns (ProfileRoleInfo memory) {\n    return LProfileRolePolicy.profileRoleGetInfo(_data, profileId, roleId);\n  }\n\n  function _doCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) internal view returns (IProfileACL.ProfileAdminAccessStatus) {\n    return LProfileRolePolicy.profileCheckAdminAccess(profileEntity, functionEntity, adminId, senderId);\n  }\n\n  function _accessPermission(ProfileMemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      ProfileEntity storage,\n      FunctionEntity storage,\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(bytes(memberSign.profileName).length > 0, \"Illegal ProfileName\");\n\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getProfileMemeberSignerAddress(memberSign, PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    bytes32 profileId = LACLUtils.generateId(memberSign.profileName);\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n\n    ProfileAccessControl(payable(address(this))).profileAclHasMemberAccess(profileId, functionId, senderId);\n\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    FunctionEntity storage functionEntity = _data.functionReadSlot(functionId);\n    return (profileEntity, functionEntity, profileId, senderId, signer);\n  }\n\n  function _getRoleAdmin(\n    ProfileEntity storage profileEntity,\n    ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId,\n    bytes32 profileId\n  ) internal view returns (bytes32 roleAdminId) {\n    return\n      LProfileRolePolicy.profileGetRoleAdmin(\n        profileEntity,\n        requestScopeType,\n        requestScopeAdmin,\n        scopeId,\n        adminId,\n        profileId\n      );\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 roleId,\n    bytes32 senderId\n  ) internal view returns (RoleEntity storage) {\n    return LProfileRolePolicy.profileGetRoleEntityAndCheckAdminAccess(profileEntity, functionEntity, roleId, senderId);\n  }\n\n  function _updateProfileAccount(\n    bytes32 profileId,\n    bytes32 typeId,\n    ProfileMemberEntity storage profileMemberEntity,\n    bool isRevoke\n  ) internal {\n    return LProfileRolePolicy.updateProfileAccount(_data, profileMemberEntity, profileId, typeId, isRevoke);\n  }\n\n  function _doProfileRoleRevokeMembers(\n    ProfileRoleRevokeMembersRequest calldata request,\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 profileId,\n    bytes32 senderId,\n    address sender\n  ) internal {\n    RoleEntity storage roleEntity = _doGetEntityAndCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      request.roleId,\n      senderId\n    );\n    TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(roleEntity.typeId);\n    require(typeEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Type Updatable\");\n\n    for (uint256 j = 0; j < request.members.length; j++) {\n      ProfileMemberEntity storage profileMemberEntity = profileEntity.profileMemberReadSlot(request.members[j]);\n      require(profileMemberEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Member Updatable\");\n      if (request.roleId == LProfileRolePolicy.LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID) {\n        require(request.members[j] != LACLUtils.accountGenerateId(profileEntity.owner), \"Illegal Owner Revoke\");\n      }\n\n      require(typeEntity.members[request.members[j]] != bytes32(0), \"Not Found\");\n      require(roleEntity.memberCount > 0, \"Illegal MemberCount\");\n      delete typeEntity.members[request.members[j]];\n      unchecked {\n        roleEntity.memberCount -= 1;\n      }\n      profileMemberEntity.types.remove(roleEntity.typeId);\n\n      // check and remove member from admin\n      if (profileEntity.admins.contains(request.members[j])) {\n        require(profileEntity.owner != profileMemberEntity.account, \"Illegal Revoke\");\n        profileEntity.admins.remove(request.members[j]);\n      }\n\n      if (profileMemberEntity.types.length() == 0) {\n        _updateProfileAccount(profileId, roleEntity.typeId, profileMemberEntity, true);\n\n        delete profileMemberEntity.ba;\n        delete profileMemberEntity.callLimit;\n        delete profileMemberEntity.typeLimit;\n        delete profileMemberEntity.account;\n        delete profileMemberEntity.registerLimits;\n        delete profileMemberEntity.types;\n\n        emit ProfileRoleMemberDeleted(\n          sender,\n          profileId,\n          request.members[j],\n          request.roleId,\n          roleEntity.typeId,\n          profileMemberEntity.account\n        );\n      }\n      emit ProfileRoleMemberRevoked(sender, profileId, request.roleId, request.members[j], roleEntity.typeId);\n    }\n  }\n\n  function _doProfileRoleGrantMembers(\n    ProfileRoleGrantMembersRequest calldata request,\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 profileId,\n    bytes32 senderId,\n    address sender\n  ) internal {\n    RoleEntity storage roleEntity = _doGetEntityAndCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      request.roleId,\n      senderId\n    );\n    TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(roleEntity.typeId);\n    require(typeEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Type Updatable\");\n\n    for (uint256 j = 0; j < request.members.length; j++) {\n      require(roleEntity.memberCount < roleEntity.memberLimit, \"Illegal Grant\");\n      if (request.roleId == LProfileRolePolicy.LIVELY_PROFILE_LIVELY_MASTER_ADMIN_ROLE_ID) {\n        require(request.members[j] != LACLUtils.accountGenerateId(profileEntity.owner), \"Illegal Owner Revoke\");\n      }\n\n      ProfileMemberEntity storage profileMemberEntity = profileEntity.profileMemberReadSlot(request.members[j]);\n      if (profileMemberEntity.types.contains(roleEntity.typeId)) {\n        {\n          bytes32 currentRoleId = typeEntity.members[request.members[j]];\n          require(currentRoleId != request.roleId, \"Already Exist\");\n          RoleEntity storage currentRoleEntity = _doGetEntityAndCheckAdminAccess(\n            profileEntity,\n            functionEntity,\n            currentRoleId,\n            senderId\n          );\n          require(currentRoleEntity.memberCount > 0, \"Illegal MemberCount\");\n          unchecked {\n            currentRoleEntity.memberCount -= 1;\n          }\n        }\n        emit ProfileRoleMemberRevoked(\n          sender,\n          profileId,\n          typeEntity.members[request.members[j]],\n          request.members[j],\n          roleEntity.typeId\n        );\n      } else {\n        require(profileMemberEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Member Updatable\");\n        require(profileMemberEntity.typeLimit > profileMemberEntity.types.length(), \"Illegal Member TypeLimit\");\n        _updateProfileAccount(profileId, roleEntity.typeId, profileMemberEntity, false);\n        // check and add member from admin\n        if (roleEntity.typeId == _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID) profileEntity.admins.add(request.members[j]);\n\n        profileMemberEntity.types.add(roleEntity.typeId);\n      }\n\n      typeEntity.members[request.members[j]] = request.roleId;\n      roleEntity.memberCount += 1;\n      emit ProfileRoleMemberGranted(sender, profileId, request.roleId, request.members[j], roleEntity.typeId);\n    }\n  }\n\n  function _doRoleRegister(\n    ProfileRoleRegisterRequest calldata request,\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 profileId,\n    bytes32 senderId,\n    address sender\n  ) internal {\n    (bytes32 newRoleId, bytes32 adminId) = LProfileRolePolicy.profileRoleRegister(\n      request,\n      profileEntity,\n      functionEntity,\n      profileId,\n      senderId\n    );\n    emit ProfileRoleRegistered(sender, profileId, newRoleId, request.typeId, adminId, request.scopeId);\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LProfileRolePolicy);\n  }\n}\n"
    },
    "src/contracts/acl/profile/agent/ProfileMemberManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IProfileMemberManagement.sol\";\nimport \"./IProfileRoleManagement.sol\";\nimport \"./IProfileTypeManagement.sol\";\nimport \"../IProfileACL.sol\";\nimport \"../ProfileAccessControl.sol\";\nimport \"../IProfileACLGenerals.sol\";\nimport \"../scope/IProfileFunctionManagement.sol\";\nimport \"../../ACLStorage.sol\";\nimport \"../../../lib/acl/LProfileStorage.sol\";\nimport \"../../../lib/acl/LACLStorage.sol\";\nimport \"../../../lib/struct/LEnumerableSet.sol\";\nimport \"../../../lib/acl/LACLUtils.sol\";\nimport \"../../../lib/acl/LProfileCommons.sol\";\nimport \"../../../proxy/IProxy.sol\";\nimport \"../../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title ACL Profile Member Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ProfileMemberManager is ACLStorage, BaseUUPSProxy, IProfileMemberManagement {\n  using LACLStorage for DataCollection;\n  using LProfileStorage for ProfileEntity;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IProfileMemberManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  // Note: called by any admin of role\n  function profileMemberRegister(\n    ProfileMemberSignature calldata memberSign,\n    ProfileMemberRegisterRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileMemberManagement.profileMemberRegister.selector);\n    ProfileMemberEntity storage profileMemberEntity = profileEntity.profileMemberReadSlot(senderId);\n    uint32 memberRegisterLimit = profileMemberEntity.registerLimits.memberRegisterLimit;\n    LProfileCommons.profileCheckMemberForMemberRegister(\n      profileEntity,\n      profileMemberEntity,\n      uint16(requests.length),\n      senderId\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      // check register limits\n      if (profileMemberEntity.types.contains(_LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID)) {\n        _doCheckRegisterLimit(profileEntity.registerLimits, requests[i].registerLimit, memberRegisterLimit, true);\n      } else {\n        _doCheckRegisterLimit(profileMemberEntity.registerLimits, requests[i].registerLimit, memberRegisterLimit, true);\n      }\n\n      _doProfileMemberRegister(profileEntity, requests[i], functionEntity, senderId, profileId, sender);\n    }\n\n    return true;\n  }\n\n  function profileMemberUpdateActivityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateActivityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileMemberManagement.profileMemberUpdateActivityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      ProfileMemberEntity storage memberEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].entityId,\n        senderId\n      );\n      require(profileEntity.owner != memberEntity.account, \"Illegal Member\");\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      memberEntity.ba.acstat = requests[i].acstat;\n      emit ProfileMemberActivityUpdated(sender, profileId, requests[i].entityId, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function profileMemberUpdateAlterabilityStatus(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileMemberManagement.profileMemberUpdateAlterabilityStatus.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      ProfileMemberEntity storage memberEntity = profileEntity.profileMemberReadSlot(requests[i].entityId);\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        memberEntity.ba.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      memberEntity.ba.alstat = requests[i].alstat;\n      emit ProfileMemberAlterabilityUpdated(sender, profileId, requests[i].entityId, requests[i].alstat);\n    }\n    return true;\n  }\n\n  // Note: member default admin is\n  function profileMemberUpdateAdmin(\n    ProfileMemberSignature calldata memberSign,\n    ProfileUpdateAdminRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileMemberManagement.profileMemberUpdateAdmin.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      ProfileMemberEntity storage memberEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].entityId,\n        senderId\n      );\n\n      // checking requested admin of member\n      if (requests[i].adminId != bytes32(0)) {\n        BaseAgent storage requestedAdminAgent = profileEntity.agents[requests[i].adminId];\n        require(requestedAdminAgent.atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n        memberEntity.ba.adminId = requests[i].adminId;\n      } else {\n        memberEntity.ba.adminId = _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID;\n      }\n      emit ProfileMemberAdminUpdated(sender, profileId, requests[i].entityId, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function profileMemberUpdateTypeLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileMemberUpdateLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileMemberManagement.profileMemberUpdateTypeLimit.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      ProfileMemberEntity storage memberEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].memberId,\n        senderId\n      );\n      require(requests[i].limit > memberEntity.types.length(), \"Illegal Limit\");\n      memberEntity.typeLimit = requests[i].limit;\n      emit ProfileMemberTypeLimitUpdated(sender, profileId, requests[i].memberId, requests[i].limit);\n    }\n    return true;\n  }\n\n  function profileMemberUpdateRegisterLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileMemberUpdateRegisterLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileMemberManagement.profileMemberUpdateRegisterLimit.selector);\n    ProfileMemberEntity storage senderMemberEntity = profileEntity.profileMemberReadSlot(senderId);\n    for (uint256 i = 0; i < requests.length; i++) {\n      ProfileMemberEntity storage memberEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].memberId,\n        senderId\n      );\n\n      // check register limits\n      if (memberEntity.types.contains(_LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID)) {\n        _doCheckRegisterLimit(profileEntity.registerLimits, requests[i].registerLimit, 0, false);\n      } else {\n        _doCheckRegisterLimit(senderMemberEntity.registerLimits, requests[i].registerLimit, 0, false);\n      }\n      memberEntity.registerLimits = requests[i].registerLimit;\n      emit ProfileMemberRegisterLimitUpdated(sender, profileId, requests[i].memberId, requests[i].registerLimit);\n    }\n    return true;\n  }\n\n  function profileMemberUpdateCallLimit(\n    ProfileMemberSignature calldata memberSign,\n    ProfileMemberUpdateLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileMemberManagement.profileMemberUpdateCallLimit.selector);\n    for (uint256 i = 0; i < requests.length; i++) {\n      ProfileMemberEntity storage memberEntity = _doGetEntityAndCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        requests[i].memberId,\n        senderId\n      );\n      memberEntity.callLimit = requests[i].limit;\n      emit ProfileMemberCallLimitUpdated(sender, profileId, requests[i].memberId, requests[i].limit);\n    }\n    return true;\n  }\n\n  function profileMemberRemove(ProfileMemberSignature calldata memberSign, bytes32[] calldata members)\n    external\n    returns (bool)\n  {\n    (\n      ProfileEntity storage profileEntity,\n      FunctionEntity storage functionEntity,\n      bytes32 profileId,\n      bytes32 senderId,\n      address sender\n    ) = _accessPermission(memberSign, IProfileMemberManagement.profileMemberRemove.selector);\n\n    for (uint256 i = 0; i < members.length; i++) {\n      ProfileMemberEntity storage memberEntity = profileEntity.profileMemberReadSlot(members[i]);\n      IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        memberEntity.ba.adminId,\n        senderId\n      );\n      if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n\n      // check and remove member from admin\n      require(profileEntity.owner != memberEntity.account, \"Illegal Owner Remove\");\n      profileEntity.admins.remove(members[i]);\n\n      _doProfileRemoveMember(profileEntity, memberEntity, members[i], profileId, sender);\n    }\n    return true;\n  }\n\n  function profileMemberCheckId(bytes32 profileId, bytes32 memberId) external view returns (bool) {\n    return _data.profiles[profileId].agents[memberId].atype == AgentType.MEMBER;\n  }\n\n  function profileMemberCheckAccount(bytes32 profileId, address account) external view returns (bool) {\n    return _data.profiles[profileId].agents[keccak256(abi.encodePacked(account))].atype == AgentType.MEMBER;\n  }\n\n  function profileMemberCheckAdmin(\n    bytes32 profileId,\n    bytes32 memberId,\n    address account\n  ) external view returns (bool) {\n    return LProfileCommons.profileMemberCheckAdmin(_data, profileId, memberId, account);\n  }\n\n  function profileMemberHasType(\n    bytes32 profileId,\n    bytes32 memberId,\n    bytes32 typeId\n  ) external view returns (bool) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return false;\n    (ProfileMemberEntity storage member, bool result) = profileEntity.profileMemberTryReadSlot(memberId);\n    if (result) return member.types.contains(typeId);\n    return false;\n  }\n\n  function profileMemberGetTypes(bytes32 profileId, bytes32 memberId) external view returns (bytes32[] memory) {\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    if (profileEntity.acstat == ActivityStatus.NONE) return new bytes32[](0);\n    (ProfileMemberEntity storage member, bool result) = profileEntity.profileMemberTryReadSlot(memberId);\n    if (!result) return new bytes32[](0);\n    return member.types.values();\n  }\n\n  function profileMemberGetInfo(bytes32 profileId, bytes32 memberId) external view returns (ProfileMemberInfo memory) {\n    return LProfileCommons.profileMemberGetInfo(_data, profileId, memberId);\n  }\n\n  function _doCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 adminId,\n    bytes32 senderId\n  ) internal view returns (IProfileACL.ProfileAdminAccessStatus) {\n    return LProfileCommons.profileCheckAdminAccess(profileEntity, functionEntity, adminId, senderId);\n  }\n\n  function _accessPermission(ProfileMemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      ProfileEntity storage,\n      FunctionEntity storage,\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    require(bytes(memberSign.profileName).length > 0, \"Illegal ProfileName\");\n\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getProfileMemeberSignerAddress(memberSign, PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    bytes32 profileId = LACLUtils.generateId(memberSign.profileName);\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n\n    ProfileAccessControl(payable(address(this))).profileAclHasMemberAccess(profileId, functionId, senderId);\n\n    ProfileEntity storage profileEntity = _data.profiles[profileId];\n    FunctionEntity storage functionEntity = _data.functionReadSlot(functionId);\n    return (profileEntity, functionEntity, profileId, senderId, signer);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    ProfileEntity storage profileEntity,\n    FunctionEntity storage functionEntity,\n    bytes32 memberId,\n    bytes32 senderId\n  ) internal view returns (ProfileMemberEntity storage) {\n    ProfileMemberEntity storage memberEntity = profileEntity.profileMemberReadSlot(memberId);\n    require(memberEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IProfileACL.ProfileAdminAccessStatus status = _doCheckAdminAccess(\n      profileEntity,\n      functionEntity,\n      memberEntity.ba.adminId,\n      senderId\n    );\n    if (status != IProfileACL.ProfileAdminAccessStatus.PERMITTED) LACLUtils.generateProfileAdminAccessError(status);\n    return memberEntity;\n  }\n\n  function _doProfileMemberRegister(\n    ProfileEntity storage profileEntity,\n    ProfileMemberRegisterRequest calldata memberRequest,\n    FunctionEntity storage functionEntity,\n    bytes32 senderId,\n    bytes32 profileId,\n    address sender\n  ) internal {\n    bytes32 newMemberId = LACLUtils.accountGenerateId(memberRequest.account);\n    require(profileEntity.agents[newMemberId].acstat == ActivityStatus.NONE, \"Already Exist\");\n\n    // check role\n    RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(memberRequest.roleId);\n    require(roleEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Role Updatable\");\n    require(roleEntity.memberLimit > roleEntity.memberCount, \"Illegal Register\");\n\n    // check type\n    TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(roleEntity.typeId);\n    require(typeEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Type Updatable\");\n\n    // check access\n    {\n      IProfileACL.ProfileAdminAccessStatus adminAccessStatus = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        roleEntity.ba.adminId,\n        senderId\n      );\n      if (adminAccessStatus != IProfileACL.ProfileAdminAccessStatus.PERMITTED)\n        LACLUtils.generateProfileAdminAccessError(adminAccessStatus);\n    }\n\n    // check and add member to profile admin\n    if (roleEntity.typeId == _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID) profileEntity.admins.add(newMemberId);\n\n    // add new member to type\n    typeEntity.members[newMemberId] = memberRequest.roleId;\n\n    // add new member to role\n    roleEntity.memberCount += 1;\n\n    // create new member\n    ProfileMemberEntity storage newMember = profileEntity.profileMemberWriteSlot(newMemberId);\n\n    // create profileAccount\n    ProfileAccount storage newProfileAccount = _data.profileAccounts[memberRequest.account];\n    require(newProfileAccount.profiles.length == 0, \"PA Already Exist\");\n    newProfileAccount.profiles.push(profileId);\n\n    // check adminId\n    if (memberRequest.adminId != bytes32(0)) {\n      require(profileEntity.agents[memberRequest.adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n      IProfileACL.ProfileAdminAccessStatus adminAccessStatus = _doCheckAdminAccess(\n        profileEntity,\n        functionEntity,\n        _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID,\n        senderId\n      );\n      if (adminAccessStatus != IProfileACL.ProfileAdminAccessStatus.PERMITTED)\n        revert IProfileACL.ProfileSetAdminForbidden(adminAccessStatus);\n      newMember.ba.adminId = memberRequest.adminId;\n    } else {\n      newMember.ba.adminId = _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID;\n    }\n\n    newMember.ba.atype = AgentType.MEMBER;\n    newMember.ba.acstat = ActivityStatus.ENABLED;\n    newMember.ba.alstat = AlterabilityStatus.UPDATABLE;\n    newMember.account = memberRequest.account;\n    newMember.types.add(roleEntity.typeId);\n    newMember.typeLimit = memberRequest.typeLimit >= 1\n      ? uint16(uint24(memberRequest.typeLimit))\n      : profileEntity.limits.typeLimit;\n    newMember.callLimit = memberRequest.callLimit >= 0\n      ? uint16(uint24(memberRequest.callLimit))\n      : profileEntity.limits.memberCallLimit;\n    newMember.registerLimits = memberRequest.registerLimit;\n\n    emit ProfileMemberRegistered(\n      sender,\n      profileId,\n      newMemberId,\n      memberRequest.roleId,\n      newMember.ba.adminId,\n      memberRequest.registerLimit\n    );\n  }\n\n  function _doCheckRegisterLimit(\n    ProfileRegisterLimit storage registerLimits,\n    ProfileRegisterLimit calldata registerLimitRequest,\n    uint32 memberRegisterLimit,\n    bool isMemberRegister\n  ) internal view {\n    if (isMemberRegister) {\n      require(memberRegisterLimit >= registerLimitRequest.memberRegisterLimit, \"Illegal MemberRegisterLimit\");\n    } else {\n      require(\n        registerLimits.memberRegisterLimit >= registerLimitRequest.memberRegisterLimit,\n        \"Illegal MemberRegisterLimit\"\n      );\n    }\n    require(registerLimits.roleRegisterLimit >= registerLimitRequest.roleRegisterLimit, \"Illegal RoleRegisterLimit\");\n    require(registerLimits.typeRegisterLimit >= registerLimitRequest.typeRegisterLimit, \"Illegal TypeRegisterLimit\");\n    require(\n      registerLimits.functionRegisterLimit >= registerLimitRequest.functionRegisterLimit,\n      \"Illegal FunctionRegisterLimit\"\n    );\n    require(\n      registerLimits.contextRegisterLimit >= registerLimitRequest.contextRegisterLimit,\n      \"Illegal ContextRegisterLimit\"\n    );\n    require(registerLimits.realmRegisterLimit >= registerLimitRequest.realmRegisterLimit, \"Illegal RealmRegisterLimit\");\n    require(\n      registerLimits.domainRegisterLimit >= registerLimitRequest.domainRegisterLimit,\n      \"Illegal DomainRegisterLimit\"\n    );\n    require(\n      registerLimits.policyRegisterLimit >= registerLimitRequest.policyRegisterLimit,\n      \"Illegal PolicyRegisterLimit\"\n    );\n  }\n\n  function _doProfileRemoveMember(\n    ProfileEntity storage profileEntity,\n    ProfileMemberEntity storage memberEntity,\n    bytes32 memberId,\n    bytes32 profileId,\n    address sender\n  ) internal {\n    bytes32 typeId;\n    for (uint256 j = 0; j < memberEntity.types.length() && j < 16; j++) {\n      // check type\n      typeId = memberEntity.types.at(j);\n      TypeEntity storage typeEntity = profileEntity.profileTypeReadSlot(typeId);\n      require(typeEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Type Updatable\");\n\n      // check role\n      bytes32 roleId = typeEntity.members[memberId];\n      RoleEntity storage roleEntity = profileEntity.profileRoleReadSlot(roleId);\n      require(roleEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Role Updatable\");\n      require(roleEntity.memberCount > 0, \"Illegal MemberCount\");\n      unchecked {\n        roleEntity.memberCount -= 1;\n      }\n\n      // delete member from type\n      delete typeEntity.members[memberId];\n\n      // delete type from member\n      memberEntity.types.remove(typeId);\n      emit ProfileMemberRoleRevoked(sender, profileId, memberId, roleId, typeId);\n    }\n\n    if (memberEntity.types.length() == 0) {\n      // revoke member from profile Account\n      LProfileCommons.updateProfileAccount(_data, memberEntity, profileId, typeId, true);\n\n      // delete member entity\n      delete memberEntity.ba;\n      delete memberEntity.account;\n      delete memberEntity.callLimit;\n      delete memberEntity.typeLimit;\n      delete memberEntity.registerLimits;\n      delete memberEntity.types;\n      emit ProfileMemberRemoved(sender, profileId, memberId, true);\n    } else {\n      emit ProfileMemberRemoved(sender, profileId, memberId, false);\n    }\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LProfileCommons);\n  }\n}\n"
    },
    "src/contracts/acl/policy/PolicyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IPolicyManagement.sol\";\nimport \"../IACL.sol\";\nimport \"../IACLGenerals.sol\";\nimport \"../ACLStorage.sol\";\nimport \"../scope/IFunctionManagement.sol\";\nimport \"../agent/IRoleManagement.sol\";\nimport \"../agent/ITypeManagement.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\nimport \"../../lib/acl/LACLAgentScope.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Policy Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract PolicyManager is ACLStorage, BaseUUPSProxy, IPolicyManagement {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IPolicyManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  // called by members of Policy Master type\n  function policyRegister(MemberSignature calldata memberSign, PolicyRegisterRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (, bytes32 senderId, address sender) = _accessPermission(memberSign, IPolicyManagement.policyRegister.selector);\n    (ScopeType senderScopeType, bytes32 senderScopeId) = _getMemberPolicyScopeInfo(sender);\n\n    // check and set\n    MemberEntity storage memberEntity = _data.memberReadSlot(senderId);\n    require(\n      int16(uint16(memberEntity.limits.policyRegisterLimit)) - int8(uint8(requests.length)) >= 0,\n      \"Illegal RegisterLimit\"\n    );\n    unchecked {\n      memberEntity.limits.policyRegisterLimit -= uint8(requests.length);\n    }\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      _doPolicyRegister(requests[i], memberEntity, senderScopeType, senderScopeId, sender);\n    }\n\n    return true;\n  }\n\n  // called by policy admin\n  function policyAddRoles(MemberSignature calldata memberSign, PolicyAddRolesRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IPolicyManagement.policyAddRoles.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(requests[i].policyId, senderId, functionId);\n      ScopeType policyScopeType = _data.scopes[policyEntity.scopeId].stype;\n\n      for (uint256 j = 0; j < requests[i].roles.length; j++) {\n        require(_data.rolePolicyMap[requests[i].roles[j]] == bytes32(0), \"Already Exist\");\n        require(policyEntity.adminId != requests[i].roles[j], \"Illegal Role\");\n        require(policyEntity.roleLimit > policyEntity.roles.length(), \"Illegal Limit\");\n        RoleEntity storage roleEntity = _data.roleReadSlot(requests[i].roles[j]);\n\n        ScopeType roleScopeType = _data.scopes[roleEntity.scopeId].stype;\n        require(roleScopeType <= policyScopeType, \"Illegal Role ScopeType\");\n        if (roleScopeType == policyScopeType) {\n          require(roleEntity.scopeId == policyEntity.scopeId, \"Illegal Role Scope\");\n        } else {\n          require(\n            IACLGenerals(address(this)).isScopesCompatible(policyEntity.scopeId, roleEntity.scopeId),\n            \"Illegal Role Scope\"\n          );\n        }\n\n        _data.rolePolicyMap[requests[i].roles[j]] = requests[i].policyId;\n        policyEntity.roles.add(requests[i].roles[j]);\n        emit PolicyRoleAdded(sender, requests[i].policyId, requests[i].roles[j]);\n      }\n    }\n    return true;\n  }\n\n  // called by policy admin\n  function policyRemoveRoles(MemberSignature calldata memberSign, PolicyRemoveRolesRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IPolicyManagement.policyRemoveRoles.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(requests[i].policyId, senderId, functionId);\n\n      for (uint256 j = 0; j < requests[i].roles.length && j < 32; j++) {\n        require(policyEntity.roles.contains(requests[i].roles[j]), \"Not Found\");\n        delete _data.rolePolicyMap[requests[i].roles[j]];\n        policyEntity.roles.remove(requests[i].roles[j]);\n        emit PolicyRoleRemoved(sender, requests[i].policyId, requests[i].roles[j]);\n      }\n    }\n    return true;\n  }\n\n  function policyUpdateCodes(MemberSignature calldata memberSign, PolicyUpdateCodeRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IPolicyManagement.policyUpdateCodes.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(requests[i].policyId, senderId, functionId);\n\n      policyEntity.policyCode = requests[i].policyCode;\n      policyEntity.ptype = _doGetPolicyType(requests[i].policyCode);\n      emit PolicyCodeUpdated(sender, requests[i].policyId, requests[i].policyCode, policyEntity.ptype);\n    }\n    return true;\n  }\n\n  function policyUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IPolicyManagement.policyUpdateAdmin.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(requests[i].id, senderId, functionId);\n      policyEntity.adminId = _getPolicyAdmin(\n        _data.scopes[policyEntity.scopeId].stype,\n        _data.scopes[policyEntity.scopeId].adminId,\n        policyEntity.scopeId,\n        requests[i].adminId\n      );\n      require(!policyEntity.roles.contains(policyEntity.adminId), \"Illegal AID\");\n      emit PolicyAdminUpdated(sender, requests[i].id, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function policyUpdateScope(MemberSignature calldata memberSign, UpdateScopeRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IPolicyManagement.policyUpdateScope.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      LACLAgentScope.updatePolicyScope(_data, requests[i], functionId, senderId);\n      emit PolicyScopeUpdated(sender, requests[i].id, requests[i].scopeId);\n    }\n    return true;\n  }\n\n  function policyUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IPolicyManagement.policyUpdateActivityStatus.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(requests[i].id, senderId, functionId);\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      policyEntity.acstat = requests[i].acstat;\n      emit PolicyActivityUpdated(sender, requests[i].id, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function policyUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IPolicyManagement.policyUpdateAlterabilityStatus.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _data.policies[requests[i].id];\n      require(policyEntity.adminId != bytes32(0), \"Not Found\");\n\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(policyEntity.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      policyEntity.alstat = requests[i].alstat;\n      emit PolicyAlterabilityUpdated(sender, requests[i].id, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function policyUpdateRoleLimit(MemberSignature calldata memberSign, PolicyUpdateRoleLimitRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IPolicyManagement.policyUpdateRoleLimit.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(requests[i].policyId, senderId, functionId);\n      require(requests[i].roleLimit > policyEntity.roles.length(), \"Illegal Limit\");\n      policyEntity.roleLimit = requests[i].roleLimit;\n      emit PolicyRoleLimitUpdated(sender, requests[i].policyId, requests[i].roleLimit);\n    }\n    return true;\n  }\n\n  function policyRemove(MemberSignature calldata memberSign, bytes32[] calldata policies) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IPolicyManagement.policyRemove.selector\n    );\n    for (uint256 i = 0; i < policies.length; i++) {\n      IACLCommons.PolicyEntity storage policyEntity = _data.policies[policies[i]];\n      require(policyEntity.adminId != bytes32(0), \"Not Found\");\n\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(policyEntity.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(policyEntity.roles.length() == 0, \"Illegal Remove\");\n\n      BaseScope storage policyScope = _data.scopes[policyEntity.scopeId];\n      require(policyScope.referredByAgent > 0, \"Illeagl Referred\");\n      unchecked {\n        policyScope.referredByAgent -= 1;\n      }\n\n      delete policyEntity.adminId;\n      delete policyEntity.scopeId;\n      delete policyEntity.name;\n      delete policyEntity.roleLimit;\n      delete policyEntity.policyCode;\n      delete policyEntity.ptype;\n      delete policyEntity.acstat;\n      delete policyEntity.alstat;\n      delete policyEntity.roles;\n      emit PolicyRemoved(sender, policies[i]);\n    }\n    return true;\n  }\n\n  function policyCheckId(bytes32 policyId) external view returns (bool) {\n    return _data.policies[policyId].adminId != bytes32(0);\n  }\n\n  function policyCheckName(string calldata policyName) external view returns (bool) {\n    return _data.policies[LACLUtils.generateId(policyName)].adminId != bytes32(0);\n  }\n\n  function policyCheckAdmin(bytes32 policyId, address account) external view returns (bool) {\n    PolicyEntity storage policyEntity = _data.policies[policyId];\n    if (policyEntity.adminId == bytes32(0)) return false;\n\n    bytes32 policyAdminId = policyEntity.adminId;\n    AgentType agentType = _data.agents[policyAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (agentType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result) = _data.roleTryReadSlot(policyAdminId);\n      if (!result) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == policyAdminId;\n    } else if (agentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(policyAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n    return true;\n  }\n\n  function policyCheckAccess(bytes32 policyId, bytes32 functionId) external view returns (bool) {\n    return _doCheckAccessPolicy(policyId, functionId);\n  }\n\n  function policyCheckRoleAccess(bytes32 roleId, bytes32 functionId) external view returns (bool) {\n    return _doCheckAccessPolicy(_data.rolePolicyMap[roleId], functionId);\n  }\n\n  function _doCheckAccessPolicy(bytes32 policyId, bytes32 functionId) internal view returns (bool) {\n    (FunctionEntity storage functionEntity, bool result) = _data.functionTryReadSlot(functionId);\n    if (!result) return false;\n\n    PolicyEntity storage policyEntity = _data.policies[policyId];\n    if (policyEntity.acstat != ActivityStatus.ENABLED) return false;\n    if (policyEntity.policyCode >= functionEntity.policyCode) return false;\n\n    return true;\n  }\n\n  function policyCheckRole(bytes32 roleId) external view returns (bool) {\n    return _data.rolePolicyMap[roleId] != bytes32(0);\n  }\n\n  function policyHasRole(bytes32 policyId, bytes32 roleId) external view returns (bool) {\n    return _data.rolePolicyMap[roleId] == policyId;\n  }\n\n  function policyGetInfoByRole(bytes32 roleId) external view returns (PolicyInfo memory) {\n    return _doPolicyGetInfo(_data.rolePolicyMap[roleId]);\n  }\n\n  function policyGetInfo(bytes32 policyId) external view returns (PolicyInfo memory) {\n    return _doPolicyGetInfo(policyId);\n  }\n\n  function _doPolicyGetInfo(bytes32 policyId) internal view returns (PolicyInfo memory) {\n    if (_data.policies[policyId].adminId == bytes32(0)) {\n      return\n        PolicyInfo({\n          adminId: bytes32(0),\n          scopeId: bytes32(0),\n          name: \"\",\n          roleLimit: 0,\n          roleCount: 0,\n          policyCode: 0,\n          adminType: AgentType.NONE,\n          scopeType: ScopeType.NONE,\n          ptype: PolicyType.UNLOCK,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE\n        });\n    }\n\n    return\n      PolicyInfo({\n        adminId: _data.policies[policyId].adminId,\n        scopeId: _data.policies[policyId].scopeId,\n        name: _data.policies[policyId].name,\n        roleLimit: _data.policies[policyId].roleLimit,\n        roleCount: uint16(_data.policies[policyId].roles.length()),\n        policyCode: _data.policies[policyId].policyCode,\n        adminType: _data.agents[_data.policies[policyId].adminId].atype,\n        scopeType: _data.scopes[_data.policies[policyId].scopeId].stype,\n        ptype: _data.policies[policyId].ptype,\n        acstat: _data.policies[policyId].acstat,\n        alstat: _data.policies[policyId].alstat\n      });\n  }\n\n  function policyGetRoles(bytes32 policyId) external view returns (bytes32[] memory) {\n    if (_data.policies[policyId].adminId == bytes32(0)) return new bytes32[](0);\n    return _data.policies[policyId].roles.values();\n  }\n\n  function _doGetPolicyType(uint8 policyCode) internal pure returns (PolicyType) {\n    if (policyCode == 0) {\n      return PolicyType.UNLOCK;\n    } else if (policyCode <= 63) {\n      return PolicyType.SLOCK;\n    } else if (policyCode <= 127) {\n      return PolicyType.MLOCK;\n    } else if (policyCode <= 191) {\n      return PolicyType.RLOCK;\n    } else if (policyCode <= 254) {\n      return PolicyType.HLOCK;\n    } else {\n      return PolicyType.LOCK;\n    }\n  }\n\n  function _doCheckAdminAccess(\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) internal view returns (IACL.AdminAccessStatus) {\n    return LACLAgentScope.checkAdminAccess(_data, adminId, memberId, functionId);\n  }\n\n  function _accessPermission(MemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getMemeberSignerAddress(memberSign, MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n    IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, senderId);\n    if (status != IACL.AuthorizationStatus.PERMITTED) LACLUtils.generateAuthorizationError(status);\n    return (functionId, senderId, signer);\n  }\n\n  function _getMemberPolicyScopeInfo(address account) internal view returns (ScopeType, bytes32) {\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n    TypeEntity storage policyMasterType = _data.typeReadSlot(_LIVELY_VERSE_POLICY_MASTER_TYPE_ID);\n    bytes32 senderRoleId = policyMasterType.members[memberId];\n    RoleEntity storage senderPolicyRole = _data.roleReadSlot(senderRoleId);\n    return (_data.scopes[senderPolicyRole.scopeId].stype, senderPolicyRole.scopeId);\n  }\n\n  function _getPolicyAdmin(\n    ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId\n  ) internal view returns (bytes32 policyAdminId) {\n    return LACLAgentScope.getPolicyAdmin(_data, requestScopeType, requestScopeAdmin, scopeId, adminId);\n  }\n\n  function _doGetPolicyAndCheckAdminAccess(\n    bytes32 policyId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) internal view returns (PolicyEntity storage) {\n    return LACLAgentScope.getPolicyAndCheckAdminAccess(_data, policyId, memberId, functionId);\n  }\n\n  function _getCheckUpdateRequestScope(\n    bytes32 requestScopeId,\n    bytes32 senderScopeId,\n    ScopeType senderScopeType\n  ) internal returns (BaseScope storage) {\n    return LACLAgentScope.getCheckUpdateRequestScope(_data, requestScopeId, senderScopeId, senderScopeType);\n  }\n\n  function _doPolicyRegister(\n    PolicyRegisterRequest calldata request,\n    MemberEntity storage memberEntity,\n    ScopeType senderScopeType,\n    bytes32 senderScopeId,\n    address sender\n  ) internal {\n    bytes32 newPolicyId = LACLUtils.generateId(request.name);\n    require(_data.policies[newPolicyId].acstat == ActivityStatus.NONE, \"Already Exist\");\n    require(\n      request.acstat > ActivityStatus.DELETED && request.alstat > AlterabilityStatus.NONE,\n      \"Illegal Activity/Alterability\"\n    );\n\n    // checking requested type scope\n    BaseScope storage requestedScope = _getCheckUpdateRequestScope(request.scopeId, senderScopeId, senderScopeType);\n\n    // create policy entity\n    PolicyEntity storage policyEntity = _data.policies[newPolicyId];\n    policyEntity.ptype = _doGetPolicyType(request.policyCode);\n    policyEntity.policyCode = request.policyCode;\n    policyEntity.acstat = request.acstat;\n    policyEntity.alstat = request.alstat;\n    policyEntity.name = request.name;\n    policyEntity.scopeId = request.scopeId;\n    policyEntity.roleLimit = request.roleLimit >= 0\n      ? uint16(uint24(request.roleLimit))\n      : memberEntity.limits.policyRoleLimit;\n    policyEntity.adminId = _getPolicyAdmin(\n      requestedScope.stype,\n      requestedScope.adminId,\n      request.scopeId,\n      request.adminId\n    );\n    emit PolicyRegistered(sender, newPolicyId, request.scopeId, request.adminId, request.policyCode);\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LACLAgentScope);\n  }\n}\n"
    },
    "src/contracts/acl/agent/TypeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../ACLStorage.sol\";\nimport \"./IMemberManagement.sol\";\nimport \"./ITypeManagement.sol\";\nimport \"../IACL.sol\";\nimport \"../IACLGenerals.sol\";\nimport \"../scope/IFunctionManagement.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../lib/acl/LACLCommons.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title ACL Type Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract TypeManager is ACLStorage, BaseUUPSProxy, ITypeManagement {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(ITypeManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  function typeRegister(MemberSignature calldata memberSign, TypeRegisterRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (, bytes32 senderId, address sender) = _accessPermission(memberSign, ITypeManagement.typeRegister.selector);\n\n    // check and set\n    MemberEntity storage memberEntity = _data.memberReadSlot(senderId);\n    require(\n      int16(uint16(memberEntity.limits.typeRegisterLimit)) - int8(uint8(requests.length)) >= 0,\n      \"Illegal RegisterLimit\"\n    );\n    unchecked {\n      memberEntity.limits.typeRegisterLimit -= uint8(requests.length);\n    }\n\n    // fetch scope type and scope id of sender\n    (ScopeType senderScopeType, bytes32 senderScopeId) = _doGetMemberScopeInfoFromType(\n      _LIVELY_VERSE_TYPE_MASTER_TYPE_ID,\n      senderId\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      bytes32 newTypeId = LACLUtils.generateId(requests[i].name);\n      require(_data.agents[newTypeId].atype == AgentType.NONE, \"Already Exist\");\n      require(\n        requests[i].acstat > ActivityStatus.DELETED && requests[i].alstat > AlterabilityStatus.NONE,\n        \"Illegal Activity/Alterability\"\n      );\n\n      // checking requested type scope\n      BaseScope storage requestedScope = _getCheckUpdateRequestScope(\n        requests[i].scopeId,\n        senderScopeId,\n        senderScopeType\n      );\n\n      // create new type\n      TypeEntity storage newType = _data.typeWriteSlot(newTypeId);\n      newType.ba.atype = AgentType.TYPE;\n      newType.ba.acstat = requests[i].acstat;\n      newType.ba.alstat = requests[i].alstat;\n      newType.ba.adminId = requests[i].adminId;\n      newType.scopeId = requests[i].scopeId;\n      newType.roleLimit = requests[i].roleLimit >= 0\n        ? uint16(uint24(requests[i].roleLimit))\n        : memberEntity.limits.typeRoleLimit;\n      newType.name = requests[i].name;\n      newType.ba.adminId = _getTypeAdmin(\n        requestedScope.stype,\n        requestedScope.adminId,\n        requests[i].scopeId,\n        requests[i].adminId\n      );\n      emit TypeRegistered(sender, newTypeId, requests[i].scopeId, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function typeUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      ITypeManagement.typeUpdateAdmin.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      TypeEntity storage typeEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].id,\n        senderId,\n        functionId,\n        ITypeManagement.typeUpdateAdmin.selector\n      );\n\n      // checking requested type admin\n      typeEntity.ba.adminId = _getTypeAdmin(\n        _data.scopes[typeEntity.scopeId].stype,\n        _data.scopes[typeEntity.scopeId].adminId,\n        typeEntity.scopeId,\n        requests[i].adminId\n      );\n\n      emit TypeAdminUpdated(sender, requests[i].id, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function typeUpdateScope(MemberSignature calldata memberSign, UpdateScopeRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      ITypeManagement.typeUpdateScope.selector\n    );\n    ScopeType senderScopeType;\n    bytes32 senderScopeId;\n    for (uint256 i = 0; i < requests.length; i++) {\n      TypeEntity storage typeEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].id,\n        senderId,\n        functionId,\n        ITypeManagement.typeUpdateScope.selector\n      );\n\n      AgentType adminAgentType = _data.agents[typeEntity.ba.adminId].atype;\n      if (adminAgentType == AgentType.ROLE) {\n        RoleEntity storage roleEntity = _data.roleReadSlot(typeEntity.ba.adminId);\n        senderScopeId = roleEntity.scopeId;\n        senderScopeType = _data.scopes[roleEntity.scopeId].stype;\n      } else {\n        TypeEntity storage agentType = _data.typeReadSlot(typeEntity.ba.adminId);\n        bytes32 memberRoleId = agentType.members[senderId];\n        RoleEntity storage memberAgentRole = _data.roleReadSlot(memberRoleId);\n        senderScopeType = _data.scopes[memberAgentRole.scopeId].stype;\n        senderScopeId = memberAgentRole.scopeId;\n      }\n\n      BaseScope storage requestScope = _getCheckUpdateRequestScope(requests[i].scopeId, senderScopeId, senderScopeType);\n      BaseScope storage currentScope = _data.scopes[typeEntity.scopeId];\n      if (typeEntity.roles.length() > 0) {\n        require(requestScope.stype > currentScope.stype, \"Illegal ScopeType\");\n        require(\n          IACLGenerals(address(this)).isScopesCompatible(requests[i].scopeId, typeEntity.scopeId),\n          \"Illegal Scope\"\n        );\n      }\n      require(currentScope.referredByAgent > 0, \"Illeagl Referred\");\n      unchecked {\n        currentScope.referredByAgent -= 1;\n      }\n      typeEntity.scopeId = requests[i].scopeId;\n      emit TypeScopeUpdated(sender, requests[i].id, requests[i].scopeId);\n    }\n    return true;\n  }\n\n  function typeUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      ITypeManagement.typeUpdateActivityStatus.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      TypeEntity storage typeEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].id,\n        senderId,\n        functionId,\n        ITypeManagement.typeUpdateActivityStatus.selector\n      );\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      typeEntity.ba.acstat = requests[i].acstat;\n      emit TypeActivityUpdated(sender, requests[i].id, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function typeUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      ITypeManagement.typeUpdateAlterabilityStatus.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      TypeEntity storage typeEntity = _data.typeReadSlot(requests[i].id);\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(typeEntity.ba.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      typeEntity.ba.alstat = requests[i].alstat;\n      emit TypeAlterabilityUpdated(sender, requests[i].id, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function typeUpdateRoleLimit(MemberSignature calldata memberSign, TypeUpdateRoleLimitRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      ITypeManagement.typeUpdateRoleLimit.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      TypeEntity storage typeEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].typeId,\n        senderId,\n        functionId,\n        ITypeManagement.typeUpdateRoleLimit.selector\n      );\n      require(requests[i].roleLimit > typeEntity.roles.length(), \"Illegal Limit\");\n      typeEntity.roleLimit = requests[i].roleLimit;\n      emit TypeRoleLimitUpdated(sender, requests[i].typeId, requests[i].roleLimit);\n    }\n    return true;\n  }\n\n  function typeRemove(MemberSignature calldata memberSign, bytes32[] calldata types) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      ITypeManagement.typeRemove.selector\n    );\n\n    for (uint256 i = 0; i < types.length; i++) {\n      TypeEntity storage typeEntity = _data.typeReadSlot(types[i]);\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(typeEntity.ba.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(typeEntity.roles.length() == 0, \"Illegal Remove\");\n\n      BaseScope storage typeScope = _data.scopes[typeEntity.scopeId];\n      require(typeScope.referredByAgent > 0, \"Illeagl Referred\");\n      unchecked {\n        typeScope.referredByAgent -= 1;\n      }\n\n      delete typeEntity.ba;\n      delete typeEntity.scopeId;\n      delete typeEntity.name;\n      delete typeEntity.roleLimit;\n      delete typeEntity.roles;\n\n      emit TypeRemoved(sender, types[i]);\n    }\n    return true;\n  }\n\n  function typeCheckId(bytes32 typeId) external view returns (bool) {\n    return _data.agents[typeId].atype == AgentType.TYPE;\n  }\n\n  function typeCheckName(string calldata typeName) external view returns (bool) {\n    return _data.agents[keccak256(abi.encodePacked(typeName))].atype == AgentType.TYPE;\n  }\n\n  function typeCheckAdmin(bytes32 typeId, address account) external view returns (bool) {\n    if (_data.agents[typeId].atype != AgentType.TYPE) return false;\n\n    bytes32 typeAdminId = _data.agents[typeId].adminId;\n    AgentType adminAgentType = _data.agents[typeAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (adminAgentType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result) = _data.roleTryReadSlot(typeAdminId);\n      if (!result) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == typeAdminId;\n    } else if (adminAgentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(typeAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function typeHasAccount(bytes32 typeId, address account) external view returns (bool) {\n    (TypeEntity storage te, bool result) = _data.typeTryReadSlot(typeId);\n    if (!result) return false;\n    return te.members[LACLUtils.accountGenerateId(account)] != bytes32(0);\n  }\n\n  function typeHasRole(bytes32 typeId, bytes32 roleId) external view returns (bool) {\n    (TypeEntity storage te, bool result) = _data.typeTryReadSlot(typeId);\n    if (!result) return false;\n    return te.roles.contains(roleId);\n  }\n\n  function typeGetRoles(bytes32 typeId) external view returns (bytes32[] memory) {\n    (TypeEntity storage te, bool result) = _data.typeTryReadSlot(typeId);\n    if (!result) return new bytes32[](0);\n    return te.roles.values();\n  }\n\n  function typeGetInfo(bytes32 typeId) external view returns (TypeInfo memory) {\n    (TypeEntity storage te, bool result) = _data.typeTryReadSlot(typeId);\n    if (!result) {\n      return\n        TypeInfo({\n          scopeId: bytes32(0),\n          adminId: bytes32(0),\n          roleLimit: 0,\n          roleCount: 0,\n          adminType: AgentType.NONE,\n          atype: AgentType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE,\n          name: \"\"\n        });\n    }\n\n    return\n      TypeInfo({\n        scopeId: te.scopeId,\n        adminId: te.ba.adminId,\n        roleLimit: te.roleLimit,\n        roleCount: uint16(te.roles.length()),\n        adminType: _data.agents[te.ba.adminId].atype,\n        atype: te.ba.atype,\n        acstat: te.ba.acstat,\n        alstat: te.ba.alstat,\n        name: te.name\n      });\n  }\n\n  function _doAgentGetScopeInfo(bytes32 agentId) internal view returns (ScopeType, bytes32) {\n    AgentType atype = _data.agents[agentId].atype;\n    if (atype == AgentType.ROLE) {\n      RoleEntity storage roleEntity = _data.roleReadSlot(agentId);\n      BaseScope storage baseScope = _data.scopes[roleEntity.scopeId];\n      return (baseScope.stype, roleEntity.scopeId);\n    } else if (atype == AgentType.TYPE) {\n      TypeEntity storage typeEntity = _data.typeReadSlot(agentId);\n      BaseScope storage baseScope = _data.scopes[typeEntity.scopeId];\n      return (baseScope.stype, typeEntity.scopeId);\n    }\n\n    return (ScopeType.NONE, bytes32(0));\n  }\n\n  function _doCheckAdminAccess(\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) internal view returns (IACL.AdminAccessStatus) {\n    return LACLCommons.checkAdminAccess(_data, adminId, memberId, functionId);\n  }\n\n  function _accessPermission(MemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getMemeberSignerAddress(memberSign, MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n    IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, senderId);\n    if (status != IACL.AuthorizationStatus.PERMITTED) {\n      if (\n        status == IACL.AuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN &&\n        selector == ITypeManagement.typeUpdateActivityStatus.selector\n      ) {\n        return (functionId, senderId, signer);\n      }\n      LACLUtils.generateAuthorizationError(status);\n    }\n    return (functionId, senderId, signer);\n  }\n\n  function _getTypeAdmin(\n    ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId\n  ) internal view returns (bytes32 typeAdminId) {\n    // checking requested type admin\n    if (adminId != bytes32(0)) {\n      require(_data.agents[adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n      (ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doAgentGetScopeInfo(adminId);\n      require(requestScopeType <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n      if (requestScopeType == requestAdminScopeType) {\n        require(requestAdminScopeId == scopeId, \"Illegal Admin Scope\");\n      } else {\n        require(IACLGenerals(address(this)).isScopesCompatible(requestAdminScopeId, scopeId), \"Illegal Admin Scope\");\n      }\n      typeAdminId = adminId;\n    } else {\n      typeAdminId = requestScopeAdmin;\n    }\n  }\n\n  function _doGetMemberScopeInfoFromType(bytes32 typeId, bytes32 senderId) internal view returns (ScopeType, bytes32) {\n    TypeEntity storage agentType = _data.typeReadSlot(typeId);\n    bytes32 memberRoleId = agentType.members[senderId];\n    RoleEntity storage memberAgentRole = _data.roleReadSlot(memberRoleId);\n    return (_data.scopes[memberAgentRole.scopeId].stype, memberAgentRole.scopeId);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    bytes32 typeId,\n    bytes32 senderId,\n    bytes32 functionId,\n    bytes4 selector\n  ) internal view returns (TypeEntity storage) {\n    TypeEntity storage typeEntity = _data.typeReadSlot(typeId);\n    require(typeEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(typeEntity.ba.adminId, senderId, functionId);\n    if (status != IACL.AdminAccessStatus.PERMITTED) {\n      if (\n        status == IACL.AdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN &&\n        selector == ITypeManagement.typeUpdateActivityStatus.selector\n      ) {\n        return typeEntity;\n      }\n      LACLUtils.generateAdminAccessError(status);\n    }\n\n    return typeEntity;\n  }\n\n  function _getCheckUpdateRequestScope(\n    bytes32 requestScopeId,\n    bytes32 senderScopeId,\n    ScopeType senderScopeType\n  ) internal returns (BaseScope storage) {\n    // checking requested type scope\n    BaseScope storage requestedScope = _data.scopes[requestScopeId];\n    require(requestedScope.stype != ScopeType.NONE, \"Not Found\");\n    require(requestedScope.acstat > ActivityStatus.DELETED, \"Scope Deleted\");\n\n    // increase referred count to target scope\n    requestedScope.referredByAgent += 1;\n\n    // check sender scope with request scope\n    require(senderScopeType >= requestedScope.stype, \"Illegal Sender ScopeType\");\n    if (senderScopeType == requestedScope.stype) {\n      require(senderScopeId == requestScopeId, \"Illegal Sender Scope\");\n    } else {\n      require(IACLGenerals(address(this)).isScopesCompatible(senderScopeId, requestScopeId), \"Illegal Sender Scope\");\n    }\n\n    return requestedScope;\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LACLCommons);\n  }\n}\n"
    },
    "src/contracts/acl/agent/RoleManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IRoleManagement.sol\";\nimport \"./IMemberManagement.sol\";\nimport \"./ITypeManagement.sol\";\nimport \"../ACLStorage.sol\";\nimport \"../IACL.sol\";\nimport \"../IACLGenerals.sol\";\nimport \"../scope/IFunctionManagement.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../lib/acl/LACLAgentScope.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title ACL Role Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract RoleManager is ACLStorage, BaseUUPSProxy, IRoleManagement {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IRoleManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  // type admins call roleRegister function\n  function roleRegister(MemberSignature calldata memberSign, RoleRegisterRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRoleManagement.roleRegister.selector\n    );\n\n    // check and set\n    MemberEntity storage memberEntity = _data.memberReadSlot(senderId);\n    require(\n      int16(uint16(memberEntity.limits.roleRegisterLimit)) - int8(uint8(requests.length)) >= 0,\n      \"Illegal RegisterLimit\"\n    );\n    unchecked {\n      memberEntity.limits.roleRegisterLimit -= uint8(requests.length);\n    }\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      (bytes32 newRoleId, bytes32 adminId) = LACLAgentScope.aclRegisterRole(\n        _data,\n        requests[i],\n        functionId,\n        senderId,\n        memberEntity.limits.memberLimit\n      );\n      emit RoleRegistered(sender, newRoleId, requests[i].typeId, adminId, requests[i].scopeId);\n    }\n    return true;\n  }\n\n  // Note: Admin must be Role or Type, and it can't be a member\n  function roleUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRoleManagement.roleUpdateAdmin.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      RoleEntity storage roleEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].id,\n        senderId,\n        functionId,\n        IRoleManagement.roleUpdateAdmin.selector\n      );\n      roleEntity.ba.adminId = _getRoleAdmin(\n        _data.scopes[roleEntity.scopeId].stype,\n        _data.agents[roleEntity.typeId].adminId,\n        roleEntity.scopeId,\n        requests[i].adminId\n      );\n      emit RoleAdminUpdated(sender, requests[i].id, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function roleUpdateScope(MemberSignature calldata memberSign, UpdateScopeRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRoleManagement.roleUpdateScope.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      RoleEntity storage roleEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].id,\n        senderId,\n        functionId,\n        IRoleManagement.roleUpdateScope.selector\n      );\n      TypeEntity storage typeEntity = _data.typeReadSlot(roleEntity.typeId);\n      _checkUpdateRequestScope(requests[i].scopeId, typeEntity.scopeId);\n      BaseScope storage oldScope = _data.scopes[roleEntity.scopeId];\n      require(oldScope.referredByAgent > 0, \"Illeagl Referred\");\n      unchecked {\n        oldScope.referredByAgent -= 1;\n      }\n      roleEntity.scopeId = requests[i].scopeId;\n      emit RoleScopeUpdated(sender, requests[i].id, requests[i].scopeId);\n    }\n    return true;\n  }\n\n  function roleUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRoleManagement.roleUpdateActivityStatus.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      RoleEntity storage roleEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].id,\n        senderId,\n        functionId,\n        IRoleManagement.roleUpdateActivityStatus.selector\n      );\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      roleEntity.ba.acstat = requests[i].acstat;\n      emit RoleActivityUpdated(sender, requests[i].id, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function roleUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRoleManagement.roleUpdateAlterabilityStatus.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      RoleEntity storage roleEntity = _data.roleReadSlot(requests[i].id);\n\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(roleEntity.ba.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      roleEntity.ba.alstat = requests[i].alstat;\n      emit RoleAlterabilityUpdated(sender, requests[i].id, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function roleUpdateMemberLimit(MemberSignature calldata memberSign, RoleUpdateMemberLimitRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRoleManagement.roleUpdateMemberLimit.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      RoleEntity storage roleEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].roleId,\n        senderId,\n        functionId,\n        IRoleManagement.roleUpdateMemberLimit.selector\n      );\n      require(requests[i].memberLimit > roleEntity.memberCount, \"Illegal Limit\");\n      roleEntity.memberLimit = requests[i].memberLimit;\n      emit RoleMemberLimitUpdated(sender, requests[i].roleId, requests[i].memberLimit);\n    }\n    return true;\n  }\n\n  function roleGrantMembers(MemberSignature calldata memberSign, RoleGrantMembersRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRoleManagement.roleGrantMembers.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      RoleEntity storage roleEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].roleId,\n        senderId,\n        functionId,\n        IRoleManagement.roleGrantMembers.selector\n      );\n      TypeEntity storage typeEntity = _data.typeReadSlot(roleEntity.typeId);\n      require(typeEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Type Updatable\");\n\n      for (uint256 j = 0; j < requests[i].members.length; j++) {\n        require(roleEntity.memberCount < roleEntity.memberLimit, \"Illegal Limit\");\n        MemberEntity storage memberEntity = _data.memberReadSlot(requests[i].members[j]);\n        if (memberEntity.types.contains(roleEntity.typeId)) {\n          bytes32 currentRoleId = typeEntity.members[requests[i].members[j]];\n          require(currentRoleId != requests[i].roleId, \"Already Exist\");\n          if (requests[i].roleId == LACLAgentScope.LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID) {\n            require(roleEntity.memberCount > 1, \"Illegal Admin Revoke\");\n          }\n          RoleEntity storage currentRoleEntity = _doGetEntityAndCheckAdminAccess(\n            currentRoleId,\n            senderId,\n            functionId,\n            IRoleManagement.roleGrantMembers.selector\n          );\n          require(currentRoleEntity.memberCount > 0, \"Illegal Count\");\n          unchecked {\n            currentRoleEntity.memberCount -= 1;\n          }\n          emit RoleMemberRevoked(sender, currentRoleId, requests[i].members[j], currentRoleEntity.typeId);\n        } else {\n          require(memberEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n          require(memberEntity.limits.typeLimit > memberEntity.types.length(), \"Illegal TypeLimit\");\n\n          if (\n            (memberEntity.types.contains(_LIVELY_VERSE_LIVELY_MASTER_TYPE_ID) ||\n              memberEntity.types.contains(_LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID)) &&\n            (roleEntity.typeId == _LIVELY_VERSE_LIVELY_MASTER_TYPE_ID ||\n              roleEntity.typeId == _LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID)\n          ) {\n            revert(\"Illegal Grant\");\n          }\n\n          memberEntity.types.add(roleEntity.typeId);\n        }\n\n        typeEntity.members[requests[i].members[j]] = requests[i].roleId;\n        roleEntity.memberCount += 1;\n        emit RoleMemberGranted(sender, requests[i].roleId, requests[i].members[j], roleEntity.typeId);\n      }\n    }\n    return true;\n  }\n\n  function roleRevokeMembers(MemberSignature calldata memberSign, RoleRevokeMembersRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRoleManagement.roleRevokeMembers.selector\n    );\n    for (uint256 i = 0; i < requests.length; i++) {\n      RoleEntity storage roleEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].roleId,\n        senderId,\n        functionId,\n        IRoleManagement.roleRevokeMembers.selector\n      );\n\n      TypeEntity storage typeEntity = _data.typeReadSlot(roleEntity.typeId);\n      require(typeEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Type Updatable\");\n\n      for (uint256 j = 0; j < requests[i].members.length; j++) {\n        MemberEntity storage memberEntity = _data.memberReadSlot(requests[i].members[j]);\n        require(memberEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n        if (requests[i].roleId == LACLAgentScope.LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID) {\n          require(roleEntity.memberCount > 1, \"Illegal Admin Revoke\");\n        }\n\n        require(typeEntity.members[requests[i].members[j]] != bytes32(0), \"Not Found\");\n        require(roleEntity.memberCount > 0, \"Illegal Count\");\n        delete typeEntity.members[requests[i].members[j]];\n        unchecked {\n          roleEntity.memberCount -= 1;\n        }\n\n        memberEntity.types.remove(roleEntity.typeId);\n        if (memberEntity.types.length() == 0) {\n          delete memberEntity.ba;\n          delete memberEntity.account;\n          delete memberEntity.limits;\n          delete memberEntity.types;\n          emit RoleMemberDeleted(\n            sender,\n            requests[i].members[j],\n            requests[i].roleId,\n            roleEntity.typeId,\n            memberEntity.account\n          );\n        }\n        emit RoleMemberRevoked(sender, requests[i].roleId, requests[i].members[j], roleEntity.typeId);\n      }\n    }\n    return true;\n  }\n\n  function roleRemove(MemberSignature calldata memberSign, bytes32[] calldata roles) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRoleManagement.roleRemove.selector\n    );\n\n    for (uint256 i = 0; i < roles.length; i++) {\n      RoleEntity storage roleEntity = _data.roleReadSlot(roles[i]);\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(roleEntity.ba.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(roleEntity.memberCount == 0, \"Illegal Remove\");\n\n      // check type\n      TypeEntity storage typeEntity = _data.typeReadSlot(roleEntity.typeId);\n      require(typeEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \"Illegal Type Updatable\");\n      typeEntity.roles.remove(roles[i]);\n\n      BaseScope storage roleScope = _data.scopes[roleEntity.scopeId];\n      require(roleScope.referredByAgent > 0, \"Illeagl Referred\");\n      unchecked {\n        roleScope.referredByAgent -= 1;\n      }\n\n      delete roleEntity.name;\n      delete roleEntity.memberCount;\n      delete roleEntity.memberLimit;\n      delete roleEntity.typeId;\n      delete roleEntity.scopeId;\n      delete roleEntity.ba;\n\n      emit RoleRemoved(sender, roles[i]);\n    }\n    return true;\n  }\n\n  function roleCheckId(bytes32 roleId) external view returns (bool) {\n    return _data.agents[roleId].atype == AgentType.ROLE;\n  }\n\n  function roleCheckName(string calldata roleName) external view returns (bool) {\n    return _data.agents[keccak256(abi.encodePacked(roleName))].atype == AgentType.ROLE;\n  }\n\n  function roleCheckAdmin(bytes32 roleId, address account) external view returns (bool) {\n    if (_data.agents[roleId].atype != AgentType.ROLE) return false;\n\n    bytes32 roleAdminId = _data.agents[roleId].adminId;\n    AgentType adminAgenType = _data.agents[roleAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (adminAgenType == AgentType.ROLE) {\n      return _doRoleHasMember(roleAdminId, memberId);\n    } else if (adminAgenType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(roleAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function roleHasAccount(bytes32 roleId, address account) external view returns (bool) {\n    return _doRoleHasMember(roleId, LACLUtils.accountGenerateId(account));\n  }\n\n  function _doRoleHasMember(bytes32 roleId, bytes32 memberId) internal view returns (bool) {\n    (RoleEntity storage roleEntity, bool result) = _data.roleTryReadSlot(roleId);\n    if (!result) return false;\n\n    (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(roleEntity.typeId);\n    if (!result1) return false;\n\n    return typeEntity.members[memberId] == roleId;\n  }\n\n  function roleGetInfo(bytes32 roleId) external view returns (RoleInfo memory) {\n    (RoleEntity storage roleEntity, bool result) = _data.roleTryReadSlot(roleId);\n    if (!result) {\n      return\n        RoleInfo({\n          scopeId: bytes32(0),\n          typeId: bytes32(0),\n          adminId: bytes32(0),\n          memberLimit: 0,\n          memberCount: 0,\n          adminType: AgentType.NONE,\n          atype: AgentType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE,\n          name: \"\"\n        });\n    }\n    return\n      RoleInfo({\n        scopeId: roleEntity.scopeId,\n        typeId: roleEntity.typeId,\n        adminId: roleEntity.ba.adminId,\n        memberLimit: roleEntity.memberLimit,\n        memberCount: roleEntity.memberCount,\n        adminType: _data.agents[roleEntity.ba.adminId].atype,\n        atype: roleEntity.ba.atype,\n        acstat: roleEntity.ba.acstat,\n        alstat: roleEntity.ba.alstat,\n        name: roleEntity.name\n      });\n  }\n\n  function _doCheckAdminAccess(\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) internal view returns (IACL.AdminAccessStatus) {\n    return LACLAgentScope.checkAdminAccess(_data, adminId, memberId, functionId);\n  }\n\n  function _accessPermission(MemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getMemeberSignerAddress(memberSign, MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n    IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, senderId);\n    if (status != IACL.AuthorizationStatus.PERMITTED) {\n      if (\n        status == IACL.AuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN &&\n        selector == IRoleManagement.roleUpdateActivityStatus.selector\n      ) {\n        return (functionId, senderId, signer);\n      }\n      LACLUtils.generateAuthorizationError(status);\n    }\n\n    return (functionId, senderId, signer);\n  }\n\n  function _getRoleAdmin(\n    ScopeType requestScopeType,\n    bytes32 requestScopeAdmin,\n    bytes32 scopeId,\n    bytes32 adminId\n  ) internal view returns (bytes32 roleAdminId) {\n    return LACLAgentScope.getRoleAdmin(_data, requestScopeType, requestScopeAdmin, scopeId, adminId);\n  }\n\n  function _checkUpdateRequestScope(bytes32 requestScopeId, bytes32 typeScopeId) internal returns (ScopeType) {\n    return LACLAgentScope.roleCheckRequestScope(_data, requestScopeId, typeScopeId);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    bytes32 roleId,\n    bytes32 senderId,\n    bytes32 functionId,\n    bytes4 selector\n  ) internal view returns (RoleEntity storage) {\n    RoleEntity storage roleEntity = _data.roleReadSlot(roleId);\n    require(roleEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n\n    // check access admin role\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(roleEntity.ba.adminId, senderId, functionId);\n    if (status != IACL.AdminAccessStatus.PERMITTED) {\n      if (\n        status == IACL.AdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN &&\n        selector == IRoleManagement.roleUpdateActivityStatus.selector\n      ) {\n        return roleEntity;\n      }\n      LACLUtils.generateAdminAccessError(status);\n    }\n    return roleEntity;\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LACLAgentScope);\n  }\n}\n"
    },
    "src/contracts/acl/scope/UniverseManger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IUniverseManagement.sol\";\nimport \"../IACL.sol\";\nimport \"../IACLGenerals.sol\";\nimport \"../ACLStorage.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../lib/acl/LACLCommons.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Universe Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract UniverseManager is ACLStorage, BaseUUPSProxy, IUniverseManagement {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IUniverseManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  function universeUpdateActivityStatus(MemberSignature calldata memberSign, ActivityStatus acstat)\n    external\n    returns (ActivityStatus)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IUniverseManagement.universeUpdateActivityStatus.selector\n    );\n    UniverseEntity storage universeEntity = _doGetEntityAndCheckAdminAccess(senderId, functionId);\n    require(acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n    universeEntity.bs.acstat = acstat;\n    emit UniverseActivityUpdated(sender, _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, universeEntity.bs.acstat);\n    return acstat;\n  }\n\n  function universeUpdateAlterabilityStatus(MemberSignature calldata memberSign, AlterabilityStatus alstat)\n    external\n    returns (AlterabilityStatus)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IUniverseManagement.universeUpdateAlterabilityStatus.selector\n    );\n\n    UniverseEntity storage universeEntity = _data.universeReadSlot(_LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID);\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(universeEntity.bs.adminId, senderId, functionId);\n    if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n    require(alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n    universeEntity.bs.alstat = alstat;\n    emit UniverseAlterabilityUpdated(sender, _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, universeEntity.bs.alstat);\n    return alstat;\n  }\n\n  function universeUpdateAdmin(MemberSignature calldata memberSign, bytes32 newAdminId) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IUniverseManagement.universeUpdateAdmin.selector\n    );\n\n    UniverseEntity storage universeEntity = _doGetEntityAndCheckAdminAccess(senderId, functionId);\n\n    require(newAdminId != universeEntity.bs.adminId && newAdminId != bytes32(0), \"Illegal AdminId\");\n\n    BaseAgent storage adminBaseAgent = _data.agents[newAdminId];\n    require(adminBaseAgent.atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n    if (adminBaseAgent.atype == AgentType.ROLE) {\n      TypeEntity storage livelyAdminType = _data.typeReadSlot(_LIVELY_VERSE_LIVELY_MASTER_TYPE_ID);\n      require(livelyAdminType.roles.contains(newAdminId), \"Not Found\");\n    } else {\n      require(_LIVELY_VERSE_LIVELY_MASTER_TYPE_ID == newAdminId, \"Illegal Admin\");\n    }\n\n    universeEntity.bs.adminId = newAdminId;\n    emit UniverseAdminUpdated(sender, _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, universeEntity.bs.adminId);\n    return true;\n  }\n\n  function universeUpdateDomainLimit(MemberSignature calldata memberSign, uint16 domainLimit) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IUniverseManagement.universeUpdateDomainLimit.selector\n    );\n\n    UniverseEntity storage universeEntity = _doGetEntityAndCheckAdminAccess(senderId, functionId);\n    require(domainLimit > universeEntity.domains.length(), \"Illegal Limit\");\n    universeEntity.domainLimit = domainLimit;\n    emit UniverseDomainLimitUpdated(sender, _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, domainLimit);\n    return true;\n  }\n\n  function universeCheckAdmin(address account) external view returns (bool) {\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n    TypeEntity storage livelyAdminType = _data.typeReadSlot(_LIVELY_VERSE_LIVELY_MASTER_TYPE_ID);\n    return livelyAdminType.members[memberId] != bytes32(0);\n  }\n\n  function _doCheckAdminAccess(\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) internal view returns (IACL.AdminAccessStatus) {\n    return LACLCommons.checkAdminAccess(_data, adminId, memberId, functionId);\n  }\n\n  function universeGetDomains() external view returns (bytes32[] memory) {\n    UniverseEntity storage universeEntity = _data.universeReadSlot(_LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID);\n    return universeEntity.domains.values();\n  }\n\n  function universeGetInfo() external view returns (UniverseInfo memory) {\n    UniverseEntity storage universeEntity = _data.universeReadSlot(_LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID);\n    return\n      UniverseInfo({\n        id: _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID,\n        adminId: universeEntity.bs.adminId,\n        domainLimit: universeEntity.domainLimit,\n        domainCount: uint16(universeEntity.domains.length()),\n        referredByAgent: universeEntity.bs.referredByAgent,\n        stype: universeEntity.bs.stype,\n        adminType: _data.agents[universeEntity.bs.adminId].atype,\n        acstat: universeEntity.bs.acstat,\n        alstat: universeEntity.bs.alstat\n      });\n  }\n\n  function _accessPermission(MemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getMemeberSignerAddress(memberSign, MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n    IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, senderId);\n    if (status != IACL.AuthorizationStatus.PERMITTED) {\n      if (\n        status == IACL.AuthorizationStatus.UNIVERSE_ACTIVITY_FORBIDDEN &&\n        IUniverseManagement.universeUpdateActivityStatus.selector == selector\n      ) {\n        return (functionId, senderId, signer);\n      }\n      LACLUtils.generateAuthorizationError(status);\n    }\n\n    return (functionId, senderId, signer);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(bytes32 senderId, bytes32 functionId)\n    internal\n    view\n    returns (UniverseEntity storage)\n  {\n    UniverseEntity storage universeEntity = _data.universeReadSlot(_LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID);\n    require(universeEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(universeEntity.bs.adminId, senderId, functionId);\n    if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n    return universeEntity;\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LACLCommons);\n  }\n}\n"
    },
    "src/contracts/acl/scope/RealmManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../ACLStorage.sol\";\nimport \"./IRealmManagement.sol\";\nimport \"../IACL.sol\";\nimport \"../IACLGenerals.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../lib/acl/LACLCommons.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Realm Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract RealmManager is ACLStorage, BaseUUPSProxy, IRealmManagement {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IRealmManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  function realmRegister(MemberSignature calldata memberSign, RealmRegisterRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRealmManagement.realmRegister.selector\n    );\n\n    // check and set\n    MemberEntity storage memberEntity = _data.memberReadSlot(senderId);\n    unchecked {\n      require(\n        int16(uint16(memberEntity.limits.realmRegisterLimit)) - int8(uint8(requests.length)) >= 0,\n        \"Illegal RegisterLimit\"\n      );\n      memberEntity.limits.realmRegisterLimit -= uint8(requests.length);\n    }\n\n    // fetch scope type and scope id of sender\n    (ScopeType memberScopeType, bytes32 memberScopeId) = _doGetMemberScopeInfoFromType(\n      _LIVELY_VERSE_SCOPE_MASTER_TYPE_ID,\n      senderId\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      bytes32 newRealmId = LACLUtils.generateId(requests[i].name);\n      require(_data.scopes[newRealmId].stype == ScopeType.NONE, \"Already Exist\");\n      require(\n        requests[i].acstat > ActivityStatus.DELETED && requests[i].alstat > AlterabilityStatus.NONE,\n        \"Illegal Activity/Alterability\"\n      );\n\n      // check sender scopes\n      require(memberScopeType >= ScopeType.DOMAIN, \"Illegal ScopeType\");\n      if (memberScopeType == ScopeType.DOMAIN) {\n        require(memberScopeId == requests[i].domainId, \"Illegal Domain Scope\");\n      } else {\n        require(memberScopeId == _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Universe Scope\");\n      }\n\n      DomainEntity storage domainEntity = _data.domainReadSlot(requests[i].domainId);\n      require(domainEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Domain Updatable\");\n      require(domainEntity.realmLimit > domainEntity.realms.length(), \"Illegal Register\");\n\n      {\n        // check access admin realm\n        IACL.AdminAccessStatus status = _doCheckAdminAccess(domainEntity.bs.adminId, senderId, functionId);\n        if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n      }\n\n      // add to domain\n      domainEntity.realms.add(newRealmId);\n\n      {\n        // create new realm entity\n        RealmEntity storage newRealm = _data.realmWriteSlot(newRealmId);\n        newRealm.bs.stype = ScopeType.REALM;\n        newRealm.bs.acstat = requests[i].acstat;\n        newRealm.bs.alstat = requests[i].alstat;\n        newRealm.bs.adminId = requests[i].adminId;\n        newRealm.name = requests[i].name;\n        newRealm.domainId = requests[i].domainId;\n        newRealm.contextLimit = requests[i].contextLimit >= 0\n          ? uint32(uint64(requests[i].contextLimit))\n          : memberEntity.limits.contextLimit;\n        newRealm.bs.adminId = _getRealmAdmin(domainEntity.bs.adminId, requests[i].domainId, requests[i].adminId);\n      }\n\n      emit RealmRegistered(sender, newRealmId, requests[i].domainId, requests[i].adminId);\n    }\n\n    return true;\n  }\n\n  function realmUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRealmManagement.realmUpdateAdmin.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      RealmEntity storage realmEntity = _doGetEntityAndCheckAdminAccess(requests[i].id, senderId, functionId);\n\n      // checking requested type admin\n      if (requests[i].adminId != bytes32(0)) {\n        require(_data.agents[requests[i].adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n        (ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doAgentGetScopeInfo(requests[i].adminId);\n        require(ScopeType.REALM <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n        if (ScopeType.REALM == requestAdminScopeType) {\n          require(requestAdminScopeId == requests[i].id, \"Illegal Admin Scope\");\n        } else {\n          require(\n            IACLGenerals(address(this)).isScopesCompatible(requestAdminScopeId, requests[i].id),\n            \"Illegal Admin Scope\"\n          );\n        }\n        realmEntity.bs.adminId = requests[i].adminId;\n      } else {\n        realmEntity.bs.adminId = _data.scopes[realmEntity.domainId].adminId;\n      }\n\n      emit RealmAdminUpdated(sender, requests[i].id, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function realmMoveContext(MemberSignature calldata memberSign, RealmMoveContextRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRealmManagement.realmMoveContext.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      RealmEntity storage realmEntity = _doGetEntityAndCheckAdminAccess(requests[i].realmId, senderId, functionId);\n      require(realmEntity.contexts.contains(requests[i].contextId), \"Context Not Found\");\n      RealmEntity storage targetRealmEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].targetRealmId,\n        senderId,\n        functionId\n      );\n\n      ContextEntity storage contextEntity = _data.contextReadSlot(requests[i].contextId);\n      require(contextEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n      require(contextEntity.bs.referredByAgent == 0, \"Illegal Referred\");\n\n      (, bytes32 contextAdminScopeId) = _doAgentGetScopeInfo(contextEntity.bs.adminId);\n      require(\n        IACLGenerals(address(this)).isScopesCompatible(contextAdminScopeId, requests[i].targetRealmId),\n        \"Illegal Admin Scope\"\n      );\n\n      require(targetRealmEntity.contextLimit > targetRealmEntity.contexts.length(), \"Illegal Move\");\n      realmEntity.contexts.remove(requests[i].contextId);\n      targetRealmEntity.contexts.add(requests[i].contextId);\n      contextEntity.realmId = requests[i].targetRealmId;\n      emit RealmContextMoved(sender, requests[i].realmId, requests[i].contextId, requests[i].targetRealmId);\n    }\n\n    return true;\n  }\n\n  function realmUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRealmManagement.realmUpdateActivityStatus.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      RealmEntity storage realmEntity = _data.realmReadSlot(requests[i].id);\n      require(realmEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(realmEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      realmEntity.bs.acstat = requests[i].acstat;\n      emit RealmActivityUpdated(sender, requests[i].id, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function realmUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRealmManagement.realmUpdateAlterabilityStatus.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      RealmEntity storage realmEntity = _data.realmReadSlot(requests[i].id);\n      require(realmEntity.bs.acstat > ActivityStatus.DELETED, \"Realm Deleted\");\n\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(realmEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      realmEntity.bs.alstat = requests[i].alstat;\n      emit RealmAlterabilityUpdated(sender, requests[i].id, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function realmUpdateContextLimit(\n    MemberSignature calldata memberSign,\n    RealmUpdateContextLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRealmManagement.realmUpdateContextLimit.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      RealmEntity storage realmEntity = _doGetEntityAndCheckAdminAccess(requests[i].realmId, senderId, functionId);\n      require(requests[i].contextLimit > realmEntity.contexts.length(), \"Illegal Limit\");\n      realmEntity.contextLimit = requests[i].contextLimit;\n      emit RealmContextLimitUpdated(sender, requests[i].realmId, requests[i].contextLimit);\n    }\n    return true;\n  }\n\n  function realmRemove(MemberSignature calldata memberSign, bytes32[] calldata realms) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IRealmManagement.realmRemove.selector\n    );\n\n    for (uint256 i = 0; i < realms.length; i++) {\n      RealmEntity storage realmEntity = _data.realmReadSlot(realms[i]);\n\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(realmEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n      require(realmEntity.contexts.length() == 0, \"Illegal Remove\");\n      if (realmEntity.bs.referredByAgent == 0) {\n        // check domain\n        DomainEntity storage domainEntity = _data.domainReadSlot(realmEntity.domainId);\n        require(domainEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Domain Updatable\");\n        domainEntity.realms.remove(realms[i]);\n\n        delete realmEntity.bs;\n        delete realmEntity.domainId;\n        delete realmEntity.contextLimit;\n        delete realmEntity.name;\n        delete realmEntity.contexts;\n        emit RealmRemoved(sender, realms[i], false);\n      } else {\n        require(realmEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n        realmEntity.bs.acstat = ActivityStatus.DELETED;\n        emit RealmRemoved(sender, realms[i], true);\n      }\n    }\n    return true;\n  }\n\n  function realmCheckId(bytes32 realmId) external view returns (bool) {\n    return _data.scopes[realmId].stype == ScopeType.REALM;\n  }\n\n  function realmCheckName(string calldata realmName) external view returns (bool) {\n    return _data.scopes[LACLUtils.generateId(realmName)].stype == ScopeType.REALM;\n  }\n\n  function realmCheckAdmin(bytes32 realmId, address account) external view returns (bool) {\n    (RealmEntity storage realmEntity, bool result) = _data.realmTryReadSlot(realmId);\n    if (!result) return false;\n\n    bytes32 realmAdminId = realmEntity.bs.adminId;\n    AgentType agentType = _data.agents[realmAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (agentType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result0) = _data.roleTryReadSlot(realmAdminId);\n      if (!result0) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == realmAdminId;\n    } else if (agentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(realmAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function realmHasFunction(bytes32 realmId, bytes32 functionId) external view returns (bool) {\n    (FunctionEntity storage fe, bool result) = _data.functionTryReadSlot(functionId);\n    if (!result) return false;\n\n    (ContextEntity storage ce, bool result1) = _data.contextTryReadSlot(fe.contextId);\n    if (!result1) return false;\n\n    return ce.realmId == realmId;\n  }\n\n  function realmHasContext(bytes32 realmId, bytes32 contextId) external view returns (bool) {\n    (RealmEntity storage re, bool result) = _data.realmTryReadSlot(realmId);\n    if (!result) return false;\n    return re.contexts.contains(contextId);\n  }\n\n  function realmGetContexts(bytes32 realmId) external view returns (bytes32[] memory) {\n    (RealmEntity storage re, bool result) = _data.realmTryReadSlot(realmId);\n    if (!result) return new bytes32[](0);\n    return re.contexts.values();\n  }\n\n  function realmGetInfo(bytes32 realmId) external view returns (RealmInfo memory) {\n    (RealmEntity storage re, bool result) = _data.realmTryReadSlot(realmId);\n    if (!result) {\n      return\n        RealmInfo({\n          domainId: bytes32(0),\n          adminId: bytes32(0),\n          contextLimit: 0,\n          contextCount: 0,\n          referredByAgent: 0,\n          stype: ScopeType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE,\n          adminType: AgentType.NONE,\n          name: \"\"\n        });\n    }\n\n    return\n      RealmInfo({\n        domainId: re.domainId,\n        adminId: re.bs.adminId,\n        contextLimit: re.contextLimit,\n        contextCount: uint32(re.contexts.length()),\n        referredByAgent: re.bs.referredByAgent,\n        stype: re.bs.stype,\n        acstat: re.bs.acstat,\n        alstat: re.bs.alstat,\n        adminType: _data.agents[re.bs.adminId].atype,\n        name: re.name\n      });\n  }\n\n  function _doAgentGetScopeInfo(bytes32 agentId) internal view returns (ScopeType, bytes32) {\n    AgentType atype = _data.agents[agentId].atype;\n    if (atype == AgentType.ROLE) {\n      RoleEntity storage roleEntity = _data.roleReadSlot(agentId);\n      BaseScope storage baseScope = _data.scopes[roleEntity.scopeId];\n      return (baseScope.stype, roleEntity.scopeId);\n    } else if (atype == AgentType.TYPE) {\n      TypeEntity storage typeEntity = _data.typeReadSlot(agentId);\n      BaseScope storage baseScope = _data.scopes[typeEntity.scopeId];\n      return (baseScope.stype, typeEntity.scopeId);\n    }\n\n    return (ScopeType.NONE, bytes32(0));\n  }\n\n  function _doCheckAdminAccess(\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) internal view returns (IACL.AdminAccessStatus) {\n    return LACLCommons.checkAdminAccess(_data, adminId, memberId, functionId);\n  }\n\n  function _accessPermission(MemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getMemeberSignerAddress(memberSign, MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n    IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, senderId);\n    if (status != IACL.AuthorizationStatus.PERMITTED) {\n      if (\n        status == IACL.AuthorizationStatus.REALM_ACTIVITY_FORBIDDEN &&\n        selector == IRealmManagement.realmUpdateActivityStatus.selector\n      ) {\n        return (functionId, senderId, signer);\n      }\n      LACLUtils.generateAuthorizationError(status);\n    }\n    return (functionId, senderId, signer);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    bytes32 realmId,\n    bytes32 senderId,\n    bytes32 functionId\n  ) internal view returns (RealmEntity storage) {\n    RealmEntity storage realmEntity = _data.realmReadSlot(realmId);\n    require(realmEntity.bs.acstat > ActivityStatus.DELETED, \"Realm Deleted\");\n    require(realmEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(realmEntity.bs.adminId, senderId, functionId);\n    if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n    return realmEntity;\n  }\n\n  function _doGetMemberScopeInfoFromType(bytes32 typeId, bytes32 senderId) internal view returns (ScopeType, bytes32) {\n    TypeEntity storage agentAdminType = _data.typeReadSlot(typeId);\n    bytes32 memberRoleId = agentAdminType.members[senderId];\n    RoleEntity storage memberAgentRole = _data.roleReadSlot(memberRoleId);\n    return (_data.scopes[memberAgentRole.scopeId].stype, memberAgentRole.scopeId);\n  }\n\n  function _getRealmAdmin(\n    bytes32 requestScopeAdmin,\n    bytes32 domainId,\n    bytes32 adminId\n  ) internal view returns (bytes32 realmAdminId) {\n    return LACLCommons.realmGetAdmin(_data, requestScopeAdmin, domainId, adminId);\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LACLCommons);\n  }\n}\n"
    },
    "src/contracts/acl/scope/DomainManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IDomainManagement.sol\";\nimport \"../IACL.sol\";\nimport \"../IACLGenerals.sol\";\nimport \"../ACLStorage.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../lib/acl/LACLCommons.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Domain Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract DomainManager is ACLStorage, BaseUUPSProxy, IDomainManagement {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IDomainManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  // called by account that member of VERSE SCOPE MASTER TYPE\n  function domainRegister(MemberSignature calldata memberSign, DomainRegisterRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IDomainManagement.domainRegister.selector\n    );\n\n    // check and set\n    MemberEntity storage memberEntity = _data.memberReadSlot(senderId);\n    require(\n      int16(uint16(memberEntity.limits.domainRegisterLimit)) - int8(uint8(requests.length)) >= 0,\n      \"Illegal RegisterLimit\"\n    );\n    unchecked {\n      memberEntity.limits.domainRegisterLimit -= uint8(requests.length);\n    }\n\n    // fetch scope type and scope id of sender\n    bytes32 senderScopeId = _doGetMemberScopeInfoFromType(_LIVELY_VERSE_SCOPE_MASTER_TYPE_ID, senderId);\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      bytes32 newDomainId = LACLUtils.generateId(requests[i].name);\n      require(_data.scopes[newDomainId].stype == ScopeType.NONE, \"Already Exist\");\n      require(\n        requests[i].acstat > ActivityStatus.DELETED && requests[i].alstat > AlterabilityStatus.NONE,\n        \"Illegal Activity/Alterability\"\n      );\n\n      // check sender scopes\n      UniverseEntity storage livelyUniverseEntity = _data.universeReadSlot(_LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID);\n      require(senderScopeId == _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Universe Scope\");\n      require(livelyUniverseEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Universe Updatable\");\n      require(livelyUniverseEntity.domainLimit > livelyUniverseEntity.domains.length(), \"Illegal Register\");\n\n      // check access admin universe\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(livelyUniverseEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      // add domain to universe\n      livelyUniverseEntity.domains.add(newDomainId);\n\n      // create new domain entity\n      DomainEntity storage newDomain = _data.domainWriteSlot(newDomainId);\n      newDomain.bs.stype = ScopeType.DOMAIN;\n      newDomain.bs.acstat = requests[i].acstat;\n      newDomain.bs.alstat = requests[i].alstat;\n      newDomain.universeId = _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n      newDomain.name = requests[i].name;\n      newDomain.realmLimit = requests[i].realmLimit >= 0\n        ? uint16(uint24(requests[i].realmLimit))\n        : memberEntity.limits.realmLimit;\n\n      // checking requested domain admin\n      if (requests[i].adminId != bytes32(0)) {\n        require(_data.agents[requests[i].adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n        bytes32 requestAdminScopeId = _doAgentGetScopeInfo(requests[i].adminId);\n        require(requestAdminScopeId == _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Admin Scope\");\n        newDomain.bs.adminId = requests[i].adminId;\n      } else {\n        newDomain.bs.adminId = livelyUniverseEntity.bs.adminId;\n      }\n\n      emit DomainRegistered(sender, newDomainId, requests[i].adminId);\n    }\n\n    return true;\n  }\n\n  function domainUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IDomainManagement.domainUpdateActivityStatus.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = _data.domainReadSlot(requests[i].id);\n      require(domainEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(domainEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      domainEntity.bs.acstat = requests[i].acstat;\n      emit DomainActivityUpdated(sender, requests[i].id, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function domainUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IDomainManagement.domainUpdateAlterabilityStatus.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = _data.domainReadSlot(requests[i].id);\n      require(domainEntity.bs.acstat > ActivityStatus.DELETED, \"Domain Deleted\");\n\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(domainEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n\n      domainEntity.bs.alstat = requests[i].alstat;\n      emit DomainAlterabilityUpdated(sender, requests[i].id, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function domainUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IDomainManagement.domainUpdateAdmin.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = _doGetEntityAndCheckAdminAccess(requests[i].id, senderId, functionId);\n\n      // checking requested domain admin\n      if (requests[i].adminId != bytes32(0)) {\n        require(_data.agents[requests[i].adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n        bytes32 requestAdminScopeId = _doAgentGetScopeInfo(requests[i].adminId);\n        require(requestAdminScopeId == _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID, \"Illegal Admin Scope\");\n        domainEntity.bs.adminId = requests[i].adminId;\n      } else {\n        domainEntity.bs.adminId = _data.scopes[_LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID].adminId;\n      }\n\n      emit DomainAdminUpdated(sender, requests[i].id, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function domainMoveRealm(MemberSignature calldata memberSign, DomainMoveRealmRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IDomainManagement.domainMoveRealm.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = _doGetEntityAndCheckAdminAccess(requests[i].domainId, senderId, functionId);\n      require(domainEntity.realms.contains(requests[i].realmId), \"Domain Realm Not Found\");\n      DomainEntity storage targetDomainEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].targetDomainId,\n        senderId,\n        functionId\n      );\n\n      RealmEntity storage realmEntity = _data.realmReadSlot(requests[i].realmId);\n      require(realmEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Realm Updatable\");\n      require(realmEntity.bs.referredByAgent == 0, \"Illeagl Referred\");\n\n      bytes32 realmAdminScopeId = _doAgentGetScopeInfo(realmEntity.bs.adminId);\n      require(\n        IACLGenerals(address(this)).isScopesCompatible(realmAdminScopeId, requests[i].targetDomainId),\n        \"Illegal Admin Scope\"\n      );\n\n      require(targetDomainEntity.realmLimit > targetDomainEntity.realms.length(), \"Illegal Move\");\n      domainEntity.realms.remove(requests[i].realmId);\n      targetDomainEntity.realms.add(requests[i].realmId);\n      realmEntity.domainId = requests[i].targetDomainId;\n      emit DomainRealmMoved(sender, requests[i].domainId, requests[i].realmId, requests[i].targetDomainId);\n    }\n    return true;\n  }\n\n  function domainUpdateRealmLimit(\n    MemberSignature calldata memberSign,\n    DomainUpdateRealmLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IDomainManagement.domainUpdateRealmLimit.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      DomainEntity storage domainEntity = _doGetEntityAndCheckAdminAccess(requests[i].domainId, senderId, functionId);\n      require(requests[i].realmLimit > domainEntity.realms.length(), \"Illegal Limit\");\n      domainEntity.realmLimit = requests[i].realmLimit;\n      emit DomainRealmLimitUpdated(sender, requests[i].domainId, requests[i].realmLimit);\n    }\n    return true;\n  }\n\n  function domainRemove(MemberSignature calldata memberSign, bytes32[] calldata domains) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IDomainManagement.domainRemove.selector\n    );\n\n    for (uint256 i = 0; i < domains.length; i++) {\n      DomainEntity storage domainEntity = _data.domainReadSlot(domains[i]);\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(domainEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(domainEntity.realms.length() == 0, \"Illegal Remove\");\n      if (domainEntity.bs.referredByAgent == 0) {\n        // check universe\n        UniverseEntity storage universeEntity = _data.universeReadSlot(domainEntity.universeId);\n        require(universeEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Universe Updatable\");\n        universeEntity.domains.remove(domains[i]);\n\n        delete domainEntity.bs;\n        delete domainEntity.universeId;\n        delete domainEntity.realmLimit;\n        delete domainEntity.name;\n        delete domainEntity.realms;\n        emit DomainRemoved(sender, domains[i], false);\n      } else {\n        require(domainEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n        domainEntity.bs.acstat = ActivityStatus.DELETED;\n        emit DomainRemoved(sender, domains[i], true);\n      }\n    }\n\n    return true;\n  }\n\n  function domainCheckId(bytes32 domainId) external view returns (bool) {\n    return _data.scopes[domainId].stype == ScopeType.DOMAIN;\n  }\n\n  function domainCheckName(string calldata domainName) external view returns (bool) {\n    return _data.scopes[LACLUtils.generateId(domainName)].stype == ScopeType.DOMAIN;\n  }\n\n  function domainCheckAdmin(bytes32 domainId, address account) external view returns (bool) {\n    (DomainEntity storage domainEntity, bool result) = _data.domainTryReadSlot(domainId);\n    if (!result) return false;\n\n    bytes32 domainAdminId = domainEntity.bs.adminId;\n    AgentType agentType = _data.agents[domainAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (agentType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result0) = _data.roleTryReadSlot(domainAdminId);\n      if (!result0) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == domainAdminId;\n    } else if (agentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(domainAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function domainHasFunction(bytes32 domainId, bytes32 functionId) external view returns (bool) {\n    (FunctionEntity storage fe, bool result) = _data.functionTryReadSlot(functionId);\n    if (!result) return false;\n\n    (ContextEntity storage ce, bool result1) = _data.contextTryReadSlot(fe.contextId);\n    if (!result1) return false;\n\n    (RealmEntity storage re, bool result2) = _data.realmTryReadSlot(ce.realmId);\n    if (!result2) return false;\n\n    return re.domainId == domainId;\n  }\n\n  function domainHasContext(bytes32 domainId, bytes32 contextId) external view returns (bool) {\n    (ContextEntity storage ce, bool result1) = _data.contextTryReadSlot(contextId);\n    if (!result1) return false;\n\n    (RealmEntity storage re, bool result2) = _data.realmTryReadSlot(ce.realmId);\n    if (!result2) return false;\n\n    return re.domainId == domainId;\n  }\n\n  function domainHasRealm(bytes32 domainId, bytes32 realmId) external view returns (bool) {\n    (DomainEntity storage de, bool result) = _data.domainTryReadSlot(domainId);\n    if (!result) return false;\n    return de.realms.contains(realmId);\n  }\n\n  function domainGetRealms(bytes32 domainId) external view returns (bytes32[] memory) {\n    (DomainEntity storage de, bool result) = _data.domainTryReadSlot(domainId);\n    if (!result) return new bytes32[](0);\n    return de.realms.values();\n  }\n\n  function domainGetInfo(bytes32 domainId) external view returns (DomainInfo memory) {\n    (DomainEntity storage de, bool result) = _data.domainTryReadSlot(domainId);\n    if (!result) {\n      return\n        DomainInfo({\n          adminId: bytes32(0),\n          universeId: bytes32(0),\n          realmLimit: 0,\n          realmCount: 0,\n          referredByAgent: 0,\n          stype: ScopeType.NONE,\n          adminType: AgentType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE,\n          name: \"\"\n        });\n    }\n\n    return\n      DomainInfo({\n        adminId: de.bs.adminId,\n        universeId: de.universeId,\n        realmLimit: de.realmLimit,\n        realmCount: uint16(de.realms.length()),\n        referredByAgent: de.bs.referredByAgent,\n        adminType: _data.agents[de.bs.adminId].atype,\n        stype: de.bs.stype,\n        acstat: de.bs.acstat,\n        alstat: de.bs.alstat,\n        name: de.name\n      });\n  }\n\n  function _doCheckAdminAccess(\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) internal view returns (IACL.AdminAccessStatus) {\n    return LACLCommons.checkAdminAccess(_data, adminId, memberId, functionId);\n  }\n\n  function _doAgentGetScopeInfo(bytes32 agentId) internal view returns (bytes32) {\n    AgentType atype = _data.agents[agentId].atype;\n    if (atype == AgentType.ROLE) {\n      RoleEntity storage roleEntity = _data.roleReadSlot(agentId);\n      return roleEntity.scopeId;\n    } else if (atype == AgentType.TYPE) {\n      TypeEntity storage typeEntity = _data.typeReadSlot(agentId);\n      return typeEntity.scopeId;\n    }\n\n    return bytes32(0);\n  }\n\n  function _accessPermission(MemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getMemeberSignerAddress(memberSign, MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n    IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, senderId);\n    if (status != IACL.AuthorizationStatus.PERMITTED) {\n      if (\n        status == IACL.AuthorizationStatus.DOMAIN_ACTIVITY_FORBIDDEN &&\n        IDomainManagement.domainUpdateActivityStatus.selector == selector\n      ) {\n        return (functionId, senderId, signer);\n      }\n      LACLUtils.generateAuthorizationError(status);\n    }\n    return (functionId, senderId, signer);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    bytes32 domainId,\n    bytes32 senderId,\n    bytes32 functionId\n  ) internal view returns (DomainEntity storage) {\n    DomainEntity storage domainEntity = _data.domainReadSlot(domainId);\n    require(domainEntity.bs.acstat > ActivityStatus.DELETED, \"Domain Deleted\");\n    require(domainEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(domainEntity.bs.adminId, senderId, functionId);\n    if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n    return domainEntity;\n  }\n\n  function _doGetMemberScopeInfoFromType(bytes32 typeId, bytes32 senderId) internal view returns (bytes32) {\n    TypeEntity storage agentAdminType = _data.typeReadSlot(typeId);\n    bytes32 memberRoleId = agentAdminType.members[senderId];\n    RoleEntity storage memberAgentRole = _data.roleReadSlot(memberRoleId);\n    return memberAgentRole.scopeId;\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LACLCommons);\n  }\n}\n"
    },
    "src/contracts/acl/scope/ContextManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IContextManagement.sol\";\nimport \"../ACLStorage.sol\";\nimport \"../IACL.sol\";\nimport \"../IACLGenerals.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../lib/acl/LACLCommons.sol\";\nimport \"../../lib/proxy/LClones.sol\";\nimport \"../../lib/cryptography/LECDSA.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title Context Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ContextManager is ACLStorage, BaseUUPSProxy, IContextManagement {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LClones for address;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IContextManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  // called by system admin\n  function contextRegister(MemberSignature calldata memberSign, ContextRegisterRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getMemeberSignerAddress(memberSign, MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      address contractId;\n      if (requests[i].contractId == address(0)) {\n        if (memberSign.signature.length == 0) {\n          if (requests[i].signature.length > 0) {\n            signer = LACLUtils.getSignerAddress(\n              requests[i].signature,\n              _getPredictContextMessageHash(requests[i].deployer, requests[i].subject, requests[i].realmId)\n            );\n          } else {\n            signer = msg.sender;\n          }\n        }\n\n        contractId = requests[i].subject.predictDeterministicAddress(requests[i].salt, requests[i].deployer);\n      } else {\n        if (memberSign.signature.length == 0) {\n          if (requests[i].signature.length > 0) {\n            bytes32 structHash = _getContextMessageHash(\n              requests[i].contractId,\n              LACLUtils.generateHash(requests[i].name),\n              LACLUtils.generateHash(requests[i].version),\n              requests[i].realmId\n            );\n            signer = LACLUtils.getSignerAddress(requests[i].signature, structHash);\n          } else {\n            signer = msg.sender;\n          }\n        }\n        contractId = requests[i].contractId;\n      }\n\n      _doRegisterContext(requests[i], contractId, signer);\n    }\n\n    return true;\n  }\n\n  function contextUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IContextManagement.contextUpdateActivityStatus.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      ContextEntity storage contextEntity = _data.contextReadSlot(requests[i].id);\n      require(contextEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(contextEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      contextEntity.bs.acstat = requests[i].acstat;\n      emit ContextActivityUpdated(sender, requests[i].id, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function contextUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IContextManagement.contextUpdateAlterabilityStatus.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      ContextEntity storage contextEntity = _data.contextReadSlot(requests[i].id);\n      require(contextEntity.bs.acstat > ActivityStatus.DELETED, \"Context Deleted\");\n\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(contextEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      contextEntity.bs.alstat = requests[i].alstat;\n      emit ContextAlterabilityUpdated(sender, requests[i].id, requests[i].alstat);\n    }\n    return true;\n  }\n\n  function contextUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IContextManagement.contextUpdateAdmin.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      ContextEntity storage contextEntity = _doGetEntityAndCheckAdminAccess(requests[i].id, senderId, functionId);\n\n      // checking requested type admin\n      if (requests[i].adminId != bytes32(0)) {\n        require(_data.agents[requests[i].adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n        (ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doAgentGetScopeInfo(requests[i].adminId);\n        require(ScopeType.CONTEXT <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n        if (ScopeType.CONTEXT == requestAdminScopeType) {\n          require(requestAdminScopeId == requests[i].id, \"Illegal Admin Scope\");\n        } else {\n          require(\n            IACLGenerals(address(this)).isScopesCompatible(requestAdminScopeId, requests[i].id),\n            \"Illegal Admin Scope\"\n          );\n        }\n        contextEntity.bs.adminId = requests[i].adminId;\n      } else {\n        contextEntity.bs.adminId = _data.scopes[contextEntity.realmId].adminId;\n      }\n\n      emit ContextAdminUpdated(sender, requests[i].id, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function contextUpdateFunctionLimit(\n    MemberSignature calldata memberSign,\n    ContextUpdateFunctionLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IContextManagement.contextUpdateFunctionLimit.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      ContextEntity storage contextEntity = _doGetEntityAndCheckAdminAccess(\n        requests[i].contextId,\n        senderId,\n        functionId\n      );\n      require(requests[i].functionLimit > contextEntity.functions.length(), \"Illegal Limit\");\n      contextEntity.functionLimit = requests[i].functionLimit;\n      emit ContextFunctionLimitUpdated(sender, requests[i].contextId, requests[i].functionLimit);\n    }\n    return true;\n  }\n\n  function contextRemove(MemberSignature calldata memberSign, bytes32[] calldata contexts) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IContextManagement.contextRemove.selector\n    );\n\n    for (uint256 i = 0; i < contexts.length; i++) {\n      ContextEntity storage contextEntity = _data.contextReadSlot(contexts[i]);\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(contextEntity.bs.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      require(contextEntity.functions.length() == 0, \"Illegal Remove\");\n      if (contextEntity.bs.referredByAgent == 0) {\n        // check realm\n        RealmEntity storage realmEntity = _data.realmReadSlot(contextEntity.realmId);\n        require(realmEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Realm Updatable\");\n        realmEntity.contexts.remove(contexts[i]);\n\n        delete contextEntity.bs;\n        delete contextEntity.realmId;\n        delete contextEntity.contractId;\n        delete contextEntity.functionLimit;\n        delete contextEntity.functions;\n        emit ContextRemoved(sender, contexts[i], false);\n      } else {\n        require(contextEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n        contextEntity.bs.acstat = ActivityStatus.DELETED;\n        emit ContextRemoved(sender, contexts[i], true);\n      }\n    }\n    return true;\n  }\n\n  function contextCheckId(bytes32 contextId) external view returns (bool) {\n    return _data.scopes[contextId].stype == ScopeType.CONTEXT;\n  }\n\n  function contextCheckAccount(address contractId) external view returns (bool) {\n    return _data.scopes[LACLUtils.accountGenerateId(contractId)].stype == ScopeType.CONTEXT;\n  }\n\n  function contextCheckAdmin(bytes32 contextId, address account) external view returns (bool) {\n    (ContextEntity storage ce, bool result) = _data.contextTryReadSlot(contextId);\n    if (!result) return false;\n\n    bytes32 contextAdminId = ce.bs.adminId;\n    AgentType agentType = _data.agents[contextAdminId].atype;\n    bytes32 memberId = LACLUtils.accountGenerateId(account);\n\n    if (agentType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result0) = _data.roleTryReadSlot(contextAdminId);\n      if (!result0) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] == contextAdminId;\n    } else if (agentType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(contextAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[memberId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function contextHasFunction(bytes32 contextId, bytes32 functionId) external view returns (bool) {\n    return _doContextHasFunction(contextId, functionId);\n  }\n\n  function contextHasSelector(address contractId, bytes4 selector) external view returns (bool) {\n    bytes32 contextId = LACLUtils.accountGenerateId(contractId);\n    bytes32 functionId = LACLUtils.functionGenerateId(contractId, selector);\n    return _doContextHasFunction(contextId, functionId);\n  }\n\n  function _doContextHasFunction(bytes32 contextId, bytes32 functionId) internal view returns (bool) {\n    (ContextEntity storage ce, bool result) = _data.contextTryReadSlot(contextId);\n    if (!result) return false;\n    return ce.functions.contains(functionId);\n  }\n\n  function _doCheckAdminAccess(\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) internal view returns (IACL.AdminAccessStatus) {\n    return LACLCommons.checkAdminAccess(_data, adminId, memberId, functionId);\n  }\n\n  function _doAgentGetScopeInfo(bytes32 agentId) internal view returns (ScopeType, bytes32) {\n    AgentType atype = _data.agents[agentId].atype;\n    if (atype == AgentType.ROLE) {\n      RoleEntity storage roleEntity = _data.roleReadSlot(agentId);\n      BaseScope storage baseScope = _data.scopes[roleEntity.scopeId];\n      return (baseScope.stype, roleEntity.scopeId);\n    } else if (atype == AgentType.TYPE) {\n      TypeEntity storage typeEntity = _data.typeReadSlot(agentId);\n      BaseScope storage baseScope = _data.scopes[typeEntity.scopeId];\n      return (baseScope.stype, typeEntity.scopeId);\n    }\n\n    return (ScopeType.NONE, bytes32(0));\n  }\n\n  function contextGetFunctions(bytes32 contextId) external view returns (bytes32[] memory) {\n    (ContextEntity storage ce, bool result) = _data.contextTryReadSlot(contextId);\n    if (!result) return new bytes32[](0);\n    return ce.functions.values();\n  }\n\n  function contextGetInfo(bytes32 contextId) external view returns (ContextInfo memory) {\n    (ContextEntity storage ce, bool result) = _data.contextTryReadSlot(contextId);\n    if (!result) {\n      return\n        ContextInfo({\n          realmId: bytes32(0),\n          adminId: bytes32(0),\n          contractId: address(0),\n          functionCount: 0,\n          functionLimit: 0,\n          referredByAgent: 0,\n          adminType: AgentType.NONE,\n          stype: ScopeType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE\n        });\n    }\n\n    return\n      ContextInfo({\n        realmId: ce.realmId,\n        adminId: ce.bs.adminId,\n        contractId: ce.contractId,\n        functionCount: uint8(ce.functions.length()),\n        functionLimit: ce.functionLimit,\n        referredByAgent: ce.bs.referredByAgent,\n        adminType: _data.agents[ce.bs.adminId].atype,\n        stype: ce.bs.stype,\n        acstat: ce.bs.acstat,\n        alstat: ce.bs.alstat\n      });\n  }\n\n  function _accessPermission(MemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getMemeberSignerAddress(memberSign, MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n    IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, senderId);\n    if (status != IACL.AuthorizationStatus.PERMITTED) {\n      if (\n        status == IACL.AuthorizationStatus.CONTEXT_ACTIVITY_FORBIDDEN &&\n        IContextManagement.contextUpdateActivityStatus.selector == selector\n      ) {\n        return (functionId, senderId, signer);\n      }\n      LACLUtils.generateAuthorizationError(status);\n    }\n\n    return (functionId, senderId, signer);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    bytes32 contextId,\n    bytes32 senderId,\n    bytes32 functionId\n  ) internal view returns (ContextEntity storage) {\n    ContextEntity storage contextEntity = _data.contextReadSlot(contextId);\n    require(contextEntity.bs.acstat > ActivityStatus.DELETED, \"Context Deleted\");\n    require(contextEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(contextEntity.bs.adminId, senderId, functionId);\n    if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n    return contextEntity;\n  }\n\n  function _getContextAdmin(\n    bytes32 realmId,\n    bytes32 scopeId,\n    bytes32 realmAdminId,\n    bytes32 requestAdminId\n  ) internal view returns (bytes32 contextAdminId) {\n    // checking requested context admin\n    if (requestAdminId != bytes32(0)) {\n      require(_data.agents[requestAdminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n      (ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doAgentGetScopeInfo(requestAdminId);\n      require(ScopeType.REALM <= requestAdminScopeType, \"Illegal Admin ScopeType\");\n      if (ScopeType.REALM == requestAdminScopeType) {\n        require(requestAdminScopeId == realmId, \"Illegal Admin Scope\");\n      } else {\n        require(IACLGenerals(address(this)).isScopesCompatible(requestAdminScopeId, scopeId), \"Illegal Admin Scope\");\n      }\n      contextAdminId = requestAdminId;\n    } else {\n      contextAdminId = realmAdminId;\n    }\n  }\n\n  function _doCheckSystemScope(bytes32 scopeId, bytes32 memberId) internal view returns (bool) {\n    TypeEntity storage systemType = _data.typeReadSlot(_LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID);\n    bytes32 memberRoleId = systemType.members[memberId];\n    RoleEntity storage memberSystemRole = _data.roleReadSlot(memberRoleId);\n    if (_data.scopes[memberSystemRole.scopeId].stype < ScopeType.REALM) return false;\n    if (memberSystemRole.scopeId == scopeId) {\n      return true;\n    }\n\n    return IACLGenerals(address(this)).isScopesCompatible(memberSystemRole.scopeId, scopeId);\n  }\n\n  function _getContextMessageHash(\n    address contractId,\n    bytes32 name,\n    bytes32 version,\n    bytes32 realmId\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(CTX_MESSAGE_TYPEHASH, contractId, name, version, realmId));\n  }\n\n  function _getPredictContextMessageHash(\n    address deployer,\n    address subject,\n    bytes32 realmId\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(PREDICT_CTX_MESSAGE_TYPEHASH, deployer, subject, realmId));\n  }\n\n  function _doRegisterContext(\n    ContextRegisterRequest calldata request,\n    address contractId,\n    address signer\n  ) internal {\n    bytes32 functionId = LACLUtils.functionGenerateId(\n      _data.selectors[IContextManagement.contextRegister.selector],\n      IContextManagement.contextRegister.selector\n    );\n    bytes32 signerId = LACLUtils.accountGenerateId(signer);\n    bytes32 newContextId = LACLUtils.accountGenerateId(contractId);\n    IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, signerId);\n    if (status != IACL.AuthorizationStatus.PERMITTED) LACLUtils.generateAuthorizationError(status);\n    require(_data.scopes[newContextId].stype == ScopeType.NONE, \"Already Exist\");\n    require(\n      request.acstat > ActivityStatus.DELETED && request.alstat > AlterabilityStatus.NONE,\n      \"Illegal Activity/Alterability\"\n    );\n\n    {\n      // update member context register limit\n      MemberEntity storage memberEntity = _data.memberReadSlot(signerId);\n      require(memberEntity.limits.contextRegisterLimit > 0, \"Illegal RegisterLimit\");\n      unchecked {\n        memberEntity.limits.contextRegisterLimit -= 1;\n      }\n\n      // check realm\n      RealmEntity storage realmEntity = _data.realmReadSlot(request.realmId);\n      require(realmEntity.bs.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Realm Updatable\");\n      require(realmEntity.contextLimit > realmEntity.contexts.length(), \"Illegal Register\");\n\n      // check system scope\n      require(_doCheckSystemScope(request.realmId, signerId), \"Forbidden\");\n\n      // add context to realm\n      realmEntity.contexts.add(newContextId);\n\n      // create new context\n      ContextEntity storage newContext = _data.contextWriteSlot(newContextId);\n      newContext.realmId = request.realmId;\n      newContext.contractId = contractId;\n      newContext.functionLimit = request.functionLimit >= 0\n        ? uint8(uint16(request.functionLimit))\n        : memberEntity.limits.functionLimit;\n      newContext.bs.stype = ScopeType.CONTEXT;\n      newContext.bs.acstat = request.acstat;\n      newContext.bs.alstat = request.alstat;\n      newContext.bs.adminId = _getContextAdmin(request.realmId, newContextId, realmEntity.bs.adminId, request.adminId);\n    }\n\n    emit ContextRegistered(\n      signer,\n      newContextId,\n      contractId,\n      request.realmId,\n      request.deployer,\n      request.subject,\n      request.adminId\n    );\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LACLCommons);\n  }\n}\n"
    },
    "src/contracts/acl/agent/MemberManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./IMemberManagement.sol\";\nimport \"./ITypeManagement.sol\";\nimport \"../ACLStorage.sol\";\nimport \"../IACL.sol\";\nimport \"../IACLGenerals.sol\";\nimport \"../scope/IFunctionManagement.sol\";\nimport \"../../lib/acl/LACLStorage.sol\";\nimport \"../../lib/acl/LACLAgentScope.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../lib/acl/LACLUtils.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\n/**\n * @title ACL Member Manager Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract MemberManager is ACLStorage, BaseUUPSProxy, IMemberManagement {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IMemberManagement).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  // Note: called by eveny admin of role\n  function memberRegister(MemberSignature calldata memberSign, MemberRegisterRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IMemberManagement.memberRegister.selector\n    );\n\n    // check and set\n    MemberEntity storage memberEntity = _data.memberReadSlot(senderId);\n    require(\n      int32(uint32(memberEntity.limits.memberRegisterLimit)) - int16(uint16(requests.length)) >= 0,\n      \"Illegal RegisterLimit\"\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      _doMemberRegister(requests[i], memberEntity, functionId, senderId, sender);\n    }\n\n    unchecked {\n      memberEntity.limits.memberRegisterLimit -= uint16(requests.length);\n    }\n    return true;\n  }\n\n  function memberUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IMemberManagement.memberUpdateActivityStatus.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      MemberEntity storage memberEntity = _doGetEntityAndCheckAdminAccess(requests[i].id, senderId, functionId);\n      require(\n        !_doRoleHasMember(LACLAgentScope.LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID, requests[i].id),\n        \"Illegal Member\"\n      );\n      require(requests[i].acstat > ActivityStatus.DELETED, \"Illegal Activity\");\n      memberEntity.ba.acstat = requests[i].acstat;\n      emit MemberActivityUpdated(sender, requests[i].id, requests[i].acstat);\n    }\n    return true;\n  }\n\n  function memberUpdateAlterabilityStatus(\n    MemberSignature calldata memberSign,\n    UpdateAlterabilityRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IMemberManagement.memberUpdateAlterabilityStatus.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      MemberEntity storage memberEntity = _data.memberReadSlot(requests[i].id);\n      IACL.AdminAccessStatus adminAccessStatus = _doCheckAdminAccess(memberEntity.ba.adminId, senderId, functionId);\n      if (adminAccessStatus != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(adminAccessStatus);\n      require(requests[i].alstat != AlterabilityStatus.NONE, \"Illegal Alterability\");\n      memberEntity.ba.alstat = requests[i].alstat;\n      emit MemberAlterabilityUpdated(sender, requests[i].id, requests[i].alstat);\n    }\n    return true;\n  }\n\n  // Note: member default admin is\n  function memberUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\n    external\n    returns (bool)\n  {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IMemberManagement.memberUpdateAdmin.selector\n    );\n\n    for (uint256 i = 0; i < requests.length; i++) {\n      MemberEntity storage memberEntity = _doGetEntityAndCheckAdminAccess(requests[i].id, senderId, functionId);\n\n      // checking requested admin of member\n      if (requests[i].adminId != bytes32(0)) {\n        BaseAgent storage requestedAdminAgent = _data.agents[requests[i].adminId];\n        require(requestedAdminAgent.atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n        memberEntity.ba.adminId = requests[i].adminId;\n      } else {\n        memberEntity.ba.adminId = _LIVELY_VERSE_MEMBER_MASTER_TYPE_ID;\n      }\n      emit MemberAdminUpdated(sender, requests[i].id, requests[i].adminId);\n    }\n    return true;\n  }\n\n  function memberUpdateGeneralLimit(\n    MemberSignature calldata memberSign,\n    MemberUpdateGeneralLimitRequest[] calldata requests\n  ) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IMemberManagement.memberUpdateGeneralLimit.selector\n    );\n    MemberEntity storage senderMemberEntity = _data.memberReadSlot(senderId);\n    for (uint256 i = 0; i < requests.length; i++) {\n      MemberEntity storage memberEntity = _doGetEntityAndCheckAdminAccess(requests[i].memberId, senderId, functionId);\n      require(requests[i].limits.typeLimit > memberEntity.types.length(), \"Illegal TypeLimit\");\n\n      if (\n        !memberEntity.types.contains(_LIVELY_VERSE_LIVELY_MASTER_TYPE_ID) &&\n        !memberEntity.types.contains(_LIVELY_VERSE_MEMBER_MASTER_TYPE_ID)\n      ) {\n        _doCheckMemberRegisterLimits(senderMemberEntity, requests[i].limits);\n      }\n      memberEntity.limits = requests[i].limits;\n      emit MemberGeneralLimitUpdated(sender, requests[i].memberId, requests[i].limits);\n    }\n    return true;\n  }\n\n  function memberRemove(MemberSignature calldata memberSign, bytes32[] calldata members) external returns (bool) {\n    (bytes32 functionId, bytes32 senderId, address sender) = _accessPermission(\n      memberSign,\n      IMemberManagement.memberRemove.selector\n    );\n\n    for (uint256 i = 0; i < members.length; i++) {\n      MemberEntity storage memberEntity = _data.memberReadSlot(members[i]);\n      IACL.AdminAccessStatus status = _doCheckAdminAccess(memberEntity.ba.adminId, senderId, functionId);\n      if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n\n      for (uint256 j = 0; j < memberEntity.types.length() && j < 16; j++) {\n        // check type\n        bytes32 typeId = memberEntity.types.at(j);\n        TypeEntity storage typeEntity = _data.typeReadSlot(typeId);\n        require(typeEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Type Updatable\");\n\n        // check role\n        bytes32 roleId = typeEntity.members[members[i]];\n        RoleEntity storage roleEntity = _data.roleReadSlot(roleId);\n        require(roleEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Role Updatable\");\n        if (roleId == LACLAgentScope.LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID) {\n          require(roleEntity.memberCount > 1, \"Illegal Member Revoke\");\n        }\n        require(roleEntity.memberCount > 0, \"Illegal MemberCount\");\n        unchecked {\n          roleEntity.memberCount -= 1;\n        }\n\n        // delete member from type\n        delete typeEntity.members[members[i]];\n\n        // delete type from member\n        memberEntity.types.remove(typeId);\n        emit MemberRoleRevoked(sender, members[i], roleId, typeId);\n      }\n\n      if (memberEntity.types.length() == 0) {\n        delete memberEntity.ba;\n        delete memberEntity.account;\n        delete memberEntity.limits;\n        delete memberEntity.types;\n        emit MemberRemoved(sender, members[i], true);\n      } else {\n        emit MemberRemoved(sender, members[i], false);\n      }\n    }\n\n    return true;\n  }\n\n  function memberCheckId(bytes32 memberId) external view returns (bool) {\n    return _data.agents[memberId].atype == AgentType.MEMBER;\n  }\n\n  function memberCheckAccount(address account) external view returns (bool) {\n    return _data.agents[keccak256(abi.encodePacked(account))].atype == AgentType.MEMBER;\n  }\n\n  function memberCheckAdmin(bytes32 memberId, address account) external view returns (bool) {\n    if (_data.agents[memberId].atype != AgentType.MEMBER) return false;\n\n    bytes32 memberAdminId = _data.agents[memberId].adminId;\n    AgentType adminAgenType = _data.agents[memberAdminId].atype;\n    bytes32 accountId = LACLUtils.accountGenerateId(account);\n\n    if (adminAgenType == AgentType.ROLE) {\n      (RoleEntity storage roleEntity, bool result) = _data.roleTryReadSlot(memberAdminId);\n      if (!result) return false;\n\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(roleEntity.typeId);\n      if (!result1) return false;\n\n      return typeEntity.members[accountId] == memberAdminId;\n    } else if (adminAgenType == AgentType.TYPE) {\n      (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(memberAdminId);\n      if (!result1) return false;\n\n      return typeEntity.members[accountId] != bytes32(0);\n    }\n\n    return false;\n  }\n\n  function memberHasType(bytes32 memberId, bytes32 typeId) external view returns (bool) {\n    (MemberEntity storage member, bool result) = _data.memberTryReadSlot(memberId);\n    if (result) return member.types.contains(typeId);\n    return false;\n  }\n\n  function memberGetTypes(bytes32 memberId) external view returns (bytes32[] memory) {\n    (MemberEntity storage member, bool result) = _data.memberTryReadSlot(memberId);\n    if (!result) return new bytes32[](0);\n    return member.types.values();\n  }\n\n  function memberGetInfo(bytes32 memberId) external view returns (MemberInfo memory) {\n    (MemberEntity storage member, bool result) = _data.memberTryReadSlot(memberId);\n    if (!result) {\n      return\n        MemberInfo({\n          adminId: bytes32(0),\n          account: address(0),\n          limits: GeneralLimit({\n            contextLimit: 0,\n            memberRegisterLimit: 0,\n            roleRegisterLimit: 0,\n            typeRegisterLimit: 0,\n            functionRegisterLimit: 0,\n            contextRegisterLimit: 0,\n            profileRegisterLimit: 0,\n            memberLimit: 0,\n            realmRegisterLimit: 0,\n            domainRegisterLimit: 0,\n            policyRegisterLimit: 0,\n            functionLimit: 0,\n            realmLimit: 0,\n            domainLimit: 0,\n            callLimit: 0,\n            typeRoleLimit: 0,\n            typeLimit: 0,\n            policyRoleLimit: 0\n          }),\n          typeCount: 0,\n          adminType: AgentType.NONE,\n          atype: AgentType.NONE,\n          acstat: ActivityStatus.NONE,\n          alstat: AlterabilityStatus.NONE\n        });\n    }\n\n    return\n      MemberInfo({\n        adminId: member.ba.adminId,\n        account: member.account,\n        limits: GeneralLimit({\n          contextLimit: member.limits.contextLimit,\n          memberRegisterLimit: member.limits.memberRegisterLimit,\n          roleRegisterLimit: member.limits.roleRegisterLimit,\n          typeRegisterLimit: member.limits.typeRegisterLimit,\n          functionRegisterLimit: member.limits.functionRegisterLimit,\n          contextRegisterLimit: member.limits.contextRegisterLimit,\n          profileRegisterLimit: member.limits.profileRegisterLimit,\n          memberLimit: member.limits.memberLimit,\n          realmRegisterLimit: member.limits.realmRegisterLimit,\n          domainRegisterLimit: member.limits.domainRegisterLimit,\n          policyRegisterLimit: member.limits.policyRegisterLimit,\n          functionLimit: member.limits.functionLimit,\n          realmLimit: member.limits.realmLimit,\n          domainLimit: member.limits.domainLimit,\n          callLimit: member.limits.callLimit,\n          typeRoleLimit: member.limits.typeRoleLimit,\n          typeLimit: member.limits.typeLimit,\n          policyRoleLimit: member.limits.policyRoleLimit\n        }),\n        typeCount: uint16(member.types.length()),\n        adminType: _data.agents[member.ba.adminId].atype,\n        atype: member.ba.atype,\n        acstat: member.ba.acstat,\n        alstat: member.ba.alstat\n      });\n  }\n\n  function _doCheckAdminAccess(\n    bytes32 adminId,\n    bytes32 memberId,\n    bytes32 functionId\n  ) internal view returns (IACL.AdminAccessStatus) {\n    return LACLAgentScope.checkAdminAccess(_data, adminId, memberId, functionId);\n  }\n\n  function _accessPermission(MemberSignature calldata memberSign, bytes4 selector)\n    internal\n    returns (\n      bytes32,\n      bytes32,\n      address\n    )\n  {\n    require(IProxy(address(this)).safeModeStatus() == IBaseProxy.ProxySafeModeStatus.DISABLED, \"Rejected\");\n    address signer;\n\n    if (memberSign.signature.length > 0) {\n      require(memberSign.expiredAt > block.timestamp, \"Expired Signature\");\n      signer = LACLUtils.getMemeberSignerAddress(memberSign, MEMBER_SIGNATURE_MESSAGE_TYPEHASH);\n    } else {\n      signer = msg.sender;\n    }\n\n    address functionFacetId = _data.selectors[selector];\n    bytes32 functionId = LACLUtils.functionGenerateId(functionFacetId, selector);\n    bytes32 senderId = LACLUtils.accountGenerateId(signer);\n    IACL.AuthorizationStatus status = IACL(address(this)).hasMemberAccess(functionId, senderId);\n    if (status != IACL.AuthorizationStatus.PERMITTED) LACLUtils.generateAuthorizationError(status);\n    return (functionId, senderId, signer);\n  }\n\n  function _doGetEntityAndCheckAdminAccess(\n    bytes32 memberId,\n    bytes32 senderId,\n    bytes32 functionId\n  ) internal view returns (MemberEntity storage) {\n    MemberEntity storage memberEntity = _data.memberReadSlot(memberId);\n    require(memberEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Updatable\");\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(memberEntity.ba.adminId, senderId, functionId);\n    if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\n    return memberEntity;\n  }\n\n  function _doMemberRegister(\n    MemberRegisterRequest calldata request,\n    MemberEntity storage memberEntity,\n    bytes32 functionId,\n    bytes32 senderId,\n    address sender\n  ) internal {\n    bytes32 newMemberId = LACLUtils.accountGenerateId(request.account);\n    require(_data.agents[newMemberId].acstat == ActivityStatus.NONE, \"Already Exist\");\n    require(request.limits.typeLimit >= 1, \"Illegal TypeLimit\");\n    require(\n      request.acstat > ActivityStatus.DELETED && request.alstat > AlterabilityStatus.NONE,\n      \"Illegal Activity/Alterability\"\n    );\n\n    if (\n      !memberEntity.types.contains(_LIVELY_VERSE_LIVELY_MASTER_TYPE_ID) &&\n      !memberEntity.types.contains(_LIVELY_VERSE_MEMBER_MASTER_TYPE_ID)\n    ) {\n      _doCheckMemberRegisterLimits(memberEntity, request.limits);\n    }\n\n    // check role\n    RoleEntity storage roleEntity = _data.roleReadSlot(request.roleId);\n    require(roleEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Role Updatable\");\n    require(roleEntity.memberLimit > roleEntity.memberCount, \"Illegal Register\");\n\n    // check type\n    TypeEntity storage typeEntity = _data.typeReadSlot(roleEntity.typeId);\n    require(typeEntity.ba.alstat >= AlterabilityStatus.UPDATABLE, \"Illegal Type Updatable\");\n\n    // check access\n    IACL.AdminAccessStatus adminAccessStatus = _doCheckAdminAccess(roleEntity.ba.adminId, senderId, functionId);\n    if (adminAccessStatus != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(adminAccessStatus);\n\n    // add new member to type\n    typeEntity.members[newMemberId] = request.roleId;\n\n    // add new member to role\n    roleEntity.memberCount += 1;\n\n    // create new member\n    MemberEntity storage newMember = _data.memberWriteSlot(newMemberId);\n\n    // check adminId\n    if (request.adminId != bytes32(0)) {\n      require(_data.agents[request.adminId].atype > AgentType.MEMBER, \"Illegal Admin AgentType\");\n      adminAccessStatus = _doCheckAdminAccess(_LIVELY_VERSE_MEMBER_MASTER_TYPE_ID, senderId, functionId);\n      if (adminAccessStatus != IACL.AdminAccessStatus.PERMITTED) revert IACL.SetAdminForbidden(adminAccessStatus);\n      newMember.ba.adminId = request.adminId;\n    } else {\n      newMember.ba.adminId = _LIVELY_VERSE_MEMBER_MASTER_TYPE_ID;\n    }\n\n    newMember.ba.atype = AgentType.MEMBER;\n    newMember.ba.acstat = request.acstat;\n    newMember.ba.alstat = request.alstat;\n    newMember.account = request.account;\n    newMember.types.add(roleEntity.typeId);\n    newMember.limits = request.limits;\n\n    emit MemberRegistered(sender, newMemberId, request.account, request.roleId, newMember.ba.adminId, request.limits);\n  }\n\n  function _doCheckMemberRegisterLimits(MemberEntity storage memberEntity, GeneralLimit calldata limits) internal view {\n    LACLAgentScope.checkMemberRegisterLimits(memberEntity, limits);\n  }\n\n  function _doRoleHasMember(bytes32 roleId, bytes32 memberId) internal view returns (bool) {\n    (RoleEntity storage roleEntity, bool result) = _data.roleTryReadSlot(roleId);\n    if (!result) return false;\n\n    (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(roleEntity.typeId);\n    if (!result1) return false;\n\n    return typeEntity.members[memberId] == roleId;\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LACLAgentScope);\n  }\n}\n"
    },
    "src/contracts/acl/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"./policy/IPolicyManagement.sol\";\nimport \"./IACL.sol\";\nimport \"./IACLGenerals.sol\";\nimport \"./ACLStorage.sol\";\nimport \"./scope/IFunctionManagement.sol\";\nimport \"./agent/IRoleManagement.sol\";\nimport \"./agent/ITypeManagement.sol\";\nimport \"../proxy/IProxy.sol\";\nimport \"../lib/acl/LACLUtils.sol\";\nimport \"../lib/acl/LACLStorage.sol\";\nimport \"../lib/struct/LEnumerableSet.sol\";\nimport \"../proxy/BaseUUPSProxy.sol\";\n\n// import \"hardhat/console.sol\";\n\n/**\n * @title AccessControl Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract AccessControl is ACLStorage, BaseUUPSProxy, IACLGenerals, IACL {\n  using LACLStorage for DataCollection;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  constructor() {}\n\n  function initialize(\n    string calldata contractName,\n    string calldata contractVersion,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    __BASE_UUPS_init(contractName, contractVersion, accessControlManager);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      contractName,\n      contractVersion,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return\n      interfaceId == type(IACL).interfaceId ||\n      interfaceId == type(IACLGenerals).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function hasAccess(bytes32 functionId) external returns (AuthorizationStatus) {\n    (FunctionEntity storage functionEntity, bool result) = _data.functionTryReadSlot(functionId);\n    if (!result) return AuthorizationStatus.FUNCTION_NOT_FOUND;\n    return _doHasAccess(functionEntity.agentId, LACLUtils.accountGenerateId(msg.sender), functionEntity);\n  }\n\n  function hasMemberAccess(bytes32 functionId, bytes32 memberId) external returns (AuthorizationStatus) {\n    (FunctionEntity storage functionEntity, bool result) = _data.functionTryReadSlot(functionId);\n    if (!result) return AuthorizationStatus.FUNCTION_NOT_FOUND;\n    return _doHasAccess(functionEntity.agentId, memberId, functionEntity);\n  }\n\n  function hasCSAccess(address contractId, bytes4 selector) external returns (AuthorizationStatus) {\n    bytes32 functionId = LACLUtils.functionGenerateId(contractId, selector);\n    (FunctionEntity storage functionEntity, bool result) = _data.functionTryReadSlot(functionId);\n    if (!result) return AuthorizationStatus.FUNCTION_NOT_FOUND;\n    return _doHasAccess(functionEntity.agentId, LACLUtils.accountGenerateId(msg.sender), functionEntity);\n  }\n\n  function hasAccountAccess(\n    address contractId,\n    bytes4 selector,\n    address accountId\n  ) external returns (AuthorizationStatus) {\n    bytes32 functionId = LACLUtils.functionGenerateId(contractId, selector);\n    bytes32 memberId = LACLUtils.accountGenerateId(accountId);\n    (FunctionEntity storage functionEntity, bool result) = _data.functionTryReadSlot(functionId);\n    if (!result) return AuthorizationStatus.FUNCTION_NOT_FOUND;\n    return _doHasAccess(functionEntity.agentId, memberId, functionEntity);\n  }\n\n  function _doHasAccess(\n    bytes32 agentId,\n    bytes32 memberId,\n    FunctionEntity storage functionEntity\n  ) internal returns (AuthorizationStatus) {\n    AgentType atype = _data.agents[agentId].atype;\n\n    if (atype == AgentType.ROLE) {\n      // check member activation\n      (MemberEntity storage memberEntity, bool result0) = _data.memberTryReadSlot(memberId);\n      if (!result0) return AuthorizationStatus.MEMBER_NOT_FOUND;\n      if (memberEntity.ba.acstat != ActivityStatus.ENABLED) return AuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN;\n      if (!memberEntity.types.contains(_LIVELY_VERSE_LIVELY_MASTER_TYPE_ID)) {\n        if (memberEntity.limits.callLimit > 0) {\n          unchecked {\n            memberEntity.limits.callLimit -= 1;\n          }\n        } else {\n          return AuthorizationStatus.CALL_FORBIDDEN;\n        }\n      }\n\n      // check role activation\n      (RoleEntity storage roleEntity, bool result1) = _data.roleTryReadSlot(agentId);\n      if (!result1) return AuthorizationStatus.ROLE_NOT_FOUND;\n      if (roleEntity.ba.acstat != ActivityStatus.ENABLED) return AuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN;\n      if (_data.scopes[roleEntity.scopeId].stype == ScopeType.FUNCTION && roleEntity.scopeId != agentId)\n        return AuthorizationStatus.ROLE_SCOPE_FORBIDDEN;\n\n      // check type activation\n      (TypeEntity storage typeEntity, bool result2) = _data.typeTryReadSlot(roleEntity.typeId);\n      if (!result2) return AuthorizationStatus.TYPE_NOT_FOUND;\n      if (typeEntity.ba.acstat != ActivityStatus.ENABLED) return AuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN;\n\n      // check memberId with agentId role\n      if (typeEntity.members[memberId] != agentId) return AuthorizationStatus.UNAUTHORIZED;\n\n      // check policy activation\n      PolicyEntity storage policyEntity = _data.policies[_data.rolePolicyMap[agentId]];\n      if (policyEntity.acstat == ActivityStatus.ENABLED && policyEntity.policyCode >= functionEntity.policyCode)\n        return AuthorizationStatus.POLICY_FORBIDDEN;\n    } else if (atype == AgentType.TYPE) {\n      if (agentId == _LIVELY_VERSE_ANY_TYPE_ID) {\n        (MemberEntity storage memberEntity, bool result0) = _data.memberTryReadSlot(memberId);\n\n        if (!result0) return AuthorizationStatus.MEMBER_NOT_FOUND;\n        if (memberEntity.ba.acstat != ActivityStatus.ENABLED) return AuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN;\n        if (!memberEntity.types.contains(_LIVELY_VERSE_LIVELY_MASTER_TYPE_ID)) {\n          if (memberEntity.limits.callLimit > 0) {\n            unchecked {\n              memberEntity.limits.callLimit -= 1;\n            }\n          } else {\n            return AuthorizationStatus.CALL_FORBIDDEN;\n          }\n        }\n      } else if (agentId != _LIVELY_VERSE_ANONYMOUS_TYPE_ID) {\n        // check member activation\n        (MemberEntity storage memberEntity, bool result0) = _data.memberTryReadSlot(memberId);\n        if (!result0) return AuthorizationStatus.MEMBER_NOT_FOUND;\n        if (memberEntity.ba.acstat != ActivityStatus.ENABLED) return AuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN;\n        if (!memberEntity.types.contains(_LIVELY_VERSE_LIVELY_MASTER_TYPE_ID)) {\n          if (memberEntity.limits.callLimit > 0) {\n            unchecked {\n              memberEntity.limits.callLimit -= 1;\n            }\n          } else {\n            return AuthorizationStatus.CALL_FORBIDDEN;\n          }\n        }\n\n        // check type activation\n        (TypeEntity storage typeEntity, bool result1) = _data.typeTryReadSlot(agentId);\n        if (!result1) return AuthorizationStatus.TYPE_NOT_FOUND;\n        if (typeEntity.ba.acstat != ActivityStatus.ENABLED) return AuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN;\n\n        // check role activation\n        bytes32 roleId = typeEntity.members[memberId];\n        (RoleEntity storage roleEntity, bool result2) = _data.roleTryReadSlot(roleId);\n        if (!result2) return AuthorizationStatus.ROLE_NOT_FOUND;\n        if (roleEntity.ba.acstat != ActivityStatus.ENABLED) return AuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN;\n        if (_data.scopes[roleEntity.scopeId].stype == ScopeType.FUNCTION && roleEntity.scopeId != agentId)\n          return AuthorizationStatus.ROLE_SCOPE_FORBIDDEN;\n\n        // check policy activation\n        PolicyEntity storage policyEntity = _data.policies[_data.rolePolicyMap[roleId]];\n\n        if (policyEntity.acstat == ActivityStatus.ENABLED && policyEntity.policyCode >= functionEntity.policyCode)\n          return AuthorizationStatus.POLICY_FORBIDDEN;\n      }\n    } else if (atype <= AgentType.MEMBER) {\n      return AuthorizationStatus.UNAUTHORIZED;\n    }\n\n    // check function activity\n    if (functionEntity.bs.acstat != ActivityStatus.ENABLED) return AuthorizationStatus.FUNCTION_ACTIVITY_FORBIDDEN;\n\n    // check context activity\n    (ContextEntity storage contextEntity, bool res1) = _data.contextTryReadSlot(functionEntity.contextId);\n    if (!res1) return AuthorizationStatus.CONTEXT_NOT_FOUND;\n    if (contextEntity.bs.acstat != ActivityStatus.ENABLED) return AuthorizationStatus.CONTEXT_ACTIVITY_FORBIDDEN;\n\n    // check realm activity\n    (RealmEntity storage realmEntity, bool res2) = _data.realmTryReadSlot(contextEntity.realmId);\n    if (!res2) return AuthorizationStatus.REALM_NOT_FOUND;\n    if (realmEntity.bs.acstat != ActivityStatus.ENABLED) return AuthorizationStatus.REALM_ACTIVITY_FORBIDDEN;\n\n    // check domain activity\n    (DomainEntity storage domainEntity, bool res3) = _data.domainTryReadSlot(realmEntity.domainId);\n    if (!res3) return AuthorizationStatus.DOMAIN_NOT_FOUND;\n    if (domainEntity.bs.acstat != ActivityStatus.ENABLED) return AuthorizationStatus.DOMAIN_ACTIVITY_FORBIDDEN;\n\n    // check universe activity\n    UniverseEntity storage universeEntity = _data.universeReadSlot(_LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID);\n    if (universeEntity.bs.acstat != ActivityStatus.ENABLED) return AuthorizationStatus.UNIVERSE_ACTIVITY_FORBIDDEN;\n\n    return AuthorizationStatus.PERMITTED;\n  }\n\n  // Anonymouse type\n  function getAnonymousType() external pure returns (bytes32) {\n    return _LIVELY_VERSE_ANONYMOUS_TYPE_ID;\n  }\n\n  // Any type\n  function getAnyType() external pure returns (bytes32) {\n    return _LIVELY_VERSE_ANY_TYPE_ID;\n  }\n\n  // scope master type\n  function getScopeMasterType() external pure returns (bytes32) {\n    return _LIVELY_VERSE_SCOPE_MASTER_TYPE_ID;\n  }\n\n  // type master type\n  function getTypeMasterType() external pure returns (bytes32) {\n    return _LIVELY_VERSE_TYPE_MASTER_TYPE_ID;\n  }\n\n  // type master type\n  function getMemberMasterType() external pure returns (bytes32) {\n    return _LIVELY_VERSE_MEMBER_MASTER_TYPE_ID;\n  }\n\n  // system admin type\n  function getSystemMasterType() external pure returns (bytes32) {\n    return _LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID;\n  }\n\n  // admin type\n  function getLivelyMasterType() external pure returns (bytes32) {\n    return _LIVELY_VERSE_LIVELY_MASTER_TYPE_ID;\n  }\n\n  // Policy Master\n  function getPolicyMasterType() external pure returns (bytes32) {\n    return _LIVELY_VERSE_POLICY_MASTER_TYPE_ID;\n  }\n\n  // Profile Master\n  function getProfileMasterType() external pure returns (bytes32) {\n    return _LIVELY_VERSE_PROFILE_MASTER_TYPE_ID;\n  }\n\n  function getUniverseScope() external pure returns (bytes32) {\n    return _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID;\n  }\n\n  // general\n  function isAgentExist(bytes32 agentId) external view returns (bool) {\n    return _data.agents[agentId].atype != AgentType.NONE;\n  }\n\n  function isScopeExist(bytes32 scopeId) external view returns (bool) {\n    return _data.scopes[scopeId].stype != ScopeType.NONE;\n  }\n\n  function getScopeBaseInfo(bytes32 scopeId) external view returns (BaseScope memory) {\n    return _data.scopes[scopeId];\n  }\n\n  function getAgentBaseInfo(bytes32 agentId) external view returns (BaseAgent memory) {\n    return _data.agents[agentId];\n  }\n\n  function isScopesCompatible(bytes32 destScopeId, bytes32 srcScopeId) external view returns (bool) {\n    ScopeType destScopeType = _data.scopes[destScopeId].stype;\n    ScopeType srcScopeType = _data.scopes[srcScopeId].stype;\n    if (destScopeType == ScopeType.NONE || srcScopeType == ScopeType.NONE) return false;\n    if (destScopeType == ScopeType.UNIVERSE) return true;\n\n    if (destScopeType == ScopeType.CONTEXT && srcScopeType == ScopeType.FUNCTION) {\n      ContextEntity storage ce = _data.contextReadSlot(destScopeId);\n      return ce.functions.contains(srcScopeId);\n    } else if (destScopeType == ScopeType.REALM && srcScopeType == ScopeType.FUNCTION) {\n      FunctionEntity storage fe = _data.functionReadSlot(srcScopeId);\n      RealmEntity storage re = _data.realmReadSlot(destScopeId);\n      return re.contexts.contains(fe.contextId);\n    } else if (destScopeType == ScopeType.DOMAIN && srcScopeType == ScopeType.FUNCTION) {\n      FunctionEntity storage fe = _data.functionReadSlot(srcScopeId);\n      ContextEntity storage ce = _data.contextReadSlot(fe.contextId);\n      DomainEntity storage de = _data.domainReadSlot(destScopeId);\n      return de.realms.contains(ce.realmId);\n    } else if (destScopeType == ScopeType.REALM && srcScopeType == ScopeType.CONTEXT) {\n      RealmEntity storage re = _data.realmReadSlot(destScopeId);\n      return re.contexts.contains(srcScopeId);\n    } else if (destScopeType == ScopeType.DOMAIN && srcScopeType == ScopeType.CONTEXT) {\n      ContextEntity storage ce = _data.contextReadSlot(srcScopeId);\n      DomainEntity storage de = _data.domainReadSlot(destScopeId);\n      return de.realms.contains(ce.realmId);\n    } else if (destScopeType == ScopeType.DOMAIN && srcScopeType == ScopeType.REALM) {\n      DomainEntity storage de = _data.domainReadSlot(destScopeId);\n      return de.realms.contains(srcScopeId);\n    }\n\n    return false;\n  }\n}\n"
    },
    "src/contracts/lib/token/LSafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Authors: OpenZeppelin, Sina Tadayon, https://github.com/SinaTadayon\n\npragma solidity 0.8.19;\n\nimport \"../../token/lively/IERC20.sol\";\nimport \"../../token/lively/IERC20Extra.sol\";\nimport \"../../token/lively/IERC20Lock.sol\";\nimport \"../LAddress.sol\";\n\n/**\n * @title LSafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary LSafeERC20 {\n  using LAddress for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(address(token), abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function batchTransfer(IERC20Extra token, IERC20Extra.BatchTransferRequest[] calldata request) internal {\n    _callOptionalReturn(address(token), abi.encodeWithSelector(token.batchTransfer.selector, request));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(address(token), abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  function batchTransferFrom(IERC20Extra token, IERC20Extra.BatchTransferFromRequest[] calldata request) internal {\n    _callOptionalReturn(address(token), abi.encodeWithSelector(token.batchTransferFrom.selector, request));\n  }\n\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(address(token), abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(\n    IERC20Extra token,\n    address spender,\n    uint256 value\n  ) internal returns (uint256) {\n    bytes memory returndata = _callMandatoryReturn(\n      address(token),\n      abi.encodeWithSelector(token.increaseAllowance.selector, spender, value)\n    );\n    return abi.decode(returndata, (uint256));\n  }\n\n  function safeDecreaseAllowance(\n    IERC20Extra token,\n    address spender,\n    uint256 value\n  ) internal returns (uint256) {\n    bytes memory returndata = _callMandatoryReturn(\n      address(token),\n      abi.encodeWithSelector(token.decreaseAllowance.selector, spender, value)\n    );\n    return abi.decode(returndata, (uint256));\n  }\n\n  function safePermit(\n    IERC20Extra token,\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    bytes calldata signature\n  ) internal {\n    uint256 nonceBefore = token.nonce(owner);\n    token.permit(owner, spender, value, deadline, signature);\n    uint256 nonceAfter = token.nonce(owner);\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20Extra: Permit Failed\");\n  }\n\n  function lockToken(IERC20Lock token, IERC20Lock.LockTokenRequest[] calldata lockRequest)\n    internal\n    returns (bytes32[] memory)\n  {\n    bytes memory returndata = _callMandatoryReturn(\n      address(token),\n      abi.encodeWithSelector(token.lockToken.selector, lockRequest)\n    );\n    return abi.decode(returndata, (bytes32[]));\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(address token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: Call Failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: Operation Failed\");\n    }\n  }\n\n  function _callMandatoryReturn(address token, bytes memory data) private returns (bytes memory) {\n    return address(token).functionCall(data, \"SafeERC20: Call Failed\");\n  }\n}\n"
    },
    "src/contracts/acl/ACLManagerProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v3.0.0)\n\npragma solidity 0.8.19;\n\nimport \"../proxy/IBaseProxy.sol\";\nimport \"../proxy/BaseProxy.sol\";\nimport \"../proxy/IERC1822.sol\";\nimport \"../proxy/IProxy.sol\";\nimport \"../lib/LAddress.sol\";\nimport \"../lib/LStorageSlot.sol\";\nimport \"../utils/IERC165.sol\";\nimport \"./ACLStorage.sol\";\n\n/**\n * @title Proxy Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract ACLManagerProxy is ACLStorage, BaseProxy {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address logic, bytes memory data) payable {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = msg.sender;\n    _sstat = ProxySafeModeStatus.ENABLED;\n    _ustat = ProxyUpdatabilityStatus.DISABLED;\n    _upgradeToAndCallUUPS(logic, data, false);\n  }\n\n  function _fallback() internal override {\n    address facetId = _data.selectors[msg.sig];\n    if (facetId == address(0) || facetId == address(this)) {\n      _delegate(_implementation());\n    } else {\n      _delegate(facetId);\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view override returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) private {\n    _setImplementation(newImplementation);\n    emit ProxyUpgraded(msg.sender, address(this), _implementation());\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) private returns (bytes memory) {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      return LAddress.functionDelegateCall(newImplementation, data);\n    }\n    return new bytes(0);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) private returns (bytes memory) {\n    require(LAddress.isContract(newImplementation), \"Illegal Contract\");\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n      return new bytes(0);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"Invalid UUPS\");\n      } catch {\n        revert(\"Illegal UUPS\");\n      }\n\n      try IERC165(newImplementation).supportsInterface(type(IProxy).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid IProxy\");\n      } catch {\n        revert(\"Illegal IProxy\");\n      }\n      return _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n}\n"
    },
    "src/contracts/test/acl/AccessControlStorageTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n\npragma solidity 0.8.19;\n\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../lib/struct/LEnumerableMap.sol\";\nimport \"../../proxy/BaseUUPSStorage.sol\";\n\n/**\n * @title Access Control Storage Test\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\nabstract contract AccessControlStorageTest is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableMap for LEnumerableMap.Bytes32ToBytes32Map;\n  using LEnumerableMap for LEnumerableMap.AddressToUintMap;\n\n  enum Status {\n    NONE,\n    ENABLED,\n    DISABLED\n  }\n\n  struct RoleStat {\n    bytes32 role;\n    Status status;\n  }\n\n  struct Context {\n    bytes32 realm;\n    address contractId;\n    bool isEnabled;\n    mapping(bytes4 => RoleStat) resources; // function selector => RoleStat\n    LEnumerableSet.Bytes32Set funcSet;\n  }\n\n  struct Role {\n    bytes32 group;\n    string name;\n    bool isEnabled;\n    LEnumerableSet.AddressSet accountSet;\n  }\n\n  struct Realm {\n    string name;\n    bool isEnabled;\n    bool isUpgradable;\n    LEnumerableSet.Bytes32Set ctxSet;\n  }\n\n  struct Group {\n    string name;\n    bool isEnabled;\n    LEnumerableSet.Bytes32Set roleSet;\n  }\n\n  struct DataCollections {\n    mapping(address => mapping(bytes32 => Status)) accountMap;\n    mapping(bytes32 => Context) ctxMap;\n    mapping(bytes32 => Role) roleMap;\n    mapping(bytes32 => Realm) realmMap;\n    mapping(bytes32 => Group) groupMap;\n    uint256 dummy_1;\n  }\n\n  DataCollections internal _data;\n  bytes32 internal dummy_2;\n}\n"
    },
    "src/contracts/lib/struct/LEnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"./LEnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`)\n * - `address -> uint256` (`AddressToUintMap`)\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`)\n * - `uint256 -> uint256` (`UintToUintMap`)\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`)\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an array of EnumerableMap.\n * ====\n */\nlibrary LEnumerableMap {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Map type with\n  // bytes32 keys and values.\n  // The Map implementation uses private functions, and user-facing\n  // implementations (such as Uint256ToAddressMap) are just wrappers around\n  // the underlying Map.\n  // This means that we can only create new EnumerableMaps for types that fit\n  // in bytes32.\n\n  struct Bytes32ToBytes32Map {\n    // Storage of keys\n    LEnumerableSet.Bytes32Set _keys;\n    mapping(bytes32 => bytes32) _values;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n   * key. O(1).\n   *\n   * Returns true if the key was added to the map, that is if it was not\n   * already present.\n   */\n  function set(\n    Bytes32ToBytes32Map storage map,\n    bytes32 key,\n    bytes32 value\n  ) internal returns (bool) {\n    map._values[key] = value;\n    return map._keys.add(key);\n  }\n\n  function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n    return map._keys.values();\n  }\n\n  /**\n   * @dev Removes a key-value pair from a map. O(1).\n   *\n   * Returns true if the key was removed from the map, that is if it was present.\n   */\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n    delete map._values[key];\n    return map._keys.remove(key);\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n   */\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n    return map._keys.contains(key);\n  }\n\n  /**\n   * @dev Returns the number of key-value pairs in the map. O(1).\n   */\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n    return map._keys.length();\n  }\n\n  /**\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n   *\n   * Note that there are no guarantees on the ordering of entries inside the\n   * array, and it may change when more entries are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n    bytes32 key = map._keys.at(index);\n    return (key, map._values[key]);\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`.  O(1).\n   * Does not revert if `key` is not in the map.\n   */\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n    bytes32 value = map._values[key];\n    if (value == bytes32(0)) {\n      return (contains(map, key), bytes32(0));\n    } else {\n      return (true, value);\n    }\n  }\n\n  /**\n   * @dev Returns the value associated with `key`.  O(1).\n   *\n   * Requirements:\n   *\n   * - `key` must be in the map.\n   */\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n    return value;\n  }\n\n  /**\n   * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {_tryGet}.\n   */\n  function get(\n    Bytes32ToBytes32Map storage map,\n    bytes32 key,\n    string memory errorMessage\n  ) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    require(value != 0 || contains(map, key), errorMessage);\n    return value;\n  }\n\n  // UintToUintMap\n\n  struct UintToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n   * key. O(1).\n   *\n   * Returns true if the key was added to the map, that is if it was not\n   * already present.\n   */\n  function set(\n    UintToUintMap storage map,\n    uint256 key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(key), bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the key was removed from the map, that is if it was present.\n   */\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n    return remove(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n   */\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n    return contains(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n   */\n  function length(UintToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (uint256(key), uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`.  O(1).\n   * Does not revert if `key` is not in the map.\n   */\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`.  O(1).\n   *\n   * Requirements:\n   *\n   * - `key` must be in the map.\n   */\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(key)));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {tryGet}.\n   */\n  function get(\n    UintToUintMap storage map,\n    uint256 key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(key), errorMessage));\n  }\n\n  // UintToAddressMap\n\n  struct UintToAddressMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n   * key. O(1).\n   *\n   * Returns true if the key was added to the map, that is if it was not\n   * already present.\n   */\n  function set(\n    UintToAddressMap storage map,\n    uint256 key,\n    address value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the key was removed from the map, that is if it was present.\n   */\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n    return remove(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n   */\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n    return contains(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n   */\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (uint256(key), address(uint160(uint256(value))));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`.  O(1).\n   * Does not revert if `key` is not in the map.\n   */\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n    return (success, address(uint160(uint256(value))));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`.  O(1).\n   *\n   * Requirements:\n   *\n   * - `key` must be in the map.\n   */\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {tryGet}.\n   */\n  function get(\n    UintToAddressMap storage map,\n    uint256 key,\n    string memory errorMessage\n  ) internal view returns (address) {\n    return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n  }\n\n  // AddressToUintMap\n\n  struct AddressToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n   * key. O(1).\n   *\n   * Returns true if the key was added to the map, that is if it was not\n   * already present.\n   */\n  function set(\n    AddressToUintMap storage map,\n    address key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the key was removed from the map, that is if it was present.\n   */\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n    return remove(map._inner, bytes32(uint256(uint160(key))));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n   */\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n    return contains(map._inner, bytes32(uint256(uint160(key))));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n   */\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (address(uint160(uint256(key))), uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`.  O(1).\n   * Does not revert if `key` is not in the map.\n   */\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`.  O(1).\n   *\n   * Requirements:\n   *\n   * - `key` must be in the map.\n   */\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {tryGet}.\n   */\n  function get(\n    AddressToUintMap storage map,\n    address key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n  }\n\n  // Bytes32ToUintMap\n\n  struct Bytes32ToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n   * key. O(1).\n   *\n   * Returns true if the key was added to the map, that is if it was not\n   * already present.\n   */\n  function set(\n    Bytes32ToUintMap storage map,\n    bytes32 key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, key, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the key was removed from the map, that is if it was present.\n   */\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n    return remove(map._inner, key);\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n   */\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n    return contains(map._inner, key);\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n   */\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (key, uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`.  O(1).\n   * Does not revert if `key` is not in the map.\n   */\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, key);\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`.  O(1).\n   *\n   * Requirements:\n   *\n   * - `key` must be in the map.\n   */\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n    return uint256(get(map._inner, key));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {tryGet}.\n   */\n  function get(\n    Bytes32ToUintMap storage map,\n    bytes32 key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, key, errorMessage));\n  }\n}\n"
    },
    "src/contracts/lib/LArrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"./math/LMath.sol\";\nimport \"./math/LSafeCast.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary LArrays {\n  /**\n   * @dev Searches a sorted `array` and returns the first index that contains\n   * a value greater or equal to `element`. If no such index exists (i.e. all\n   * values in the array are strictly less than `element`), the array length is\n   * returned. Time complexity O(log n).\n   *\n   * `array` is expected to be sorted in ascending order, and to contain no\n   * repeated elements.\n   */\n  function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n    if (array.length == 0) {\n      return 0;\n    }\n\n    uint256 low = 0;\n    uint256 high = array.length;\n\n    while (low < high) {\n      uint256 mid = LMath.average(low, high);\n\n      // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n      // because Math.average rounds down (it does integer division with truncation).\n      if (array[mid] > element) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n    if (low > 0 && array[low - 1] == element) {\n      return low - 1;\n    } else {\n      return low;\n    }\n  }\n\n  function findIndex(uint256[] storage array, uint256 element) internal view returns (int256) {\n    for (uint256 i = 0; i < array.length; i++) {\n      if (array[i] == element) {\n        return LSafeCast.toInt256(i);\n      }\n    }\n    return -1;\n  }\n\n  function deleteIndex(uint256[] storage array, uint256 index) internal {\n    require(index < array.length, \"Invalid Index\");\n    array[index] = array[array.length - 1];\n    array.pop();\n  }\n\n  function findIndex(bytes32[] storage array, bytes32 element) internal view returns (int256) {\n    for (uint256 i = 0; i < array.length; i++) {\n      if (array[i] == element) {\n        return LSafeCast.toInt256(i);\n      }\n    }\n    return -1;\n  }\n\n  function deleteIndex(bytes32[] storage array, uint256 index) internal {\n    require(index < array.length, \"Invalid Index\");\n    array[index] = array[array.length - 1];\n    array.pop();\n  }\n}\n"
    },
    "src/contracts/lib/math/LMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary LMath {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n   * zero.\n   */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n   *\n   * This differs from standard division with `/` in that it rounds up instead\n   * of rounding down.\n   */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n   * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n   * with further edits by Uniswap Labs also under MIT license.\n   */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n    unchecked {\n      // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n      // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n      // variables such that product = prod1 * 2^256 + prod0.\n      uint256 prod0; // Least significant 256 bits of the product\n      uint256 prod1; // Most significant 256 bits of the product\n      assembly {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n      }\n\n      // Handle non-overflow cases, 256 by 256 division.\n      if (prod1 == 0) {\n        return prod0 / denominator;\n      }\n\n      // Make sure the result is less than 2^256. Also prevents denominator == 0.\n      require(denominator > prod1);\n\n      ///////////////////////////////////////////////\n      // 512 by 256 division.\n      ///////////////////////////////////////////////\n\n      // Make division exact by subtracting the remainder from [prod1 prod0].\n      uint256 remainder;\n      assembly {\n        // Compute remainder using mulmod.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512 bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n      }\n\n      // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n      // See https://cs.stackexchange.com/q/138556/92363.\n\n      // Does not overflow because the denominator cannot be zero at this stage in the function.\n      uint256 twos = denominator & (~denominator + 1);\n      assembly {\n        // Divide denominator by twos.\n        denominator := div(denominator, twos)\n\n        // Divide [prod1 prod0] by twos.\n        prod0 := div(prod0, twos)\n\n        // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n        twos := add(div(sub(0, twos), twos), 1)\n      }\n\n      // Shift in bits from prod1 into prod0.\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n      // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n      // four bits. That is, denominator * inv = 1 mod 2^4.\n      uint256 inverse = (3 * denominator) ^ 2;\n\n      // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n      // in modular arithmetic, doubling the correct bits in each step.\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n      // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n      // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n      // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inverse;\n      return result;\n    }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n   */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator,\n    Rounding rounding\n  ) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n   *\n   * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n   */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`.\n    // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n    // This gives `2**k < a <= 2**(k+1)`  `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n    // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n    // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1;\n    uint256 x = a;\n    if (x >> 128 > 0) {\n      x >>= 128;\n      result <<= 64;\n    }\n    if (x >> 64 > 0) {\n      x >>= 64;\n      result <<= 32;\n    }\n    if (x >> 32 > 0) {\n      x >>= 32;\n      result <<= 16;\n    }\n    if (x >> 16 > 0) {\n      x >>= 16;\n      result <<= 8;\n    }\n    if (x >> 8 > 0) {\n      x >>= 8;\n      result <<= 4;\n    }\n    if (x >> 4 > 0) {\n      x >>= 4;\n      result <<= 2;\n    }\n    if (x >> 2 > 0) {\n      result <<= 1;\n    }\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n    unchecked {\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      return min(result, a / result);\n    }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n   */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n    uint256 result = sqrt(a);\n    if (rounding == Rounding.Up && result * result < a) {\n      result += 1;\n    }\n    return result;\n  }\n}\n"
    },
    "src/contracts/lib/math/LSafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary LSafeCast {\n  /**\n   * @dev Returns the downcasted uint248 from uint256, reverting on\n   * overflow (when the input is greater than largest uint248).\n   *\n   * Counterpart to Solidity's `uint248` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 248 bits\n   */\n  function toUint248(uint256 value) internal pure returns (uint248) {\n    require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n    return uint248(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint240 from uint256, reverting on\n   * overflow (when the input is greater than largest uint240).\n   *\n   * Counterpart to Solidity's `uint240` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 240 bits\n   */\n  function toUint240(uint256 value) internal pure returns (uint240) {\n    require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n    return uint240(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint232 from uint256, reverting on\n   * overflow (when the input is greater than largest uint232).\n   *\n   * Counterpart to Solidity's `uint232` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 232 bits\n   */\n  function toUint232(uint256 value) internal pure returns (uint232) {\n    require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n    return uint232(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint224 from uint256, reverting on\n   * overflow (when the input is greater than largest uint224).\n   *\n   * Counterpart to Solidity's `uint224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   */\n  function toUint224(uint256 value) internal pure returns (uint224) {\n    require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n    return uint224(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint216 from uint256, reverting on\n   * overflow (when the input is greater than largest uint216).\n   *\n   * Counterpart to Solidity's `uint216` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 216 bits\n   */\n  function toUint216(uint256 value) internal pure returns (uint216) {\n    require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n    return uint216(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint208 from uint256, reverting on\n   * overflow (when the input is greater than largest uint208).\n   *\n   * Counterpart to Solidity's `uint208` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 208 bits\n   */\n  function toUint208(uint256 value) internal pure returns (uint208) {\n    require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n    return uint208(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint200 from uint256, reverting on\n   * overflow (when the input is greater than largest uint200).\n   *\n   * Counterpart to Solidity's `uint200` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 200 bits\n   */\n  function toUint200(uint256 value) internal pure returns (uint200) {\n    require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n    return uint200(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint192 from uint256, reverting on\n   * overflow (when the input is greater than largest uint192).\n   *\n   * Counterpart to Solidity's `uint192` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 192 bits\n   */\n  function toUint192(uint256 value) internal pure returns (uint192) {\n    require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n    return uint192(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint184 from uint256, reverting on\n   * overflow (when the input is greater than largest uint184).\n   *\n   * Counterpart to Solidity's `uint184` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 184 bits\n   */\n  function toUint184(uint256 value) internal pure returns (uint184) {\n    require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n    return uint184(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint176 from uint256, reverting on\n   * overflow (when the input is greater than largest uint176).\n   *\n   * Counterpart to Solidity's `uint176` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 176 bits\n   */\n  function toUint176(uint256 value) internal pure returns (uint176) {\n    require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n    return uint176(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint168 from uint256, reverting on\n   * overflow (when the input is greater than largest uint168).\n   *\n   * Counterpart to Solidity's `uint168` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 168 bits\n   */\n  function toUint168(uint256 value) internal pure returns (uint168) {\n    require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n    return uint168(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint160 from uint256, reverting on\n   * overflow (when the input is greater than largest uint160).\n   *\n   * Counterpart to Solidity's `uint160` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 160 bits\n   */\n  function toUint160(uint256 value) internal pure returns (uint160) {\n    require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n    return uint160(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint152 from uint256, reverting on\n   * overflow (when the input is greater than largest uint152).\n   *\n   * Counterpart to Solidity's `uint152` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 152 bits\n   */\n  function toUint152(uint256 value) internal pure returns (uint152) {\n    require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n    return uint152(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint144 from uint256, reverting on\n   * overflow (when the input is greater than largest uint144).\n   *\n   * Counterpart to Solidity's `uint144` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 144 bits\n   */\n  function toUint144(uint256 value) internal pure returns (uint144) {\n    require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n    return uint144(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint136 from uint256, reverting on\n   * overflow (when the input is greater than largest uint136).\n   *\n   * Counterpart to Solidity's `uint136` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 136 bits\n   */\n  function toUint136(uint256 value) internal pure returns (uint136) {\n    require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n    return uint136(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint128 from uint256, reverting on\n   * overflow (when the input is greater than largest uint128).\n   *\n   * Counterpart to Solidity's `uint128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   */\n  function toUint128(uint256 value) internal pure returns (uint128) {\n    require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n    return uint128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint120 from uint256, reverting on\n   * overflow (when the input is greater than largest uint120).\n   *\n   * Counterpart to Solidity's `uint120` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 120 bits\n   */\n  function toUint120(uint256 value) internal pure returns (uint120) {\n    require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n    return uint120(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint112 from uint256, reverting on\n   * overflow (when the input is greater than largest uint112).\n   *\n   * Counterpart to Solidity's `uint112` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 112 bits\n   */\n  function toUint112(uint256 value) internal pure returns (uint112) {\n    require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n    return uint112(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint104 from uint256, reverting on\n   * overflow (when the input is greater than largest uint104).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 104 bits\n   */\n  function toUint104(uint256 value) internal pure returns (uint104) {\n    require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n    return uint104(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint96 from uint256, reverting on\n   * overflow (when the input is greater than largest uint96).\n   *\n   * Counterpart to Solidity's `uint96` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   */\n  function toUint96(uint256 value) internal pure returns (uint96) {\n    require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n    return uint96(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint88 from uint256, reverting on\n   * overflow (when the input is greater than largest uint88).\n   *\n   * Counterpart to Solidity's `uint88` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 88 bits\n   */\n  function toUint88(uint256 value) internal pure returns (uint88) {\n    require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n    return uint88(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint80 from uint256, reverting on\n   * overflow (when the input is greater than largest uint80).\n   *\n   * Counterpart to Solidity's `uint80` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 80 bits\n   */\n  function toUint80(uint256 value) internal pure returns (uint80) {\n    require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n    return uint80(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint72 from uint256, reverting on\n   * overflow (when the input is greater than largest uint72).\n   *\n   * Counterpart to Solidity's `uint72` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 72 bits\n   */\n  function toUint72(uint256 value) internal pure returns (uint72) {\n    require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n    return uint72(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint64 from uint256, reverting on\n   * overflow (when the input is greater than largest uint64).\n   *\n   * Counterpart to Solidity's `uint64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   */\n  function toUint64(uint256 value) internal pure returns (uint64) {\n    require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n    return uint64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint56 from uint256, reverting on\n   * overflow (when the input is greater than largest uint56).\n   *\n   * Counterpart to Solidity's `uint56` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 56 bits\n   */\n  function toUint56(uint256 value) internal pure returns (uint56) {\n    require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n    return uint56(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint48 from uint256, reverting on\n   * overflow (when the input is greater than largest uint48).\n   *\n   * Counterpart to Solidity's `uint48` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 48 bits\n   */\n  function toUint48(uint256 value) internal pure returns (uint48) {\n    require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n    return uint48(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint40 from uint256, reverting on\n   * overflow (when the input is greater than largest uint40).\n   *\n   * Counterpart to Solidity's `uint40` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 40 bits\n   */\n  function toUint40(uint256 value) internal pure returns (uint40) {\n    require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n    return uint40(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint32 from uint256, reverting on\n   * overflow (when the input is greater than largest uint32).\n   *\n   * Counterpart to Solidity's `uint32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   */\n  function toUint32(uint256 value) internal pure returns (uint32) {\n    require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n    return uint32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint24 from uint256, reverting on\n   * overflow (when the input is greater than largest uint24).\n   *\n   * Counterpart to Solidity's `uint24` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 24 bits\n   */\n  function toUint24(uint256 value) internal pure returns (uint24) {\n    require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n    return uint24(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint16 from uint256, reverting on\n   * overflow (when the input is greater than largest uint16).\n   *\n   * Counterpart to Solidity's `uint16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   */\n  function toUint16(uint256 value) internal pure returns (uint16) {\n    require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n    return uint16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint8 from uint256, reverting on\n   * overflow (when the input is greater than largest uint8).\n   *\n   * Counterpart to Solidity's `uint8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits\n   */\n  function toUint8(uint256 value) internal pure returns (uint8) {\n    require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n    return uint8(value);\n  }\n\n  /**\n   * @dev Converts a signed int256 into an unsigned uint256.\n   *\n   * Requirements:\n   *\n   * - input must be greater than or equal to 0.\n   */\n  function toUint256(int256 value) internal pure returns (uint256) {\n    require(value >= 0, \"SafeCast: value must be positive\");\n    return uint256(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int248 from int256, reverting on\n   * overflow (when the input is less than smallest int248 or\n   * greater than largest int248).\n   *\n   * Counterpart to Solidity's `int248` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 248 bits\n   */\n  function toInt248(int256 value) internal pure returns (int248) {\n    require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n    return int248(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int240 from int256, reverting on\n   * overflow (when the input is less than smallest int240 or\n   * greater than largest int240).\n   *\n   * Counterpart to Solidity's `int240` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 240 bits\n   */\n  function toInt240(int256 value) internal pure returns (int240) {\n    require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n    return int240(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int232 from int256, reverting on\n   * overflow (when the input is less than smallest int232 or\n   * greater than largest int232).\n   *\n   * Counterpart to Solidity's `int232` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 232 bits\n   */\n  function toInt232(int256 value) internal pure returns (int232) {\n    require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n    return int232(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int224 from int256, reverting on\n   * overflow (when the input is less than smallest int224 or\n   * greater than largest int224).\n   *\n   * Counterpart to Solidity's `int224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   */\n  function toInt224(int256 value) internal pure returns (int224) {\n    require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n    return int224(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int216 from int256, reverting on\n   * overflow (when the input is less than smallest int216 or\n   * greater than largest int216).\n   *\n   * Counterpart to Solidity's `int216` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 216 bits\n   */\n  function toInt216(int256 value) internal pure returns (int216) {\n    require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n    return int216(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int208 from int256, reverting on\n   * overflow (when the input is less than smallest int208 or\n   * greater than largest int208).\n   *\n   * Counterpart to Solidity's `int208` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 208 bits\n   */\n  function toInt208(int256 value) internal pure returns (int208) {\n    require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n    return int208(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int200 from int256, reverting on\n   * overflow (when the input is less than smallest int200 or\n   * greater than largest int200).\n   *\n   * Counterpart to Solidity's `int200` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 200 bits\n   */\n  function toInt200(int256 value) internal pure returns (int200) {\n    require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n    return int200(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int192 from int256, reverting on\n   * overflow (when the input is less than smallest int192 or\n   * greater than largest int192).\n   *\n   * Counterpart to Solidity's `int192` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 192 bits\n   */\n  function toInt192(int256 value) internal pure returns (int192) {\n    require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n    return int192(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int184 from int256, reverting on\n   * overflow (when the input is less than smallest int184 or\n   * greater than largest int184).\n   *\n   * Counterpart to Solidity's `int184` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 184 bits\n   */\n  function toInt184(int256 value) internal pure returns (int184) {\n    require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n    return int184(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int176 from int256, reverting on\n   * overflow (when the input is less than smallest int176 or\n   * greater than largest int176).\n   *\n   * Counterpart to Solidity's `int176` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 176 bits\n   */\n  function toInt176(int256 value) internal pure returns (int176) {\n    require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n    return int176(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int168 from int256, reverting on\n   * overflow (when the input is less than smallest int168 or\n   * greater than largest int168).\n   *\n   * Counterpart to Solidity's `int168` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 168 bits\n   */\n  function toInt168(int256 value) internal pure returns (int168) {\n    require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n    return int168(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int160 from int256, reverting on\n   * overflow (when the input is less than smallest int160 or\n   * greater than largest int160).\n   *\n   * Counterpart to Solidity's `int160` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 160 bits\n   */\n  function toInt160(int256 value) internal pure returns (int160) {\n    require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n    return int160(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int152 from int256, reverting on\n   * overflow (when the input is less than smallest int152 or\n   * greater than largest int152).\n   *\n   * Counterpart to Solidity's `int152` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 152 bits\n   */\n  function toInt152(int256 value) internal pure returns (int152) {\n    require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n    return int152(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int144 from int256, reverting on\n   * overflow (when the input is less than smallest int144 or\n   * greater than largest int144).\n   *\n   * Counterpart to Solidity's `int144` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 144 bits\n   */\n  function toInt144(int256 value) internal pure returns (int144) {\n    require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n    return int144(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int136 from int256, reverting on\n   * overflow (when the input is less than smallest int136 or\n   * greater than largest int136).\n   *\n   * Counterpart to Solidity's `int136` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 136 bits\n   */\n  function toInt136(int256 value) internal pure returns (int136) {\n    require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n    return int136(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int128 from int256, reverting on\n   * overflow (when the input is less than smallest int128 or\n   * greater than largest int128).\n   *\n   * Counterpart to Solidity's `int128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   */\n  function toInt128(int256 value) internal pure returns (int128) {\n    require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n    return int128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int120 from int256, reverting on\n   * overflow (when the input is less than smallest int120 or\n   * greater than largest int120).\n   *\n   * Counterpart to Solidity's `int120` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 120 bits\n   */\n  function toInt120(int256 value) internal pure returns (int120) {\n    require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n    return int120(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int112 from int256, reverting on\n   * overflow (when the input is less than smallest int112 or\n   * greater than largest int112).\n   *\n   * Counterpart to Solidity's `int112` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 112 bits\n   */\n  function toInt112(int256 value) internal pure returns (int112) {\n    require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n    return int112(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int104 from int256, reverting on\n   * overflow (when the input is less than smallest int104 or\n   * greater than largest int104).\n   *\n   * Counterpart to Solidity's `int104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 104 bits\n   */\n  function toInt104(int256 value) internal pure returns (int104) {\n    require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n    return int104(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int96 from int256, reverting on\n   * overflow (when the input is less than smallest int96 or\n   * greater than largest int96).\n   *\n   * Counterpart to Solidity's `int96` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   */\n  function toInt96(int256 value) internal pure returns (int96) {\n    require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n    return int96(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int88 from int256, reverting on\n   * overflow (when the input is less than smallest int88 or\n   * greater than largest int88).\n   *\n   * Counterpart to Solidity's `int88` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 88 bits\n   */\n  function toInt88(int256 value) internal pure returns (int88) {\n    require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n    return int88(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int80 from int256, reverting on\n   * overflow (when the input is less than smallest int80 or\n   * greater than largest int80).\n   *\n   * Counterpart to Solidity's `int80` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 80 bits\n   */\n  function toInt80(int256 value) internal pure returns (int80) {\n    require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n    return int80(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int72 from int256, reverting on\n   * overflow (when the input is less than smallest int72 or\n   * greater than largest int72).\n   *\n   * Counterpart to Solidity's `int72` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 72 bits\n   */\n  function toInt72(int256 value) internal pure returns (int72) {\n    require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n    return int72(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int64 from int256, reverting on\n   * overflow (when the input is less than smallest int64 or\n   * greater than largest int64).\n   *\n   * Counterpart to Solidity's `int64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   */\n  function toInt64(int256 value) internal pure returns (int64) {\n    require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n    return int64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int56 from int256, reverting on\n   * overflow (when the input is less than smallest int56 or\n   * greater than largest int56).\n   *\n   * Counterpart to Solidity's `int56` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 56 bits\n   */\n  function toInt56(int256 value) internal pure returns (int56) {\n    require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n    return int56(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int48 from int256, reverting on\n   * overflow (when the input is less than smallest int48 or\n   * greater than largest int48).\n   *\n   * Counterpart to Solidity's `int48` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 48 bits\n   */\n  function toInt48(int256 value) internal pure returns (int48) {\n    require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n    return int48(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int40 from int256, reverting on\n   * overflow (when the input is less than smallest int40 or\n   * greater than largest int40).\n   *\n   * Counterpart to Solidity's `int40` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 40 bits\n   */\n  function toInt40(int256 value) internal pure returns (int40) {\n    require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n    return int40(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int32 from int256, reverting on\n   * overflow (when the input is less than smallest int32 or\n   * greater than largest int32).\n   *\n   * Counterpart to Solidity's `int32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   */\n  function toInt32(int256 value) internal pure returns (int32) {\n    require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n    return int32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int24 from int256, reverting on\n   * overflow (when the input is less than smallest int24 or\n   * greater than largest int24).\n   *\n   * Counterpart to Solidity's `int24` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 24 bits\n   */\n  function toInt24(int256 value) internal pure returns (int24) {\n    require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n    return int24(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int16 from int256, reverting on\n   * overflow (when the input is less than smallest int16 or\n   * greater than largest int16).\n   *\n   * Counterpart to Solidity's `int16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   */\n  function toInt16(int256 value) internal pure returns (int16) {\n    require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n    return int16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int8 from int256, reverting on\n   * overflow (when the input is less than smallest int8 or\n   * greater than largest int8).\n   *\n   * Counterpart to Solidity's `int8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits\n   */\n  function toInt8(int256 value) internal pure returns (int8) {\n    require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n    return int8(value);\n  }\n\n  /**\n   * @dev Converts an unsigned uint256 into a signed int256.\n   *\n   * Requirements:\n   *\n   * - input must be less than or equal to maxInt256.\n   */\n  function toInt256(uint256 value) internal pure returns (int256) {\n    // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n    require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n    return int256(value);\n  }\n}\n"
    },
    "src/contracts/lib/struct/LDoubleEndedQueueUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"../math/LSafeCast.sol\";\n\n/**\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\n * the existing queue contents are left in storage.\n *\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\n * used in storage, and not in memory.\n * ```\n * DoubleEndedQueue.Bytes32Deque queue;\n * ```\n */\nlibrary DoubleEndedQueueUpgradeable {\n  /**\n   * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\n   */\n  error Empty();\n\n  /**\n   * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\n   */\n  error OutOfBounds();\n\n  /**\n   * @dev Indices are signed integers because the queue can grow in any direction. They are 128 bits so begin and end\n   * are packed in a single storage slot for efficient access. Since the items are added one at a time we can safely\n   * assume that these 128-bit indices will not overflow, and use unchecked arithmetic.\n   *\n   * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n   * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n   * lead to unexpected behavior.\n   *\n   * Indices are in the range [begin, end) which means the first item is at data[begin] and the last item is at\n   * data[end - 1].\n   */\n  struct Bytes32Deque {\n    int128 _begin;\n    int128 _end;\n    mapping(int128 => bytes32) _data;\n  }\n\n  /**\n   * @dev Inserts an item at the end of the queue.\n   */\n  function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\n    int128 backIndex = deque._end;\n    deque._data[backIndex] = value;\n    unchecked {\n      deque._end = backIndex + 1;\n    }\n  }\n\n  /**\n   * @dev Removes the item at the end of the queue and returns it.\n   *\n   * Reverts with `Empty` if the queue is empty.\n   */\n  function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\n    if (empty(deque)) revert Empty();\n    int128 backIndex;\n    unchecked {\n      backIndex = deque._end - 1;\n    }\n    value = deque._data[backIndex];\n    delete deque._data[backIndex];\n    deque._end = backIndex;\n  }\n\n  /**\n   * @dev Inserts an item at the beginning of the queue.\n   */\n  function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\n    int128 frontIndex;\n    unchecked {\n      frontIndex = deque._begin - 1;\n    }\n    deque._data[frontIndex] = value;\n    deque._begin = frontIndex;\n  }\n\n  /**\n   * @dev Removes the item at the beginning of the queue and returns it.\n   *\n   * Reverts with `Empty` if the queue is empty.\n   */\n  function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\n    if (empty(deque)) revert Empty();\n    int128 frontIndex = deque._begin;\n    value = deque._data[frontIndex];\n    delete deque._data[frontIndex];\n    unchecked {\n      deque._begin = frontIndex + 1;\n    }\n  }\n\n  /**\n   * @dev Returns the item at the beginning of the queue.\n   *\n   * Reverts with `Empty` if the queue is empty.\n   */\n  function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n    if (empty(deque)) revert Empty();\n    int128 frontIndex = deque._begin;\n    return deque._data[frontIndex];\n  }\n\n  /**\n   * @dev Returns the item at the end of the queue.\n   *\n   * Reverts with `Empty` if the queue is empty.\n   */\n  function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n    if (empty(deque)) revert Empty();\n    int128 backIndex;\n    unchecked {\n      backIndex = deque._end - 1;\n    }\n    return deque._data[backIndex];\n  }\n\n  /**\n   * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\n   * `length(deque) - 1`.\n   *\n   * Reverts with `OutOfBounds` if the index is out of bounds.\n   */\n  function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\n    // int256(deque._begin) is a safe upcast\n    int128 idx = LSafeCast.toInt128(int256(deque._begin) + LSafeCast.toInt256(index));\n    if (idx >= deque._end) revert OutOfBounds();\n    return deque._data[idx];\n  }\n\n  /**\n   * @dev Resets the queue back to being empty.\n   *\n   * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\n   * out on potential gas refunds.\n   */\n  function clear(Bytes32Deque storage deque) internal {\n    deque._begin = 0;\n    deque._end = 0;\n  }\n\n  /**\n   * @dev Returns the number of items in the queue.\n   */\n  function length(Bytes32Deque storage deque) internal view returns (uint256) {\n    // The interface preserves the invariant that begin <= end so we assume this will not overflow.\n    // We also assume there are at most int256.max items in the queue.\n    unchecked {\n      return uint256(int256(deque._end) - int256(deque._begin));\n    }\n  }\n\n  /**\n   * @dev Returns true if the queue is empty.\n   */\n  function empty(Bytes32Deque storage deque) internal view returns (bool) {\n    return deque._end <= deque._begin;\n  }\n}\n"
    },
    "src/contracts/lib/LCheckpoints.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\nimport \"./math/LMath.sol\";\nimport \"./math/LSafeCast.sol\";\n\n/**\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n */\nlibrary LCheckpoints {\n  struct Checkpoint {\n    uint32 _blockNumber;\n    uint224 _value;\n  }\n\n  struct History {\n    Checkpoint[] _checkpoints;\n  }\n\n  /**\n   * @dev Returns the value in the latest checkpoint, or zero if there are no checkpoints.\n   */\n  function latest(History storage self) internal view returns (uint256) {\n    uint256 pos = self._checkpoints.length;\n    return pos == 0 ? 0 : self._checkpoints[pos - 1]._value;\n  }\n\n  /**\n   * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n   * before it is returned, or zero otherwise.\n   */\n  function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n    require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n\n    uint256 high = self._checkpoints.length;\n    uint256 low = 0;\n    while (low < high) {\n      uint256 mid = LMath.average(low, high);\n      if (self._checkpoints[mid]._blockNumber > blockNumber) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    return high == 0 ? 0 : self._checkpoints[high - 1]._value;\n  }\n\n  /**\n   * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\n   *\n   * Returns previous value and new value.\n   */\n  function push(History storage self, uint256 value) internal returns (uint256, uint256) {\n    uint256 pos = self._checkpoints.length;\n    uint256 old = latest(self);\n    if (pos > 0 && self._checkpoints[pos - 1]._blockNumber == block.number) {\n      self._checkpoints[pos - 1]._value = LSafeCast.toUint224(value);\n    } else {\n      self._checkpoints.push(\n        Checkpoint({_blockNumber: LSafeCast.toUint32(block.number), _value: LSafeCast.toUint224(value)})\n      );\n    }\n    return (old, value);\n  }\n\n  /**\n   * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\n   * be set to `op(latest, delta)`.\n   *\n   * Returns previous value and new value.\n   */\n  function push(\n    History storage self,\n    function(uint256, uint256) view returns (uint256) op,\n    uint256 delta\n  ) internal returns (uint256, uint256) {\n    return push(self, op(latest(self), delta));\n  }\n}\n"
    },
    "src/contracts/lib/LBase64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n */\nlibrary LBase64 {\n  /**\n   * @dev Base64 Encoding/Decoding Table\n   */\n  string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  /**\n   * @dev Converts a `bytes` to its Bytes64 `string` representation.\n   */\n  function encode(bytes memory data) internal pure returns (string memory) {\n    /**\n     * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n     * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n     */\n    if (data.length == 0) return \"\";\n\n    // Loads the table into memory\n    string memory table = _TABLE;\n\n    // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n    // and split into 4 numbers of 6 bits.\n    // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n    // - `data.length + 2`  -> Round up\n    // - `/ 3`              -> Number of 3-bytes chunks\n    // - `4 *`              -> 4 characters for each chunk\n    string memory result = new string(4 * ((data.length + 2) / 3));\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Prepare the lookup table (skip the first \"length\" byte)\n      let tablePtr := add(table, 1)\n\n      // Prepare result pointer, jump over length\n      let resultPtr := add(result, 32)\n\n      // Run over the input, 3 bytes at a time\n      for {\n        let dataPtr := data\n        let endPtr := add(data, mload(data))\n      } lt(dataPtr, endPtr) {\n\n      } {\n        // Advance 3 bytes\n        dataPtr := add(dataPtr, 3)\n        let input := mload(dataPtr)\n\n        // To write each character, shift the 3 bytes (18 bits) chunk\n        // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n        // and apply logical AND with 0x3F which is the number of\n        // the previous character in the ASCII table prior to the Base64 Table\n        // The result is then added to the table to get the character to write,\n        // and finally write it in the result pointer but with a left shift\n        // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n      }\n\n      // When data `bytes` is not exactly 3 bytes long\n      // it is padded with `=` characters at the end\n      switch mod(mload(data), 3)\n      case 1 {\n        mstore8(sub(resultPtr, 1), 0x3d)\n        mstore8(sub(resultPtr, 2), 0x3d)\n      }\n      case 2 {\n        mstore8(sub(resultPtr, 1), 0x3d)\n      }\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/contracts/lib/LCreate2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary LCreate2 {\n  /**\n   * @dev Deploys a contract using `CREATE2`. The address where the contract\n   * will be deployed can be known in advance via {computeAddress}.\n   *\n   * The bytecode for a contract can be obtained from Solidity with\n   * `type(contractName).creationCode`.\n   *\n   * Requirements:\n   *\n   * - `bytecode` must not be empty.\n   * - `salt` must have not been used for `bytecode` already.\n   * - the factory must have a balance of at least `amount`.\n   * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n   */\n  function deploy(\n    uint256 amount,\n    bytes32 salt,\n    bytes memory bytecode\n  ) internal returns (address) {\n    address addr;\n    require(address(this).balance >= amount, \"Create2: insufficient balance\");\n    require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n    /// @solidity memory-safe-assembly\n    assembly {\n      addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n    }\n    require(addr != address(0), \"Create2: Failed on deploy\");\n    return addr;\n  }\n\n  /**\n   * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n   * `bytecodeHash` or `salt` will result in a new destination address.\n   */\n  function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n    return computeAddress(salt, bytecodeHash, address(this));\n  }\n\n  /**\n   * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n   * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n   */\n  function computeAddress(\n    bytes32 salt,\n    bytes32 bytecodeHash,\n    address deployer\n  ) internal pure returns (address) {\n    bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n    return address(uint160(uint256(_data)));\n  }\n}\n"
    },
    "src/contracts/lib/LTimers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Tooling for timepoints, timers and delays\n */\nlibrary LTimers {\n  struct Timestamp {\n    uint64 _deadline;\n  }\n\n  function getDeadline(Timestamp memory timer) internal pure returns (uint64) {\n    return timer._deadline;\n  }\n\n  function setDeadline(Timestamp storage timer, uint64 timestamp) internal {\n    timer._deadline = timestamp;\n  }\n\n  function reset(Timestamp storage timer) internal {\n    timer._deadline = 0;\n  }\n\n  function isUnset(Timestamp memory timer) internal pure returns (bool) {\n    return timer._deadline == 0;\n  }\n\n  function isStarted(Timestamp memory timer) internal pure returns (bool) {\n    return timer._deadline > 0;\n  }\n\n  function isPending(Timestamp memory timer) internal view returns (bool) {\n    return timer._deadline > block.timestamp;\n  }\n\n  function isExpired(Timestamp memory timer) internal view returns (bool) {\n    return isStarted(timer) && timer._deadline <= block.timestamp;\n  }\n\n  struct BlockNumber {\n    uint64 _deadline;\n  }\n\n  function getDeadline(BlockNumber memory timer) internal pure returns (uint64) {\n    return timer._deadline;\n  }\n\n  function setDeadline(BlockNumber storage timer, uint64 timestamp) internal {\n    timer._deadline = timestamp;\n  }\n\n  function reset(BlockNumber storage timer) internal {\n    timer._deadline = 0;\n  }\n\n  function isUnset(BlockNumber memory timer) internal pure returns (bool) {\n    return timer._deadline == 0;\n  }\n\n  function isStarted(BlockNumber memory timer) internal pure returns (bool) {\n    return timer._deadline > 0;\n  }\n\n  function isPending(BlockNumber memory timer) internal view returns (bool) {\n    return timer._deadline > block.number;\n  }\n\n  function isExpired(BlockNumber memory timer) internal view returns (bool) {\n    return isStarted(timer) && timer._deadline <= block.number;\n  }\n}\n"
    },
    "src/contracts/lib/cryptography/LMerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary LMerkleProof {\n  /**\n   * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n   * defined by `root`. For this, a `proof` must be provided, containing\n   * sibling hashes on the branch from the leaf to the root of the tree. Each\n   * pair of leaves and each pair of pre-images are assumed to be sorted.\n   */\n  function verify(\n    bytes32[] memory proof,\n    bytes32 root,\n    bytes32 leaf\n  ) internal pure returns (bool) {\n    return processProof(proof, leaf) == root;\n  }\n\n  /**\n   * @dev Calldata version of {verify}\n   */\n  function verifyCalldata(\n    bytes32[] calldata proof,\n    bytes32 root,\n    bytes32 leaf\n  ) internal pure returns (bool) {\n    return processProofCalldata(proof, leaf) == root;\n  }\n\n  /**\n   * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n   * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n   * hash matches the root of the tree. When processing the proof, the pairs\n   * of leafs & pre-images are assumed to be sorted.\n   */\n  function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n      computedHash = _hashPair(computedHash, proof[i]);\n    }\n    return computedHash;\n  }\n\n  /**\n   * @dev Calldata version of {processProof}\n   */\n  function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n      computedHash = _hashPair(computedHash, proof[i]);\n    }\n    return computedHash;\n  }\n\n  /**\n   * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n   * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n   */\n  function multiProofVerify(\n    bytes32[] memory proof,\n    bool[] memory proofFlags,\n    bytes32 root,\n    bytes32[] memory leaves\n  ) internal pure returns (bool) {\n    return processMultiProof(proof, proofFlags, leaves) == root;\n  }\n\n  /**\n   * @dev Calldata version of {multiProofVerify}\n   */\n  function multiProofVerifyCalldata(\n    bytes32[] calldata proof,\n    bool[] calldata proofFlags,\n    bytes32 root,\n    bytes32[] memory leaves\n  ) internal pure returns (bool) {\n    return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n  }\n\n  /**\n   * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n   * consuming from one or the other at each step according to the instructions given by\n   * `proofFlags`.\n   */\n  function processMultiProof(\n    bytes32[] memory proof,\n    bool[] memory proofFlags,\n    bytes32[] memory leaves\n  ) internal pure returns (bytes32 merkleRoot) {\n    // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n    // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n    // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n    // the merkle tree.\n    uint256 leavesLen = leaves.length;\n    uint256 totalHashes = proofFlags.length;\n\n    // Check proof validity.\n    require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n    // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n    // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n    bytes32[] memory hashes = new bytes32[](totalHashes);\n    uint256 leafPos = 0;\n    uint256 hashPos = 0;\n    uint256 proofPos = 0;\n    // At each step, we compute the next hash using two values:\n    // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n    //   get the next hash.\n    // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n    //   `proof` array.\n    for (uint256 i = 0; i < totalHashes; i++) {\n      bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n      bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n      hashes[i] = _hashPair(a, b);\n    }\n\n    if (totalHashes > 0) {\n      return hashes[totalHashes - 1];\n    } else if (leavesLen > 0) {\n      return leaves[0];\n    } else {\n      return proof[0];\n    }\n  }\n\n  /**\n   * @dev Calldata version of {processMultiProof}\n   */\n  function processMultiProofCalldata(\n    bytes32[] calldata proof,\n    bool[] calldata proofFlags,\n    bytes32[] memory leaves\n  ) internal pure returns (bytes32 merkleRoot) {\n    // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n    // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n    // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n    // the merkle tree.\n    uint256 leavesLen = leaves.length;\n    uint256 totalHashes = proofFlags.length;\n\n    // Check proof validity.\n    require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n    // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n    // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n    bytes32[] memory hashes = new bytes32[](totalHashes);\n    uint256 leafPos = 0;\n    uint256 hashPos = 0;\n    uint256 proofPos = 0;\n    // At each step, we compute the next hash using two values:\n    // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n    //   get the next hash.\n    // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n    //   `proof` array.\n    for (uint256 i = 0; i < totalHashes; i++) {\n      bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n      bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n      hashes[i] = _hashPair(a, b);\n    }\n\n    if (totalHashes > 0) {\n      return hashes[totalHashes - 1];\n    } else if (leavesLen > 0) {\n      return leaves[0];\n    } else {\n      return proof[0];\n    }\n  }\n\n  function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n    return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n  }\n\n  function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x00, a)\n      mstore(0x20, b)\n      value := keccak256(0x00, 0x40)\n    }\n  }\n}\n"
    },
    "src/contracts/lib/math/LSignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary LSignedMath {\n  /**\n   * @dev Returns the largest of two signed numbers.\n   */\n  function max(int256 a, int256 b) internal pure returns (int256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two signed numbers.\n   */\n  function min(int256 a, int256 b) internal pure returns (int256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two signed numbers without overflow.\n   * The result is rounded towards zero.\n   */\n  function average(int256 a, int256 b) internal pure returns (int256) {\n    // Formula from the book \"Hacker's Delight\"\n    int256 x = (a & b) + ((a ^ b) >> 1);\n    return x + (int256(uint256(x) >> 255) & (a ^ b));\n  }\n\n  /**\n   * @dev Returns the absolute unsigned value of a signed value.\n   */\n  function abs(int256 n) internal pure returns (uint256) {\n    unchecked {\n      // must be unchecked in order to support `n = type(int256).min`\n      return uint256(n >= 0 ? n : -n);\n    }\n  }\n}\n"
    },
    "src/contracts/lib/math/LSignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary LSignedSafeMath {\n  /**\n   * @dev Returns the multiplication of two signed integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   *\n   * - Multiplication cannot overflow.\n   */\n  function mul(int256 a, int256 b) internal pure returns (int256) {\n    return a * b;\n  }\n\n  /**\n   * @dev Returns the integer division of two signed integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator.\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(int256 a, int256 b) internal pure returns (int256) {\n    return a / b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two signed integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(int256 a, int256 b) internal pure returns (int256) {\n    return a - b;\n  }\n\n  /**\n   * @dev Returns the addition of two signed integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   *\n   * - Addition cannot overflow.\n   */\n  function add(int256 a, int256 b) internal pure returns (int256) {\n    return a + b;\n  }\n}\n"
    },
    "src/contracts/lib/struct/LBitMapsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n// Author: OpenZeppelin\n\npragma solidity 0.8.19;\n\n/**\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\n */\nlibrary LBitMaps {\n  struct BitMap {\n    mapping(uint256 => uint256) _data;\n  }\n\n  /**\n   * @dev Returns whether the bit at `index` is set.\n   */\n  function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n    uint256 bucket = index >> 8;\n    uint256 mask = 1 << (index & 0xff);\n    return bitmap._data[bucket] & mask != 0;\n  }\n\n  /**\n   * @dev Sets the bit at `index` to the boolean `value`.\n   */\n  function setTo(\n    BitMap storage bitmap,\n    uint256 index,\n    bool value\n  ) internal {\n    if (value) {\n      set(bitmap, index);\n    } else {\n      unset(bitmap, index);\n    }\n  }\n\n  /**\n   * @dev Sets the bit at `index`.\n   */\n  function set(BitMap storage bitmap, uint256 index) internal {\n    uint256 bucket = index >> 8;\n    uint256 mask = 1 << (index & 0xff);\n    bitmap._data[bucket] |= mask;\n  }\n\n  /**\n   * @dev Unsets the bit at `index`.\n   */\n  function unset(BitMap storage bitmap, uint256 index) internal {\n    uint256 bucket = index >> 8;\n    uint256 mask = 1 << (index & 0xff);\n    bitmap._data[bucket] &= ~mask;\n  }\n}\n"
    },
    "src/contracts/test/acl/AccessControlManagerTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n\npragma solidity 0.8.19;\n\n// import \"./AccessControlStorageTest.sol\";\n// import \"../../acl/IAccessControl.sol\";\n// import \"../../acl/IGroupManagement.sol\";\n// import \"../../acl/IRealmManagement.sol\";\n// import \"../../acl/IRoleManagement.sol\";\n// import \"../../acl/IContextManagement.sol\";\n// import \"../../lib/struct/LEnumerableSet.sol\";\n// import \"../../lib/struct/LEnumerableMap.sol\";\n// import \"../../lib/acl/LContextManagement.sol\";\n// import \"../../lib/acl/LRoleManagement.sol\";\n// import \"../../lib/acl/LGroupManagement.sol\";\n// import \"../../lib/acl/LRealmManagement.sol\";\n// import \"../../lib/acl/LAccessControl.sol\";\n// import \"../../proxy/Initializable.sol\";\n// import \"../../proxy/BaseUUPSProxy.sol\";\n\n// /**\n//  * @title Access Control Manager Test\n//  * @author Sina Tadayon, https://github.com/SinaTadayon\n//  * @dev\n//  *\n//  */\n// contract AccessControlManagerTest is AccessControlStorageTest, BaseUUPSProxy {\n//   using LEnumerableSet for LEnumerableSet.AddressSet;\n//   using LEnumerableSet for LEnumerableSet.Bytes32Set;\n//   using LEnumerableMap for LEnumerableMap.Bytes32ToBytes32Map;\n//   using LEnumerableMap for LEnumerableMap.AddressToUintMap;\n\n//   constructor() {}\n\n//   function initialize() public onlyProxy reinitializer(2) {\n//     _data.dummy_1 = 100;\n//     dummy_2 = keccak256(\"UPDATE_TEST\");\n//   }\n\n//   /**\n//    * @dev See {IERC165-supportsInterface}.\n//    */\n//   function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n//     return\n//       interfaceId == type(IAccessControl).interfaceId ||\n//       interfaceId == type(IContextManagement).interfaceId ||\n//       interfaceId == type(IRoleManagement).interfaceId ||\n//       interfaceId == type(IGroupManagement).interfaceId ||\n//       interfaceId == type(IRealmManagement).interfaceId ||\n//       super.supportsInterface(interfaceId);\n//   }\n// }\n"
    },
    "src/contracts/test/proxy/Relay.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n\npragma solidity 0.8.19;\n\n/**\n * @title Relay Contract\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ncontract Relay {\n  address private _destContract;\n\n  constructor(address destContract) {\n    _destContract = destContract;\n  }\n\n  /**\n   * @dev Forwards the current call to `_destContract`.\n   *\n   * This function does not return to its internall call site, it will return directly to the external caller.\n   */\n  function _forward(uint256 value) internal {\n    assembly {\n      // loading state variable to stack\n      let addr := sload(_destContract.slot)\n\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := call(gas(), addr, value, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev Forward the current call to the address returned by `_destContract`.\n   *\n   * This function does not return to its internall call site, it will return directly to the external caller.\n   */\n  function _fallback() internal virtual {\n    _forward(msg.value);\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_destContract`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  // solhint-disable-next-line\n  fallback() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_destContract`. Will run if call data\n   * is empty.\n   */\n  // solhint-disable-next-line\n  receive() external payable virtual {\n    _fallback();\n  }\n}\n"
    },
    "src/contracts/token/lively/IShortTermDeposite.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// LivelyVerse Contracts (last updated v2.0.1)\n\npragma solidity 0.8.19;\n\n/**\n * @title Short Term Deposite Staking Interface\n * @author Sina Tadayon, https://github.com/SinaTadayon\n * @dev\n *\n */\ninterface IShortTermDeposite {\n  event STDDeposited(\n    address indexed sender,\n    uint256 amount,\n    uint256 balance,\n    uint256 interest,\n    uint128 timestamp,\n    uint64 aprId\n  );\n\n  event STDWithdrawn(\n    address indexed sender,\n    uint256 amount,\n    uint256 balance,\n    uint256 interest,\n    uint128 timestamp,\n    uint64 aprId\n  );\n\n  event STDClaimed(address indexed sender, uint256 balance, uint256 interest, uint128 timestamp, uint64 aprId);\n\n  function depositeStd(uint256 amount) external returns (uint256);\n\n  function withdrawStd(uint256 amount) external returns (uint256);\n\n  function claimStd() external returns (uint256);\n\n  function getStdInfo(address account)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint128,\n      uint128\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}