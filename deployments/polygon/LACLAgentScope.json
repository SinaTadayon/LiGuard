{
  "address": "0x8B3b4D799e8e2a26356C9e07Ad65857Fa02c371B",
  "abi": [
    {
      "inputs": [],
      "name": "AdminAccessFunctionNotFound",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AdminAccessNotPermitted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AdminAccessPolicyForbidden",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AdminAccessRoleActivityForbidden",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AdminAccessRoleNotFound",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AdminAccessTypeActivityForbidden",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AdminAccessTypeNotFound",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LIB_NAME",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LIB_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LIVELY_VERSE_ANONYMOUS_TYPE_ID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LIVELY_VERSE_ANY_TYPE_ID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x1cadfba91b5170d25d7a333b5a2fef265750bf99fe49bd8115b1b2596a9b60ad",
  "receipt": {
    "to": null,
    "from": "0xCB93d383638cc7B174FE2139Dec8570521Bb8118",
    "contractAddress": "0x8B3b4D799e8e2a26356C9e07Ad65857Fa02c371B",
    "transactionIndex": 33,
    "gasUsed": "2453700",
    "logsBloom": "0x00000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000002000000000000000000000000000084000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000010000000000000004000000000000000000001000000000000000000000008000000100000000000000000000002000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x25241d2a2e5675de1930fd01d13a120596b309efcdc689e0b0788cab600af527",
    "transactionHash": "0x1cadfba91b5170d25d7a333b5a2fef265750bf99fe49bd8115b1b2596a9b60ad",
    "logs": [
      {
        "transactionIndex": 33,
        "blockNumber": 40018235,
        "transactionHash": "0x1cadfba91b5170d25d7a333b5a2fef265750bf99fe49bd8115b1b2596a9b60ad",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000cb93d383638cc7b174fe2139dec8570521bb8118",
          "0x000000000000000000000000ec20607aa654d823dd01beb8780a44863c57ed07"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000114c1851155f0880000000000000000000000000000000000000000000000032a50fe76110843a90000000000000000000000000000000000000000000001446b2709aecfd67842000000000000000000000000000000000000000000000003293c3cf0ffb253210000000000000000000000000000000000000000000001446c3bcb33e12c68ca",
        "logIndex": 109,
        "blockHash": "0x25241d2a2e5675de1930fd01d13a120596b309efcdc689e0b0788cab600af527"
      }
    ],
    "blockNumber": 40018235,
    "cumulativeGasUsed": "8807706",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "bf3d37f12163392c6a812b5af749abec",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AdminAccessFunctionNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdminAccessNotPermitted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdminAccessPolicyForbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdminAccessRoleActivityForbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdminAccessRoleNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdminAccessTypeActivityForbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdminAccessTypeNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LIB_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIB_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIVELY_VERSE_ANONYMOUS_TYPE_ID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIVELY_VERSE_ANY_TYPE_ID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Sina Tadayon, https://github.com/SinaTadayon\",\"kind\":\"dev\",\"methods\":{},\"title\":\"ACL Commons Library\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/lib/acl/LACLAgentScope.sol\":\"LACLAgentScope\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"src/contracts/acl/ACLStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./IACLCommons.sol\\\";\\nimport \\\"../proxy/BaseUUPSStorage.sol\\\";\\nimport \\\"../lib/struct/LEnumerableSet.sol\\\";\\n\\n/**\\n * @title Abstract Access Control List Storage Contract\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\nabstract contract ACLStorage is BaseUUPSStorage, IACLCommons {\\n  using LEnumerableSet for LEnumerableSet.AddressSet;\\n\\n  struct DataCollection {\\n    mapping(bytes32 => BaseAgent) agents;\\n    mapping(bytes32 => BaseScope) scopes;\\n    mapping(bytes32 => PolicyEntity) policies;\\n    mapping(bytes32 => bytes32) rolePolicyMap;\\n    mapping(bytes32 => ProfileEntity) profiles;\\n    mapping(address => ProfileAccount) profileAccounts;\\n    mapping(bytes4 => address) selectors;\\n    mapping(address => FacetEntity) facets;\\n    LEnumerableSet.AddressSet facetSet;\\n  }\\n\\n  bytes32 public constant CTX_MESSAGE_TYPEHASH =\\n    keccak256(\\\"Context(address contractId,string name,string version,string realm)\\\");\\n\\n  bytes32 public constant PREDICT_CTX_MESSAGE_TYPEHASH =\\n    keccak256(\\\"PredictContext(address deployer,address subject,string realm)\\\");\\n\\n  bytes32 public constant MEMBER_SIGNATURE_MESSAGE_TYPEHASH =\\n    keccak256(\\\"MemberSignature(address account,uint256 expiredAt)\\\");\\n\\n  bytes32 public constant PROFILE_CTX_MESSAGE_TYPEHASH =\\n    keccak256(\\\"ProfileContext(string profile,address contractId,string name,string version,string realm)\\\");\\n\\n  bytes32 public constant PROFILE_PREDICT_CTX_MESSAGE_TYPEHASH =\\n    keccak256(\\\"ProfilePredictContext(string profile,address deployer,address subject,string realm)\\\");\\n\\n  bytes32 public constant PROFILE_MEMBER_SIGNATURE_MESSAGE_TYPEHASH =\\n    keccak256(\\\"ProfileMemberSignature(string profile,address account,uint256 expiredAt)\\\");\\n\\n  // General Types ID\\n  bytes32 internal constant _LIVELY_VERSE_LIVELY_MASTER_TYPE_ID =\\n    keccak256(abi.encodePacked(\\\"TYPE.LIVELY_VERSE.LIVELY_MASTER\\\"));\\n  bytes32 internal constant _LIVELY_VERSE_SYSTEM_MASTER_TYPE_ID =\\n    keccak256(abi.encodePacked(\\\"TYPE.LIVELY_VERSE.LIVELY_SYSTEM_MASTER\\\"));\\n  bytes32 internal constant _LIVELY_VERSE_ANONYMOUS_TYPE_ID =\\n    keccak256(abi.encodePacked(\\\"TYPE.LIVELY_VERSE.LIVELY_ANONYMOUS\\\"));\\n  bytes32 internal constant _LIVELY_VERSE_ANY_TYPE_ID = keccak256(abi.encodePacked(\\\"TYPE.LIVELY_VERSE.LIVELY_ANY\\\"));\\n  bytes32 internal constant _LIVELY_VERSE_SCOPE_MASTER_TYPE_ID =\\n    keccak256(abi.encodePacked(\\\"TYPE.LIVELY_VERSE.LIVELY_SCOPE_MASTER\\\"));\\n  bytes32 internal constant _LIVELY_VERSE_MEMBER_MASTER_TYPE_ID =\\n    keccak256(abi.encodePacked(\\\"TYPE.LIVELY_VERSE.LIVELY_MEMBER_MASTER\\\"));\\n  bytes32 internal constant _LIVELY_VERSE_TYPE_MASTER_TYPE_ID =\\n    keccak256(abi.encodePacked(\\\"TYPE.LIVELY_VERSE.LIVELY_TYPE_MASTER\\\"));\\n  bytes32 internal constant _LIVELY_VERSE_POLICY_MASTER_TYPE_ID =\\n    keccak256(abi.encodePacked(\\\"TYPE.LIVELY_VERSE.LIVELY_POLICY_MASTER\\\"));\\n  bytes32 internal constant _LIVELY_VERSE_PROFILE_MASTER_TYPE_ID =\\n    keccak256(abi.encodePacked(\\\"TYPE.LIVELY_VERSE.LIVELY_PROFILE_MASTER\\\"));\\n\\n  // Universe Scope ID\\n  bytes32 internal constant _LIVELY_VERSE_LIVELY_UNIVERSE_SCOPE_ID =\\n    keccak256(abi.encodePacked(\\\"UNIVERSE.LIVELY_VERSE\\\"));\\n\\n  // General Profile Type\\n  bytes32 internal constant _LIVELY_PROFILE_LIVELY_MASTER_TYPE_ID =\\n    keccak256(abi.encodePacked(\\\"TYPE.LIVELY_PROFILE.LIVELY_MASTER\\\"));\\n  bytes32 internal constant _LIVELY_PROFILE_SYSTEM_MASTER_TYPE_ID =\\n    keccak256(abi.encodePacked(\\\"TYPE.LIVELY_PROFILE.LIVELY_SYSTEM_MASTER\\\"));\\n  bytes32 internal constant _LIVELY_PROFILE_ANY_TYPE_ID = keccak256(abi.encodePacked(\\\"TYPE.LIVELY_PROFILE.LIVELY_ANY\\\"));\\n  bytes32 internal constant _LIVELY_PROFILE_LIVELY_UNIVERSE_SCOPE_ID =\\n    keccak256(abi.encodePacked(\\\"UNIVERSE.LIVELY_PROFILE\\\"));\\n\\n  bool internal _firstInit;\\n  DataCollection internal _data;\\n  // Note: for next upgrade add new variables after this line\\n}\\n\",\"keccak256\":\"0x748ba9ee4ce4e5492afd3261bf61e8360b3f45ae3588218c1bbf90699df2065b\",\"license\":\"MIT\"},\"src/contracts/acl/IACL.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title Access Control Interface\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\ninterface IACL {\\n  enum AuthorizationStatus {\\n    PERMITTED,\\n    UNAUTHORIZED,\\n    POLICY_FORBIDDEN,\\n    CALL_FORBIDDEN,\\n    ROLE_SCOPE_FORBIDDEN,\\n    MEMBER_NOT_FOUND,\\n    ROLE_NOT_FOUND,\\n    TYPE_NOT_FOUND,\\n    FUNCTION_NOT_FOUND,\\n    CONTEXT_NOT_FOUND,\\n    REALM_NOT_FOUND,\\n    DOMAIN_NOT_FOUND,\\n    MEMBER_ACTIVITY_FORBIDDEN,\\n    ROLE_ACTIVITY_FORBIDDEN,\\n    TYPE_ACTIVITY_FORBIDDEN,\\n    FUNCTION_ACTIVITY_FORBIDDEN,\\n    CONTEXT_ACTIVITY_FORBIDDEN,\\n    REALM_ACTIVITY_FORBIDDEN,\\n    DOMAIN_ACTIVITY_FORBIDDEN,\\n    UNIVERSE_ACTIVITY_FORBIDDEN\\n  }\\n\\n  error ACLUnauthorized();\\n  error ACLPolicyForbidden();\\n  error ACLCallForbidden();\\n  error ACLRoleScopeForbidden();\\n  error ACLMemberNotFound();\\n  error ACLRoleNotFound();\\n  error ACLTypeNotFound();\\n  error ACLFunctionNotFound();\\n  error ACLContextNotFound();\\n  error ACLRealmNotFound();\\n  error ACLDomainNotFound();\\n  error ACLMemberActivityForbidden();\\n  error ACLRoleActivityForbidden();\\n  error ACLTypeActivityForbidden();\\n  error ACLFunctionActivityForbidden();\\n  error ACLContextActivityForbidden();\\n  error ACLRealmActivityForbidden();\\n  error ACLDomainActivityForbidden();\\n  error ACLUniverseActivityForbidden();\\n\\n  error ACLActionForbidden(AuthorizationStatus);\\n\\n  enum AdminAccessStatus {\\n    PERMITTED,\\n    NOT_PERMITTED,\\n    POLICY_FORBIDDEN,\\n    ROLE_NOT_FOUND,\\n    TYPE_NOT_FOUND,\\n    FUNCTION_NOT_FOUND,\\n    ROLE_ACTIVITY_FORBIDDEN,\\n    TYPE_ACTIVITY_FORBIDDEN\\n  }\\n\\n  error AdminAccessNotPermitted();\\n  error AdminAccessPolicyForbidden();\\n  error AdminAccessRoleNotFound();\\n  error AdminAccessTypeNotFound();\\n  error AdminAccessFunctionNotFound();\\n  error AdminAccessRoleActivityForbidden();\\n  error AdminAccessTypeActivityForbidden();\\n\\n  error SetAdminForbidden(AdminAccessStatus);\\n\\n  function hasAccess(bytes32 functionId) external returns (AuthorizationStatus);\\n\\n  function hasMemberAccess(bytes32 functionId, bytes32 memberId) external returns (AuthorizationStatus);\\n\\n  function hasCSAccess(address contractId, bytes4 selector) external returns (AuthorizationStatus);\\n\\n  function hasAccountAccess(\\n    address contractId,\\n    bytes4 selector,\\n    address accountId\\n  ) external returns (AuthorizationStatus);\\n}\\n\",\"keccak256\":\"0x3b4bd5cd73079a4bcbc82fe3699b21fcc08fdafc964f978a9c540756302dbb2e\",\"license\":\"MIT\"},\"src/contracts/acl/IACLCommons.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../lib/struct/LEnumerableSet.sol\\\";\\n\\n/**\\n * @title Access Control Interface\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\ninterface IACLCommons {\\n  enum AgentType {\\n    NONE,\\n    MEMBER,\\n    ROLE,\\n    TYPE\\n  }\\n\\n  enum ActivityStatus {\\n    NONE,\\n    DELETED,\\n    DISABLED,\\n    ENABLED\\n  }\\n\\n  enum AlterabilityStatus {\\n    NONE,\\n    DISABLED,\\n    UPDATABLE,\\n    UPGRADABLE\\n  }\\n\\n  enum ScopeType {\\n    NONE,\\n    FUNCTION,\\n    CONTEXT,\\n    REALM,\\n    DOMAIN,\\n    UNIVERSE\\n  }\\n\\n  enum ActionType {\\n    ADD,\\n    UPDATE,\\n    REMOVE\\n  }\\n\\n  enum PolicyType {\\n    UNLOCK, // 0\\n    SLOCK, // soft lock, 1 - 63\\n    MLOCK, // medium lock, 64 - 127\\n    RLOCK, // restrict lock, 128 - 191\\n    HLOCK, // hard lock, 192 - 254\\n    LOCK // 255\\n  }\\n\\n  struct BaseAgent {\\n    bytes32 adminId;\\n    AgentType atype;\\n    ActivityStatus acstat;\\n    AlterabilityStatus alstat;\\n  }\\n\\n  struct BaseScope {\\n    bytes32 adminId;\\n    ScopeType stype;\\n    ActivityStatus acstat;\\n    AlterabilityStatus alstat;\\n    uint32 referredByAgent;\\n  }\\n\\n  struct PolicyEntity {\\n    bytes32 adminId;\\n    bytes32 scopeId;\\n    string name;\\n    uint16 roleLimit;\\n    uint8 policyCode;\\n    PolicyType ptype;\\n    ActivityStatus acstat;\\n    AlterabilityStatus alstat;\\n    LEnumerableSet.Bytes32Set roles;\\n  }\\n\\n  struct FunctionEntity {\\n    BaseScope bs;\\n    bytes32 agentId;\\n    bytes32 contextId;\\n    bytes4 selector;\\n    uint8 policyCode;\\n  }\\n\\n  struct ContextEntity {\\n    BaseScope bs;\\n    bytes32 realmId;\\n    address contractId;\\n    uint8 functionLimit;\\n    LEnumerableSet.Bytes32Set functions;\\n  }\\n\\n  struct RealmEntity {\\n    BaseScope bs;\\n    bytes32 domainId;\\n    uint32 contextLimit;\\n    string name;\\n    LEnumerableSet.Bytes32Set contexts;\\n  }\\n\\n  struct DomainEntity {\\n    BaseScope bs;\\n    bytes32 universeId;\\n    uint16 realmLimit;\\n    string name;\\n    LEnumerableSet.Bytes32Set realms;\\n  }\\n\\n  struct UniverseEntity {\\n    BaseScope bs;\\n    uint16 domainLimit;\\n    string name;\\n    LEnumerableSet.Bytes32Set domains;\\n  }\\n\\n  struct GeneralLimit {\\n    uint24 memberLimit;\\n    uint16 memberRegisterLimit;\\n    uint16 contextRegisterLimit;\\n    uint16 functionRegisterLimit;\\n    uint16 profileRegisterLimit;\\n    uint16 contextLimit;\\n    uint16 realmLimit;\\n    uint16 domainLimit;\\n    uint16 callLimit;\\n    uint16 typeRoleLimit;\\n    uint16 typeLimit;\\n    uint8 roleRegisterLimit;\\n    uint8 typeRegisterLimit;\\n    uint8 realmRegisterLimit;\\n    uint8 domainRegisterLimit;\\n    uint8 policyRegisterLimit;\\n    uint8 policyRoleLimit;\\n    uint8 functionLimit;\\n  }\\n\\n  struct MemberEntity {\\n    BaseAgent ba;\\n    address account;\\n    GeneralLimit limits;\\n    LEnumerableSet.Bytes32Set types;\\n  }\\n\\n  struct MemberSignature {\\n    address account;\\n    uint64 expiredAt;\\n    bytes signature;\\n  }\\n\\n  struct RoleEntity {\\n    BaseAgent ba;\\n    bytes32 scopeId;\\n    bytes32 typeId;\\n    string name;\\n    uint24 memberLimit;\\n    uint24 memberCount;\\n  }\\n\\n  struct TypeEntity {\\n    BaseAgent ba;\\n    bytes32 scopeId;\\n    string name;\\n    uint16 roleLimit;\\n    mapping(bytes32 => bytes32) members;\\n    LEnumerableSet.Bytes32Set roles;\\n  }\\n\\n  struct FacetEntity {\\n    address subjectId;\\n  }\\n\\n  struct UpdateActivityRequest {\\n    bytes32 id;\\n    ActivityStatus acstat;\\n  }\\n\\n  struct UpdateAlterabilityRequest {\\n    bytes32 id;\\n    AlterabilityStatus alstat;\\n  }\\n\\n  struct UpdateAdminRequest {\\n    bytes32 id;\\n    bytes32 adminId;\\n  }\\n\\n  // used in Policy / Role / Type\\n  struct UpdateScopeRequest {\\n    bytes32 id;\\n    bytes32 scopeId;\\n  }\\n\\n  ////////////////////////////////////////////////////////////////////\\n  // Profiles\\n\\n  struct ProfileMemberSignature {\\n    string profileName;\\n    address account;\\n    uint64 expiredAt;\\n    bytes signature;\\n  }\\n\\n  struct ProfileRegisterLimit {\\n    uint32 memberRegisterLimit;\\n    uint32 roleRegisterLimit;\\n    uint32 typeRegisterLimit;\\n    uint32 functionRegisterLimit;\\n    uint32 contextRegisterLimit;\\n    uint16 realmRegisterLimit;\\n    uint16 domainRegisterLimit;\\n    uint16 policyRegisterLimit;\\n  }\\n\\n  struct ProfileLimit {\\n    uint32 profileCallLimit;\\n    uint32 contextLimit;\\n    uint24 memberLimit;\\n    uint16 realmLimit;\\n    uint16 domainLimit;\\n    uint16 memberCallLimit;\\n    uint16 typeRoleLimit;\\n    uint16 typeLimit;\\n    uint16 policyRoleLimit;\\n    uint8 functionLimit;\\n  }\\n\\n  struct ProfileAccount {\\n    bytes32[] profiles;\\n  }\\n\\n  struct ProfileEntity {\\n    mapping(bytes32 => BaseAgent) agents;\\n    mapping(bytes32 => BaseScope) scopes;\\n    mapping(bytes32 => PolicyEntity) policies;\\n    mapping(bytes32 => bytes32) rolePolicyMap;\\n    LEnumerableSet.Bytes32Set admins;\\n    bytes32 adminId;\\n    string name;\\n    address owner;\\n    ActivityStatus acstat;\\n    AlterabilityStatus alstat;\\n    ProfileRegisterLimit registerLimits;\\n    ProfileLimit limits;\\n  }\\n\\n  struct ProfileMemberEntity {\\n    BaseAgent ba;\\n    address account;\\n    uint16 callLimit;\\n    uint16 typeLimit;\\n    ProfileRegisterLimit registerLimits;\\n    LEnumerableSet.Bytes32Set types;\\n  }\\n\\n  struct ProfileUpdateActivityRequest {\\n    bytes32 entityId;\\n    ActivityStatus acstat;\\n  }\\n\\n  struct ProfileUpdateAlterabilityRequest {\\n    bytes32 entityId;\\n    AlterabilityStatus alstat;\\n  }\\n\\n  struct ProfileUpdateAdminRequest {\\n    bytes32 entityId;\\n    bytes32 adminId;\\n  }\\n\\n  struct ProfileUpdateScopeRequest {\\n    bytes32 entityId;\\n    bytes32 scopeId;\\n  }\\n}\\n\",\"keccak256\":\"0x2269cec662cb8f25c0523b281f8f97bd9b5115ea80771c7d1e4083031f4a1c87\",\"license\":\"MIT\"},\"src/contracts/acl/IACLGenerals.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./IACLCommons.sol\\\";\\n\\n/**\\n * @title Access Control Interface\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\ninterface IACLGenerals is IACLCommons {\\n  // Anonymouse type\\n  function getAnonymousType() external pure returns (bytes32);\\n\\n  // Any type\\n  function getAnyType() external pure returns (bytes32);\\n\\n  // scope master type\\n  function getScopeMasterType() external pure returns (bytes32);\\n\\n  // type master type\\n  function getTypeMasterType() external pure returns (bytes32);\\n\\n  // member master type\\n  function getMemberMasterType() external pure returns (bytes32);\\n\\n  // system master type\\n  function getSystemMasterType() external pure returns (bytes32);\\n\\n  // lively master type\\n  function getLivelyMasterType() external pure returns (bytes32);\\n\\n  // Policy Master type\\n  function getPolicyMasterType() external pure returns (bytes32);\\n\\n  // Profile Master type\\n  function getProfileMasterType() external pure returns (bytes32);\\n\\n  // Universe Scope\\n  function getUniverseScope() external pure returns (bytes32);\\n\\n  // general\\n  function isAgentExist(bytes32 agentId) external view returns (bool);\\n\\n  function isScopeExist(bytes32 scopeId) external view returns (bool);\\n\\n  function getScopeBaseInfo(bytes32 scopeId) external view returns (BaseScope memory);\\n\\n  function getAgentBaseInfo(bytes32 agentId) external view returns (BaseAgent memory);\\n\\n  function isScopesCompatible(bytes32 destScopeId, bytes32 srcScopeId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x303b03b04f7fc7356cc4c88bf54e218e29ce9fb479b44310d0788fa176ecfc50\",\"license\":\"MIT\"},\"src/contracts/acl/IACLManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./IACLCommons.sol\\\";\\n\\n/**\\n * @title Access Control Manager Interface\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\ninterface IACLManager is IACLCommons {\\n  // Request Types\\n  struct FacetSelectorUpgradeRequest {\\n    ActionType action;\\n    bytes4[] selectors;\\n  }\\n\\n  struct FacetUpgradeRequest {\\n    address facetId;\\n    address subjectId;\\n    FacetSelectorUpgradeRequest[] functions;\\n  }\\n\\n  struct FacetRegisterRequest {\\n    address facetId;\\n    address subjectId;\\n    bytes4[] selectors;\\n  }\\n\\n  struct FacetInfo {\\n    address subjectId;\\n  }\\n\\n  event ACLFacetRegistered(address indexed sender, address indexed facetId, address indexed subjectId);\\n\\n  event ACLFacetUpgraded(address indexed sender, address indexed facetId, address indexed subjectId);\\n\\n  event ACLFacetFunctionUpgraded(address indexed sender, address indexed facetId, bytes4 selector, ActionType action);\\n\\n  event ACLInitialized(\\n    address indexed sender,\\n    address indexed admin,\\n    address indexed systemAdmin,\\n    address contextManager,\\n    address functionManager\\n  );\\n\\n  function aclRegisterFacet(FacetRegisterRequest[] calldata requests) external returns (bool);\\n\\n  function aclUpgradeFacet(FacetUpgradeRequest[] calldata requests) external returns (bool);\\n\\n  function aclGetFacets() external view returns (address[] memory);\\n\\n  function aclGetFacet(bytes4 selector) external view returns (address);\\n\\n  function aclHasSelector(bytes4 selector) external view returns (bool);\\n\\n  function aclGetFacetInfo(address facetId) external view returns (FacetInfo memory);\\n}\\n\",\"keccak256\":\"0xc124daf10a79621e8a3fa8d6c4a21e3afafc7d4d1864bef1223bb7530addd270\",\"license\":\"MIT\"},\"src/contracts/acl/agent/IMemberManagement.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../IACLCommons.sol\\\";\\n\\n/**\\n * @title Member Management Interface\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\ninterface IMemberManagement is IACLCommons {\\n  struct MemberRegisterRequest {\\n    bytes32 roleId;\\n    bytes32 adminId;\\n    address account;\\n    GeneralLimit limits;\\n    ActivityStatus acstat;\\n    AlterabilityStatus alstat;\\n  }\\n\\n  struct MemberUpdateGeneralLimitRequest {\\n    bytes32 memberId;\\n    GeneralLimit limits;\\n  }\\n\\n  struct MemberInfo {\\n    bytes32 adminId;\\n    address account;\\n    GeneralLimit limits;\\n    uint16 typeCount;\\n    AgentType adminType;\\n    AgentType atype;\\n    ActivityStatus acstat;\\n    AlterabilityStatus alstat;\\n  }\\n\\n  event MemberRegistered(\\n    address indexed sender,\\n    bytes32 indexed memberId,\\n    address indexed account,\\n    bytes32 roleId,\\n    bytes32 adminId,\\n    GeneralLimit limits\\n  );\\n\\n  event MemberGeneralLimitUpdated(address indexed sender, bytes32 indexed memberId, GeneralLimit limits);\\n\\n  event MemberAdminUpdated(address indexed sender, bytes32 indexed memberId, bytes32 indexed adminId);\\n\\n  event MemberActivityUpdated(address indexed sender, bytes32 indexed memberId, ActivityStatus acstat);\\n\\n  event MemberAlterabilityUpdated(address indexed sender, bytes32 indexed memberId, AlterabilityStatus alstat);\\n\\n  event MemberRoleRevoked(address indexed sender, bytes32 indexed memberId, bytes32 indexed roleId, bytes32 typeId);\\n\\n  event MemberRemoved(address indexed sender, bytes32 indexed memberId, bool isCompleted);\\n\\n  function memberRegister(MemberSignature calldata memberSign, MemberRegisterRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function memberUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function memberUpdateAlterabilityStatus(\\n    MemberSignature calldata memberSign,\\n    UpdateAlterabilityRequest[] calldata requests\\n  ) external returns (bool);\\n\\n  function memberUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function memberUpdateGeneralLimit(\\n    MemberSignature calldata memberSign,\\n    MemberUpdateGeneralLimitRequest[] calldata requests\\n  ) external returns (bool);\\n\\n  function memberRemove(MemberSignature calldata memberSign, bytes32[] calldata members) external returns (bool);\\n\\n  function memberCheckId(bytes32 memberId) external view returns (bool);\\n\\n  function memberCheckAccount(address account) external view returns (bool);\\n\\n  function memberCheckAdmin(bytes32 memberId, address account) external view returns (bool);\\n\\n  function memberHasType(bytes32 memberId, bytes32 typeId) external view returns (bool);\\n\\n  function memberGetTypes(bytes32 memberId) external view returns (bytes32[] memory);\\n\\n  function memberGetInfo(bytes32 memberId) external view returns (MemberInfo memory);\\n}\\n\",\"keccak256\":\"0xf37af1012005b6b55ccee3de27c1dd0e5851a550388257c6a77f73962d822945\",\"license\":\"MIT\"},\"src/contracts/acl/agent/IRoleManagement.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../IACLCommons.sol\\\";\\n\\n/**\\n * @title Role Management Interface\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\ninterface IRoleManagement is IACLCommons {\\n  struct RoleRegisterRequest {\\n    bytes32 adminId;\\n    bytes32 scopeId;\\n    bytes32 typeId;\\n    int32 memberLimit;\\n    ActivityStatus acstat;\\n    AlterabilityStatus alstat;\\n    string name;\\n  }\\n\\n  struct RoleGrantMembersRequest {\\n    bytes32 roleId;\\n    bytes32[] members;\\n  }\\n\\n  struct RoleRevokeMembersRequest {\\n    bytes32 roleId;\\n    bytes32[] members;\\n  }\\n\\n  struct RoleUpdateMemberLimitRequest {\\n    bytes32 roleId;\\n    uint24 memberLimit;\\n  }\\n\\n  struct RoleInfo {\\n    bytes32 scopeId;\\n    bytes32 typeId;\\n    bytes32 adminId;\\n    uint24 memberLimit;\\n    uint24 memberCount;\\n    AgentType adminType;\\n    AgentType atype;\\n    ActivityStatus acstat;\\n    AlterabilityStatus alstat;\\n    string name;\\n  }\\n\\n  event RoleRegistered(\\n    address indexed sender,\\n    bytes32 indexed roleId,\\n    bytes32 indexed typeId,\\n    bytes32 adminId,\\n    bytes32 scopeId\\n  );\\n\\n  event RoleMemberDeleted(\\n    address indexed sender,\\n    bytes32 indexed roleId,\\n    bytes32 indexed memberId,\\n    bytes32 typeId,\\n    address account\\n  );\\n\\n  event RoleMemberGranted(address indexed sender, bytes32 indexed roleId, bytes32 indexed memberId, bytes32 typeId);\\n\\n  event RoleMemberRevoked(address indexed sender, bytes32 indexed roleId, bytes32 indexed memberId, bytes32 typeId);\\n\\n  event RoleMemberLimitUpdated(address indexed sender, bytes32 indexed roleId, uint24 memberLimit);\\n\\n  event RoleAdminUpdated(address indexed sender, bytes32 indexed roleId, bytes32 indexed adminId);\\n\\n  event RoleScopeUpdated(address indexed sender, bytes32 indexed roleId, bytes32 indexed scopeId);\\n\\n  event RoleActivityUpdated(address indexed sender, bytes32 indexed roleId, ActivityStatus acstat);\\n\\n  event RoleAlterabilityUpdated(address indexed sender, bytes32 indexed roleId, AlterabilityStatus alstat);\\n\\n  event RoleRemoved(address indexed sender, bytes32 indexed roleId);\\n\\n  function roleRegister(MemberSignature calldata memberSign, RoleRegisterRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function roleGrantMembers(MemberSignature calldata memberSign, RoleGrantMembersRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function roleRevokeMembers(MemberSignature calldata memberSign, RoleRevokeMembersRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function roleUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function roleUpdateScope(MemberSignature calldata memberSign, UpdateScopeRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function roleUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function roleUpdateAlterabilityStatus(\\n    MemberSignature calldata memberSign,\\n    UpdateAlterabilityRequest[] calldata requests\\n  ) external returns (bool);\\n\\n  function roleUpdateMemberLimit(MemberSignature calldata memberSign, RoleUpdateMemberLimitRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function roleRemove(MemberSignature calldata memberSign, bytes32[] calldata roles) external returns (bool);\\n\\n  function roleCheckId(bytes32 roleId) external view returns (bool);\\n\\n  function roleCheckName(string calldata roleName) external view returns (bool);\\n\\n  function roleCheckAdmin(bytes32 roleId, address account) external view returns (bool);\\n\\n  function roleHasAccount(bytes32 roleId, address account) external view returns (bool);\\n\\n  function roleGetInfo(bytes32 roleId) external view returns (RoleInfo memory);\\n}\\n\",\"keccak256\":\"0xd577f997c4da278bcf299f28134d89a2807745820b182d7f4de0bcfa68ad262c\",\"license\":\"MIT\"},\"src/contracts/acl/policy/IPolicyManagement.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../IACLCommons.sol\\\";\\n\\n/**\\n * @title Policy Management Interface\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\n\\ninterface IPolicyManagement is IACLCommons {\\n  struct PolicyRegisterRequest {\\n    bytes32 adminId;\\n    bytes32 scopeId;\\n    uint8 policyCode;\\n    int24 roleLimit;\\n    ActivityStatus acstat;\\n    AlterabilityStatus alstat;\\n    string name;\\n  }\\n\\n  struct PolicyAddRolesRequest {\\n    bytes32 policyId;\\n    bytes32[] roles;\\n  }\\n\\n  struct PolicyRemoveRolesRequest {\\n    bytes32 policyId;\\n    bytes32[] roles;\\n  }\\n\\n  struct PolicyUpdateCodeRequest {\\n    bytes32 policyId;\\n    uint8 policyCode;\\n  }\\n\\n  struct PolicyUpdateRoleLimitRequest {\\n    bytes32 policyId;\\n    uint16 roleLimit;\\n  }\\n\\n  struct PolicyInfo {\\n    bytes32 adminId;\\n    bytes32 scopeId;\\n    string name;\\n    uint16 roleLimit;\\n    uint16 roleCount;\\n    uint8 policyCode;\\n    AgentType adminType;\\n    ScopeType scopeType;\\n    PolicyType ptype;\\n    ActivityStatus acstat;\\n    AlterabilityStatus alstat;\\n  }\\n\\n  event PolicyRegistered(\\n    address indexed sender,\\n    bytes32 indexed policyId,\\n    bytes32 indexed scopeId,\\n    bytes32 adminId,\\n    uint8 policyCode\\n  );\\n\\n  event PolicyRoleAdded(address indexed sender, bytes32 indexed policyId, bytes32 indexed roleId);\\n\\n  event PolicyRoleRemoved(address indexed sender, bytes32 indexed policyId, bytes32 indexed roleId);\\n\\n  event PolicyActivityUpdated(address indexed sender, bytes32 indexed policyId, ActivityStatus acstat);\\n\\n  event PolicyAlterabilityUpdated(address indexed sender, bytes32 indexed policyId, AlterabilityStatus alstat);\\n\\n  event PolicyCodeUpdated(address indexed sender, bytes32 indexed policyId, uint8 policyCode, PolicyType ptype);\\n\\n  event PolicyRoleLimitUpdated(address indexed sender, bytes32 indexed policyId, uint16 roleLimit);\\n\\n  event PolicyAdminUpdated(address indexed sender, bytes32 indexed policyId, bytes32 indexed adminId);\\n\\n  event PolicyScopeUpdated(address indexed sender, bytes32 indexed policyId, bytes32 indexed scopeId);\\n\\n  event PolicyRemoved(address indexed sender, bytes32 indexed policyId);\\n\\n  function policyRegister(MemberSignature calldata memberSign, PolicyRegisterRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function policyAddRoles(MemberSignature calldata memberSign, PolicyAddRolesRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function policyRemoveRoles(MemberSignature calldata memberSign, PolicyRemoveRolesRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function policyUpdateCodes(MemberSignature calldata memberSign, PolicyUpdateCodeRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function policyUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function policyUpdateScope(MemberSignature calldata memberSign, UpdateScopeRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function policyUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function policyUpdateAlterabilityStatus(\\n    MemberSignature calldata memberSign,\\n    UpdateAlterabilityRequest[] calldata requests\\n  ) external returns (bool);\\n\\n  function policyUpdateRoleLimit(MemberSignature calldata memberSign, PolicyUpdateRoleLimitRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function policyRemove(MemberSignature calldata memberSign, bytes32[] calldata policies) external returns (bool);\\n\\n  function policyCheckId(bytes32 policyId) external view returns (bool);\\n\\n  function policyCheckName(string calldata policyName) external view returns (bool);\\n\\n  function policyCheckAdmin(bytes32 policyId, address account) external view returns (bool);\\n\\n  function policyCheckRole(bytes32 roleId) external view returns (bool);\\n\\n  function policyCheckAccess(bytes32 policyId, bytes32 functionId) external view returns (bool);\\n\\n  function policyCheckRoleAccess(bytes32 roleId, bytes32 functionId) external view returns (bool);\\n\\n  function policyHasRole(bytes32 policyId, bytes32 roleId) external view returns (bool);\\n\\n  function policyGetInfoByRole(bytes32 roleId) external view returns (PolicyInfo memory);\\n\\n  function policyGetInfo(bytes32 policyId) external view returns (PolicyInfo memory);\\n\\n  function policyGetRoles(bytes32 policyId) external view returns (bytes32[] memory);\\n}\\n\",\"keccak256\":\"0x1b437e48ec11bfdbc482d65b0a1fe0ae790f58782d31725fb2fe64dddd3dfdeb\",\"license\":\"MIT\"},\"src/contracts/acl/profile/IProfileACL.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title Access Control Interface\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\ninterface IProfileACL {\\n  enum ProfileAuthorizationStatus {\\n    PERMITTED,\\n    UNAUTHORIZED,\\n    POLICY_FORBIDDEN,\\n    PROFILE_CALL_FORBIDDEN,\\n    MEMBER_CALL_FORBIDDEN,\\n    ROLE_SCOPE_FORBIDDEN,\\n    MEMBER_NOT_FOUND,\\n    ROLE_NOT_FOUND,\\n    TYPE_NOT_FOUND,\\n    FUNCTION_NOT_FOUND,\\n    CONTEXT_NOT_FOUND,\\n    REALM_NOT_FOUND,\\n    DOMAIN_NOT_FOUND,\\n    MEMBER_ACTIVITY_FORBIDDEN,\\n    ROLE_ACTIVITY_FORBIDDEN,\\n    TYPE_ACTIVITY_FORBIDDEN,\\n    FUNCTION_ACTIVITY_FORBIDDEN,\\n    CONTEXT_ACTIVITY_FORBIDDEN,\\n    REALM_ACTIVITY_FORBIDDEN,\\n    DOMAIN_ACTIVITY_FORBIDDEN,\\n    UNIVERSE_ACTIVITY_FORBIDDEN,\\n    PROFILE_ACTIVITY_FORBIDDEN\\n  }\\n\\n  error ProfileACLUnauthorized();\\n  error ProfileACLPolicyForbidden();\\n  error ProfileACLCallForbidden();\\n  error ProfileACLRoleScopeForbidden();\\n  error ProfileACLMemberCallForbidden();\\n  error ProfileACLMemberNotFound();\\n  error ProfileACLRoleNotFound();\\n  error ProfileACLTypeNotFound();\\n  error ProfileACLFunctionNotFound();\\n  error ProfileACLContextNotFound();\\n  error ProfileACLRealmNotFound();\\n  error ProfileACLDomainNotFound();\\n  error ProfileACLMemberActivityForbidden();\\n  error ProfileACLRoleActivityForbidden();\\n  error ProfileACLTypeActivityForbidden();\\n  error ProfileACLFunctionActivityForbidden();\\n  error ProfileACLContextActivityForbidden();\\n  error ProfileACLRealmActivityForbidden();\\n  error ProfileACLDomainActivityForbidden();\\n  error ProfileACLUniverseActivityForbidden();\\n  error ProfileACLProfileActivityForbidden();\\n\\n  enum ProfileAdminAccessStatus {\\n    PERMITTED,\\n    NOT_PERMITTED,\\n    POLICY_FORBIDDEN,\\n    ROLE_NOT_FOUND,\\n    TYPE_NOT_FOUND,\\n    FUNCTION_NOT_FOUND,\\n    ROLE_ACTIVITY_FORBIDDEN,\\n    TYPE_ACTIVITY_FORBIDDEN\\n  }\\n\\n  error ProfileAdminAccessNotPermitted();\\n  error ProfileAdminAccessPolicyForbidden();\\n  error ProfileAdminAccessRoleNotFound();\\n  error ProfileAdminAccessTypeNotFound();\\n  error ProfileAdminAccessFunctionNotFound();\\n  error ProfileAdminAccessRoleActivityForbidden();\\n  error ProfileAdminAccessTypeActivityForbidden();\\n\\n  error ProfileSetAdminForbidden(ProfileAdminAccessStatus);\\n\\n  function profileHasAccess(bytes32 profileId, bytes32 functionId) external returns (ProfileAuthorizationStatus);\\n\\n  function profileHasMemberAccess(\\n    bytes32 profileId,\\n    bytes32 functionId,\\n    bytes32 memberId\\n  ) external returns (ProfileAuthorizationStatus);\\n\\n  function profileHasCSAccess(\\n    bytes32 profileId,\\n    address contractId,\\n    bytes4 selector\\n  ) external returns (ProfileAuthorizationStatus);\\n\\n  function profileHasAccountAccess(\\n    bytes32 profileId,\\n    address contractId,\\n    bytes4 selector,\\n    address accountId\\n  ) external returns (ProfileAuthorizationStatus);\\n}\\n\",\"keccak256\":\"0xb3687f11a1d2d28b78e815657864fbe1ef4aeba750e8c9760b3d3f97e467efc2\",\"license\":\"MIT\"},\"src/contracts/acl/profile/IProfileACLGenerals.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../IACLCommons.sol\\\";\\n\\n/**\\n * @title Access Control General Interface\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\ninterface IProfileACLGenerals is IACLCommons {\\n  // Anonymouse type\\n  function profileAnonymousType() external pure returns (bytes32);\\n\\n  // Any type\\n  function profileAnyType() external pure returns (bytes32);\\n\\n  // system master type\\n  function profileSystemMasterType() external pure returns (bytes32);\\n\\n  // profile master type\\n  function profileMasterType() external pure returns (bytes32);\\n\\n  // Universe Scope\\n  function profileUniverseScope() external pure returns (bytes32);\\n\\n  // general\\n  function profileIsAgentExist(bytes32 profileId, bytes32 agentId) external view returns (bool);\\n\\n  function profileIsScopeExist(bytes32 profileId, bytes32 scopeId) external view returns (bool);\\n\\n  function profileScopeBaseInfo(bytes32 profileId, bytes32 scopeId) external view returns (BaseScope memory);\\n\\n  function profileAgentBaseInfo(bytes32 profileId, bytes32 agentId) external view returns (BaseAgent memory);\\n\\n  function profileIsScopesCompatible(\\n    bytes32 profileId,\\n    bytes32 destScopeId,\\n    bytes32 srcScopeId\\n  ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5eeaa7ce1f5f26662cf0368f1c9b415214f37f1659c3a2defccedf0d1943760f\",\"license\":\"MIT\"},\"src/contracts/acl/scope/IFunctionManagement.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../IACLCommons.sol\\\";\\n\\n/**\\n * @title Function Management Interface\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\ninterface IFunctionManagement is IACLCommons {\\n  struct FunctionRegisterRequest {\\n    bytes signature;\\n    bytes32 realmId;\\n    bytes32 salt;\\n    string name;\\n    string version;\\n    address subject;\\n    address deployer;\\n    address contractId;\\n    FunctionRequest[] functions;\\n  }\\n\\n  struct FunctionRequest {\\n    bytes32 adminId;\\n    bytes32 agentId;\\n    bytes4 selector;\\n    uint8 policyCode;\\n    ActivityStatus acstat;\\n    AlterabilityStatus alstat;\\n  }\\n\\n  struct FunctionUpdatePolicyRequest {\\n    bytes32 functionId;\\n    uint8 policyCode;\\n  }\\n\\n  struct FunctionUpdateAgentRequest {\\n    bytes32 functionId;\\n    bytes32 agentId;\\n  }\\n\\n  struct FunctionInfo {\\n    bytes32 adminId;\\n    bytes32 agentId;\\n    bytes32 contextId;\\n    bytes4 selector;\\n    uint32 referredByAgent;\\n    ScopeType stype;\\n    ActivityStatus acstat;\\n    AlterabilityStatus alstat;\\n    AgentType adminType;\\n    AgentType agentType;\\n    uint8 policyCode;\\n  }\\n\\n  event FunctionRegistered(\\n    address indexed sender,\\n    bytes32 indexed contextId,\\n    bytes32 indexed functionId,\\n    bytes32 adminId,\\n    bytes32 agentId\\n  );\\n\\n  event FunctionAdminUpdated(address indexed sender, bytes32 indexed functionId, bytes32 indexed adminId);\\n\\n  event FunctionAgentUpdated(address indexed sender, bytes32 indexed functionId, bytes32 indexed agentId);\\n\\n  event FunctionActivityUpdated(address indexed sender, bytes32 indexed functionId, ActivityStatus acstat);\\n\\n  event FunctionAlterabilityUpdated(address indexed sender, bytes32 indexed functionId, AlterabilityStatus alstat);\\n\\n  event FunctionPolicyUpdated(address indexed sender, bytes32 indexed functionId, uint8 policyCode);\\n\\n  event FunctionRemoved(address indexed sender, bytes32 indexed functionId, bool isSoftDeleted);\\n\\n  function functionRegister(MemberSignature calldata memberSign, FunctionRegisterRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function functionUpdateAdmin(MemberSignature calldata memberSign, UpdateAdminRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function functionUpdateAgent(MemberSignature calldata memberSign, FunctionUpdateAgentRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function functionUpdateActivityStatus(MemberSignature calldata memberSign, UpdateActivityRequest[] calldata requests)\\n    external\\n    returns (bool);\\n\\n  function functionUpdateAlterabilityStatus(\\n    MemberSignature calldata memberSign,\\n    UpdateAlterabilityRequest[] calldata requests\\n  ) external returns (bool);\\n\\n  function functionUpdatePolicyCode(\\n    MemberSignature calldata memberSign,\\n    FunctionUpdatePolicyRequest[] calldata requests\\n  ) external returns (bool);\\n\\n  function functionRemove(MemberSignature calldata memberSign, bytes32[] calldata functions) external returns (bool);\\n\\n  function functionCheckId(bytes32 functionId) external view returns (bool);\\n\\n  function functionCheckSelector(address contractId, bytes4 selector) external view returns (bool);\\n\\n  function functionCheckAdmin(bytes32 functionId, address account) external view returns (bool);\\n\\n  function functionCheckAgent(bytes32 functionId, address account) external view returns (bool);\\n\\n  function functionGetInfo(bytes32 functionId) external view returns (FunctionInfo memory);\\n}\\n\",\"keccak256\":\"0xf9cab043ca2218987527dc17343b3bb632a65ba9be0ab9e863c6c140d9d488b7\",\"license\":\"MIT\"},\"src/contracts/lib/LStrings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v2.0.1)\\n// Author: OpenZeppelin\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary LStrings {\\n  bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n  uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n   */\\n  function toString(uint256 value) internal pure returns (string memory) {\\n    // Inspired by OraclizeAPI's implementation - MIT licence\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n    if (value == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint256 temp = value;\\n    uint256 digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n   */\\n  function toHexString(uint256 value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return \\\"0x00\\\";\\n    }\\n    uint256 temp = value;\\n    uint256 length = 0;\\n    while (temp != 0) {\\n      length++;\\n      temp >>= 8;\\n    }\\n    return toHexString(value, length);\\n  }\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n   */\\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n    bytes memory buffer = new bytes(2 * length + 2);\\n    buffer[0] = \\\"0\\\";\\n    buffer[1] = \\\"x\\\";\\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n      value >>= 4;\\n    }\\n    require(value == 0, \\\"Strings: hex length insufficient\\\");\\n    return string(buffer);\\n  }\\n\\n  /**\\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n   */\\n  function toHexString(address addr) internal pure returns (string memory) {\\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n  }\\n}\\n\",\"keccak256\":\"0xf6b56daea1f2692628dff63bd57ff8ad0bc38ecbc34887db37a8305162ce1394\",\"license\":\"MIT\"},\"src/contracts/lib/acl/LACLAgentScope.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./LACLUtils.sol\\\";\\nimport \\\"./LACLStorage.sol\\\";\\nimport \\\"./LProfileStorage.sol\\\";\\nimport \\\"../struct/LEnumerableSet.sol\\\";\\nimport \\\"../../acl/IACLCommons.sol\\\";\\nimport \\\"../../acl/IACLGenerals.sol\\\";\\nimport \\\"../../acl/IACLManager.sol\\\";\\nimport \\\"../../acl/ACLStorage.sol\\\";\\nimport \\\"../../proxy/IProxy.sol\\\";\\nimport \\\"../../proxy/IERC1822.sol\\\";\\nimport \\\"../../utils/IERC165.sol\\\";\\nimport \\\"../../acl/IACL.sol\\\";\\nimport \\\"../../acl/agent/IRoleManagement.sol\\\";\\nimport \\\"../../acl/agent/IMemberManagement.sol\\\";\\nimport \\\"../../acl/scope/IFunctionManagement.sol\\\";\\nimport \\\"../../acl/policy/IPolicyManagement.sol\\\";\\nimport \\\"../../acl/profile/IProfileACL.sol\\\";\\nimport \\\"../../acl/profile/IProfileACLGenerals.sol\\\";\\n\\n/**\\n * @title ACL Commons Library\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\nlibrary LACLAgentScope {\\n  using LProfileStorage for IACLCommons.ProfileEntity;\\n  using LACLStorage for ACLStorage.DataCollection;\\n  using LEnumerableSet for LEnumerableSet.AddressSet;\\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\\n\\n  string public constant LIB_NAME = \\\"LACLAgentScope\\\";\\n  string public constant LIB_VERSION = \\\"3.0.0\\\";\\n\\n  bytes32 public constant LIVELY_VERSE_ANONYMOUS_TYPE_ID =\\n    keccak256(abi.encodePacked(\\\"TYPE.LIVELY_VERSE.LIVELY_ANONYMOUS\\\"));\\n  bytes32 public constant LIVELY_VERSE_ANY_TYPE_ID = keccak256(abi.encodePacked(\\\"TYPE.LIVELY_VERSE.LIVELY_ANY\\\"));\\n\\n  bytes32 public constant LIVELY_VERSE_LIVELY_MASTER_ADMIN_ROLE_ID =\\n    keccak256(abi.encodePacked(\\\"ROLE.LIVELY_VERSE.LIVELY_MASTER_ADMIN\\\"));\\n\\n  function checkAdminAccess(\\n    ACLStorage.DataCollection storage data,\\n    bytes32 adminId,\\n    bytes32 memberId,\\n    bytes32 functionId\\n  ) external view returns (IACL.AdminAccessStatus) {\\n    return _doCheckAdminAccess(data, adminId, memberId, functionId);\\n  }\\n\\n  function aclRegisterRole(\\n    ACLStorage.DataCollection storage data,\\n    IRoleManagement.RoleRegisterRequest calldata request,\\n    bytes32 functionId,\\n    bytes32 senderId,\\n    uint24 memberLimit\\n  ) external returns (bytes32, bytes32) {\\n    bytes32 newRoleId = LACLUtils.generateId(request.name);\\n    require(data.agents[newRoleId].atype == IACLCommons.AgentType.NONE, \\\"Role Already Exist\\\");\\n    require(\\n      request.acstat > IACLCommons.ActivityStatus.DELETED && request.alstat > IACLCommons.AlterabilityStatus.NONE,\\n      \\\"Illegal Activity/Alterability\\\"\\n    );\\n    require(\\n      request.typeId != LIVELY_VERSE_ANONYMOUS_TYPE_ID && request.typeId != LIVELY_VERSE_ANY_TYPE_ID,\\n      \\\"Illegal Type\\\"\\n    );\\n\\n    // check type\\n    IACLCommons.TypeEntity storage typeEntity = data.typeReadSlot(request.typeId);\\n    require(typeEntity.ba.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \\\"Illegal Type Updatable\\\");\\n    require(typeEntity.roles.length() < typeEntity.roleLimit, \\\"Illegal Register\\\");\\n\\n    // check access\\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(data, typeEntity.ba.adminId, senderId, functionId);\\n    if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\\n\\n    // check and get requested scope type\\n    IACLCommons.ScopeType requestScopeType = _doRoleCheckRequestScope(data, request.scopeId, typeEntity.scopeId);\\n\\n    // add role to type\\n    typeEntity.roles.add(newRoleId);\\n\\n    // create role entity\\n    IACLCommons.RoleEntity storage newRole = data.roleWriteSlot(newRoleId);\\n    newRole.ba.atype = IACLCommons.AgentType.ROLE;\\n    newRole.ba.acstat = request.acstat;\\n    newRole.ba.alstat = request.alstat;\\n    newRole.name = request.name;\\n    newRole.scopeId = request.scopeId;\\n    newRole.memberLimit = request.memberLimit >= 0 ? uint24(uint32(request.memberLimit)) : memberLimit;\\n    newRole.typeId = request.typeId;\\n    newRole.ba.adminId = _getRoleAdmin(data, requestScopeType, typeEntity.ba.adminId, request.scopeId, request.adminId);\\n\\n    return (newRoleId, newRole.ba.adminId);\\n  }\\n\\n  function getPolicyAdmin(\\n    ACLStorage.DataCollection storage data,\\n    IACLCommons.ScopeType requestScopeType,\\n    bytes32 requestScopeAdmin,\\n    bytes32 scopeId,\\n    bytes32 adminId\\n  ) external view returns (bytes32 policyAdminId) {\\n    // checking requested type admin\\n    if (adminId != bytes32(0)) {\\n      require(data.agents[adminId].atype == IACLCommons.AgentType.ROLE, \\\"Illegal Admin AgentType\\\");\\n      (IACLCommons.ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doGetAgentScopeInfo(data, adminId);\\n      require(requestScopeType <= requestAdminScopeType, \\\"Illegal Admin ScopeType\\\");\\n      if (requestScopeType == requestAdminScopeType) {\\n        require(requestAdminScopeId == scopeId, \\\"Illegal Admin Scope\\\");\\n      } else {\\n        require(IACLGenerals(address(this)).isScopesCompatible(requestAdminScopeId, scopeId), \\\"Illegal Admin Scope\\\");\\n      }\\n      policyAdminId = adminId;\\n    } else {\\n      policyAdminId = requestScopeAdmin;\\n    }\\n  }\\n\\n  function getPolicyAndCheckAdminAccess(\\n    ACLStorage.DataCollection storage data,\\n    bytes32 policyId,\\n    bytes32 memberId,\\n    bytes32 functionId\\n  ) external view returns (IACLCommons.PolicyEntity storage) {\\n    return _doGetPolicyAndCheckAdminAccess(data, policyId, memberId, functionId);\\n  }\\n\\n  function getCheckUpdateRequestScope(\\n    ACLStorage.DataCollection storage data,\\n    bytes32 requestScopeId,\\n    bytes32 senderScopeId,\\n    IACLCommons.ScopeType senderScopeType\\n  ) external returns (IACLCommons.BaseScope storage) {\\n    return _getCheckUpdateRequestScope(data, requestScopeId, senderScopeId, senderScopeType);\\n  }\\n\\n  function _getCheckUpdateRequestScope(\\n    ACLStorage.DataCollection storage data,\\n    bytes32 requestScopeId,\\n    bytes32 senderScopeId,\\n    IACLCommons.ScopeType senderScopeType\\n  ) private returns (IACLCommons.BaseScope storage) {\\n    // checking requested type scope\\n    IACLCommons.BaseScope storage requestedScope = data.scopes[requestScopeId];\\n    require(requestedScope.stype != IACLCommons.ScopeType.NONE, \\\"Scope Not Found\\\");\\n    require(requestedScope.acstat > IACLCommons.ActivityStatus.DELETED, \\\"Scope Deleted\\\");\\n\\n    // increase referred count to target scope\\n    requestedScope.referredByAgent += 1;\\n\\n    require(requestedScope.stype <= senderScopeType, \\\"Illegal ScopeType\\\");\\n    if (requestedScope.stype == senderScopeType) {\\n      require(requestScopeId == senderScopeId, \\\"Illegal Scope\\\");\\n    } else {\\n      require(IACLGenerals(address(this)).isScopesCompatible(senderScopeId, requestScopeId), \\\"Illegal Scope\\\");\\n    }\\n\\n    return requestedScope;\\n  }\\n\\n  function roleCheckRequestScope(\\n    ACLStorage.DataCollection storage data,\\n    bytes32 requestScopeId,\\n    bytes32 typeScopeId\\n  ) external returns (IACLCommons.ScopeType) {\\n    return _doRoleCheckRequestScope(data, requestScopeId, typeScopeId);\\n  }\\n\\n  function _doGetPolicyAndCheckAdminAccess(\\n    ACLStorage.DataCollection storage data,\\n    bytes32 policyId,\\n    bytes32 memberId,\\n    bytes32 functionId\\n  ) private view returns (IACLCommons.PolicyEntity storage) {\\n    IACLCommons.PolicyEntity storage policyEntity = data.policies[policyId];\\n    require(policyEntity.adminId != bytes32(0), \\\"Not Found\\\");\\n    require(policyEntity.alstat >= IACLCommons.AlterabilityStatus.UPDATABLE, \\\"Illegal Updatable\\\");\\n    IACL.AdminAccessStatus status = _doCheckAdminAccess(data, policyEntity.adminId, memberId, functionId);\\n    if (status != IACL.AdminAccessStatus.PERMITTED) LACLUtils.generateAdminAccessError(status);\\n    return policyEntity;\\n  }\\n\\n  function _doRoleCheckRequestScope(\\n    ACLStorage.DataCollection storage data,\\n    bytes32 requestScopeId,\\n    bytes32 typeScopeId\\n  ) private returns (IACLCommons.ScopeType) {\\n    // checking requested role scope\\n    IACLCommons.BaseScope storage requestScope = data.scopes[requestScopeId];\\n    require(requestScope.stype != IACLCommons.ScopeType.NONE, \\\"Scope Not Found\\\");\\n    require(requestScope.acstat > IACLCommons.ActivityStatus.DELETED, \\\"Scope Deleted\\\");\\n\\n    // increase referred count to target scope\\n    requestScope.referredByAgent += 1;\\n\\n    // checking requested role type scope with role scope\\n    IACLCommons.ScopeType typeScopeType = data.scopes[typeScopeId].stype;\\n    require(typeScopeType >= requestScope.stype, \\\"Illegal ScopeType\\\");\\n    if (typeScopeType == requestScope.stype) {\\n      require(typeScopeId == requestScopeId, \\\"Illegal Scope\\\");\\n    } else {\\n      require(IACLGenerals(address(this)).isScopesCompatible(typeScopeId, requestScopeId), \\\"Illegal Scope\\\");\\n    }\\n\\n    return requestScope.stype;\\n  }\\n\\n  function updatePolicyScope(\\n    ACLStorage.DataCollection storage data,\\n    IPolicyManagement.UpdateScopeRequest calldata request,\\n    bytes32 functionId,\\n    bytes32 senderId\\n  ) external {\\n    IACLCommons.ScopeType senderScopeType;\\n    bytes32 senderScopeId;\\n    IACLCommons.PolicyEntity storage policyEntity = _doGetPolicyAndCheckAdminAccess(\\n      data,\\n      request.id,\\n      senderId,\\n      functionId\\n    );\\n    IACLCommons.AgentType adminAgentType = data.agents[policyEntity.adminId].atype;\\n    if (adminAgentType == IACLCommons.AgentType.ROLE) {\\n      IACLCommons.RoleEntity storage roleEntity = data.roleReadSlot(policyEntity.adminId);\\n      senderScopeId = roleEntity.scopeId;\\n      senderScopeType = data.scopes[roleEntity.scopeId].stype;\\n    } else {\\n      IACLCommons.TypeEntity storage agentType = data.typeReadSlot(policyEntity.adminId);\\n      bytes32 memberRoleId = agentType.members[senderId];\\n      IACLCommons.RoleEntity storage memberAgentRole = data.roleReadSlot(memberRoleId);\\n      senderScopeType = data.scopes[memberAgentRole.scopeId].stype;\\n      senderScopeId = memberAgentRole.scopeId;\\n    }\\n\\n    IACLCommons.BaseScope storage requestScope = _getCheckUpdateRequestScope(\\n      data,\\n      request.scopeId,\\n      senderScopeId,\\n      senderScopeType\\n    );\\n    IACLCommons.BaseScope storage currentScope = data.scopes[policyEntity.scopeId];\\n    if (policyEntity.roles.length() > 0) {\\n      require(requestScope.stype > currentScope.stype, \\\"Illegal ScopeType\\\");\\n      require(IACLGenerals(address(this)).isScopesCompatible(request.scopeId, policyEntity.scopeId), \\\"Illegal Scope\\\");\\n    }\\n    require(currentScope.referredByAgent > 0, \\\"Illeagl Referred\\\");\\n    unchecked {\\n      currentScope.referredByAgent -= 1;\\n    }\\n    policyEntity.scopeId = request.scopeId;\\n  }\\n\\n  function getAgentScopeInfo(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    external\\n    view\\n    returns (IACLCommons.ScopeType, bytes32)\\n  {\\n    return _doGetAgentScopeInfo(data, agentId);\\n  }\\n\\n  function getRoleAdmin(\\n    ACLStorage.DataCollection storage data,\\n    IACLCommons.ScopeType requestScopeType,\\n    bytes32 requestScopeAdmin,\\n    bytes32 scopeId,\\n    bytes32 adminId\\n  ) external view returns (bytes32 roleAdminId) {\\n    return _getRoleAdmin(data, requestScopeType, requestScopeAdmin, scopeId, adminId);\\n  }\\n\\n  function checkMemberRegisterLimits(\\n    IACLCommons.MemberEntity storage memberEntity,\\n    IACLCommons.GeneralLimit calldata limits\\n  ) external view {\\n    require(memberEntity.limits.memberRegisterLimit >= limits.memberRegisterLimit, \\\"Illegal MemberRegisterLimit\\\");\\n    require(memberEntity.limits.contextRegisterLimit >= limits.contextRegisterLimit, \\\"Illegal ContextRegisterLimit\\\");\\n    require(memberEntity.limits.functionRegisterLimit >= limits.functionRegisterLimit, \\\"Illegal FunctionRegisterLimit\\\");\\n    require(memberEntity.limits.profileRegisterLimit >= limits.profileRegisterLimit, \\\"Illegal ProfileRegisterLimit\\\");\\n    require(memberEntity.limits.roleRegisterLimit >= limits.roleRegisterLimit, \\\"Illegal RoleRegisterLimit\\\");\\n    require(memberEntity.limits.typeRegisterLimit >= limits.typeRegisterLimit, \\\"Illegal TypeRegisterLimit\\\");\\n    require(memberEntity.limits.realmRegisterLimit >= limits.realmRegisterLimit, \\\"Illegal RealmRegisterLimit\\\");\\n    require(memberEntity.limits.domainRegisterLimit >= limits.domainRegisterLimit, \\\"Illegal DomainRegisterLimit\\\");\\n    require(memberEntity.limits.policyRegisterLimit >= limits.policyRegisterLimit, \\\"Illegal PolicyRegisterLimit\\\");\\n    require(memberEntity.limits.memberLimit >= limits.memberLimit, \\\"Illegal MemberLimit\\\");\\n    require(memberEntity.limits.contextLimit >= limits.contextLimit, \\\"Illegal ContextLimit\\\");\\n    require(memberEntity.limits.realmLimit >= limits.realmLimit, \\\"Illegal RealmLimit\\\");\\n    require(memberEntity.limits.domainLimit >= limits.domainLimit, \\\"Illegal DomainLimit\\\");\\n    require(memberEntity.limits.callLimit >= limits.callLimit, \\\"Illegal CallLimit\\\");\\n    require(memberEntity.limits.typeRoleLimit >= limits.typeRoleLimit, \\\"Illegal TypeRoleLimit\\\");\\n    require(memberEntity.limits.typeLimit >= limits.typeLimit, \\\"Illegal TypeLimit\\\");\\n    require(memberEntity.limits.policyRoleLimit >= limits.policyRoleLimit, \\\"Illegal PolicyRoleLimit\\\");\\n    require(memberEntity.limits.functionLimit >= limits.functionLimit, \\\"Illegal FunctionLimit\\\");\\n  }\\n\\n  function _doCheckAdminAccess(\\n    ACLStorage.DataCollection storage data,\\n    bytes32 adminId,\\n    bytes32 memberId,\\n    bytes32 functionId\\n  ) private view returns (IACL.AdminAccessStatus) {\\n    (IACLCommons.FunctionEntity storage functionEntity, bool res) = data.functionTryReadSlot(functionId);\\n    if (!res) return IACL.AdminAccessStatus.FUNCTION_NOT_FOUND;\\n\\n    IACLCommons.AgentType adminAgentType = data.agents[adminId].atype;\\n    if (adminAgentType == IACLCommons.AgentType.ROLE) {\\n      (IACLCommons.RoleEntity storage roleEntity, bool result) = data.roleTryReadSlot(adminId);\\n      if (!result) return IACL.AdminAccessStatus.ROLE_NOT_FOUND;\\n      if (roleEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\\n        return IACL.AdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN;\\n\\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = data.typeTryReadSlot(roleEntity.typeId);\\n      if (!result1) return IACL.AdminAccessStatus.TYPE_NOT_FOUND;\\n      if (typeEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\\n        return IACL.AdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN;\\n\\n      if (typeEntity.members[memberId] != adminId) return IACL.AdminAccessStatus.NOT_PERMITTED;\\n\\n      IACLCommons.PolicyEntity storage policyEntity = data.policies[data.rolePolicyMap[adminId]];\\n      if (\\n        policyEntity.acstat == IACLCommons.ActivityStatus.ENABLED &&\\n        policyEntity.policyCode >= functionEntity.policyCode\\n      ) return IACL.AdminAccessStatus.POLICY_FORBIDDEN;\\n\\n      return IACL.AdminAccessStatus.PERMITTED;\\n    } else if (adminAgentType == IACLCommons.AgentType.TYPE) {\\n      (IACLCommons.TypeEntity storage typeEntity, bool result1) = data.typeTryReadSlot(adminId);\\n      if (!result1) return IACL.AdminAccessStatus.TYPE_NOT_FOUND;\\n      if (typeEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\\n        return IACL.AdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN;\\n\\n      bytes32 roleId = typeEntity.members[memberId];\\n      (IACLCommons.RoleEntity storage roleEntity, bool result2) = data.roleTryReadSlot(roleId);\\n      if (!result2) return IACL.AdminAccessStatus.ROLE_NOT_FOUND;\\n      if (roleEntity.ba.acstat != IACLCommons.ActivityStatus.ENABLED)\\n        return IACL.AdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN;\\n\\n      IACLCommons.PolicyEntity storage policyEntity = data.policies[data.rolePolicyMap[roleId]];\\n      if (\\n        policyEntity.acstat == IACLCommons.ActivityStatus.ENABLED &&\\n        policyEntity.policyCode >= functionEntity.policyCode\\n      ) return IACL.AdminAccessStatus.POLICY_FORBIDDEN;\\n\\n      return IACL.AdminAccessStatus.PERMITTED;\\n    }\\n\\n    return IACL.AdminAccessStatus.NOT_PERMITTED;\\n  }\\n\\n  function _getRoleAdmin(\\n    ACLStorage.DataCollection storage data,\\n    IACLCommons.ScopeType requestScopeType,\\n    bytes32 requestScopeAdmin,\\n    bytes32 scopeId,\\n    bytes32 adminId\\n  ) private view returns (bytes32 roleAdminId) {\\n    // checking requested type admin\\n    if (adminId != bytes32(0)) {\\n      require(data.agents[adminId].atype > IACLCommons.AgentType.MEMBER, \\\"Illegal Admin AgentType\\\");\\n      (IACLCommons.ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doGetAgentScopeInfo(data, adminId);\\n      require(requestScopeType <= requestAdminScopeType, \\\"Illegal Admin ScopeType\\\");\\n      if (requestScopeType == requestAdminScopeType) {\\n        require(requestAdminScopeId == scopeId, \\\"Illegal Admin Scope\\\");\\n      } else {\\n        require(IACLGenerals(address(this)).isScopesCompatible(requestAdminScopeId, scopeId), \\\"Illegal Admin Scope\\\");\\n      }\\n      roleAdminId = adminId;\\n    } else {\\n      roleAdminId = requestScopeAdmin;\\n    }\\n  }\\n\\n  function getAndCheckFunctionAdmin(\\n    ACLStorage.DataCollection storage data,\\n    bytes32 contextAdminId,\\n    bytes32 contextId,\\n    bytes32 adminId\\n  ) external view returns (bytes32 functionAdminId) {\\n    return _doGetAndCheckFunctionAdmin(data, contextAdminId, contextId, adminId);\\n  }\\n\\n  function _doGetAgentScopeInfo(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    private\\n    view\\n    returns (IACLCommons.ScopeType, bytes32)\\n  {\\n    IACLCommons.AgentType atype = data.agents[agentId].atype;\\n    if (atype == IACLCommons.AgentType.ROLE) {\\n      IACLCommons.RoleEntity storage roleEntity = data.roleReadSlot(agentId);\\n      IACLCommons.BaseScope storage baseScope = data.scopes[roleEntity.scopeId];\\n      return (baseScope.stype, roleEntity.scopeId);\\n    } else if (atype == IACLCommons.AgentType.TYPE) {\\n      IACLCommons.TypeEntity storage typeEntity = data.typeReadSlot(agentId);\\n      IACLCommons.BaseScope storage baseScope = data.scopes[typeEntity.scopeId];\\n      return (baseScope.stype, typeEntity.scopeId);\\n    }\\n\\n    return (IACLCommons.ScopeType.NONE, bytes32(0));\\n  }\\n\\n  function _doGetAndCheckFunctionAdmin(\\n    ACLStorage.DataCollection storage data,\\n    bytes32 contextAdminId,\\n    bytes32 contextId,\\n    bytes32 requestAdminId\\n  ) private view returns (bytes32 functionAdminId) {\\n    // checking requested functionAdmin admin\\n    if (requestAdminId != bytes32(0)) {\\n      require(data.agents[requestAdminId].atype > IACLCommons.AgentType.MEMBER, \\\"Illegal Admin AgentType\\\");\\n\\n      (IACLCommons.ScopeType requestAdminScopeType, bytes32 requestAdminScopeId) = _doGetAgentScopeInfo(\\n        data,\\n        requestAdminId\\n      );\\n      require(IACLCommons.ScopeType.CONTEXT <= requestAdminScopeType, \\\"Illegal Admin ScopeType\\\");\\n      if (IACLCommons.ScopeType.CONTEXT == requestAdminScopeType) {\\n        require(requestAdminScopeId == contextAdminId, \\\"Illegal Admin Scope\\\");\\n      } else {\\n        require(IACLGenerals(address(this)).isScopesCompatible(requestAdminScopeId, contextId), \\\"Illegal Admin Scope\\\");\\n      }\\n      functionAdminId = requestAdminId;\\n    } else {\\n      functionAdminId = contextAdminId;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x19ea5fb85b47e563a7f2345c6ad4bc2ab85298c1e9ed663c210621e4b2a6fb5f\",\"license\":\"MIT\"},\"src/contracts/lib/acl/LACLStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../../acl/IACLCommons.sol\\\";\\nimport \\\"../../acl/ACLStorage.sol\\\";\\n\\n/**\\n * @title ACL Storage Library\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\nlibrary LACLStorage {\\n  function universeReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.UniverseEntity storage ge)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.UNIVERSE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        ge.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\\n      revert(\\\"GID Not Found\\\");\\n    } else {\\n      revert(\\\"Illeagl GID Slot\\\");\\n    }\\n  }\\n\\n  function universeWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.UniverseEntity storage ge)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.UNIVERSE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        ge.slot := keccak256(ptr, 0x40)\\n      }\\n    } else {\\n      revert(\\\"Illegal GID Slot\\\");\\n    }\\n  }\\n\\n  function functionReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.FunctionEntity storage fc)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.FUNCTION) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        fc.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\\n      revert(\\\"FID Not Found\\\");\\n    } else {\\n      revert(\\\"Illeagl FID Slot\\\");\\n    }\\n  }\\n\\n  function functionTryReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.FunctionEntity storage fc, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.FUNCTION) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        fc.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        fc.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function functionWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.FunctionEntity storage fc)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.FUNCTION) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        fc.slot := keccak256(ptr, 0x40)\\n      }\\n    } else {\\n      revert(\\\"Illegal FID Slot\\\");\\n    }\\n  }\\n\\n  function functionTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.FunctionEntity storage fe, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.FUNCTION) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        fe.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        fe.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function contextReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.ContextEntity storage ce)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.CONTEXT) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        ce.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\\n      revert(\\\"CID Not Found\\\");\\n    } else {\\n      revert(\\\"Illegal CID Slot\\\");\\n    }\\n  }\\n\\n  function contextTryReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.ContextEntity storage ce, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.CONTEXT) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        ce.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        ce.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function contextWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.ContextEntity storage ce)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.CONTEXT) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        ce.slot := keccak256(ptr, 0x40)\\n      }\\n    } else {\\n      revert(\\\"Illegal CID Slot\\\");\\n    }\\n  }\\n\\n  function contextTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.ContextEntity storage ce, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.CONTEXT) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        ce.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        ce.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function realmReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.RealmEntity storage re)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.REALM) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        re.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\\n      revert(\\\"RID Not Found\\\");\\n    } else {\\n      revert(\\\"Illeagl RID Slot\\\");\\n    }\\n  }\\n\\n  function realmTryReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.RealmEntity storage re, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.REALM) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        re.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function realmWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.RealmEntity storage re)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.REALM) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        let slot := keccak256(ptr, 0x40)\\n        re.slot := slot\\n      }\\n    } else {\\n      revert(\\\"Illeagl RID Slot\\\");\\n    }\\n  }\\n\\n  function realmTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.RealmEntity storage re, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.REALM) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        re.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function domainReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.DomainEntity storage de)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.DOMAIN) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        de.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\\n      revert(\\\"DID Not Found\\\");\\n    } else {\\n      revert(\\\"Illegal DID Slot\\\");\\n    }\\n  }\\n\\n  function domainTryReadSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.DomainEntity storage de, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.DOMAIN) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        de.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        de.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function domainWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.DomainEntity storage de)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.DOMAIN) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        de.slot := keccak256(ptr, 0x40)\\n      }\\n    } else {\\n      revert(\\\"Illegal DID Slot\\\");\\n    }\\n  }\\n\\n  function domainTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.DomainEntity storage de, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = data.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.DOMAIN) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(data.slot, 1))\\n        de.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        de.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function memberReadSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.MemberEntity storage me)\\n  {\\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.MEMBER) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(data.slot, 0))\\n        me.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (ba.atype == IACLCommons.AgentType.NONE) {\\n      revert(\\\"MID Not Found\\\");\\n    } else {\\n      revert(\\\"Illegal MID Slot\\\");\\n    }\\n  }\\n\\n  function memberTryReadSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.MemberEntity storage me, bool result)\\n  {\\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.MEMBER) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(data.slot, 0))\\n        me.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        me.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function memberWriteSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.MemberEntity storage me)\\n  {\\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.MEMBER) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(data.slot, 0))\\n        me.slot := keccak256(ptr, 0x40)\\n      }\\n    } else {\\n      revert(\\\"Illegal MID Slot\\\");\\n    }\\n  }\\n\\n  function memberTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.MemberEntity storage me, bool result)\\n  {\\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.MEMBER) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(data.slot, 0))\\n        me.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        me.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function roleReadSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.RoleEntity storage re)\\n  {\\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.ROLE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(data.slot, 0))\\n        re.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (ba.atype == IACLCommons.AgentType.NONE) {\\n      revert(\\\"RoleId Not Found\\\");\\n    } else {\\n      revert(\\\"Illegal RoleId Slot\\\");\\n    }\\n  }\\n\\n  function roleTryReadSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.RoleEntity storage re, bool result)\\n  {\\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.ROLE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(data.slot, 0))\\n        re.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function roleWriteSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.RoleEntity storage re)\\n  {\\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.ROLE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(data.slot, 0))\\n        let slot := keccak256(ptr, 0x40)\\n        re.slot := slot\\n      }\\n    } else {\\n      revert(\\\"Illegal RoleId Slot\\\");\\n    }\\n  }\\n\\n  function roleTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.RoleEntity storage re, bool result)\\n  {\\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.ROLE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(data.slot, 0))\\n        let slot := keccak256(ptr, 0x40)\\n        re.slot := slot\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function typeReadSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.TypeEntity storage te)\\n  {\\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.TYPE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(data.slot, 0))\\n        te.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (ba.atype == IACLCommons.AgentType.NONE) {\\n      revert(\\\"TID Not Found\\\");\\n    } else {\\n      revert(\\\"Illegal TID Slot\\\");\\n    }\\n  }\\n\\n  function typeTryReadSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.TypeEntity storage te, bool result)\\n  {\\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.TYPE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(data.slot, 0))\\n        te.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        te.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n\\n  function typeWriteSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.TypeEntity storage te)\\n  {\\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.TYPE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(data.slot, 0))\\n        te.slot := keccak256(ptr, 0x40)\\n      }\\n    } else {\\n      revert(\\\"Illegal TID Slot\\\");\\n    }\\n  }\\n\\n  function typeTryWriteSlot(ACLStorage.DataCollection storage data, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.TypeEntity storage te, bool result)\\n  {\\n    IACLCommons.BaseAgent storage ba = data.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.TYPE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(data.slot, 0))\\n        te.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n    } else {\\n      assembly {\\n        te.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n      }\\n      result = false;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x1db1476a40cb3e0912d1c07d6ed6c1e9171f6960014e49b66e3532610c80bb6d\",\"license\":\"MIT\"},\"src/contracts/lib/acl/LACLUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../../proxy/IProxy.sol\\\";\\nimport \\\"../../acl/IACL.sol\\\";\\nimport \\\"../../acl/IACLCommons.sol\\\";\\nimport \\\"../../acl/profile/IProfileACL.sol\\\";\\nimport \\\"../../acl/ACLStorage.sol\\\";\\nimport \\\"../cryptography/LECDSA.sol\\\";\\n\\n/**\\n * @title Context Utils Library\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\nlibrary LACLUtils {\\n  function functionGenerateId(address contractId, bytes4 selector) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(contractId, selector));\\n  }\\n\\n  function accountGenerateId(address account) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(account));\\n  }\\n\\n  function generateId(string calldata name) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(name));\\n  }\\n\\n  function generateId2(string memory name) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(name));\\n  }\\n\\n  function generateHash(string memory name) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(name));\\n  }\\n\\n  function getMemeberSignerAddress(IACLCommons.MemberSignature calldata memberSign, bytes32 msgTypeHash)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return\\n      getSignerAddress(\\n        memberSign.signature,\\n        _generateMemberSignMsgHash(msgTypeHash, memberSign.account, memberSign.expiredAt)\\n      );\\n  }\\n\\n  function getProfileMemeberSignerAddress(IACLCommons.ProfileMemberSignature calldata memberSign, bytes32 msgTypeHash)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return\\n      getSignerAddress(\\n        memberSign.signature,\\n        _generateProfileMemberSignMsgHash(\\n          msgTypeHash,\\n          generateId(memberSign.profileName),\\n          memberSign.account,\\n          memberSign.expiredAt\\n        )\\n      );\\n  }\\n\\n  function _hashTypedDataV4(bytes32 structHash) private view returns (bytes32) {\\n    return LECDSA.toTypedDataHash(IProxy(address(this)).domainSeparator(), structHash);\\n  }\\n\\n  function _generateMemberSignMsgHash(\\n    bytes32 msgTypeHash,\\n    address account,\\n    uint256 expiredAt\\n  ) private pure returns (bytes32) {\\n    return keccak256(abi.encode(msgTypeHash, account, expiredAt));\\n  }\\n\\n  function _generateProfileMemberSignMsgHash(\\n    bytes32 msgTypeHash,\\n    bytes32 profileName,\\n    address account,\\n    uint256 expiredAt\\n  ) private pure returns (bytes32) {\\n    return keccak256(abi.encode(msgTypeHash, profileName, account, expiredAt));\\n  }\\n\\n  function getSignerAddress(bytes memory signature, bytes32 structHash) internal view returns (address) {\\n    bytes32 msgDigest = _hashTypedDataV4(structHash);\\n    (address msgSigner, LECDSA.RecoverError recoverErr) = LECDSA.tryRecover(msgDigest, signature);\\n    require(recoverErr == LECDSA.RecoverError.NoError, \\\"Illegal Signature\\\");\\n    return msgSigner;\\n  }\\n\\n  function generateAuthorizationError(IACL.AuthorizationStatus status) internal pure {\\n    if (status == IACL.AuthorizationStatus.UNAUTHORIZED) revert IACL.ACLUnauthorized();\\n    else if (status == IACL.AuthorizationStatus.POLICY_FORBIDDEN) revert IACL.ACLPolicyForbidden();\\n    else if (status == IACL.AuthorizationStatus.CALL_FORBIDDEN) revert IACL.ACLCallForbidden();\\n    else if (status == IACL.AuthorizationStatus.ROLE_SCOPE_FORBIDDEN) revert IACL.ACLRoleScopeForbidden();\\n    else if (status == IACL.AuthorizationStatus.MEMBER_NOT_FOUND) revert IACL.ACLMemberNotFound();\\n    else if (status == IACL.AuthorizationStatus.ROLE_NOT_FOUND) revert IACL.ACLRoleNotFound();\\n    else if (status == IACL.AuthorizationStatus.TYPE_NOT_FOUND) revert IACL.ACLTypeNotFound();\\n    else if (status == IACL.AuthorizationStatus.FUNCTION_NOT_FOUND) revert IACL.ACLFunctionNotFound();\\n    else if (status == IACL.AuthorizationStatus.CONTEXT_NOT_FOUND) revert IACL.ACLContextNotFound();\\n    else if (status == IACL.AuthorizationStatus.REALM_NOT_FOUND) revert IACL.ACLRealmNotFound();\\n    else if (status == IACL.AuthorizationStatus.DOMAIN_NOT_FOUND) revert IACL.ACLDomainNotFound();\\n    else if (status == IACL.AuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN) revert IACL.ACLMemberActivityForbidden();\\n    else if (status == IACL.AuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN) revert IACL.ACLRoleActivityForbidden();\\n    else if (status == IACL.AuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN) revert IACL.ACLTypeActivityForbidden();\\n    else if (status == IACL.AuthorizationStatus.FUNCTION_ACTIVITY_FORBIDDEN) revert IACL.ACLFunctionActivityForbidden();\\n    else if (status == IACL.AuthorizationStatus.CONTEXT_ACTIVITY_FORBIDDEN) revert IACL.ACLContextActivityForbidden();\\n    else if (status == IACL.AuthorizationStatus.REALM_ACTIVITY_FORBIDDEN) revert IACL.ACLRealmActivityForbidden();\\n    else if (status == IACL.AuthorizationStatus.DOMAIN_ACTIVITY_FORBIDDEN) revert IACL.ACLDomainActivityForbidden();\\n    else if (status == IACL.AuthorizationStatus.UNIVERSE_ACTIVITY_FORBIDDEN) revert IACL.ACLUniverseActivityForbidden();\\n    else revert(\\\"Unknown ERR\\\");\\n  }\\n\\n  function generateProfileAuthorizationError(IProfileACL.ProfileAuthorizationStatus status) internal pure {\\n    if (status == IProfileACL.ProfileAuthorizationStatus.UNAUTHORIZED) revert IProfileACL.ProfileACLUnauthorized();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.POLICY_FORBIDDEN)\\n      revert IProfileACL.ProfileACLPolicyForbidden();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.PROFILE_CALL_FORBIDDEN)\\n      revert IProfileACL.ProfileACLCallForbidden();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.MEMBER_CALL_FORBIDDEN)\\n      revert IProfileACL.ProfileACLMemberCallForbidden();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.ROLE_SCOPE_FORBIDDEN)\\n      revert IProfileACL.ProfileACLRoleScopeForbidden();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.MEMBER_NOT_FOUND)\\n      revert IProfileACL.ProfileACLMemberNotFound();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.ROLE_NOT_FOUND)\\n      revert IProfileACL.ProfileACLRoleNotFound();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.TYPE_NOT_FOUND)\\n      revert IProfileACL.ProfileACLTypeNotFound();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.FUNCTION_NOT_FOUND)\\n      revert IProfileACL.ProfileACLFunctionNotFound();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.CONTEXT_NOT_FOUND)\\n      revert IProfileACL.ProfileACLContextNotFound();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.REALM_NOT_FOUND)\\n      revert IProfileACL.ProfileACLRealmNotFound();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.DOMAIN_NOT_FOUND)\\n      revert IProfileACL.ProfileACLDomainNotFound();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.MEMBER_ACTIVITY_FORBIDDEN)\\n      revert IProfileACL.ProfileACLMemberActivityForbidden();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.ROLE_ACTIVITY_FORBIDDEN)\\n      revert IProfileACL.ProfileACLRoleActivityForbidden();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.TYPE_ACTIVITY_FORBIDDEN)\\n      revert IProfileACL.ProfileACLTypeActivityForbidden();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.FUNCTION_ACTIVITY_FORBIDDEN)\\n      revert IProfileACL.ProfileACLFunctionActivityForbidden();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.CONTEXT_ACTIVITY_FORBIDDEN)\\n      revert IProfileACL.ProfileACLContextActivityForbidden();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.REALM_ACTIVITY_FORBIDDEN)\\n      revert IProfileACL.ProfileACLRealmActivityForbidden();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.DOMAIN_ACTIVITY_FORBIDDEN)\\n      revert IProfileACL.ProfileACLDomainActivityForbidden();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.UNIVERSE_ACTIVITY_FORBIDDEN)\\n      revert IProfileACL.ProfileACLUniverseActivityForbidden();\\n    else if (status == IProfileACL.ProfileAuthorizationStatus.PROFILE_ACTIVITY_FORBIDDEN)\\n      revert IProfileACL.ProfileACLProfileActivityForbidden();\\n    else revert(\\\"Unknown ERR\\\");\\n  }\\n\\n  function generateProfileAdminAccessError(IProfileACL.ProfileAdminAccessStatus status) internal pure {\\n    if (status == IProfileACL.ProfileAdminAccessStatus.NOT_PERMITTED)\\n      revert IProfileACL.ProfileAdminAccessNotPermitted();\\n    else if (status == IProfileACL.ProfileAdminAccessStatus.POLICY_FORBIDDEN)\\n      revert IProfileACL.ProfileAdminAccessPolicyForbidden();\\n    else if (status == IProfileACL.ProfileAdminAccessStatus.ROLE_NOT_FOUND)\\n      revert IProfileACL.ProfileAdminAccessRoleNotFound();\\n    else if (status == IProfileACL.ProfileAdminAccessStatus.TYPE_NOT_FOUND)\\n      revert IProfileACL.ProfileAdminAccessTypeNotFound();\\n    else if (status == IProfileACL.ProfileAdminAccessStatus.FUNCTION_NOT_FOUND)\\n      revert IProfileACL.ProfileAdminAccessFunctionNotFound();\\n    else if (status == IProfileACL.ProfileAdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN)\\n      revert IProfileACL.ProfileAdminAccessRoleActivityForbidden();\\n    else if (status == IProfileACL.ProfileAdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN)\\n      revert IProfileACL.ProfileAdminAccessTypeActivityForbidden();\\n    else revert(\\\"Unknown ERR\\\");\\n  }\\n\\n  function generateAdminAccessError(IACL.AdminAccessStatus status) internal pure {\\n    if (status == IACL.AdminAccessStatus.NOT_PERMITTED) revert IACL.AdminAccessNotPermitted();\\n    else if (status == IACL.AdminAccessStatus.POLICY_FORBIDDEN) revert IACL.AdminAccessPolicyForbidden();\\n    else if (status == IACL.AdminAccessStatus.ROLE_NOT_FOUND) revert IACL.AdminAccessRoleNotFound();\\n    else if (status == IACL.AdminAccessStatus.TYPE_NOT_FOUND) revert IACL.AdminAccessTypeNotFound();\\n    else if (status == IACL.AdminAccessStatus.FUNCTION_NOT_FOUND) revert IACL.AdminAccessFunctionNotFound();\\n    else if (status == IACL.AdminAccessStatus.ROLE_ACTIVITY_FORBIDDEN) revert IACL.AdminAccessRoleActivityForbidden();\\n    else if (status == IACL.AdminAccessStatus.TYPE_ACTIVITY_FORBIDDEN) revert IACL.AdminAccessTypeActivityForbidden();\\n    else revert(\\\"Unknown ERR\\\");\\n  }\\n}\\n\",\"keccak256\":\"0x0a1ead86733fdae5c48faf98479dea608f2a5743722b7d458981c33ff13489c1\",\"license\":\"MIT\"},\"src/contracts/lib/acl/LProfileStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../../acl/IACLCommons.sol\\\";\\nimport \\\"../../acl/ACLStorage.sol\\\";\\n\\n/**\\n * @title ACL Storage Library\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\nlibrary LProfileStorage {\\n  function profileUniverseReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.UniverseEntity storage ge)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.UNIVERSE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        ge.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\\n      revert(\\\"GID Not Found\\\");\\n    } else {\\n      revert(\\\"Illeagl GID Slot\\\");\\n    }\\n  }\\n\\n  function profileUniverseWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.UniverseEntity storage ge)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.UNIVERSE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        ge.slot := keccak256(ptr, 0x40)\\n      }\\n    } else {\\n      revert(\\\"Illegal GID Slot\\\");\\n    }\\n  }\\n\\n  function profileFunctionReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.FunctionEntity storage fe)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.FUNCTION) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        fe.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\\n      revert(\\\"FID Not Found\\\");\\n    } else {\\n      revert(\\\"Illeagl FID Slot\\\");\\n    }\\n  }\\n\\n  function profileFunctionTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.FunctionEntity storage fe, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.FUNCTION) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        fe.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (fe, result);\\n    }\\n    assembly {\\n      fe.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileFunctionWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.FunctionEntity storage fe)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.FUNCTION) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        fe.slot := keccak256(ptr, 0x40)\\n      }\\n    } else {\\n      revert(\\\"Illegal FID Slot\\\");\\n    }\\n  }\\n\\n  function profileFunctionTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.FunctionEntity storage fe, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.FUNCTION) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        fe.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (fe, result);\\n    }\\n    assembly {\\n      fe.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileContextReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.ContextEntity storage ce)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.CONTEXT) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        ce.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\\n      revert(\\\"CID Not Found\\\");\\n    } else {\\n      revert(\\\"Illegal CID Slot\\\");\\n    }\\n  }\\n\\n  function profileContextTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.ContextEntity storage ce, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.CONTEXT) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        ce.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (ce, result);\\n    }\\n    assembly {\\n      ce.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileContextWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.ContextEntity storage ce)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.CONTEXT) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        ce.slot := keccak256(ptr, 0x40)\\n      }\\n    } else {\\n      revert(\\\"Illegal CID Slot\\\");\\n    }\\n  }\\n\\n  function profileContextTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.ContextEntity storage ce, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.CONTEXT) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        ce.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (ce, result);\\n    }\\n    assembly {\\n      ce.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileRealmReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.RealmEntity storage re)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.REALM) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        re.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\\n      revert(\\\"RID Not Found\\\");\\n    } else {\\n      revert(\\\"Illeagl RID Slot\\\");\\n    }\\n  }\\n\\n  function profileRealmTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.RealmEntity storage re, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.REALM) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        re.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (re, result);\\n    }\\n    assembly {\\n      re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileRealmWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.RealmEntity storage re)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.REALM) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        let slot := keccak256(ptr, 0x40)\\n        re.slot := slot\\n      }\\n    } else {\\n      revert(\\\"Illeagl RID Slot\\\");\\n    }\\n  }\\n\\n  function profileRealmTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.RealmEntity storage re, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.REALM) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        re.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (re, result);\\n    }\\n    assembly {\\n      re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileDomainReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.DomainEntity storage de)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.DOMAIN) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        de.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (bs.stype == IACLCommons.ScopeType.NONE) {\\n      revert(\\\"DID Not Found\\\");\\n    } else {\\n      revert(\\\"Illegal DID Slot\\\");\\n    }\\n  }\\n\\n  function profileDomainTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.DomainEntity storage de, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.DOMAIN) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        de.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (de, result);\\n    }\\n    assembly {\\n      de.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileDomainWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.DomainEntity storage de)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.DOMAIN) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        de.slot := keccak256(ptr, 0x40)\\n      }\\n    } else {\\n      revert(\\\"Illegal DID Slot\\\");\\n    }\\n  }\\n\\n  function profileDomainTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 scopeId)\\n    internal\\n    view\\n    returns (IACLCommons.DomainEntity storage de, bool result)\\n  {\\n    IACLCommons.BaseScope storage bs = profileEntity.scopes[scopeId];\\n    if (bs.stype == IACLCommons.ScopeType.NONE || bs.stype == IACLCommons.ScopeType.DOMAIN) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), scopeId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 1))\\n        de.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (de, result);\\n    }\\n    assembly {\\n      de.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileMemberReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.ProfileMemberEntity storage me)\\n  {\\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.MEMBER) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\\n        me.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (ba.atype == IACLCommons.AgentType.NONE) {\\n      revert(\\\"MID Not Found\\\");\\n    } else {\\n      revert(\\\"Illegal MID Slot\\\");\\n    }\\n  }\\n\\n  function profileMemberTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.ProfileMemberEntity storage me, bool result)\\n  {\\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.MEMBER) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\\n        me.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (me, result);\\n    }\\n    assembly {\\n      me.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileMemberWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.ProfileMemberEntity storage me)\\n  {\\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.MEMBER) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\\n        me.slot := keccak256(ptr, 0x40)\\n      }\\n    } else {\\n      revert(\\\"Illegal MID Slot\\\");\\n    }\\n  }\\n\\n  function profileMemberTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.ProfileMemberEntity storage me, bool result)\\n  {\\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.MEMBER) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\\n        me.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (me, result);\\n    }\\n    assembly {\\n      me.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileRoleReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.RoleEntity storage re)\\n  {\\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.ROLE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\\n        re.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (ba.atype == IACLCommons.AgentType.NONE) {\\n      revert(\\\"RoleId Not Found\\\");\\n    } else {\\n      revert(\\\"Illegal RoleId Slot\\\");\\n    }\\n  }\\n\\n  function profileRoleTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.RoleEntity storage re, bool result)\\n  {\\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.ROLE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\\n        re.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (re, result);\\n    }\\n    assembly {\\n      re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileRoleWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.RoleEntity storage re)\\n  {\\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.ROLE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\\n        let slot := keccak256(ptr, 0x40)\\n        re.slot := slot\\n      }\\n    } else {\\n      revert(\\\"Illegal RoleId Slot\\\");\\n    }\\n  }\\n\\n  function profileRoleTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.RoleEntity storage re, bool result)\\n  {\\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.ROLE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\\n        let slot := keccak256(ptr, 0x40)\\n        re.slot := slot\\n      }\\n      result = true;\\n      return (re, result);\\n    }\\n    assembly {\\n      re.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileTypeReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.TypeEntity storage te)\\n  {\\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.TYPE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\\n        te.slot := keccak256(ptr, 0x40)\\n      }\\n    } else if (ba.atype == IACLCommons.AgentType.NONE) {\\n      revert(\\\"TID Not Found\\\");\\n    } else {\\n      revert(\\\"Illegal TID Slot\\\");\\n    }\\n  }\\n\\n  function profileTypeTryReadSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.TypeEntity storage te, bool result)\\n  {\\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.TYPE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\\n        te.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (te, result);\\n    }\\n    assembly {\\n      te.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n\\n  function profileTypeWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.TypeEntity storage te)\\n  {\\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.TYPE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\\n        te.slot := keccak256(ptr, 0x40)\\n      }\\n    } else {\\n      revert(\\\"Illegal TID Slot\\\");\\n    }\\n  }\\n\\n  function profileTypeTryWriteSlot(IACLCommons.ProfileEntity storage profileEntity, bytes32 agentId)\\n    internal\\n    view\\n    returns (IACLCommons.TypeEntity storage te, bool result)\\n  {\\n    IACLCommons.BaseAgent storage ba = profileEntity.agents[agentId];\\n    if (ba.atype == IACLCommons.AgentType.NONE || ba.atype == IACLCommons.AgentType.TYPE) {\\n      assembly {\\n        let ptr := mload(0x40)\\n        mstore(add(ptr, 0x00), agentId)\\n        mstore(add(ptr, 0x20), add(profileEntity.slot, 0))\\n        te.slot := keccak256(ptr, 0x40)\\n      }\\n      result = true;\\n      return (te, result);\\n    }\\n    assembly {\\n      te.slot := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n    }\\n    result = false;\\n  }\\n}\\n\",\"keccak256\":\"0xe95300b9bb0c9fa78648108acf843bd0609e08a60b03b61a79f271f5fcb46b91\",\"license\":\"MIT\"},\"src/contracts/lib/cryptography/LECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v2.0.1)\\n// Author: OpenZeppelin\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../LStrings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary LECDSA {\\n  enum RecoverError {\\n    NoError,\\n    InvalidSignature,\\n    InvalidSignatureLength,\\n    InvalidSignatureS,\\n    InvalidSignatureV\\n  }\\n\\n  function _throwError(RecoverError error) private pure {\\n    if (error == RecoverError.NoError) {\\n      return; // no error: do nothing\\n    } else if (error == RecoverError.InvalidSignature) {\\n      revert(\\\"ECDSA: invalid signature\\\");\\n    } else if (error == RecoverError.InvalidSignatureLength) {\\n      revert(\\\"ECDSA: invalid signature length\\\");\\n    } else if (error == RecoverError.InvalidSignatureS) {\\n      revert(\\\"ECDSA: invalid signature 's' value\\\");\\n    } else if (error == RecoverError.InvalidSignatureV) {\\n      revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the address that signed a hashed message (`hash`) with\\n   * `signature` or error string. This address can then be used for verification purposes.\\n   *\\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n   * this function rejects them by requiring the `s` value to be in the lower\\n   * half order, and the `v` value to be either 27 or 28.\\n   *\\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n   * verification to be secure: it is possible to craft signatures that\\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n   * this is by receiving a hash of the original message (which may otherwise\\n   * be too long), and then calling {toEthSignedMessageHash} on it.\\n   *\\n   * Documentation for signature generation:\\n   * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n   * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n   *\\n   */\\n  function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n    // Check the signature length\\n    // - case 65: r,s,v signature (standard)\\n    // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n    if (signature.length == 65) {\\n      bytes32 r;\\n      bytes32 s;\\n      uint8 v;\\n      // ecrecover takes the signature parameters, and the only way to get them\\n      // currently is to use assembly.\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        r := mload(add(signature, 0x20))\\n        s := mload(add(signature, 0x40))\\n        v := byte(0, mload(add(signature, 0x60)))\\n      }\\n      return tryRecover(hash, v, r, s);\\n    } else if (signature.length == 64) {\\n      bytes32 r;\\n      bytes32 vs;\\n      // ecrecover takes the signature parameters, and the only way to get them\\n      // currently is to use assembly.\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        r := mload(add(signature, 0x20))\\n        vs := mload(add(signature, 0x40))\\n      }\\n      return tryRecover(hash, r, vs);\\n    } else {\\n      return (address(0), RecoverError.InvalidSignatureLength);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the address that signed a hashed message (`hash`) with\\n   * `signature`. This address can then be used for verification purposes.\\n   *\\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n   * this function rejects them by requiring the `s` value to be in the lower\\n   * half order, and the `v` value to be either 27 or 28.\\n   *\\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n   * verification to be secure: it is possible to craft signatures that\\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n   * this is by receiving a hash of the original message (which may otherwise\\n   * be too long), and then calling {toEthSignedMessageHash} on it.\\n   */\\n  function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\\n    _throwError(error);\\n    return recovered;\\n  }\\n\\n  /**\\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n   *\\n   * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n   */\\n  function tryRecover(\\n    bytes32 hash,\\n    bytes32 r,\\n    bytes32 vs\\n  ) internal pure returns (address, RecoverError) {\\n    bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\\n    return tryRecover(hash, v, r, s);\\n  }\\n\\n  /**\\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n   */\\n  function recover(\\n    bytes32 hash,\\n    bytes32 r,\\n    bytes32 vs\\n  ) internal pure returns (address) {\\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n    _throwError(error);\\n    return recovered;\\n  }\\n\\n  /**\\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n   * `r` and `s` signature fields separately.\\n   */\\n  function tryRecover(\\n    bytes32 hash,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal pure returns (address, RecoverError) {\\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n    // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n    //\\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n    // these malleable signatures as well.\\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n      return (address(0), RecoverError.InvalidSignatureS);\\n    }\\n    if (v != 27 && v != 28) {\\n      return (address(0), RecoverError.InvalidSignatureV);\\n    }\\n\\n    // If the signature is valid (and not malleable), return the signer address\\n    address signer = ecrecover(hash, v, r, s);\\n    if (signer == address(0)) {\\n      return (address(0), RecoverError.InvalidSignature);\\n    }\\n\\n    return (signer, RecoverError.NoError);\\n  }\\n\\n  /**\\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\\n   * `r` and `s` signature fields separately.\\n   */\\n  function recover(\\n    bytes32 hash,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal pure returns (address) {\\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n    _throwError(error);\\n    return recovered;\\n  }\\n\\n  /**\\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n   * produces hash corresponding to the one signed with the\\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n   * JSON-RPC method as part of EIP-191.\\n   *\\n   * See {recover}.\\n   */\\n  function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n    // 32 is the length in bytes of hash,\\n    // enforced by the type signature above\\n    return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n  }\\n\\n  /**\\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\\n   * produces hash corresponding to the one signed with the\\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n   * JSON-RPC method as part of EIP-191.\\n   *\\n   * See {recover}.\\n   */\\n  function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", LStrings.toString(s.length), s));\\n  }\\n\\n  /**\\n   * @dev Returns an Ethereum Signed Typed Data, created from a\\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\\n   * to the one signed with the\\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n   * JSON-RPC method as part of EIP-712.\\n   *\\n   * See {recover}.\\n   */\\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n  }\\n}\\n\",\"keccak256\":\"0x75b905d070ebb72fa3358e262ab18166f6c6386c11171324f235058ce9185ca4\",\"license\":\"MIT\"},\"src/contracts/lib/struct/LEnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v2.0.1)\\n// Author: OpenZeppelin\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary LEnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position of the value in the `values` array, plus 1 because index 0\\n    // means a value is not in the set.\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We read and store the value's index to prevent multiple reads from the same storage slot\\n    uint256 valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 toDeleteIndex = valueIndex - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (lastIndex != toDeleteIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the last value to the index where the value to delete is\\n        set._values[toDeleteIndex] = lastValue;\\n        // Update the index for the moved value\\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the index for the deleted slot\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n   */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    return _values(set._inner);\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n   */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\",\"keccak256\":\"0xe49098eb2019f9d9628a399f6a06ec310fe8a10785c369cc508c56df1f203dd0\",\"license\":\"MIT\"},\"src/contracts/proxy/BaseUUPSStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./IBaseProxy.sol\\\";\\n\\n/**\\n * @title Abstract Base UUPS Storage Contract\\n * @author OpenZeppelin, Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\nabstract contract BaseUUPSStorage is IBaseProxy {\\n  // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n  bytes32 internal constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n  /**\\n   * @dev Storage slot with the address of the current implementation.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n  bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n  /**\\n   * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n   * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n   */\\n  bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n  /**\\n   * @dev Storage slot with the admin of the contract.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n  bytes32 public constant TYPE_HASH =\\n    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n  address internal immutable __self = address(this);\\n\\n  string internal _contractName;\\n  string internal _contractVersion;\\n  address internal _accessControlManager;\\n  ProxySafeModeStatus internal _sstat;\\n  ProxyUpdatabilityStatus internal _ustat;\\n\\n  /**\\n   * @dev This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   */\\n  uint256[64] private __reserved;\\n}\\n\",\"keccak256\":\"0x4ff079fd2fd1ad102d42e82a72bff6bb1ffb8f9ab29cec2dd8e970b892ea415e\",\"license\":\"MIT\"},\"src/contracts/proxy/IBaseProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title Base Proxy Interface\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\ninterface IBaseProxy {\\n  enum ProxySafeModeStatus {\\n    DISABLED,\\n    ENABLED\\n  }\\n\\n  enum ProxyUpdatabilityStatus {\\n    DISABLED,\\n    ENABLED\\n  }\\n\\n  event ProxyUpgraded(address indexed sender, address indexed proxy, address indexed newImplementation);\\n}\\n\",\"keccak256\":\"0x4b2695303b3acb300ba472d17da71a16367191af571d325d43171503d7c92846\",\"license\":\"MIT\"},\"src/contracts/proxy/IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v2.0.1)\\n// Author: OpenZeppelin\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n  /**\\n   * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n   * address.\\n   *\\n   * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n   * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n   * function revert if invoked through a proxy.\\n   */\\n  function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x98571e9bc4231bb67b3c8b339c052fa968e56b0bef3e35f5d82c391335336ae8\",\"license\":\"MIT\"},\"src/contracts/proxy/IProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v3.0.0)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./IBaseProxy.sol\\\";\\n\\n/**\\n * @title Base Proxy Interface\\n * @author Sina Tadayon, https://github.com/SinaTadayon\\n * @dev\\n *\\n */\\ninterface IProxy is IBaseProxy {\\n  /**\\n   * @dev Emitted when the admin account has changed.\\n   */\\n  event ProxyLocalAdminUpdated(address indexed sender, address indexed proxy, address newAdmin);\\n\\n  event ProxyAccessControlUpdated(address indexed sender, address indexed proxy, address acl);\\n\\n  event ProxySafeModeUpdated(address indexed sender, address indexed proxy, ProxySafeModeStatus sstat);\\n\\n  event ProxyUpdatabilityUpdated(address indexed sender, address indexed proxy, ProxyUpdatabilityStatus ustat);\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n   */\\n  event Initialized(\\n    address indexed sender,\\n    address indexed proxy,\\n    address indexed subject,\\n    string name,\\n    string version,\\n    uint16 initCount\\n  );\\n\\n  function upgradeTo(\\n    address newImplementation,\\n    bytes memory data,\\n    bool forceCall\\n  ) external returns (bytes memory);\\n\\n  function setSafeModeStatus(ProxySafeModeStatus sstat) external returns (bool);\\n\\n  function setUpdatabilityStatus(ProxyUpdatabilityStatus ustat) external returns (bool);\\n\\n  function setLocalAdmin(address newAdmin) external returns (bool);\\n\\n  function setAccessControlManager(address acl) external returns (bool);\\n\\n  function withdrawBalance(address recepient) external returns (uint256);\\n\\n  function contractName() external view returns (string memory);\\n\\n  function contractVersion() external view returns (string memory);\\n\\n  function accessControlManager() external view returns (address);\\n\\n  function subjectAddress() external view returns (address);\\n\\n  function safeModeStatus() external view returns (ProxySafeModeStatus);\\n\\n  function updatabilityStatus() external view returns (ProxyUpdatabilityStatus);\\n\\n  function localAdmin() external view returns (address);\\n\\n  function domainSeparator() external view returns (bytes32);\\n\\n  function initVersion() external view returns (uint16);\\n}\\n\",\"keccak256\":\"0xaadf51e846486cf9dc7387ad1dcac9a67e6a2d9354ce71694d79de783e1dea3b\",\"license\":\"MIT\"},\"src/contracts/utils/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// LivelyVerse Contracts (last updated v2.0.1)\\n// Author: OpenZeppelin\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x95ac867088cd7cca6d583788b83e56e0c521c847aa9844f6184c14f5ce3ddf90\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x612b6f61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061010a5760003560e01c80639f968c44116100a1578063bec9475111610070578063bec9475114610269578063ca37fa8514610296578063d149fa56146102b6578063f986902e146102c957600080fd5b80639f968c4414610203578063af5f31ce14610216578063b85104d014610229578063b8ec20671461023c57600080fd5b80634a6439e6116100dd5780634a6439e61461019e57806358c910c1146101a65780635bc469b2146101ae57806377d8dd70146101e357600080fd5b80631d53c7101461010f57806323908f64146101315780632466209b1461014c5780633fd79deb1461017d575b600080fd5b81801561011b57600080fd5b5061012f61012a3660046124c4565b6102dc565b005b61013961055d565b6040519081526020015b60405180910390f35b610170604051806040016040528060058152602001640332e302e360dc1b81525081565b604051610143919061250b565b61019061018b366004612559565b6105b7565b6040516101439291906125a5565b6101396105d0565b610139610601565b8180156101ba57600080fd5b506101ce6101c93660046125d8565b610610565b60408051928352602083019190915201610143565b8180156101ef57600080fd5b506101396101fe366004612657565b610a44565b610139610211366004612696565b610a5d565b6101396102243660046126c8565b610a6b565b6101396102373660046126c8565b610c1b565b81801561024857600080fd5b5061025c61025736600461270e565b610c34565b604051610143919061273a565b6101706040518060400160405280600e81526020016d4c41434c4167656e7453636f706560901b81525081565b6102a96102a4366004612696565b610c41565b6040516101439190612748565b6101396102c4366004612696565b610c4f565b61012f6102d7366004612762565b610c5d565b600080806102ed8787358688611448565b805460009081526020899052604090206001015490915060ff16600281600381111561031b5761031b61257b565b03610356578154600090610330908a90611538565b6002015460008181526001808c016020526040909120015460ff16955093506103a79050565b8154600090610366908a9061161c565b60008781526005820160205260408120549192506103848b83611538565b6002015460008181526001808e016020526040909120015460ff16975095505050505b60006103b989896020013586886116f3565b6001848101546000908152908b01602052604081209192506103dd60048601611918565b11156104c757600181015460ff1660058111156103fc576103fc61257b565b600183015460ff1660058111156104155761041561257b565b1161043b5760405162461bcd60e51b81526004016104329061279c565b60405180910390fd5b6001840154604051631de3230560e11b815260208b0135600482015260248101919091523090633bc6460a90604401602060405180830381865afa158015610487573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104ab91906127c7565b6104c75760405162461bcd60e51b8152600401610432906127e9565b60018101546301000000900463ffffffff166105185760405162461bcd60e51b815260206004820152601060248201526f125b1b195859db08149959995c9c995960821b6044820152606401610432565b6001908101805460001963ffffffff6301000000808404821692909201160266ffffffff00000019909116179055602090980135929097019190915550505050505050565b60405160200161059e907f524f4c452e4c4956454c595f56455253452e4c4956454c595f4d41535445525f81526420a226a4a760d91b602082015260250190565b6040516020818303038152906040528051906020012081565b6000806105c48484611928565b915091505b9250929050565b6040517f545950452e4c4956454c595f56455253452e4c4956454c595f414e59000000006020820152603c0161059e565b60405160200161059e90612810565b6000808061062961062460c0890189612844565b6119bd565b905060008082815260208a9052604090206001015460ff1660038111156106525761065261257b565b146106945760405162461bcd60e51b8152602060048201526012602482015271149bdb1948105b1c9958591e48115e1a5cdd60721b6044820152606401610432565b60016106a660a0890160808a01612898565b60038111156106b7576106b761257b565b1180156106e4575060006106d160c0890160a08a01612898565b60038111156106e2576106e261257b565b115b6107305760405162461bcd60e51b815260206004820152601d60248201527f496c6c6567616c2041637469766974792f416c7465726162696c6974790000006044820152606401610432565b60405160200161073f90612810565b604051602081830303815290604052805190602001208760400135141580156107ad57506040517f545950452e4c4956454c595f56455253452e4c4956454c595f414e59000000006020820152603c0160405160208183030381529060405280519060200120876040013514155b6107e85760405162461bcd60e51b815260206004820152600c60248201526b496c6c6567616c205479706560a01b6044820152606401610432565b60006107f88960408a013561161c565b90506002600182015462010000900460ff16600381111561081b5761081b61257b565b10156108625760405162461bcd60e51b8152602060048201526016602482015275496c6c6567616c205479706520557064617461626c6560501b6044820152606401610432565b600481015461ffff1661087760068301611918565b106108b75760405162461bcd60e51b815260206004820152601060248201526f24b63632b3b0b6102932b3b4b9ba32b960811b6044820152606401610432565b80546000906108c9908b90898b6119f0565b905060008160078111156108df576108df61257b565b146108ed576108ed81611d79565b60006109028b8b602001358560020154611f10565b9050610911600684018561215f565b50600061091e8c86612172565b60018101805460ff19166002179055905061093f60a08c0160808d01612898565b60018201805461ff00191661010083600381111561095f5761095f61257b565b021790555061097460c08c0160a08d01612898565b60018201805462ff00001916620100008360038111156109965761099661257b565b02179055506109a860c08c018c612844565b60048301916109b8919083612954565b5060208b0135600282015560006109d560808d0160608e01612a15565b60030b12156109e457876109f4565b6109f460808c0160608d01612a15565b60058201805462ffffff191662ffffff9290921691909117905560408b013560038201558354610a2e908d90849060208f01358f356121d9565b90819055939b939a509298505050505050505050565b6000610a52858585856116f3565b90505b949350505050565b6000610a5285858585612226565b60008115610c0f57600260008381526020889052604090206001015460ff166003811115610a9b57610a9b61257b565b14610ab85760405162461bcd60e51b815260040161043290612a38565b600080610ac58885611928565b91509150816005811115610adb57610adb61257b565b876005811115610aed57610aed61257b565b1115610b355760405162461bcd60e51b8152602060048201526017602482015276496c6c6567616c2041646d696e2053636f70655479706560481b6044820152606401610432565b816005811115610b4757610b4761257b565b876005811115610b5957610b5961257b565b03610b8257848114610b7d5760405162461bcd60e51b815260040161043290612a6f565b610c05565b604051631de3230560e11b815260048101829052602481018690523090633bc6460a90604401602060405180830381865afa158015610bc5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610be991906127c7565b610c055760405162461bcd60e51b815260040161043290612a6f565b8392505050610c12565b50825b95945050505050565b6000610c2a86868686866121d9565b9695505050505050565b6000610a55848484611f10565b6000610a52858585856119f0565b6000610a5285858585611448565b610c6d6040820160208301612a9c565b600383015461ffff91821663010000009091049091161015610cd15760405162461bcd60e51b815260206004820152601b60248201527f496c6c6567616c204d656d62657252656769737465724c696d697400000000006044820152606401610432565b610ce16060820160408301612a9c565b600383015461ffff918216650100000000009091049091161015610d475760405162461bcd60e51b815260206004820152601c60248201527f496c6c6567616c20436f6e7465787452656769737465724c696d6974000000006044820152606401610432565b610d576080820160608301612a9c565b600383015461ffff9182166701000000000000009091049091161015610dbf5760405162461bcd60e51b815260206004820152601d60248201527f496c6c6567616c2046756e6374696f6e52656769737465724c696d69740000006044820152606401610432565b610dcf60a0820160808301612a9c565b600383015461ffff91821669010000000000000000009091049091161015610e395760405162461bcd60e51b815260206004820152601c60248201527f496c6c6567616c2050726f66696c6552656769737465724c696d6974000000006044820152606401610432565b610e4b61018082016101608301612ac0565b600383015460ff918216600160b81b9091049091161015610eae5760405162461bcd60e51b815260206004820152601960248201527f496c6c6567616c20526f6c6552656769737465724c696d6974000000000000006044820152606401610432565b610ec06101a082016101808301612ac0565b600383015460ff918216600160c01b9091049091161015610f235760405162461bcd60e51b815260206004820152601960248201527f496c6c6567616c205479706552656769737465724c696d6974000000000000006044820152606401610432565b610f356101c082016101a08301612ac0565b600383015460ff918216600160c81b9091049091161015610f985760405162461bcd60e51b815260206004820152601a60248201527f496c6c6567616c205265616c6d52656769737465724c696d69740000000000006044820152606401610432565b610faa6101e082016101c08301612ac0565b600383015460ff918216600160d01b909104909116101561100d5760405162461bcd60e51b815260206004820152601b60248201527f496c6c6567616c20446f6d61696e52656769737465724c696d697400000000006044820152606401610432565b61101f61020082016101e08301612ac0565b600383015460ff918216600160d81b90910490911610156110825760405162461bcd60e51b815260206004820152601b60248201527f496c6c6567616c20506f6c69637952656769737465724c696d697400000000006044820152606401610432565b61108f6020820182612ae3565b600383015462ffffff918216911610156110e15760405162461bcd60e51b8152602060048201526013602482015272125b1b1959d85b0813595b58995c931a5b5a5d606a1b6044820152606401610432565b6110f160c0820160a08301612a9c565b600383015461ffff918216600160581b909104909116101561114c5760405162461bcd60e51b8152602060048201526014602482015273125b1b1959d85b0810dbdb9d195e1d131a5b5a5d60621b6044820152606401610432565b61115c60e0820160c08301612a9c565b600383015461ffff918216600160681b90910490911610156111b55760405162461bcd60e51b8152602060048201526012602482015271125b1b1959d85b081499585b1b531a5b5a5d60721b6044820152606401610432565b6111c6610100820160e08301612a9c565b600383015461ffff918216600160781b90910490911610156112205760405162461bcd60e51b8152602060048201526013602482015272125b1b1959d85b08111bdb585a5b931a5b5a5d606a1b6044820152606401610432565b61123261012082016101008301612a9c565b600383015461ffff918216600160881b909104909116101561128a5760405162461bcd60e51b8152602060048201526011602482015270125b1b1959d85b0810d85b1b131a5b5a5d607a1b6044820152606401610432565b61129c61014082016101208301612a9c565b600383015461ffff918216600160981b90910490911610156112f85760405162461bcd60e51b8152602060048201526015602482015274125b1b1959d85b08151e5c19549bdb19531a5b5a5d605a1b6044820152606401610432565b61130a61016082016101408301612a9c565b600383015461ffff918216600160a81b90910490911610156113625760405162461bcd60e51b8152602060048201526011602482015270125b1b1959d85b08151e5c19531a5b5a5d607a1b6044820152606401610432565b61137461022082016102008301612ac0565b600383015460ff918216600160e01b90910490911610156113d75760405162461bcd60e51b815260206004820152601760248201527f496c6c6567616c20506f6c696379526f6c654c696d69740000000000000000006044820152606401610432565b6113e961024082016102208301612ac0565b600383015460ff918216600160e81b90910490911610156114445760405162461bcd60e51b8152602060048201526015602482015274125b1b1959d85b08119d5b98dd1a5bdb931a5b5a5d605a1b6044820152606401610432565b5050565b6000838152600285016020526040812080546114925760405162461bcd60e51b8152602060048201526009602482015268139bdd08119bdd5b9960ba1b6044820152606401610432565b600260038281015465010000000000900460ff16908111156114b6576114b661257b565b10156114f85760405162461bcd60e51b8152602060048201526011602482015270496c6c6567616c20557064617461626c6560781b6044820152606401610432565b600061150a87836000015487876119f0565b905060008160078111156115205761152061257b565b1461152e5761152e81611d79565b5095945050505050565b60008181526020839052604081206002600182015460ff1660038111156115615761156161257b565b0361157c576040805184815260208101869052209150611615565b6000600182015460ff1660038111156115975761159761257b565b036115d75760405162461bcd60e51b815260206004820152601060248201526f149bdb19525908139bdd08119bdd5b9960821b6044820152606401610432565b60405162461bcd60e51b8152602060048201526013602482015272125b1b1959d85b08149bdb1952590814db1bdd606a1b6044820152606401610432565b5092915050565b60008181526020839052604081206003600182015460ff1660038111156116455761164561257b565b03611660576040805184815260208101869052209150611615565b6000600182015460ff16600381111561167b5761167b61257b565b036116b85760405162461bcd60e51b815260206004820152600d60248201526c15125108139bdd08119bdd5b99609a1b6044820152606401610432565b60405162461bcd60e51b815260206004820152601060248201526f125b1b1959d85b081512510814db1bdd60821b6044820152606401610432565b6000838152600185016020526040812081600182015460ff16600581111561171d5761171d61257b565b0361175c5760405162461bcd60e51b815260206004820152600f60248201526e14d8dbdc1948139bdd08119bdd5b99608a1b6044820152606401610432565b600180820154610100900460ff16600381111561177b5761177b61257b565b116117b85760405162461bcd60e51b815260206004820152600d60248201526c14d8dbdc194811195b195d1959609a1b6044820152606401610432565b600181810180546003906117da9084906301000000900463ffffffff16612afe565b92506101000a81548163ffffffff021916908363ffffffff16021790555082600581111561180a5761180a61257b565b600182015460ff1660058111156118235761182361257b565b11156118415760405162461bcd60e51b81526004016104329061279c565b8260058111156118535761185361257b565b600182015460ff16600581111561186c5761186c61257b565b03611895578385146118905760405162461bcd60e51b8152600401610432906127e9565b610a52565b604051631de3230560e11b815260048101859052602481018690523090633bc6460a90604401602060405180830381865afa1580156118d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118fc91906127c7565b610a525760405162461bcd60e51b8152600401610432906127e9565b6000611922825490565b92915050565b600081815260208390526040812060010154819060ff1660028160038111156119535761195361257b565b0361198b5760006119648686611538565b60020154600081815260018089016020526040909120015460ff16945092506105c9915050565b600381600381111561199f5761199f61257b565b036119b0576000611964868661161c565b5060009485945092505050565b600082826040516020016119d2929190612b29565b60405160208183030381529060405280519060200120905092915050565b600080806119fe87856123b3565b9150915080611a1257600592505050610a55565b60008681526020889052604090206001015460ff166002816003811115611a3b57611a3b61257b565b03611bd957600080611a4d8a8a612413565b9150915080611a6457600395505050505050610a55565b60036001830154610100900460ff166003811115611a8457611a8461257b565b14611a9757600695505050505050610a55565b600080611ab184600301548d61245e90919063ffffffff16565b9150915080611aca576004975050505050505050610a55565b60036001830154610100900460ff166003811115611aea57611aea61257b565b14611aff576007975050505050505050610a55565b60008a81526005830160205260409020548b14611b26576001975050505050505050610a55565b60008c60020160008e60030160008f81526020019081526020016000205481526020019081526020016000209050600380811115611b6657611b6661257b565b600382810154640100000000900460ff1690811115611b8757611b8761257b565b148015611bb257506004880154600382015464010000000090910460ff908116620100009092041610155b15611bc857600298505050505050505050610a55565b600098505050505050505050610a55565b6003816003811115611bed57611bed61257b565b03611d6b57600080611bff8a8a61245e565b9150915080611c1657600495505050505050610a55565b60036001830154610100900460ff166003811115611c3657611c3661257b565b14611c4957600795505050505050610a55565b60008881526005830160205260408120549080611c668d84612413565b9150915080611c8057600398505050505050505050610a55565b60036001830154610100900460ff166003811115611ca057611ca061257b565b14611cb657600698505050505050505050610a55565b60008d60020160008f60030160008781526020019081526020016000205481526020019081526020016000209050600380811115611cf657611cf661257b565b600382810154640100000000900460ff1690811115611d1757611d1761257b565b148015611d4257506004890154600382015464010000000090910460ff908116620100009092041610155b15611d595760029950505050505050505050610a55565b60009950505050505050505050610a55565b506001979650505050505050565b6001816007811115611d8d57611d8d61257b565b03611dab576040516334267bfb60e11b815260040160405180910390fd5b6002816007811115611dbf57611dbf61257b565b03611ddd576040516343f871e760e11b815260040160405180910390fd5b6003816007811115611df157611df161257b565b03611e0f57604051639afb7c5f60e01b815260040160405180910390fd5b6004816007811115611e2357611e2361257b565b03611e41576040516332314d6b60e11b815260040160405180910390fd5b6005816007811115611e5557611e5561257b565b03611e7357604051633123155560e01b815260040160405180910390fd5b6006816007811115611e8757611e8761257b565b03611ea557604051631b210af760e21b815260040160405180910390fd5b6007816007811115611eb957611eb961257b565b03611ed7576040516339f73ba360e11b815260040160405180910390fd5b60405162461bcd60e51b815260206004820152600b60248201526a2ab735b737bbb71022a92960a91b6044820152606401610432565b50565b6000828152600184016020526040812081600182015460ff166005811115611f3a57611f3a61257b565b03611f795760405162461bcd60e51b815260206004820152600f60248201526e14d8dbdc1948139bdd08119bdd5b99608a1b6044820152606401610432565b600180820154610100900460ff166003811115611f9857611f9861257b565b11611fd55760405162461bcd60e51b815260206004820152600d60248201526c14d8dbdc194811195b195d1959609a1b6044820152606401610432565b60018181018054600390611ff79084906301000000900463ffffffff16612afe565b825463ffffffff9182166101009390930a9283029190920219909116179055506000838152600186810160205260409091208101549082015460ff918216911660058111156120485761204861257b565b81600581111561205a5761205a61257b565b10156120785760405162461bcd60e51b81526004016104329061279c565b600182015460ff1660058111156120915761209161257b565b8160058111156120a3576120a361257b565b036120cc578484146120c75760405162461bcd60e51b8152600401610432906127e9565b61214f565b604051631de3230560e11b815260048101859052602481018690523090633bc6460a90604401602060405180830381865afa15801561210f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061213391906127c7565b61214f5760405162461bcd60e51b8152600401610432906127e9565b506001015460ff16949350505050565b600061216b8383612475565b9392505050565b600081815260208390526040812081600182015460ff16600381111561219a5761219a61257b565b14806121be57506002600182015460ff1660038111156121bc576121bc61257b565b145b156115d7576040805184815260208101869052209150611615565b60008115610c0f57600160008381526020889052604090206001015460ff1660038111156122095761220961257b565b11610ab85760405162461bcd60e51b815260040161043290612a38565b600081156123aa57600160008381526020879052604090206001015460ff1660038111156122565761225661257b565b116122735760405162461bcd60e51b815260040161043290612a38565b6000806122808785611928565b915091508160058111156122965761229661257b565b600211156122e05760405162461bcd60e51b8152602060048201526017602482015276496c6c6567616c2041646d696e2053636f70655479706560481b6044820152606401610432565b8160058111156122f2576122f261257b565b60020361231d578581146123185760405162461bcd60e51b815260040161043290612a6f565b6123a0565b604051631de3230560e11b815260048101829052602481018690523090633bc6460a90604401602060405180830381865afa158015612360573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061238491906127c7565b6123a05760405162461bcd60e51b815260040161043290612a6f565b8392505050610a55565b50919392505050565b60008181526001808401602052604082208291600182015460ff1660058111156123df576123df61257b565b036124015760408051858152600187810160208301529190209350915061240b565b6000199250600091505b509250929050565b6000818152602083905260408120819060025b600182015460ff16600381111561243f5761243f61257b565b036124015760408051858152602081018790522092506001915061240b565b600081815260208390526040812081906003612426565b60008181526001830160205260408120546124bc57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155611922565b506000611922565b60008060008084860360a08112156124db57600080fd5b853594506040601f19820112156124f157600080fd5b509295602085019550606085013594608001359350915050565b600060208083528351808285015260005b818110156125385785810183015185820160400152820161251c565b506000604082860101526040601f19601f8301168501019250505092915050565b6000806040838503121561256c57600080fd5b50508035926020909101359150565b634e487b7160e01b600052602160045260246000fd5b600681106125a1576125a161257b565b9052565b604081016125b38285612591565b8260208301529392505050565b803562ffffff811681146125d357600080fd5b919050565b600080600080600060a086880312156125f057600080fd5b85359450602086013567ffffffffffffffff81111561260e57600080fd5b860160e0818903121561262057600080fd5b9350604086013592506060860135915061263c608087016125c0565b90509295509295909350565b8035600681106125d357600080fd5b6000806000806080858703121561266d57600080fd5b84359350602085013592506040850135915061268b60608601612648565b905092959194509250565b600080600080608085870312156126ac57600080fd5b5050823594602084013594506040840135936060013592509050565b600080600080600060a086880312156126e057600080fd5b853594506126f060208701612648565b94979496505050506040830135926060810135926080909101359150565b60008060006060848603121561272357600080fd5b505081359360208301359350604090920135919050565b602081016119228284612591565b602081016008831061275c5761275c61257b565b91905290565b60008082840361026081121561277757600080fd5b83359250610240601f198201121561278e57600080fd5b506020830190509250929050565b602080825260119082015270496c6c6567616c2053636f70655479706560781b604082015260600190565b6000602082840312156127d957600080fd5b8151801515811461216b57600080fd5b6020808252600d908201526c496c6c6567616c2053636f706560981b604082015260600190565b7f545950452e4c4956454c595f56455253452e4c4956454c595f414e4f4e594d4f815261555360f01b602082015260220190565b6000808335601e1984360301811261285b57600080fd5b83018035915067ffffffffffffffff82111561287657600080fd5b6020019150368190038213156105c957600080fd5b60048110611f0d57600080fd5b6000602082840312156128aa57600080fd5b813561216b8161288b565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806128df57607f821691505b6020821081036128ff57634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561294f57600081815260208120601f850160051c8101602086101561292c5750805b601f850160051c820191505b8181101561294b57828155600101612938565b5050505b505050565b67ffffffffffffffff83111561296c5761296c6128b5565b6129808361297a83546128cb565b83612905565b6000601f8411600181146129b4576000851561299c5750838201355b600019600387901b1c1916600186901b178355612a0e565b600083815260209020601f19861690835b828110156129e557868501358255602094850194600190920191016129c5565b5086821015612a025760001960f88860031b161c19848701351681555b505060018560011b0183555b5050505050565b600060208284031215612a2757600080fd5b81358060030b811461216b57600080fd5b60208082526017908201527f496c6c6567616c2041646d696e204167656e7454797065000000000000000000604082015260600190565b602080825260139082015272496c6c6567616c2041646d696e2053636f706560681b604082015260600190565b600060208284031215612aae57600080fd5b813561ffff8116811461216b57600080fd5b600060208284031215612ad257600080fd5b813560ff8116811461216b57600080fd5b600060208284031215612af557600080fd5b61216b826125c0565b63ffffffff81811683821601908082111561161557634e487b7160e01b600052601160045260246000fd5b818382376000910190815291905056fea26469706673582212202afcf9280eefab7a2e70116a0717c1347fe17111865fb7f1342d6a2d9d25137764736f6c63430008130033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061010a5760003560e01c80639f968c44116100a1578063bec9475111610070578063bec9475114610269578063ca37fa8514610296578063d149fa56146102b6578063f986902e146102c957600080fd5b80639f968c4414610203578063af5f31ce14610216578063b85104d014610229578063b8ec20671461023c57600080fd5b80634a6439e6116100dd5780634a6439e61461019e57806358c910c1146101a65780635bc469b2146101ae57806377d8dd70146101e357600080fd5b80631d53c7101461010f57806323908f64146101315780632466209b1461014c5780633fd79deb1461017d575b600080fd5b81801561011b57600080fd5b5061012f61012a3660046124c4565b6102dc565b005b61013961055d565b6040519081526020015b60405180910390f35b610170604051806040016040528060058152602001640332e302e360dc1b81525081565b604051610143919061250b565b61019061018b366004612559565b6105b7565b6040516101439291906125a5565b6101396105d0565b610139610601565b8180156101ba57600080fd5b506101ce6101c93660046125d8565b610610565b60408051928352602083019190915201610143565b8180156101ef57600080fd5b506101396101fe366004612657565b610a44565b610139610211366004612696565b610a5d565b6101396102243660046126c8565b610a6b565b6101396102373660046126c8565b610c1b565b81801561024857600080fd5b5061025c61025736600461270e565b610c34565b604051610143919061273a565b6101706040518060400160405280600e81526020016d4c41434c4167656e7453636f706560901b81525081565b6102a96102a4366004612696565b610c41565b6040516101439190612748565b6101396102c4366004612696565b610c4f565b61012f6102d7366004612762565b610c5d565b600080806102ed8787358688611448565b805460009081526020899052604090206001015490915060ff16600281600381111561031b5761031b61257b565b03610356578154600090610330908a90611538565b6002015460008181526001808c016020526040909120015460ff16955093506103a79050565b8154600090610366908a9061161c565b60008781526005820160205260408120549192506103848b83611538565b6002015460008181526001808e016020526040909120015460ff16975095505050505b60006103b989896020013586886116f3565b6001848101546000908152908b01602052604081209192506103dd60048601611918565b11156104c757600181015460ff1660058111156103fc576103fc61257b565b600183015460ff1660058111156104155761041561257b565b1161043b5760405162461bcd60e51b81526004016104329061279c565b60405180910390fd5b6001840154604051631de3230560e11b815260208b0135600482015260248101919091523090633bc6460a90604401602060405180830381865afa158015610487573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104ab91906127c7565b6104c75760405162461bcd60e51b8152600401610432906127e9565b60018101546301000000900463ffffffff166105185760405162461bcd60e51b815260206004820152601060248201526f125b1b195859db08149959995c9c995960821b6044820152606401610432565b6001908101805460001963ffffffff6301000000808404821692909201160266ffffffff00000019909116179055602090980135929097019190915550505050505050565b60405160200161059e907f524f4c452e4c4956454c595f56455253452e4c4956454c595f4d41535445525f81526420a226a4a760d91b602082015260250190565b6040516020818303038152906040528051906020012081565b6000806105c48484611928565b915091505b9250929050565b6040517f545950452e4c4956454c595f56455253452e4c4956454c595f414e59000000006020820152603c0161059e565b60405160200161059e90612810565b6000808061062961062460c0890189612844565b6119bd565b905060008082815260208a9052604090206001015460ff1660038111156106525761065261257b565b146106945760405162461bcd60e51b8152602060048201526012602482015271149bdb1948105b1c9958591e48115e1a5cdd60721b6044820152606401610432565b60016106a660a0890160808a01612898565b60038111156106b7576106b761257b565b1180156106e4575060006106d160c0890160a08a01612898565b60038111156106e2576106e261257b565b115b6107305760405162461bcd60e51b815260206004820152601d60248201527f496c6c6567616c2041637469766974792f416c7465726162696c6974790000006044820152606401610432565b60405160200161073f90612810565b604051602081830303815290604052805190602001208760400135141580156107ad57506040517f545950452e4c4956454c595f56455253452e4c4956454c595f414e59000000006020820152603c0160405160208183030381529060405280519060200120876040013514155b6107e85760405162461bcd60e51b815260206004820152600c60248201526b496c6c6567616c205479706560a01b6044820152606401610432565b60006107f88960408a013561161c565b90506002600182015462010000900460ff16600381111561081b5761081b61257b565b10156108625760405162461bcd60e51b8152602060048201526016602482015275496c6c6567616c205479706520557064617461626c6560501b6044820152606401610432565b600481015461ffff1661087760068301611918565b106108b75760405162461bcd60e51b815260206004820152601060248201526f24b63632b3b0b6102932b3b4b9ba32b960811b6044820152606401610432565b80546000906108c9908b90898b6119f0565b905060008160078111156108df576108df61257b565b146108ed576108ed81611d79565b60006109028b8b602001358560020154611f10565b9050610911600684018561215f565b50600061091e8c86612172565b60018101805460ff19166002179055905061093f60a08c0160808d01612898565b60018201805461ff00191661010083600381111561095f5761095f61257b565b021790555061097460c08c0160a08d01612898565b60018201805462ff00001916620100008360038111156109965761099661257b565b02179055506109a860c08c018c612844565b60048301916109b8919083612954565b5060208b0135600282015560006109d560808d0160608e01612a15565b60030b12156109e457876109f4565b6109f460808c0160608d01612a15565b60058201805462ffffff191662ffffff9290921691909117905560408b013560038201558354610a2e908d90849060208f01358f356121d9565b90819055939b939a509298505050505050505050565b6000610a52858585856116f3565b90505b949350505050565b6000610a5285858585612226565b60008115610c0f57600260008381526020889052604090206001015460ff166003811115610a9b57610a9b61257b565b14610ab85760405162461bcd60e51b815260040161043290612a38565b600080610ac58885611928565b91509150816005811115610adb57610adb61257b565b876005811115610aed57610aed61257b565b1115610b355760405162461bcd60e51b8152602060048201526017602482015276496c6c6567616c2041646d696e2053636f70655479706560481b6044820152606401610432565b816005811115610b4757610b4761257b565b876005811115610b5957610b5961257b565b03610b8257848114610b7d5760405162461bcd60e51b815260040161043290612a6f565b610c05565b604051631de3230560e11b815260048101829052602481018690523090633bc6460a90604401602060405180830381865afa158015610bc5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610be991906127c7565b610c055760405162461bcd60e51b815260040161043290612a6f565b8392505050610c12565b50825b95945050505050565b6000610c2a86868686866121d9565b9695505050505050565b6000610a55848484611f10565b6000610a52858585856119f0565b6000610a5285858585611448565b610c6d6040820160208301612a9c565b600383015461ffff91821663010000009091049091161015610cd15760405162461bcd60e51b815260206004820152601b60248201527f496c6c6567616c204d656d62657252656769737465724c696d697400000000006044820152606401610432565b610ce16060820160408301612a9c565b600383015461ffff918216650100000000009091049091161015610d475760405162461bcd60e51b815260206004820152601c60248201527f496c6c6567616c20436f6e7465787452656769737465724c696d6974000000006044820152606401610432565b610d576080820160608301612a9c565b600383015461ffff9182166701000000000000009091049091161015610dbf5760405162461bcd60e51b815260206004820152601d60248201527f496c6c6567616c2046756e6374696f6e52656769737465724c696d69740000006044820152606401610432565b610dcf60a0820160808301612a9c565b600383015461ffff91821669010000000000000000009091049091161015610e395760405162461bcd60e51b815260206004820152601c60248201527f496c6c6567616c2050726f66696c6552656769737465724c696d6974000000006044820152606401610432565b610e4b61018082016101608301612ac0565b600383015460ff918216600160b81b9091049091161015610eae5760405162461bcd60e51b815260206004820152601960248201527f496c6c6567616c20526f6c6552656769737465724c696d6974000000000000006044820152606401610432565b610ec06101a082016101808301612ac0565b600383015460ff918216600160c01b9091049091161015610f235760405162461bcd60e51b815260206004820152601960248201527f496c6c6567616c205479706552656769737465724c696d6974000000000000006044820152606401610432565b610f356101c082016101a08301612ac0565b600383015460ff918216600160c81b9091049091161015610f985760405162461bcd60e51b815260206004820152601a60248201527f496c6c6567616c205265616c6d52656769737465724c696d69740000000000006044820152606401610432565b610faa6101e082016101c08301612ac0565b600383015460ff918216600160d01b909104909116101561100d5760405162461bcd60e51b815260206004820152601b60248201527f496c6c6567616c20446f6d61696e52656769737465724c696d697400000000006044820152606401610432565b61101f61020082016101e08301612ac0565b600383015460ff918216600160d81b90910490911610156110825760405162461bcd60e51b815260206004820152601b60248201527f496c6c6567616c20506f6c69637952656769737465724c696d697400000000006044820152606401610432565b61108f6020820182612ae3565b600383015462ffffff918216911610156110e15760405162461bcd60e51b8152602060048201526013602482015272125b1b1959d85b0813595b58995c931a5b5a5d606a1b6044820152606401610432565b6110f160c0820160a08301612a9c565b600383015461ffff918216600160581b909104909116101561114c5760405162461bcd60e51b8152602060048201526014602482015273125b1b1959d85b0810dbdb9d195e1d131a5b5a5d60621b6044820152606401610432565b61115c60e0820160c08301612a9c565b600383015461ffff918216600160681b90910490911610156111b55760405162461bcd60e51b8152602060048201526012602482015271125b1b1959d85b081499585b1b531a5b5a5d60721b6044820152606401610432565b6111c6610100820160e08301612a9c565b600383015461ffff918216600160781b90910490911610156112205760405162461bcd60e51b8152602060048201526013602482015272125b1b1959d85b08111bdb585a5b931a5b5a5d606a1b6044820152606401610432565b61123261012082016101008301612a9c565b600383015461ffff918216600160881b909104909116101561128a5760405162461bcd60e51b8152602060048201526011602482015270125b1b1959d85b0810d85b1b131a5b5a5d607a1b6044820152606401610432565b61129c61014082016101208301612a9c565b600383015461ffff918216600160981b90910490911610156112f85760405162461bcd60e51b8152602060048201526015602482015274125b1b1959d85b08151e5c19549bdb19531a5b5a5d605a1b6044820152606401610432565b61130a61016082016101408301612a9c565b600383015461ffff918216600160a81b90910490911610156113625760405162461bcd60e51b8152602060048201526011602482015270125b1b1959d85b08151e5c19531a5b5a5d607a1b6044820152606401610432565b61137461022082016102008301612ac0565b600383015460ff918216600160e01b90910490911610156113d75760405162461bcd60e51b815260206004820152601760248201527f496c6c6567616c20506f6c696379526f6c654c696d69740000000000000000006044820152606401610432565b6113e961024082016102208301612ac0565b600383015460ff918216600160e81b90910490911610156114445760405162461bcd60e51b8152602060048201526015602482015274125b1b1959d85b08119d5b98dd1a5bdb931a5b5a5d605a1b6044820152606401610432565b5050565b6000838152600285016020526040812080546114925760405162461bcd60e51b8152602060048201526009602482015268139bdd08119bdd5b9960ba1b6044820152606401610432565b600260038281015465010000000000900460ff16908111156114b6576114b661257b565b10156114f85760405162461bcd60e51b8152602060048201526011602482015270496c6c6567616c20557064617461626c6560781b6044820152606401610432565b600061150a87836000015487876119f0565b905060008160078111156115205761152061257b565b1461152e5761152e81611d79565b5095945050505050565b60008181526020839052604081206002600182015460ff1660038111156115615761156161257b565b0361157c576040805184815260208101869052209150611615565b6000600182015460ff1660038111156115975761159761257b565b036115d75760405162461bcd60e51b815260206004820152601060248201526f149bdb19525908139bdd08119bdd5b9960821b6044820152606401610432565b60405162461bcd60e51b8152602060048201526013602482015272125b1b1959d85b08149bdb1952590814db1bdd606a1b6044820152606401610432565b5092915050565b60008181526020839052604081206003600182015460ff1660038111156116455761164561257b565b03611660576040805184815260208101869052209150611615565b6000600182015460ff16600381111561167b5761167b61257b565b036116b85760405162461bcd60e51b815260206004820152600d60248201526c15125108139bdd08119bdd5b99609a1b6044820152606401610432565b60405162461bcd60e51b815260206004820152601060248201526f125b1b1959d85b081512510814db1bdd60821b6044820152606401610432565b6000838152600185016020526040812081600182015460ff16600581111561171d5761171d61257b565b0361175c5760405162461bcd60e51b815260206004820152600f60248201526e14d8dbdc1948139bdd08119bdd5b99608a1b6044820152606401610432565b600180820154610100900460ff16600381111561177b5761177b61257b565b116117b85760405162461bcd60e51b815260206004820152600d60248201526c14d8dbdc194811195b195d1959609a1b6044820152606401610432565b600181810180546003906117da9084906301000000900463ffffffff16612afe565b92506101000a81548163ffffffff021916908363ffffffff16021790555082600581111561180a5761180a61257b565b600182015460ff1660058111156118235761182361257b565b11156118415760405162461bcd60e51b81526004016104329061279c565b8260058111156118535761185361257b565b600182015460ff16600581111561186c5761186c61257b565b03611895578385146118905760405162461bcd60e51b8152600401610432906127e9565b610a52565b604051631de3230560e11b815260048101859052602481018690523090633bc6460a90604401602060405180830381865afa1580156118d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118fc91906127c7565b610a525760405162461bcd60e51b8152600401610432906127e9565b6000611922825490565b92915050565b600081815260208390526040812060010154819060ff1660028160038111156119535761195361257b565b0361198b5760006119648686611538565b60020154600081815260018089016020526040909120015460ff16945092506105c9915050565b600381600381111561199f5761199f61257b565b036119b0576000611964868661161c565b5060009485945092505050565b600082826040516020016119d2929190612b29565b60405160208183030381529060405280519060200120905092915050565b600080806119fe87856123b3565b9150915080611a1257600592505050610a55565b60008681526020889052604090206001015460ff166002816003811115611a3b57611a3b61257b565b03611bd957600080611a4d8a8a612413565b9150915080611a6457600395505050505050610a55565b60036001830154610100900460ff166003811115611a8457611a8461257b565b14611a9757600695505050505050610a55565b600080611ab184600301548d61245e90919063ffffffff16565b9150915080611aca576004975050505050505050610a55565b60036001830154610100900460ff166003811115611aea57611aea61257b565b14611aff576007975050505050505050610a55565b60008a81526005830160205260409020548b14611b26576001975050505050505050610a55565b60008c60020160008e60030160008f81526020019081526020016000205481526020019081526020016000209050600380811115611b6657611b6661257b565b600382810154640100000000900460ff1690811115611b8757611b8761257b565b148015611bb257506004880154600382015464010000000090910460ff908116620100009092041610155b15611bc857600298505050505050505050610a55565b600098505050505050505050610a55565b6003816003811115611bed57611bed61257b565b03611d6b57600080611bff8a8a61245e565b9150915080611c1657600495505050505050610a55565b60036001830154610100900460ff166003811115611c3657611c3661257b565b14611c4957600795505050505050610a55565b60008881526005830160205260408120549080611c668d84612413565b9150915080611c8057600398505050505050505050610a55565b60036001830154610100900460ff166003811115611ca057611ca061257b565b14611cb657600698505050505050505050610a55565b60008d60020160008f60030160008781526020019081526020016000205481526020019081526020016000209050600380811115611cf657611cf661257b565b600382810154640100000000900460ff1690811115611d1757611d1761257b565b148015611d4257506004890154600382015464010000000090910460ff908116620100009092041610155b15611d595760029950505050505050505050610a55565b60009950505050505050505050610a55565b506001979650505050505050565b6001816007811115611d8d57611d8d61257b565b03611dab576040516334267bfb60e11b815260040160405180910390fd5b6002816007811115611dbf57611dbf61257b565b03611ddd576040516343f871e760e11b815260040160405180910390fd5b6003816007811115611df157611df161257b565b03611e0f57604051639afb7c5f60e01b815260040160405180910390fd5b6004816007811115611e2357611e2361257b565b03611e41576040516332314d6b60e11b815260040160405180910390fd5b6005816007811115611e5557611e5561257b565b03611e7357604051633123155560e01b815260040160405180910390fd5b6006816007811115611e8757611e8761257b565b03611ea557604051631b210af760e21b815260040160405180910390fd5b6007816007811115611eb957611eb961257b565b03611ed7576040516339f73ba360e11b815260040160405180910390fd5b60405162461bcd60e51b815260206004820152600b60248201526a2ab735b737bbb71022a92960a91b6044820152606401610432565b50565b6000828152600184016020526040812081600182015460ff166005811115611f3a57611f3a61257b565b03611f795760405162461bcd60e51b815260206004820152600f60248201526e14d8dbdc1948139bdd08119bdd5b99608a1b6044820152606401610432565b600180820154610100900460ff166003811115611f9857611f9861257b565b11611fd55760405162461bcd60e51b815260206004820152600d60248201526c14d8dbdc194811195b195d1959609a1b6044820152606401610432565b60018181018054600390611ff79084906301000000900463ffffffff16612afe565b825463ffffffff9182166101009390930a9283029190920219909116179055506000838152600186810160205260409091208101549082015460ff918216911660058111156120485761204861257b565b81600581111561205a5761205a61257b565b10156120785760405162461bcd60e51b81526004016104329061279c565b600182015460ff1660058111156120915761209161257b565b8160058111156120a3576120a361257b565b036120cc578484146120c75760405162461bcd60e51b8152600401610432906127e9565b61214f565b604051631de3230560e11b815260048101859052602481018690523090633bc6460a90604401602060405180830381865afa15801561210f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061213391906127c7565b61214f5760405162461bcd60e51b8152600401610432906127e9565b506001015460ff16949350505050565b600061216b8383612475565b9392505050565b600081815260208390526040812081600182015460ff16600381111561219a5761219a61257b565b14806121be57506002600182015460ff1660038111156121bc576121bc61257b565b145b156115d7576040805184815260208101869052209150611615565b60008115610c0f57600160008381526020889052604090206001015460ff1660038111156122095761220961257b565b11610ab85760405162461bcd60e51b815260040161043290612a38565b600081156123aa57600160008381526020879052604090206001015460ff1660038111156122565761225661257b565b116122735760405162461bcd60e51b815260040161043290612a38565b6000806122808785611928565b915091508160058111156122965761229661257b565b600211156122e05760405162461bcd60e51b8152602060048201526017602482015276496c6c6567616c2041646d696e2053636f70655479706560481b6044820152606401610432565b8160058111156122f2576122f261257b565b60020361231d578581146123185760405162461bcd60e51b815260040161043290612a6f565b6123a0565b604051631de3230560e11b815260048101829052602481018690523090633bc6460a90604401602060405180830381865afa158015612360573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061238491906127c7565b6123a05760405162461bcd60e51b815260040161043290612a6f565b8392505050610a55565b50919392505050565b60008181526001808401602052604082208291600182015460ff1660058111156123df576123df61257b565b036124015760408051858152600187810160208301529190209350915061240b565b6000199250600091505b509250929050565b6000818152602083905260408120819060025b600182015460ff16600381111561243f5761243f61257b565b036124015760408051858152602081018790522092506001915061240b565b600081815260208390526040812081906003612426565b60008181526001830160205260408120546124bc57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155611922565b506000611922565b60008060008084860360a08112156124db57600080fd5b853594506040601f19820112156124f157600080fd5b509295602085019550606085013594608001359350915050565b600060208083528351808285015260005b818110156125385785810183015185820160400152820161251c565b506000604082860101526040601f19601f8301168501019250505092915050565b6000806040838503121561256c57600080fd5b50508035926020909101359150565b634e487b7160e01b600052602160045260246000fd5b600681106125a1576125a161257b565b9052565b604081016125b38285612591565b8260208301529392505050565b803562ffffff811681146125d357600080fd5b919050565b600080600080600060a086880312156125f057600080fd5b85359450602086013567ffffffffffffffff81111561260e57600080fd5b860160e0818903121561262057600080fd5b9350604086013592506060860135915061263c608087016125c0565b90509295509295909350565b8035600681106125d357600080fd5b6000806000806080858703121561266d57600080fd5b84359350602085013592506040850135915061268b60608601612648565b905092959194509250565b600080600080608085870312156126ac57600080fd5b5050823594602084013594506040840135936060013592509050565b600080600080600060a086880312156126e057600080fd5b853594506126f060208701612648565b94979496505050506040830135926060810135926080909101359150565b60008060006060848603121561272357600080fd5b505081359360208301359350604090920135919050565b602081016119228284612591565b602081016008831061275c5761275c61257b565b91905290565b60008082840361026081121561277757600080fd5b83359250610240601f198201121561278e57600080fd5b506020830190509250929050565b602080825260119082015270496c6c6567616c2053636f70655479706560781b604082015260600190565b6000602082840312156127d957600080fd5b8151801515811461216b57600080fd5b6020808252600d908201526c496c6c6567616c2053636f706560981b604082015260600190565b7f545950452e4c4956454c595f56455253452e4c4956454c595f414e4f4e594d4f815261555360f01b602082015260220190565b6000808335601e1984360301811261285b57600080fd5b83018035915067ffffffffffffffff82111561287657600080fd5b6020019150368190038213156105c957600080fd5b60048110611f0d57600080fd5b6000602082840312156128aa57600080fd5b813561216b8161288b565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806128df57607f821691505b6020821081036128ff57634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561294f57600081815260208120601f850160051c8101602086101561292c5750805b601f850160051c820191505b8181101561294b57828155600101612938565b5050505b505050565b67ffffffffffffffff83111561296c5761296c6128b5565b6129808361297a83546128cb565b83612905565b6000601f8411600181146129b4576000851561299c5750838201355b600019600387901b1c1916600186901b178355612a0e565b600083815260209020601f19861690835b828110156129e557868501358255602094850194600190920191016129c5565b5086821015612a025760001960f88860031b161c19848701351681555b505060018560011b0183555b5050505050565b600060208284031215612a2757600080fd5b81358060030b811461216b57600080fd5b60208082526017908201527f496c6c6567616c2041646d696e204167656e7454797065000000000000000000604082015260600190565b602080825260139082015272496c6c6567616c2041646d696e2053636f706560681b604082015260600190565b600060208284031215612aae57600080fd5b813561ffff8116811461216b57600080fd5b600060208284031215612ad257600080fd5b813560ff8116811461216b57600080fd5b600060208284031215612af557600080fd5b61216b826125c0565b63ffffffff81811683821601908082111561161557634e487b7160e01b600052601160045260246000fd5b818382376000910190815291905056fea26469706673582212202afcf9280eefab7a2e70116a0717c1347fe17111865fb7f1342d6a2d9d25137764736f6c63430008130033",
  "devdoc": {
    "author": "Sina Tadayon, https://github.com/SinaTadayon",
    "kind": "dev",
    "methods": {},
    "title": "ACL Commons Library",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}