{
  "language": "Solidity",
  "sources": {
    "src/contracts/acl/AccessControlManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IAccessControl.sol\";\nimport \"./AccessControlStorage.sol\";\nimport \"./IGroupManagement.sol\";\nimport \"./IRealmManagement.sol\";\nimport \"./IRoleManagement.sol\";\nimport \"./IContextManagement.sol\";\nimport \"../lib/struct/LEnumerableSet.sol\";\nimport \"../lib/struct/LEnumerableMap.sol\";\nimport \"../lib/acl/LContextManagement.sol\";\nimport \"../lib/acl/LRoleManagement.sol\";\nimport \"../lib/acl/LGroupManagement.sol\";\nimport \"../lib/acl/LRealmManagement.sol\";\nimport \"../lib/acl/LAccessControl.sol\";\nimport \"../proxy/Initializable.sol\";\nimport \"../proxy/BaseUUPSProxy.sol\";\n\ncontract AccessControlManager is\n  AccessControlStorage,\n  BaseUUPSProxy,\n  IContextManagement,\n  IAccessControl,\n  IGroupManagement,\n  IRealmManagement,\n  IRoleManagement\n{\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableMap for LEnumerableMap.Bytes32ToBytes32Map;\n  using LEnumerableMap for LEnumerableMap.AddressToUintMap;\n\n  constructor() {}\n\n  function initialize(\n    string calldata domainName,\n    string calldata domainVersion,\n    string calldata domainRealm,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n\n    LAccessControl.initializeContext(_data);\n\n    __BASE_UUPS_init(domainName, domainVersion, realm, accessControlManager);\n\n    RequestRegisterContext[] memory rc = LAccessControl.createRequestContext();\n    LContextManagement.registerAccessControlManagerContext(_data, address(this), realm, rc);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      domainName,\n      domainVersion,\n      realm,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n    return\n      interfaceId == type(IAccessControl).interfaceId ||\n      interfaceId == type(IContextManagement).interfaceId ||\n      interfaceId == type(IRoleManagement).interfaceId ||\n      interfaceId == type(IGroupManagement).interfaceId ||\n      interfaceId == type(IRealmManagement).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function hasAccess(\n    bytes32 context,\n    address account,\n    bytes4 signature\n  ) external view returns (bool) {\n    return LAccessControl.hasAccess(_data, context, account, signature);\n  }\n\n  function isLivelySystemAdminRole(address account) external view returns (bool) {\n    return LAccessControl.isLivelySystemAdminRole(_data, account);\n  }\n\n  function isLivelyAdminRole(address account) external view returns (bool) {\n    return LAccessControl.isLivelyAdminRole(_data, account);\n  }\n\n  function isLivelyAssetManagerRole(address account) external view returns (bool) {\n    return LAccessControl.isLivelyAssetManagerRole(_data, account);\n  }\n\n  function isLivelyAssetAdminRole(address account) external view returns (bool) {\n    return LAccessControl.isLivelyAssetAdminRole(_data, account);\n  }\n\n  function isLivelyCommunityDaoRole(address account) external view returns (bool) {\n    return LAccessControl.isLivelyCommunityDaoRole(_data, account);\n  }\n\n  function isLivelyCommunityDaoExecutorRole(address account) external view returns (bool) {\n    return LAccessControl.isLivelyCommunityDaoExecutorRole(_data, account);\n  }\n\n  function isLivelyGeneralGroup(bytes32 role) external view returns (bool) {\n    return LAccessControl.isLivelyGeneralGroup(_data, role);\n  }\n\n  function isLivelyDaoGroup(bytes32 role) external view returns (bool) {\n    return LAccessControl.isLivelyDaoGroup(_data, role);\n  }\n\n  function isLivelyAssetGroup(bytes32 role) external view returns (bool) {\n    return LAccessControl.isLivelyAssetGroup(_data, role);\n  }\n\n  function isLivelyGeneralRealm(bytes32 context) external view returns (bool) {\n    return LAccessControl.isLivelyGeneralRealm(_data, context);\n  }\n\n  function isLivelyAssetRealm(bytes32 context) external view returns (bool) {\n    return LAccessControl.isLivelyAssetRealm(_data, context);\n  }\n\n  function isContextSafeMode(bytes32 context) external view returns (bool) {\n    return LAccessControl.isContextSafeMode(_data, context);\n  }\n\n  function isContextUpgradable(bytes32 context) external view returns (bool) {\n    return LAccessControl.isContextUpgradable(_data, context);\n  }\n\n  function isRealmUpgradable(bytes32 realm) external view returns (bool) {\n    return LAccessControl.isRealmUpgradable(_data, realm);\n  }\n\n  function isGroupExists(bytes32 group) external view returns (bool) {\n    return LAccessControl.isGroupExists(_data, group);\n  }\n\n  function isGroupEnabled(bytes32 group) external view returns (bool) {\n    return LAccessControl.isGroupEnabled(_data, group);\n  }\n\n  function isContextExists(bytes32 context) external view returns (bool) {\n    return LAccessControl.isContextExists(_data, context);\n  }\n\n  function isContextFunctionExists(bytes32 context, bytes4 functionSelector) external view returns (bool) {\n    return LAccessControl.isContextFunctionExists(_data, context, functionSelector);\n  }\n\n  function isContextFunctionEnabled(bytes32 context, bytes4 functionSelector) external view returns (bool) {\n    return LAccessControl.isContextFunctionEnabled(_data, context, functionSelector);\n  }\n\n  function isContextEnabled(bytes32 context) external view returns (bool) {\n    return LAccessControl.isContextEnabled(_data, context);\n  }\n\n  function isRoleExists(bytes32 role) external view returns (bool) {\n    return LAccessControl.isRoleExists(_data, role);\n  }\n\n  function isRoleEnabled(bytes32 role) external view returns (bool) {\n    return LAccessControl.isRoleEnabled(_data, role);\n  }\n\n  function isRealmExists(bytes32 realm) external view returns (bool) {\n    return LAccessControl.isRealmExists(_data, realm);\n  }\n\n  function isRealmEnabled(bytes32 realm) external view returns (bool) {\n    return LAccessControl.isRealmEnabled(_data, realm);\n  }\n\n  function registerContext(\n    bytes memory signature,\n    RequestContext calldata rc,\n    RequestRegisterContext[] calldata rrc\n  ) external returns (bytes32) {\n    (bytes32 context, address signer) = LContextManagement.registerContext(_data, signature, rc, rrc);\n    emit ContextRegistered(context, rc.contractId, signer, _msgSender(), rc.realm);\n    return context;\n  }\n\n  function registerPredictContext(\n    bytes memory signature,\n    RequestPredictContext calldata rpc,\n    RequestRegisterContext[] calldata rrc\n  ) external returns (bytes32) {\n    (address contractId, bytes32 context, address signer) = LContextManagement.registerPredictContext(_data, signature, rpc, rrc);\n    emit PredictContextRegistered(context, contractId, _msgSender(), signer, rpc.deployer, rpc.subject, rpc.realm);\n    return context;\n  }\n\n  function updateContext(\n    bytes32 ctx,\n    bytes memory signature,\n    RequestContext calldata rc,\n    RequestUpdateContext[] calldata rcr\n  ) external returns (address) {\n    (address contractId, address sender) = LContextManagement.updateContext(_data, ctx, signature, rc, rcr);\n    emit ContextUpdated(ctx, contractId, sender, rc.realm);\n    return contractId;\n  }\n\n  function addContextFuncRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool) {\n    bytes32 realm = LContextManagement.addContextFuncRole(_data, ctx, functionSelector, role);\n    emit ContextFuncRoleAdded(ctx, role, msg.sender, functionSelector, realm);\n    return true;\n  }\n\n  function removeContextFunc(bytes32 ctx, bytes4 functionSelector) external returns (bool) {\n    bytes32 realm = LContextManagement.removeContextFunc(_data, ctx, functionSelector);\n    emit ContextFuncRemoved(ctx, msg.sender, functionSelector, realm);\n    return true;\n  }\n\n  function grantContextRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool) {\n    bytes32 realm = LContextManagement.grantContextRole(_data, ctx, functionSelector, role);\n    emit ContextRoleGranted(ctx, role, msg.sender, functionSelector, realm);\n    return true;\n  }\n\n  function revokeContextRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool) {\n    bytes32 realm = LContextManagement.revokeContextRole(_data, ctx, functionSelector, role);\n    emit ContextRoleRevoked(ctx, role, msg.sender, functionSelector, realm);\n    return true;\n  }\n\n  function setContextStatus(bytes32 ctx, bool status) external returns (bool) {\n    (bool success, bytes32 realm) = LContextManagement.setContextStatus(_data, ctx, status);\n    emit ContextStatusChanged(ctx, _msgSender(), realm, status);\n    return success;\n  }\n\n  function setContextRealm(bytes32 ctx, bytes32 realm) external returns (bool) {\n    (bool success, bytes32 oldRealm) = LContextManagement.setContextRealm(_data, ctx, realm);\n    emit ContextRealmChanged(ctx, _msgSender(), realm, oldRealm);\n    return success;\n  }\n\n  function hasContextRole(\n    bytes32 ctx,\n    bytes32 role,\n    bytes4 functionSelector\n  ) external view returns (bool) {\n    return LContextManagement.hasContextRole(_data, ctx, role, functionSelector);\n  }\n\n  function getContextInfo(bytes32 ctx) external view returns (ResponseContext memory) {\n    return LContextManagement.getContextInfo(_data, ctx);\n  }\n\n  function getContextFuncs(bytes32 ctx) external view returns (bytes4[] memory) {\n    return LContextManagement.getContextFuncs(_data, ctx);\n  }\n\n  function registerGroup(string calldata name, bool status) external returns (bytes32) {\n    bytes32 group = LGroupManagement.registerGroup(_data, name, status);\n    emit GroupRegistered(group, _msgSender(), name, status);\n    return group;\n  }\n\n  function setGroupStatus(bytes32 group, bool status) external returns (bool) {\n    emit GroupStatusChanged(group, _msgSender(), status);\n    return LGroupManagement.setGroupStatus(_data, group, status);\n  }\n\n  function hasGroupRole(bytes32 group, bytes32 role) external view returns (bool) {\n    return LGroupManagement.hasGroupRole(_data, group, role);\n  }\n\n  function getGroupInfo(bytes32 group) external view returns (string memory, bool) {\n    return LGroupManagement.getGroupInfo(_data, group);\n  }\n\n  function getGroupRoles(bytes32 group) external view returns (bytes32[] memory) {\n    return LGroupManagement.getGroupRoles(_data, group);\n  }\n\n  function registerRealm(\n    string calldata name,\n    bool status,\n    bool isUpgradable\n  ) external returns (bytes32) {\n    bytes32 realm = LRealmManagement.registerRealm(_data, name, status, isUpgradable);\n    emit RealmRegistered(realm, _msgSender(), name, status, isUpgradable);\n    return realm;\n  }\n\n  function setRealmStatus(bytes32 realm, bool status) external returns (bool) {\n    emit RealmStatusChanged(realm, _msgSender(), status);\n    return LRealmManagement.setRealmStatus(_data, realm, status);\n  }\n\n  function setRealmUpgradeStatus(bytes32 realm, bool status) external returns (bool) {\n    emit RealmUpgradeStatusChanged(realm, _msgSender(), status);\n    return LRealmManagement.setRealmUpgradeStatus(_data, realm, status);\n  }\n\n  function hasRealmContext(bytes32 realm, bytes32 context) external view returns (bool) {\n    return LRealmManagement.hasRealmContext(_data, realm, context);\n  }\n\n  function getRealmInfo(bytes32 realm)\n    external\n    view\n    returns (\n      string memory,\n      bool,\n      bool\n    )\n  {\n    return LRealmManagement.getRealmInfo(_data, realm);\n  }\n\n  function getRealmContexts(bytes32 realm) external view returns (bytes32[] memory) {\n    return LRealmManagement.getRealmContexts(_data, realm);\n  }\n\n  function grantRoleAccount(bytes32 role, address account) external returns (bool) {\n    emit RoleAccountGranted(_msgSender(), role, account);\n    return LRoleManagement.grantRoleAccount(_data, role, account);\n  }\n\n  function batchGrantRoleAccount(UpdateRoleRequest[] calldata requests) external returns (bool) {\n    for (uint i; i < requests.length; i++) {\n      emit RoleAccountGranted(_msgSender(), requests[i].role, requests[i].account);\n    }\n    return LRoleManagement.batchGrantRoleAccount(_data, requests);    \n  }\n\n  function revokeRoleAccount(bytes32 role, address account) external returns (bool) {\n    emit RoleAccountRevoked(_msgSender(), role, account);\n    return LRoleManagement.revokeRoleAccount(_data, role, account);\n  }\n\n  function batchRevokeRoleAccount(UpdateRoleRequest[] calldata requests) external returns (bool) {\n    for (uint i; i < requests.length; i++) {\n      emit RoleAccountRevoked(_msgSender(), requests[i].role, requests[i].account);\n    }\n    return LRoleManagement.batchRevokeRoleAccount(_data, requests);\n  }\n\n  function registerRole(\n    string calldata name,\n    bytes32 group,\n    bool status\n  ) external returns (bytes32) {\n    bytes32 role = LRoleManagement.registerRole(_data, name, group, status);\n    emit RoleRegistered(_msgSender(), role, name, group, status);\n    return role;\n  }\n\n  function batchRegisterRole(RegiterRoleRequest[] calldata requests) external returns(bytes32[] memory) {\n    bytes32[] memory roles = LRoleManagement.batchRegisterRole(_data, requests);\n    for (uint i; i < requests.length; i++) {\n      emit RoleRegistered(_msgSender(), roles[i], requests[i].name, requests[i].group, requests[i].status);\n    }\n    \n    return roles;\n  }\n\n  function setRoleStatus(bytes32 role, bool status) external returns (bool) {\n    (bool success, bytes32 group) = LRoleManagement.setRoleStatus(_data, role, status);\n    emit RoleStatusChanged(_msgSender(), role, group, status);\n    return success;\n  }\n\n  function setRoleGroup(bytes32 role, bytes32 group) external returns (bool) {\n    (bool success, bytes32 oldGroup) = LRoleManagement.setRoleGroup(_data, role, group);\n    emit RoleGroupChanged(_msgSender(), role, group, oldGroup);\n    return success;\n  }\n\n  function getRoleInfo(bytes32 role)\n    external\n    view\n    returns (\n      string memory,\n      bytes32,\n      bool\n    )\n  {\n    return LRoleManagement.getRoleInfo(_data, role);\n  }\n\n  function getRoleAccounts(bytes32 role) external view returns (address[] memory) {\n    return LRoleManagement.getRoleAccounts(_data, role);\n  }\n\n  function hasRoleAccount(bytes32 role, address account) external view returns (bool) {\n    return LRoleManagement.hasRoleAccount(_data, role, account);\n  }\n\n  function getLibraries() external pure returns (address[] memory) {\n    address[] memory libs = new address[](5);\n    libs[0] = address(LAccessControl);\n    libs[1] = address(LContextManagement);\n    libs[2] = address(LRealmManagement);\n    libs[3] = address(LRoleManagement);\n    libs[4] = address(LGroupManagement);\n    return libs;\n  }\n}\n"
    },
    "src/contracts/acl/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IAccessControl {\n  /**\n   * @dev Function called by apps to check ACL\n   * @return boolean indicating whether the ACL allows\n   */\n  function hasAccess(\n    bytes32 context,\n    address account,\n    bytes4 signature\n  ) external view returns (bool);\n\n  function isLivelySystemAdminRole(address account) external view returns (bool);\n\n  function isLivelyAdminRole(address account) external view returns (bool);\n\n  function isLivelyAssetManagerRole(address account) external view returns (bool);\n\n  function isLivelyAssetAdminRole(address account) external view returns (bool);\n\n  function isLivelyCommunityDaoRole(address account) external view returns (bool);\n\n  function isLivelyCommunityDaoExecutorRole(address account) external view returns (bool);\n\n  function isLivelyGeneralGroup(bytes32 role) external view returns (bool);\n\n  function isLivelyDaoGroup(bytes32 role) external view returns (bool);\n\n  function isLivelyAssetGroup(bytes32 role) external view returns (bool);\n\n  function isLivelyGeneralRealm(bytes32 context) external view returns (bool);\n\n  function isLivelyAssetRealm(bytes32 context) external view returns (bool);\n\n  function isContextSafeMode(bytes32 context) external view returns (bool);\n\n  function isContextUpgradable(bytes32 context) external view returns (bool);\n\n  function isContextExists(bytes32 context) external view returns (bool);\n\n  function isContextFunctionExists(bytes32 context, bytes4 functionSelector) external view returns (bool);\n\n  function isContextFunctionEnabled(bytes32 context, bytes4 functionSelector) external view returns (bool);\n\n  function isContextEnabled(bytes32 context) external view returns (bool);\n\n  function isGroupExists(bytes32 group) external view returns (bool);\n\n  function isGroupEnabled(bytes32 group) external view returns (bool);\n\n  function isRoleExists(bytes32 role) external view returns (bool);\n\n  function isRoleEnabled(bytes32 role) external view returns (bool);\n\n  function isRealmExists(bytes32 realm) external view returns (bool);\n\n  function isRealmEnabled(bytes32 realm) external view returns (bool); \n\n  function isRealmUpgradable(bytes32 realm) external view returns (bool);\n}\n"
    },
    "src/contracts/acl/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../lib/struct/LEnumerableSet.sol\";\nimport \"../lib/struct/LEnumerableMap.sol\";\nimport \"../proxy/BaseUUPSStorage.sol\";\n\nabstract contract AccessControlStorage is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableMap for LEnumerableMap.Bytes32ToBytes32Map;\n  using LEnumerableMap for LEnumerableMap.AddressToUintMap;\n\n  enum Status {\n    NONE,\n    ENABLED,\n    DISABLED\n  }\n\n  struct RoleStat {\n    bytes32 role;\n    Status status;\n  }\n\n  struct Context {\n    bytes32 realm;\n    address contractId;\n    bool isEnabled;\n    mapping(bytes4 => RoleStat) resources; // function selector => RoleStat\n    LEnumerableSet.Bytes32Set funcSet;\n  }\n\n  struct Role {\n    bytes32 group;\n    string name;\n    bool isEnabled;\n    LEnumerableSet.AddressSet accountSet;\n  }\n\n  struct Realm {\n    string name;\n    bool isEnabled;\n    bool isUpgradable;\n    LEnumerableSet.Bytes32Set ctxSet;\n  }\n\n  struct Group {\n    string name;\n    bool isEnabled;\n    LEnumerableSet.Bytes32Set roleSet;\n  }\n\n  struct DataCollections {\n    mapping(address => mapping(bytes32 => Status)) accountMap;\n    mapping(bytes32 => Context) ctxMap;\n    mapping(bytes32 => Role) roleMap;\n    mapping(bytes32 => Realm) realmMap;\n    mapping(bytes32 => Group) groupMap;\n  }\n\n  DataCollections internal _data;\n}\n"
    },
    "src/contracts/acl/IGroupManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IGroupManagement {\n  event GroupRegistered(bytes32 indexed group, address indexed sender, string name, bool status);\n\n  event GroupStatusChanged(bytes32 indexed group, address indexed sender, bool status);\n\n  function registerGroup(string calldata name, bool status) external returns (bytes32);\n\n  function setGroupStatus(bytes32 group, bool status) external returns (bool);\n\n  function hasGroupRole(bytes32 group, bytes32 role) external view returns (bool);\n\n  function getGroupInfo(bytes32 group) external view returns (string memory, bool);\n\n  function getGroupRoles(bytes32 group) external view returns (bytes32[] memory);\n}\n"
    },
    "src/contracts/acl/IRealmManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IRealmManagement {\n  event RealmRegistered(bytes32 indexed realm, address indexed sender, string name, bool status, bool isUpgradable);\n\n  event RealmStatusChanged(bytes32 indexed realm, address indexed sender, bool status);\n\n  event RealmUpgradeStatusChanged(bytes32 indexed realm, address indexed sender, bool status);\n\n  function registerRealm(\n    string calldata name,\n    bool status,\n    bool isUpgradable\n  ) external returns (bytes32);\n\n  function setRealmStatus(bytes32 realm, bool status) external returns (bool);\n\n  function setRealmUpgradeStatus(bytes32 realm, bool status) external returns (bool);\n\n  function hasRealmContext(bytes32 realm, bytes32 context) external view returns (bool);\n\n  function getRealmInfo(bytes32 realm)\n    external\n    view\n    returns (\n      string memory,\n      bool,\n      bool\n    );\n\n  function getRealmContexts(bytes32 realm) external view returns (bytes32[] memory);\n}\n"
    },
    "src/contracts/acl/IRoleManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IRoleManagement {\n\n  struct RegiterRoleRequest {\n    bytes32 group;\n    string name;    \n    bool status;\n  }\n\n  struct UpdateRoleRequest {\n    bytes32 role;\n    address account;\n  }\n\n  event RoleAccountGranted(address indexed sender, bytes32 indexed role, address indexed account);\n\n  event RoleAccountRevoked(address indexed sender, bytes32 indexed role, address indexed account);\n\n  event RoleRegistered(\n    address indexed sender,\n    bytes32 indexed role,\n    string indexed name,\n    bytes32 group,\n    bool isEnabled\n  );\n\n  event RoleStatusChanged(address indexed sender, bytes32 indexed role, bytes32 indexed group, bool status);\n\n  event RoleGroupChanged(address indexed sender, bytes32 indexed role, bytes32 indexed newGroup, bytes32 oldGroup);\n\n  function registerRole(\n    string calldata name,\n    bytes32 group,\n    bool status\n  ) external returns (bytes32);\n\n  function batchRegisterRole(RegiterRoleRequest[] calldata requests) external returns(bytes32[] memory);\n\n  function grantRoleAccount(bytes32 role, address account) external returns (bool);\n\n  function batchGrantRoleAccount(UpdateRoleRequest[] calldata requests) external returns (bool);\n\n  function revokeRoleAccount(bytes32 role, address account) external returns (bool);\n\n  function batchRevokeRoleAccount(UpdateRoleRequest[] calldata requests) external returns (bool);\n\n  function setRoleStatus(bytes32 role, bool status) external returns (bool);\n\n  function setRoleGroup(bytes32 role, bytes32 group) external returns (bool);\n\n  function getRoleInfo(bytes32 role)\n    external\n    view\n    returns (\n      string memory,\n      bytes32,\n      bool\n    );\n\n  function getRoleAccounts(bytes32 role) external view returns (address[] memory);\n\n  function hasRoleAccount(bytes32 role, address account) external view returns (bool);\n}\n"
    },
    "src/contracts/acl/IContextManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IContextManagement {\n  enum UpdateContextStatus {\n    DISABLE,\n    ENABLE,\n    REMOVE\n  }\n\n  struct RequestContext {\n    bytes32 name;\n    bytes32 version;\n    bytes32 realm;\n    address contractId;\n    bool status;\n  }\n\n   struct RequestPredictContext {\n    bytes32 name;\n    bytes32 version;\n    bytes32 realm;\n    bytes32 salt;\n    address subject;\n    address deployer;\n    bool status;\n  }\n\n  struct RequestRegisterContext {\n    bytes32 role;\n    bytes4[] funcSelectors;\n    bool isEnabled;\n  }\n\n  struct RequestUpdateContext {\n    bytes32 role;\n    bytes4[] funcSelectors;\n    UpdateContextStatus updateStatus;\n  }\n\n  struct ResponseContext {\n    bytes32 name;\n    bytes32 version;\n    bytes32 realm;\n    address contractId;\n    bool isSafeMode;\n    bool isUpgradable;\n  }\n\n  event ContextRegistered(bytes32 indexed context, address indexed contractId, address indexed sender, address signer, bytes32 realm);\n\n  event PredictContextRegistered(bytes32 indexed context, address indexed contractId, address indexed sender, address signer, address deployer, address subject, bytes32 realm);\n\n  event ContextUpdated(bytes32 indexed context, address indexed contractId, address indexed sender, bytes32 realm);\n\n  event ContextStatusChanged(bytes32 indexed context, address indexed sender, bytes32 indexed realm, bool status);\n\n  event ContextFuncRoleAdded(\n    bytes32 indexed context,\n    bytes32 indexed role,\n    address indexed sender,\n    bytes4 functionSelector,\n    bytes32 realm\n  );\n\n  event ContextFuncRemoved(bytes32 indexed context, address indexed sender, bytes4 functionSelector, bytes32 realm);\n\n  event ContextRoleGranted(\n    bytes32 indexed context,\n    bytes32 indexed role,\n    address indexed sender,\n    bytes4 functionSelector,\n    bytes32 realm\n  );\n\n  event ContextRoleRevoked(\n    bytes32 indexed context,\n    bytes32 indexed role,\n    address indexed sender,\n    bytes4 functionSelector,\n    bytes32 realm\n  );\n\n  event ContextRealmChanged(bytes32 indexed context, address indexed sender, bytes32 indexed realm, bytes32 oldRealm);\n\n  function registerContext(\n    bytes memory signature,\n    RequestContext calldata rc,\n    RequestRegisterContext[] calldata rcr\n  ) external returns (bytes32);\n\n  function registerPredictContext(\n    bytes memory signature,\n    RequestPredictContext calldata rpc,\n    RequestRegisterContext[] calldata rrc\n  ) external returns (bytes32);\n\n  function updateContext(\n    bytes32 ctx,\n    bytes memory signature,\n    RequestContext calldata rc,\n    RequestUpdateContext[] calldata ruc\n  ) external returns (address);\n\n  function addContextFuncRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool);\n\n  function removeContextFunc(bytes32 ctx, bytes4 functionSelector) external returns (bool);\n\n  function grantContextRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool);\n\n  function revokeContextRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool);\n\n  function setContextRealm(bytes32 ctx, bytes32 realm) external returns (bool);\n\n  function setContextStatus(bytes32 ctx, bool status) external returns (bool);\n\n  function hasContextRole(\n    bytes32 ctx,\n    bytes32 role,\n    bytes4 functionSelector\n  ) external view returns (bool);\n\n  function getContextInfo(bytes32 ctx) external view returns (ResponseContext memory);\n\n  function getContextFuncs(bytes32 ctx) external view returns (bytes4[] memory);\n}\n"
    },
    "src/contracts/lib/struct/LEnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary LEnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n    return _values(set._inner);\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(AddressSet storage set) internal view returns (address[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/contracts/lib/struct/LEnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./LEnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) \n * - `address -> uint256` (`AddressToUintMap`) \n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) \n * - `uint256 -> uint256` (`UintToUintMap`) \n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) \n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an array of EnumerableMap.\n * ====\n */\nlibrary LEnumerableMap {\n    using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        LEnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToUintMap storage map,\n        uint256 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToUintMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key), errorMessage));\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        AddressToUintMap storage map,\n        address key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, key, errorMessage));\n    }\n}\n"
    },
    "src/contracts/lib/acl/LContextManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../LContextUtils.sol\";\nimport \"./LAccessControl.sol\";\nimport \"../cryptography/LECDSA.sol\";\nimport \"../proxy/LClones.sol\";\n\nlibrary LContextManagement {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LClones for address;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LContextManagement\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  bytes32 public constant TYPE_HASH =\n    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n  \n  bytes32 public constant CTX_MESSAGE_TYPEHASH =\n    keccak256(\"Context(address contractId,string name,string version,string realm)\");\n  \n  bytes32 public constant PREDICT_CTX_MESSAGE_TYPEHASH =\n    keccak256(\"PredictContext(address deployer,address subject,string realm)\");\n\n  function registerAccessControlManagerContext(\n    AccessControlStorage.DataCollections storage data,\n    address newContract,\n    bytes32 realm,\n    IContextManagement.RequestRegisterContext[] calldata rc\n  ) external returns (bytes32) {\n    return _registerContext(data, newContract, realm, true, rc);\n  }\n\n  function registerContext(\n    AccessControlStorage.DataCollections storage data,\n    bytes memory signature,\n    IContextManagement.RequestContext calldata rc,\n    IContextManagement.RequestRegisterContext[] calldata rrc\n  ) external returns (bytes32, address) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n\n    bytes32 structHash = _getContextMessageHash(rc.contractId, rc.name, rc.version, rc.realm);\n    bytes32 msgDigest = _hashTypedDataV4(structHash);\n    (address msgSigner, LECDSA.RecoverError recoverErr) = LECDSA.tryRecover(msgDigest, signature);\n\n    require(recoverErr == LECDSA.RecoverError.NoError, \"Illegal ECDASA Signature\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msgSigner,\n        IContextManagement.registerContext.selector\n      ),\n      \"RegisterContext Access Denied\"\n    );\n    return (_registerContext(data, rc.contractId, rc.realm, rc.status, rrc), msgSigner);\n  }\n\n  function registerPredictContext(\n      AccessControlStorage.DataCollections storage data,\n      bytes memory signature,\n      IContextManagement.RequestPredictContext calldata rpc,\n      IContextManagement.RequestRegisterContext[] calldata rrc\n  ) external returns (address, bytes32, address) {\n        require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n\n    bytes32 structHash = _getPredictContextMessageHash(rpc.deployer, rpc.subject, rpc.realm);\n    bytes32 msgDigest = _hashTypedDataV4(structHash);\n    (address msgSigner, LECDSA.RecoverError recoverErr) = LECDSA.tryRecover(msgDigest, signature);\n\n    require(recoverErr == LECDSA.RecoverError.NoError, \"Illegal ECDASA Signature\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msgSigner,\n        IContextManagement.registerContext.selector\n      ),\n      \"RegisterPredictContext Access Denied\"\n    );\n\n    (address contractId, bytes32 ctx) = _registerPredictContext(data, rrc, rpc);\n    return (contractId, ctx, msgSigner);\n  }\n\n\n  function _getContextMessageHash(\n    address contractId,\n    bytes32 name,\n    bytes32 version,\n    bytes32 realm\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(CTX_MESSAGE_TYPEHASH, contractId, name, version, realm));\n  }\n\n  function _getPredictContextMessageHash(\n    address deployer,\n    address subject,\n    bytes32 realm\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(PREDICT_CTX_MESSAGE_TYPEHASH, deployer, subject, realm));\n  }\n\n  function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {\n    return LECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          TYPE_HASH,\n          IProxy(address(this)).contractName(),\n          IProxy(address(this)).contractVersion(),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  function _registerContext(\n    AccessControlStorage.DataCollections storage data,\n    address newContract,\n    bytes32 realm,\n    bool status,\n    IContextManagement.RequestRegisterContext[] calldata rrc\n  ) private returns (bytes32) {\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    bytes32 ctx = LContextUtils.generateCtx(newContract);\n    require(data.ctxMap[ctx].contractId == address(0), \"Context Already Registered\");\n    data.realmMap[realm].ctxSet.add(ctx);\n    AccessControlStorage.Context storage newContext = data.ctxMap[ctx];\n    newContext.realm = realm;\n    newContext.contractId = newContract;\n    newContext.isEnabled = status;\n\n    for (uint256 i = 0; i < rrc.length; i++) {\n      require(bytes(data.roleMap[rrc[i].role].name).length != 0, \"Role Not Found\");\n      for (uint256 j = 0; j < rrc[i].funcSelectors.length; j++) {\n        newContext.resources[rrc[i].funcSelectors[j]].role = rrc[i].role;\n        newContext.resources[rrc[i].funcSelectors[j]].status = rrc[i].isEnabled\n          ? AccessControlStorage.Status.ENABLED\n          : AccessControlStorage.Status.DISABLED;\n        newContext.funcSet.add(rrc[i].funcSelectors[j]);\n      }\n    }\n\n    return ctx;\n  }\n\n  function _registerPredictContext(\n    AccessControlStorage.DataCollections storage data,\n    IContextManagement.RequestRegisterContext[] calldata rrc,\n    IContextManagement.RequestPredictContext calldata rpc\n  ) private returns (address, bytes32) {\n    require(bytes(data.realmMap[rpc.realm].name).length != 0, \"Realm Not Found\");\n\n    address predictedContractId = rpc.subject.predictDeterministicAddress(rpc.salt, rpc.deployer);\n    bytes32 ctx = LContextUtils.generateCtx(predictedContractId);\n\n    require(data.ctxMap[ctx].contractId == address(0), \"Context Already Registered\");\n    data.realmMap[rpc.realm].ctxSet.add(ctx);\n    AccessControlStorage.Context storage newContext = data.ctxMap[ctx];\n    newContext.realm = rpc.realm;\n    newContext.contractId = predictedContractId;\n    newContext.isEnabled = rpc.status;\n\n    for (uint256 i = 0; i < rrc.length; i++) {  \n      require(bytes(data.roleMap[rrc[i].role].name).length != 0, \"Role Not Found\");\n      for (uint256 j = 0; j < rrc[i].funcSelectors.length; j++) {\n        newContext.resources[rrc[i].funcSelectors[j]].role = rrc[i].role;\n        newContext.resources[rrc[i].funcSelectors[j]].status = rrc[i].isEnabled\n          ? AccessControlStorage.Status.ENABLED\n          : AccessControlStorage.Status.DISABLED;\n        newContext.funcSet.add(rrc[i].funcSelectors[j]);\n      }\n    }\n\n    return (predictedContractId, ctx);\n  }\n\n  function updateContext(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes memory signature,\n    IContextManagement.RequestContext calldata rc,\n    IContextManagement.RequestUpdateContext[] calldata ruc\n  ) external returns (address, address) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n\n    bytes32 structHash = _getContextMessageHash(rc.contractId, rc.name, rc.version, rc.realm);\n    bytes32 msgDigest = _hashTypedDataV4(structHash);\n    (address msgSigner, LECDSA.RecoverError recoverErr) = LECDSA.tryRecover(msgDigest, signature);\n    require(recoverErr == LECDSA.RecoverError.NoError, \"Illegal ECDASA Signature\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msgSigner,\n        IContextManagement.updateContext.selector\n      ),\n      \"UpdateContext Access Denied\"\n    );\n    return (_updateContext(data, ctx, rc.realm, rc.status, ruc), msgSigner);\n  }\n\n  function _updateContext(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes32 realm,\n    bool status,\n    IContextManagement.RequestUpdateContext[] calldata ruc\n  ) internal returns (address) {\n    address contractId = data.ctxMap[ctx].contractId;\n    require(contractId != address(0), \"Context Not Found\");\n    require(contractId == msg.sender, \"Update Context Forbidden\");\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    data.ctxMap[ctx].isEnabled = status;\n\n    if (data.ctxMap[ctx].realm != realm) {\n      data.realmMap[data.ctxMap[ctx].realm].ctxSet.remove(ctx);\n      data.realmMap[realm].ctxSet.add(ctx);\n    }\n    data.ctxMap[ctx].realm = realm;\n\n    for (uint256 i = 0; i < ruc.length; i++) {\n      require(bytes(data.roleMap[ruc[i].role].name).length != 0, \"Role Not Found\");\n      for (uint256 j = 0; j < ruc[i].funcSelectors.length; j++) {\n        if (\n          ruc[i].updateStatus == IContextManagement.UpdateContextStatus.ENABLE ||\n          ruc[i].updateStatus == IContextManagement.UpdateContextStatus.DISABLE\n        ) {\n          data.ctxMap[ctx].resources[ruc[i].funcSelectors[j]].role = ruc[i].role;\n          data.ctxMap[ctx].resources[ruc[i].funcSelectors[j]].status = ruc[i].updateStatus ==\n            IContextManagement.UpdateContextStatus.ENABLE\n            ? AccessControlStorage.Status.ENABLED\n            : AccessControlStorage.Status.DISABLED;\n          if (!data.ctxMap[ctx].funcSet.contains(ruc[i].funcSelectors[j])) {\n            data.ctxMap[ctx].funcSet.add(ruc[i].funcSelectors[j]);\n          }\n        } else {\n          delete data.ctxMap[ctx].resources[ruc[i].funcSelectors[j]].role;\n          delete data.ctxMap[ctx].resources[ruc[i].funcSelectors[j]].status;\n          data.ctxMap[ctx].funcSet.remove(ruc[i].funcSelectors[j]);\n        }\n      }\n    }\n    return contractId;\n  }\n\n  function addContextFuncRole(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.addContextFuncRole.selector\n      ),\n      \"AddContextFuncRole Access Denied\"\n    );\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(!data.ctxMap[ctx].funcSet.contains(functionSelector), \"FunctionSelector Already Exists\");\n    data.ctxMap[ctx].resources[functionSelector].role = role;\n    data.ctxMap[ctx].resources[functionSelector].status = AccessControlStorage.Status.ENABLED;\n    data.ctxMap[ctx].funcSet.add(functionSelector);\n    return data.ctxMap[ctx].realm;\n  }\n\n  function removeContextFunc(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes4 functionSelector\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.removeContextFunc.selector\n      ),\n      \"RemoveContextFunc Access Denied\"\n    );\n\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Remove ACL Context\");\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    require(data.ctxMap[ctx].funcSet.contains(functionSelector), \"FunctionSelector Not Found\");\n    delete data.ctxMap[ctx].resources[functionSelector].role;\n    delete data.ctxMap[ctx].resources[functionSelector].status;\n    data.ctxMap[ctx].funcSet.remove(functionSelector);\n    return data.ctxMap[ctx].realm;\n  }\n\n  function grantContextRole(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.grantContextRole.selector\n      ),\n      \"GrantContextRole Access Denied\"\n    );\n\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Grant ACL Context\");\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(data.ctxMap[ctx].funcSet.contains(functionSelector), \"FunctionSelector Not Found\");\n    data.ctxMap[ctx].resources[functionSelector].role = role;\n    data.ctxMap[ctx].resources[functionSelector].status = AccessControlStorage.Status.ENABLED;\n    return data.ctxMap[ctx].realm;\n  }\n\n  function revokeContextRole(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.revokeContextRole.selector\n      ),\n      \"RevokeContextRole Access Denied\"\n    );\n\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Revoke ACL Context\");\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(data.ctxMap[ctx].funcSet.contains(functionSelector), \"FunctionSelector Not Found\");\n    data.ctxMap[ctx].resources[functionSelector].status = AccessControlStorage.Status.DISABLED;\n    return data.ctxMap[ctx].realm;\n  }\n\n  function setContextStatus(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bool status\n  ) external returns (bool, bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.setContextStatus.selector\n      ),\n      \"SetContextStatus Access Denied\"\n    );\n\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Change ACL Context Status\");\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    data.ctxMap[ctx].isEnabled = status;\n    return (true, data.ctxMap[ctx].realm);\n  }\n\n  function setContextRealm(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes32 realm\n  ) external returns (bool, bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.setContextRealm.selector\n      ),\n      \"SetContextRealm Access Denied\"\n    );\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Change ACL Context Realm\");\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    require(data.ctxMap[ctx].realm != realm, \"Illegal Realm Duplication\");\n    bytes32 oldRealm = data.ctxMap[ctx].realm;\n    data.realmMap[realm].ctxSet.add(ctx);\n    data.realmMap[data.ctxMap[ctx].realm].ctxSet.remove(ctx);\n    return (true, oldRealm);\n  }\n\n  function hasContextRole(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 ctx,\n    bytes32 role,\n    bytes4 functionSelector\n  ) external view returns (bool) {\n    return\n      data.ctxMap[ctx].contractId != address(0) &&\n      data.ctxMap[ctx].resources[functionSelector].role == role &&\n      data.ctxMap[ctx].resources[functionSelector].status == AccessControlStorage.Status.ENABLED;\n  }\n\n  function getContextInfo(AccessControlStorage.DataCollections storage data, bytes32 ctx)\n    external\n    view\n    returns (IContextManagement.ResponseContext memory)\n  {\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    bytes32 name = IProxy(data.ctxMap[ctx].contractId).contractName();\n    bytes32 version = IProxy(data.ctxMap[ctx].contractId).contractVersion();\n    bool isSafeMode = IProxy(data.ctxMap[ctx].contractId).isSafeMode();\n    bool isUpgradable = IProxy(data.ctxMap[ctx].contractId).isUpgradable();\n\n    return\n      IContextManagement.ResponseContext({\n        name: name,\n        version: version,\n        contractId: data.ctxMap[ctx].contractId,\n        realm: data.ctxMap[ctx].realm,\n        isSafeMode: isSafeMode,\n        isUpgradable: isUpgradable\n      });\n  }\n\n  function getContextFuncs(AccessControlStorage.DataCollections storage data, bytes32 ctx)\n    external\n    view\n    returns (bytes4[] memory)\n  {\n    require(data.ctxMap[ctx].contractId != address(0), \"Context Not Found\");\n    bytes4[] memory funcs = new bytes4[](data.ctxMap[ctx].funcSet.length());\n    for (uint32 i = 0; i < data.ctxMap[ctx].funcSet.length(); i++) {\n      funcs[i] = bytes4(data.ctxMap[ctx].funcSet.at(i));\n    }\n    return funcs;\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LAccessControl);\n  }\n}\n"
    },
    "src/contracts/lib/acl/LRoleManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../../acl/IRoleManagement.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../LContextUtils.sol\";\nimport \"./LAccessControl.sol\";\n\nlibrary LRoleManagement {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LRoleManagement\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  function registerRole(\n    AccessControlStorage.DataCollections storage data,\n    string calldata name,\n    bytes32 group,\n    bool isEnabled\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.registerRole.selector\n      ),\n      \"RegisterRole Access Denied\"\n    );\n  \n    return _registerRole(data, name, group, isEnabled);\n  }\n\n  function batchRegisterRole(AccessControlStorage.DataCollections storage data, IRoleManagement.RegiterRoleRequest[] calldata requests) external returns(bytes32[] memory) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.batchRegisterRole.selector\n      ),\n      \"BatchRegisterRole Access Denied\"\n    );\n    bytes32[] memory roles = new bytes32[](requests.length);\n    for(uint i; i < requests.length; i++) {\n      roles[i] = _registerRole(data, requests[i].name, requests[i].group, requests[i].status);\n    }\n    return roles;\n  }\n\n  function _registerRole(\n    AccessControlStorage.DataCollections storage data,\n    string calldata name,\n    bytes32 group,\n    bool isEnabled\n  ) private returns (bytes32) {\n    require(bytes(data.groupMap[group].name).length != 0, \"Group Not Found\");\n    require(bytes(name).length != 0, \"Role Name Invalid\");\n    bytes32 roleKey = keccak256(abi.encodePacked(name));\n    require(bytes(data.roleMap[roleKey].name).length == 0, \"Role Already Registered\");\n\n    data.groupMap[group].roleSet.add(roleKey);\n    AccessControlStorage.Role storage newRole = data.roleMap[roleKey];\n    newRole.name = name;\n    newRole.group = group;\n    newRole.isEnabled = isEnabled;\n    return roleKey;\n  }\n\n\n  function grantRoleAccount(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    address account\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.grantRoleAccount.selector\n      ),\n      \"GrantRoleAccount Access Denied\"\n    );\n\n    _grantRoleAccount(data, role, account);\n    return true;\n  }\n\n  function batchGrantRoleAccount(AccessControlStorage.DataCollections storage data, IRoleManagement.UpdateRoleRequest[] calldata requests) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.batchGrantRoleAccount.selector\n      ),\n      \"BatchGrantRoleAccount Access Denied\"\n    );\n    for(uint i; i < requests.length; i++) {\n      _grantRoleAccount(data, requests[i].role, requests[i].account);\n    }\n    return true;\n  }\n\n   function _grantRoleAccount(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    address account\n  ) private returns (bool) {\n    if(role == LAccessControl.LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE) {      \n      require(account.code.length > 0, \"Illegal Grant Community Dao Executor Role\");\n    }\n\n    if(role == LAccessControl.LIVELY_ASSET_MANAGER_ROLE) {      \n      require(account.code.length > 0, \"Illegal Grant Asset Manager Role\");\n    }\n\n    require(role != LAccessControl.LIVELY_ANONYMOUS_ROLE, \"Illegal Grant Anonymous Role\");\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(account != address(0), \"Address Invalid\");\n    data.accountMap[account][role] = AccessControlStorage.Status.ENABLED;\n    if (!data.roleMap[role].accountSet.contains(account)) {\n      data.roleMap[role].accountSet.add(account);\n    }\n    return true;\n  }\n\n  function revokeRoleAccount(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    address account\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.revokeRoleAccount.selector\n      ),\n      \"RevokeRoleAccount Access Denied\"\n    );\n    \n    _revokeRoleAccount(data, role, account);\n    return true;\n  }\n\n  function batchRevokeRoleAccount(AccessControlStorage.DataCollections storage data, IRoleManagement.UpdateRoleRequest[] calldata requests) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.batchRevokeRoleAccount.selector\n      ),\n      \"BatchRevokeRoleAccount Access Denied\"\n    );\n    for(uint i; i < requests.length; i++) {\n      _revokeRoleAccount(data, requests[i].role, requests[i].account);\n    }\n    return true;\n  }\n\n  function _revokeRoleAccount(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    address account\n  ) private returns (bool) {    \n    if (role == LAccessControl.LIVELY_ADMIN_ROLE || role == LAccessControl.LIVELY_SYSTEM_ADMIN_ROLE) {\n      require(data.roleMap[role].accountSet.length() > 1, \"Illegal Revoke Role Account\");    \n    } \n\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(account != address(0), \"Address Invalid\");\n    require(data.roleMap[role].accountSet.contains(account), \"Account Not Found\");\n    require(data.accountMap[account][role] != AccessControlStorage.Status.NONE, \"Account Role Not Found\");\n    data.accountMap[account][role] = AccessControlStorage.Status.DISABLED;\n    data.roleMap[role].accountSet.remove(account);\n    return true;\n  }\n\n  function setRoleStatus(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    bool status\n  ) external returns (bool, bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.setRoleStatus.selector\n      ),\n      \"SetRoleStatus Access Denied\"\n    );\n    require(\n      role != LAccessControl.LIVELY_ANONYMOUS_ROLE &&\n        role != LAccessControl.LIVELY_ADMIN_ROLE &&\n        role != LAccessControl.LIVELY_SYSTEM_ADMIN_ROLE,\n      \"Illegal Change Role Status\"\n    );\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    data.roleMap[role].isEnabled = status;\n    return (true, data.roleMap[role].group);\n  }\n\n  function setRoleGroup(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    bytes32 group\n  ) external returns (bool, bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.setRoleGroup.selector\n      ),\n      \"SetRoleGroup Access Denied\"\n    );\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(bytes(data.groupMap[group].name).length != 0, \"Group Not Found\");\n    require(data.roleMap[role].group != group, \"Illegal Group Duplication\");\n    bytes32 oldGroup = data.roleMap[role].group;\n    data.groupMap[data.roleMap[role].group].roleSet.remove(role);\n    data.groupMap[group].roleSet.add(role);\n    data.roleMap[role].group = group;\n    return (true, oldGroup);\n  }\n\n  function getRoleInfo(AccessControlStorage.DataCollections storage data, bytes32 role)\n    external\n    view\n    returns (\n      string memory,\n      bytes32,\n      bool\n    )\n  {\n    return (data.roleMap[role].name, data.roleMap[role].group, data.roleMap[role].isEnabled);\n  }\n\n  function getRoleAccounts(AccessControlStorage.DataCollections storage data, bytes32 role)\n    external\n    view\n    returns (address[] memory)\n  {\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    return data.roleMap[role].accountSet.values();\n  }\n\n  function hasRoleAccount(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 role,\n    address account\n  ) external view returns (bool) {\n    return\n      bytes(data.roleMap[role].name).length != 0 &&\n      account != address(0) &&\n      data.accountMap[account][role] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LAccessControl);\n  }\n}\n"
    },
    "src/contracts/lib/acl/LGroupManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../../acl/IGroupManagement.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../LContextUtils.sol\";\nimport \"./LAccessControl.sol\";\n\nlibrary LGroupManagement {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LGroupManagement\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  function registerGroup(\n    AccessControlStorage.DataCollections storage data,\n    string calldata name,\n    bool status\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IGroupManagement.registerGroup.selector\n      ),\n      \"RegisterGroup Access Denied\"\n    );\n    require(bytes(name).length != 0, \"Group Name Invalid\");\n    bytes32 groupKey = keccak256(abi.encodePacked(name));\n    require(bytes(data.groupMap[groupKey].name).length == 0, \"Group Already Registered\");\n\n    AccessControlStorage.Group storage newGroup = data.groupMap[groupKey];\n    newGroup.name = name;\n    newGroup.isEnabled = status;\n    return groupKey;\n  }\n\n  function setGroupStatus(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 group,\n    bool status\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n\n    if (group == LAccessControl.LIVELY_GENERAL_GROUP) {\n      bytes32 context = LContextUtils.generateCtx(address(this));\n      bytes4 signature = IRealmManagement.setRealmStatus.selector;\n      bytes32 role = data.ctxMap[context].resources[signature].role;\n      require(\n        data.ctxMap[context].isEnabled &&\n          data.ctxMap[context].resources[signature].status == AccessControlStorage.Status.ENABLED &&\n          data.realmMap[data.ctxMap[context].realm].isEnabled &&\n          data.accountMap[msg.sender][role] == AccessControlStorage.Status.ENABLED,\n        \"SetGroupStatus Access Denied\"\n      );\n    } else {\n      require(\n        LAccessControl.hasAccess(\n          data,\n          LContextUtils.generateCtx(address(this)),\n          msg.sender,\n          IGroupManagement.setGroupStatus.selector\n        ),\n        \"SetGroupStatus Access Denied\"\n      );\n    }\n    require(bytes(data.groupMap[group].name).length != 0, \"Group Not Found\");\n    data.groupMap[group].isEnabled = status;\n    return true;\n  }\n\n  function hasGroupRole(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 group,\n    bytes32 role\n  ) external view returns (bool) {\n    return bytes(data.groupMap[group].name).length != 0 && data.groupMap[group].roleSet.contains(role);\n  }\n\n  function getGroupInfo(AccessControlStorage.DataCollections storage data, bytes32 group)\n    external\n    view\n    returns (string memory, bool)\n  {\n    return (data.groupMap[group].name, data.groupMap[group].isEnabled);\n  }\n\n  function getGroupRoles(AccessControlStorage.DataCollections storage data, bytes32 group)\n    external\n    view\n    returns (bytes32[] memory)\n  {\n    return data.groupMap[group].roleSet.values();\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LAccessControl);\n  }\n}\n"
    },
    "src/contracts/lib/acl/LRealmManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../../acl/IRealmManagement.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../LContextUtils.sol\";\nimport \"./LAccessControl.sol\";\n\nlibrary LRealmManagement {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LRealmManagement\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  function registerRealm(\n    AccessControlStorage.DataCollections storage data,\n    string calldata name,\n    bool status,\n    bool isUpgradable\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRealmManagement.registerRealm.selector\n      ),\n      \"RegisterRealm Access Denied\"\n    );\n    require(bytes(name).length != 0, \"Realm Name Invalid\");\n    bytes32 realmKey = keccak256(abi.encodePacked(name));\n    require(bytes(data.realmMap[realmKey].name).length == 0, \"Realm Already Registered\");\n\n    AccessControlStorage.Realm storage newRealm = data.realmMap[realmKey];\n    newRealm.name = name;\n    newRealm.isEnabled = status;\n    newRealm.isUpgradable = isUpgradable;\n    return realmKey;\n  }\n\n  function setRealmStatus(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 realm,\n    bool status\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    if (LAccessControl.LIVELY_GENERAL_REALM == realm) {\n      bytes32 context = LContextUtils.generateCtx(address(this));\n      bytes4 signature = IRealmManagement.setRealmStatus.selector;\n      bytes32 role = data.ctxMap[context].resources[signature].role;\n      require(\n        data.ctxMap[context].isEnabled &&\n          data.ctxMap[context].resources[signature].status == AccessControlStorage.Status.ENABLED &&\n          data.groupMap[data.roleMap[role].group].isEnabled &&\n          data.accountMap[msg.sender][role] == AccessControlStorage.Status.ENABLED,\n        \"SetRealmStatus Access Denied\"\n      );\n    } else {\n      require(\n        LAccessControl.hasAccess(\n          data,\n          LContextUtils.generateCtx(address(this)),\n          msg.sender,\n          IRealmManagement.setRealmStatus.selector\n        ),\n        \"SetRealmStatus Access Denied\"\n      );\n    }\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    data.realmMap[realm].isEnabled = status;\n    return true;\n  }\n\n  function setRealmUpgradeStatus(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 realm,\n    bool status\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRealmManagement.setRealmUpgradeStatus.selector\n      ),\n      \"SetRealmUpgradeStatus Access Denied\"\n    );\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    data.realmMap[realm].isUpgradable = status;\n    return true;\n  }\n\n  function hasRealmContext(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 realm,\n    bytes32 context\n  ) external view returns (bool) {\n    return bytes(data.realmMap[realm].name).length != 0 && data.realmMap[realm].ctxSet.contains(context);\n  }\n\n  function getRealmInfo(AccessControlStorage.DataCollections storage data, bytes32 realm)\n    external\n    view\n    returns (\n      string memory,\n      bool,\n      bool\n    )\n  {\n    return (data.realmMap[realm].name, data.realmMap[realm].isEnabled, data.realmMap[realm].isUpgradable);\n  }\n\n  function getRealmContexts(AccessControlStorage.DataCollections storage data, bytes32 realm)\n    external\n    view\n    returns (bytes32[] memory)\n  {\n    return data.realmMap[realm].ctxSet.values();\n  }\n\n  function getLibrary() external pure returns (address) {\n    return address(LAccessControl);\n  }\n}\n"
    },
    "src/contracts/lib/acl/LAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../acl/IRoleManagement.sol\";\nimport \"../../acl/IGroupManagement.sol\";\nimport \"../../acl/IRealmManagement.sol\";\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../LContextUtils.sol\";\n\nlibrary LAccessControl {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LAccessControl\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  bytes32 public constant LIVELY_GENERAL_REALM = keccak256(abi.encodePacked(\"LIVELY_GENERAL_REALM\"));\n  bytes32 public constant LIVELY_ASSET_REALM = keccak256(abi.encodePacked(\"LIVELY_ASSET_REALM\"));\n\n  bytes32 public constant LIVELY_GENERAL_GROUP = keccak256(abi.encodePacked(\"LIVELY_GENERAL_GROUP\"));\n  bytes32 public constant LIVELY_DAO_GROUP = keccak256(abi.encodePacked(\"LIVELY_DAO_GROUP\"));\n  bytes32 public constant LIVELY_ASSET_GROUP = keccak256(abi.encodePacked(\"LIVELY_ASSET_GROUP\"));\n\n  bytes32 public constant LIVELY_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_SYSTEM_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_SYSTEM_ADMIN_ROLE\"));\n  \n  bytes32 public constant LIVELY_ASSET_MANAGER_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_MANAGER_ROLE\"));\n  bytes32 public constant LIVELY_ASSET_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_ADMIN_ROLE\"));\n  \n  bytes32 public constant LIVELY_COMMUNITY_DAO_ROLE = keccak256(abi.encodePacked(\"LIVELY_COMMUNITY_DAO_ROLE\"));  \n  bytes32 public constant LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE = keccak256(abi.encodePacked(\"LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE\"));\n  \n  bytes32 public constant LIVELY_ANONYMOUS_ROLE = keccak256(abi.encodePacked(\"LIVELY_ANONYMOUS_ROLE\"));\n\n  function initializeContext(AccessControlStorage.DataCollections storage data) external {\n    data.accountMap[msg.sender][LIVELY_ADMIN_ROLE] = AccessControlStorage.Status.ENABLED;\n    data.accountMap[msg.sender][LIVELY_SYSTEM_ADMIN_ROLE] = AccessControlStorage.Status.ENABLED;\n\n    data.roleMap[LIVELY_ADMIN_ROLE].name = \"LIVELY_ADMIN_ROLE\";\n    data.roleMap[LIVELY_ADMIN_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_ADMIN_ROLE].group = LIVELY_GENERAL_GROUP;\n    data.roleMap[LIVELY_ADMIN_ROLE].accountSet.add(msg.sender);\n\n    data.roleMap[LIVELY_SYSTEM_ADMIN_ROLE].name = \"LIVELY_SYSTEM_ADMIN_ROLE\";\n    data.roleMap[LIVELY_SYSTEM_ADMIN_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_SYSTEM_ADMIN_ROLE].group = LIVELY_GENERAL_GROUP;\n    data.roleMap[LIVELY_SYSTEM_ADMIN_ROLE].accountSet.add(msg.sender);\n\n    data.roleMap[LIVELY_ASSET_MANAGER_ROLE].name = \"LIVELY_ASSET_MANAGER_ROLE\";\n    data.roleMap[LIVELY_ASSET_MANAGER_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_ASSET_MANAGER_ROLE].group = LIVELY_ASSET_GROUP;\n\n    data.roleMap[LIVELY_ASSET_ADMIN_ROLE].name = \"LIVELY_ASSET_ADMIN_ROLE\";\n    data.roleMap[LIVELY_ASSET_ADMIN_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_ASSET_ADMIN_ROLE].group = LIVELY_ASSET_GROUP;\n\n    data.roleMap[LIVELY_COMMUNITY_DAO_ROLE].name = \"LIVELY_COMMUNITY_DAO_ROLE\";\n    data.roleMap[LIVELY_COMMUNITY_DAO_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_COMMUNITY_DAO_ROLE].group = LIVELY_DAO_GROUP;\n\n    data.roleMap[LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE].name = \"LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE\";\n    data.roleMap[LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE].group = LIVELY_DAO_GROUP;\n    \n    data.roleMap[LIVELY_ANONYMOUS_ROLE].name = \"LIVELY_ANONYMOUS_ROLE\";\n    data.roleMap[LIVELY_ANONYMOUS_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_ANONYMOUS_ROLE].group = LIVELY_GENERAL_GROUP;\n\n    data.groupMap[LIVELY_GENERAL_GROUP].name = \"LIVELY_GENERAL_GROUP\";\n    data.groupMap[LIVELY_GENERAL_GROUP].isEnabled = true;\n    data.groupMap[LIVELY_GENERAL_GROUP].roleSet.add(LIVELY_ADMIN_ROLE);\n    data.groupMap[LIVELY_GENERAL_GROUP].roleSet.add(LIVELY_SYSTEM_ADMIN_ROLE);\n\n    data.groupMap[LIVELY_DAO_GROUP].name = \"LIVELY_DAO_GROUP\";\n    data.groupMap[LIVELY_DAO_GROUP].isEnabled = true;\n    data.groupMap[LIVELY_DAO_GROUP].roleSet.add(LIVELY_COMMUNITY_DAO_ROLE);\n    data.groupMap[LIVELY_DAO_GROUP].roleSet.add(LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE);\n\n    data.groupMap[LIVELY_ASSET_GROUP].name = \"LIVELY_ASSET_GROUP\";\n    data.groupMap[LIVELY_ASSET_GROUP].isEnabled = true;\n    data.groupMap[LIVELY_ASSET_GROUP].roleSet.add(LIVELY_ASSET_MANAGER_ROLE);\n    data.groupMap[LIVELY_ASSET_GROUP].roleSet.add(LIVELY_ASSET_ADMIN_ROLE);\n\n    data.realmMap[LIVELY_GENERAL_REALM].name = \"LIVELY_GENERAL_REALM\";\n    data.realmMap[LIVELY_GENERAL_REALM].isEnabled = true;\n    data.realmMap[LIVELY_GENERAL_REALM].isUpgradable = true;\n    data.realmMap[LIVELY_GENERAL_REALM].ctxSet.add(LContextUtils.generateCtx(address(this)));\n\n    data.realmMap[LIVELY_ASSET_REALM].name = \"LIVELY_ASSET_REALM\";\n    data.realmMap[LIVELY_ASSET_REALM].isEnabled = true;\n    data.realmMap[LIVELY_ASSET_REALM].isUpgradable = true;  \n  }\n\n  function createRequestContext() external pure returns (IContextManagement.RequestRegisterContext[] memory) {\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n    rrc[0].role = LIVELY_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](22);\n    rrc[0].funcSelectors[0] = IProxy.setUpgradeStatus.selector;\n    rrc[0].funcSelectors[1] = IProxy.setSafeMode.selector;\n    rrc[0].funcSelectors[2] = IContextManagement.addContextFuncRole.selector;\n    rrc[0].funcSelectors[3] = IContextManagement.removeContextFunc.selector;\n    rrc[0].funcSelectors[4] = IContextManagement.grantContextRole.selector;\n    rrc[0].funcSelectors[5] = IContextManagement.revokeContextRole.selector;\n    rrc[0].funcSelectors[6] = IContextManagement.setContextRealm.selector;\n    rrc[0].funcSelectors[7] = IContextManagement.setContextStatus.selector;\n    rrc[0].funcSelectors[8] = IRoleManagement.registerRole.selector;\n    rrc[0].funcSelectors[9] = IRoleManagement.batchRegisterRole.selector;\n    rrc[0].funcSelectors[10] = IRoleManagement.grantRoleAccount.selector;\n    rrc[0].funcSelectors[11] = IRoleManagement.batchGrantRoleAccount.selector;\n    rrc[0].funcSelectors[12] = IRoleManagement.revokeRoleAccount.selector;\n    rrc[0].funcSelectors[13] = IRoleManagement.batchRevokeRoleAccount.selector;\n    rrc[0].funcSelectors[14] = IRoleManagement.setRoleStatus.selector;\n    rrc[0].funcSelectors[15] = IRoleManagement.setRoleGroup.selector;\n    rrc[0].funcSelectors[16] = IGroupManagement.registerGroup.selector;\n    rrc[0].funcSelectors[17] = IGroupManagement.setGroupStatus.selector;\n    rrc[0].funcSelectors[18] = IRealmManagement.registerRealm.selector;\n    rrc[0].funcSelectors[19] = IRealmManagement.setRealmStatus.selector;\n    rrc[0].funcSelectors[20] = IRealmManagement.setRealmUpgradeStatus.selector;\n    rrc[0].funcSelectors[21] = bytes4(keccak256(\"withdrawBalance(address)\"));\n\n    rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](4);\n    rrc[1].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[1].funcSelectors[1] = IProxy.upgradeTo.selector;\n    rrc[1].funcSelectors[2] = IContextManagement.registerContext.selector;\n    rrc[1].funcSelectors[3] = IContextManagement.updateContext.selector;\n\n    return rrc;\n  }\n\n  function hasAccess(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 context,\n    address account,\n    bytes4 signature\n  ) external view returns (bool) {\n    bytes32 role = data.ctxMap[context].resources[signature].role;\n    // console.log(\"hasAccess called, address: %s\", account);\n\n    // console.log(\"data.ctxMap[context].smca: %s\", data.ctxMap[context].smca);\n    // console.log(\"data.ctxMap[context].isEnabled:\");\n    // console.logBool(data.ctxMap[context].isEnabled);\n    // console.log(\"data.ctxMap[context].realm: \");\n    // console.logBytes32(data.ctxMap[context].realm);\n    // console.log(\"data.ctxMap[context].resources[signature].status: \");\n    // console.logBytes1(bytes1(uint8(data.ctxMap[context].resources[signature].status)));\n    // console.log(\"data.ctxMap[context].resources[signature].role: \");\n    // console.logBytes32(data.ctxMap[context].resources[signature].role);\n\n    // console.log(\"data.realmMap[data.ctxMap[context].realm].name: %s\", data.realmMap[data.ctxMap[context].realm].name);\n    // console.log(\"data.realmMap[data.ctxMap[context].realm].isEnabled: \");\n    // console.logBool(data.realmMap[data.ctxMap[context].realm].isEnabled);\n\n    // console.log(\"data.groupMap[data.roleMap[role].group].name: %s\", data.groupMap[data.roleMap[role].group].name);\n    // console.log(\"data.groupMap[data.roleMap[role].group].isEnabled: \");\n    // console.logBool(data.groupMap[data.roleMap[role].group].isEnabled);\n\n    // console.log(\"data.accountMap[account][role]: \");\n    // console.logBytes1(bytes1(uint8(data.accountMap[account][role])));\n\n    if (role == LIVELY_ANONYMOUS_ROLE) {\n      return\n        data.ctxMap[context].isEnabled &&\n        data.ctxMap[context].resources[signature].status == AccessControlStorage.Status.ENABLED;\n    } else {\n      return\n        data.ctxMap[context].isEnabled &&\n        data.ctxMap[context].resources[signature].status == AccessControlStorage.Status.ENABLED &&\n        data.realmMap[data.ctxMap[context].realm].isEnabled &&\n        data.groupMap[data.roleMap[role].group].isEnabled &&\n        data.accountMap[account][role] == AccessControlStorage.Status.ENABLED;\n    }\n  }\n\n  function isLivelySystemAdminRole(AccessControlStorage.DataCollections storage data, address account)\n    external\n    view\n    returns (bool)\n  {\n    return data.accountMap[account][LIVELY_SYSTEM_ADMIN_ROLE] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isLivelyAdminRole(AccessControlStorage.DataCollections storage data, address account) external view returns (bool) {\n    return data.accountMap[account][LIVELY_ADMIN_ROLE] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isLivelyAssetManagerRole(AccessControlStorage.DataCollections storage data, address account) external view returns (bool) {\n    return data.accountMap[account][LIVELY_ASSET_MANAGER_ROLE] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isLivelyAssetAdminRole(AccessControlStorage.DataCollections storage data, address account) external view returns (bool) {\n    return data.accountMap[account][LIVELY_ASSET_ADMIN_ROLE] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isLivelyCommunityDaoRole(AccessControlStorage.DataCollections storage data, address account) external view returns (bool) {\n    return data.accountMap[account][LIVELY_COMMUNITY_DAO_ROLE] == AccessControlStorage.Status.ENABLED;  \n  }\n\n  function isLivelyCommunityDaoExecutorRole(AccessControlStorage.DataCollections storage data, address account) external view returns (bool) {\n    return data.accountMap[account][LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isLivelyGeneralGroup(AccessControlStorage.DataCollections storage data, bytes32 role) external view returns (bool) {\n    return data.groupMap[LIVELY_GENERAL_GROUP].roleSet.contains(role);\n  }\n\n  function isLivelyAssetGroup(AccessControlStorage.DataCollections storage data, bytes32 role) external view returns (bool) {\n    return data.groupMap[LIVELY_ASSET_GROUP].roleSet.contains(role);\n  }\n\n  function isLivelyDaoGroup(AccessControlStorage.DataCollections storage data, bytes32 role) external view returns (bool) {\n    return data.groupMap[LIVELY_DAO_GROUP].roleSet.contains(role);\n  }\n\n  function isLivelyGeneralRealm(AccessControlStorage.DataCollections storage data, bytes32 context)\n    external\n    view\n    returns (bool)\n  {\n    return data.realmMap[LIVELY_GENERAL_REALM].ctxSet.contains(context);\n  }\n\n  function isLivelyAssetRealm(AccessControlStorage.DataCollections storage data, bytes32 context)\n    external\n    view\n    returns (bool)\n  {\n    return data.realmMap[LIVELY_ASSET_REALM].ctxSet.contains(context);\n  }\n\n\n  function isContextSafeMode(AccessControlStorage.DataCollections storage data, bytes32 context) external view returns (bool) {\n    return IProxy(data.ctxMap[context].contractId).isSafeMode();\n  }\n\n  function isContextUpgradable(AccessControlStorage.DataCollections storage data, bytes32 context)\n    external\n    view\n    returns (bool)\n  {\n    return IProxy(data.ctxMap[context].contractId).isUpgradable();\n  }\n\n  function isRealmUpgradable(AccessControlStorage.DataCollections storage data, bytes32 realm) external view returns (bool) {\n    if (bytes(data.realmMap[realm].name).length == 0) return false;\n    return data.realmMap[realm].isUpgradable;\n  }\n\n  function isGroupExists(AccessControlStorage.DataCollections storage data, bytes32 group) external view returns (bool) {\n    return bytes(data.groupMap[group].name).length > 0;\n  }\n\n  function isGroupEnabled(AccessControlStorage.DataCollections storage data, bytes32 group) external view returns (bool) {\n    return bytes(data.groupMap[group].name).length > 0 && data.groupMap[group].isEnabled;\n  }\n\n  function isContextExists(AccessControlStorage.DataCollections storage data, bytes32 context) external view returns (bool) {\n    return data.ctxMap[context].contractId != address(0);\n  }\n\n  function isContextFunctionExists(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 context,\n    bytes4 functionSelector\n  ) external view returns (bool) {\n    return data.ctxMap[context].contractId != address(0) && data.ctxMap[context].funcSet.contains(functionSelector);\n  }\n\n  function isContextFunctionEnabled(\n    AccessControlStorage.DataCollections storage data,\n    bytes32 context,\n    bytes4 functionSelector\n  ) external view returns (bool) {\n    return\n      data.ctxMap[context].contractId != address(0) &&\n      data.ctxMap[context].resources[functionSelector].status == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isContextEnabled(AccessControlStorage.DataCollections storage data, bytes32 context) external view returns (bool) {\n    return data.ctxMap[context].contractId != address(0) && data.ctxMap[context].isEnabled;\n  }\n\n  function isRoleExists(AccessControlStorage.DataCollections storage data, bytes32 role) external view returns (bool) {\n    return bytes(data.roleMap[role].name).length > 0;\n  }\n\n  function isRoleEnabled(AccessControlStorage.DataCollections storage data, bytes32 role) external view returns (bool) {\n    return bytes(data.roleMap[role].name).length > 0 && data.roleMap[role].isEnabled;\n  }\n\n  function isRealmExists(AccessControlStorage.DataCollections storage data, bytes32 realm) external view returns (bool) {\n    return bytes(data.realmMap[realm].name).length > 0;\n  }\n\n  function isRealmEnabled(AccessControlStorage.DataCollections storage data, bytes32 realm) external view returns (bool) {\n    return bytes(data.realmMap[realm].name).length > 0 && data.realmMap[realm].isEnabled;\n  }\n}\n"
    },
    "src/contracts/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../lib/LAddress.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n   * @custom:oz-retyped-from bool\n   */\n  uint16 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private _initializing;\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n   * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n   */\n  modifier initializer() {\n    bool isTopLevelCall = !_initializing;\n    require(\n      (isTopLevelCall && _initialized < 1) || (!LAddress.isContract(address(this)) && _initialized == 1),\n      \"Contract Already Initialized\"\n    );\n    _initialized = 1;\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n   * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n   * used to initialize parent contracts.\n   *\n   * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n   * initialization step. This is essential to configure modules that are added through upgrades and that require\n   * initialization.\n   *\n   * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n   * a contract, executing them in the right order is up to the developer or operator.\n   */\n  modifier reinitializer(uint16 version) {\n    require(!_initializing && _initialized < version, \"Contract Already Initialized\");\n    _initialized = version;\n    _initializing = true;\n    _;\n    _initializing = false;\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n   * {initializer} and {reinitializer} modifiers, directly or indirectly.\n   */\n  modifier onlyInitializing() {\n    require(_initializing, \"Contract Not Initializing\");\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n   * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n   * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n   * through proxies.\n   */\n  function _disableInitializers() internal virtual {\n    require(!_initializing, \"Contract Initializing Invalid\");\n    if (_initialized < type(uint16).max) {\n      _initialized = type(uint16).max;\n    }\n  }\n\n  function _getInitializedCount() internal view returns (uint16) {\n    return _initialized;\n  }\n\n  function _isInitializing() internal view returns (bool) {\n    return _initializing;\n  }\n}\n"
    },
    "src/contracts/proxy/BaseUUPSProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IERC1822.sol\";\nimport \"./IProxy.sol\";\nimport \"./BaseProxy.sol\";\nimport \"./BaseUUPSStorage.sol\";\nimport \"./Initializable.sol\";\nimport \"../lib/LAddress.sol\";\nimport \"../lib/LStorageSlot.sol\";\nimport \"../acl/IAccessControl.sol\";\nimport \"../acl/IContextManagement.sol\";\nimport \"../utils/Message.sol\";\nimport \"../utils/ERC165.sol\";\nimport \"../lib/LContextUtils.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n\n * An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\n\nabstract contract BaseUUPSProxy is\n  BaseUUPSStorage,\n  BaseProxy,\n  Initializable,\n  IProxy,\n  IERC1822Proxiable,\n    Message,\n    ERC165\n{\n  /**\n   * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n   * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n   * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n   * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n   * fail.\n   */\n  modifier onlyProxy() {\n    require(address(this) != __self, \"Illegal Contract Call\");\n    require(_implementation() == __self, \"Proxy Called Invalid\");\n    _;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyLocalAdmin() {\n    require(_getLocalAdmin() == _msgSender(), \"Caller Not Authorized\");\n    _;\n  }\n\n  /**\n   * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n   * callable on the implementing contract but not through proxies.\n   */\n  modifier notDelegated() {\n    require(address(this) == __self, \"Illegal Contract Delegatecall\");\n    _;\n  }\n\n  modifier safeModeCheck() {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    _;\n  }\n\n  modifier aclCheck(bytes4 selector) {\n    require(_hasPermission(selector), \"Access Denied\");\n    _;\n  }\n\n  function _hasPermission(bytes4 selector) internal returns (bool) {\n    if (address(this) == _accessControlManager) {\n      bytes memory data = abi.encodeWithSelector(\n        IAccessControl.hasAccess.selector,\n        LContextUtils.generateCtx(address(this)),\n        _msgSender(),\n        selector\n      );\n      bytes memory returndata = LAddress.functionDelegateCall(_implementation(), data, \"Delegatecall hasAccess Failed\");\n      return uint8(returndata[returndata.length - 1]) == 1;\n    } else {\n      return\n        IAccessControl(_accessControlManager).hasAccess(\n          LContextUtils.generateCtx(address(this)),\n          _msgSender(),\n          selector\n        );\n    }\n  }\n\n  function _isRealmUpgradable() internal returns (bool) {\n    if (address(this) == _accessControlManager) {\n      bytes memory data = abi.encodeWithSelector(IAccessControl.isRealmUpgradable.selector, _domainRealm);\n      bytes memory returndata = LAddress.functionDelegateCall(\n        _implementation(),\n        data,\n        \"Delegatecall isRealmUpgradable Failed\"\n      );\n      return uint8(returndata[returndata.length - 1]) == 1;\n    } else {\n      return IAccessControl(_accessControlManager).isRealmUpgradable(_domainRealm);\n    }\n  }\n\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n   */\n\n  constructor() {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n    // set contract Admin (implementation contract)\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = _msgSender();\n\n    // set _isUpgradable and _isSafeMode of contact\n    _isUpgradable = false;\n    _isSafeMode = true;\n  }\n\n  function __BASE_UUPS_init(\n    string calldata domainName,\n    string calldata domainVersion,\n    bytes32 domainRealm,\n    address accessControl\n  ) internal {\n    __BASE_UUPS_init_unchained(domainName, domainVersion, domainRealm, accessControl);\n  }\n\n  function __BASE_UUPS_init_unchained(\n    string calldata domainName,\n    string calldata domainVersion,\n    bytes32 domainRealm,\n    address accessControl\n  ) internal onlyInitializing {\n    _domainName = keccak256(abi.encodePacked(domainName));\n    _domainVersion = keccak256(abi.encodePacked(domainVersion));\n    _domainRealm = domainRealm;\n    if (accessControl == address(0)) {\n      _accessControlManager = address(this);\n    } else {\n      try IERC165(accessControl).supportsInterface(type(IAccessControl).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid AccessControlManager\");\n      } catch {\n        revert(\"Illegal AccessControlManager\");\n      }\n      _accessControlManager = accessControl;\n    }\n    _isUpgradable = false;\n    _isSafeMode = false;\n    _setLocalAdmin(_msgSender());\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return\n      interfaceId == type(IProxy).interfaceId ||\n      interfaceId == type(IERC1822Proxiable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _implementation() internal view override returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    require(LAddress.isContract(newImplementation), \"Illegal Contract Address\");\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(msg.sender, address(this), newImplementation);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal returns (bytes memory) {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      return LAddress.functionDelegateCall(newImplementation, data, \"Delegatecall Failed\");\n    }\n    return new bytes(0);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal returns (bytes memory) {\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n      return new bytes(0);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"Invalid UUPS Contract\");\n      } catch {\n        revert(\"Illegal UUPS Contract\");\n      }\n\n      try IERC165(newImplementation).supportsInterface(type(IProxy).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid IProxy Contract\");\n      } catch {\n        revert(\"Illegal IProxy Contract\");\n      }\n\n      return _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n\n  /**\n   * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n   * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n   *\n   * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n   * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n   * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n   */\n  function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n    return _IMPLEMENTATION_SLOT;\n  }\n\n  function upgradeTo(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) external virtual onlyProxy returns (bytes memory) {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_isUpgradable, \"Upgrade Call Rejected\");\n    _authorizeUpgrade(newImplementation);\n    return _upgradeToAndCallUUPS(newImplementation, data, forceCall);\n  }\n\n  /**\n   * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n   * {upgradeTo} and {upgradeToAndCall}.\n   *\n   * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n   *\n   * ```solidity\n   * function _authorizeUpgrade(address) internal override onlyOwner {}\n   * ```\n   */\n  function _authorizeUpgrade(address newImplementation) internal virtual {\n    require(newImplementation != _implementation(), \"Illegal New Implementation\");\n    require(_hasPermission(this.upgradeTo.selector), \"Upgrade Context Forbidden\");\n  }\n\n  function localAdmin() external view returns (address) {\n    return _getLocalAdmin();\n  }\n\n  function setLocalAdmin(address newLocalAdmin) external onlyProxy returns (bool) {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_hasPermission(this.setLocalAdmin.selector), \"SetLocalAdmin Forbidden\");\n    require(newLocalAdmin != address(0), \"Address Invalid\");\n    _setLocalAdmin(newLocalAdmin);\n    return true;\n  }\n\n  /**\n   * @dev Returns the current admin.require(!_isSafeMode, \"SafeMode: Call Rejected\");\n   */\n  function _getLocalAdmin() internal view returns (address) {\n    return LStorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 admin slot.\n   */\n  function _setLocalAdmin(address newAdmin) internal {\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    emit LocalAdminChanged(_msgSender(), address(this), newAdmin);\n  }\n\n  // In each upgrade the initialize requirement must be changed\n  function setSafeMode(bool status) external onlyProxy returns (bool) {\n    require(_getInitializedCount() > 0, \"Contract Not Initialized\");\n    require(_hasPermission(this.setSafeMode.selector), \"SetSafeMode Forbidden\");\n    _isSafeMode = status;\n    emit SafeModeChanged(_msgSender(), address(this), _domainRealm, status);\n    return status;\n  }\n\n  function setUpgradeStatus(bool status) external onlyProxy returns (bool) {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_hasPermission(this.setUpgradeStatus.selector), \"SetUpgradeStatus Forbidden\");\n    require(_isRealmUpgradable(), \"Realm Upgrade Forbidden\");\n    _isUpgradable = status;\n    emit UpgradeStatusChanged(_msgSender(), address(this), _domainRealm, status);\n    return status;\n  }\n\n  function contractName() external view returns (bytes32) {\n    return _domainName;\n  }\n\n  function contractVersion() external view returns (bytes32) {\n    return _domainVersion;\n  }\n\n  function contractRealm() external view returns (bytes32) {\n    return _domainRealm;\n  }\n\n  function contractContext() external view returns (bytes32) {\n    return LContextUtils.generateCtx(address(this));\n  }\n\n  function accessControlManager() external view returns (address) {\n    return _accessControlManager;\n  }\n\n  function subjectAddress() external view returns (address) {\n    return _implementation();\n  }\n\n  function isSafeMode() external view returns (bool) {\n    return _isSafeMode;\n  }\n\n  function isUpgradable() external view returns (bool) {\n    return _isUpgradable;\n  }\n\n  function domainSeparator() external view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    return keccak256(abi.encode(_TYPE_HASH, _domainName, _domainVersion, block.chainid, address(this)));\n  }\n\n  function initVersion() external view returns (uint16) {\n    return _getInitializedCount();\n  }\n\n  function withdrawBalance(address recepient) public {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_hasPermission(this.withdrawBalance.selector), \"Withdraw Balance Forbidden\");\n    payable(recepient).transfer(address(this).balance);\n  }\n\n  // solhint-disable-next-line\n  receive() external payable override {}\n\n  // solhint-disable-next-line\n  fallback() external payable override {}\n}\n"
    },
    "src/contracts/proxy/BaseUUPSStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n */\n\nabstract contract BaseUUPSStorage {\n  // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n  bytes32 internal constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n   * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n   */\n  bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  bytes32 internal constant _TYPE_HASH =\n    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n  \n  address internal immutable __self = address(this);\n\n  bytes32 internal _domainName;\n  bytes32 internal _domainVersion;\n  bytes32 internal _domainRealm;\n  address internal _accessControlManager;\n  bool internal _isSafeMode;\n  bool internal _isUpgradable;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[64] private __reserved;\n}\n"
    },
    "src/contracts/proxy/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IBaseProxy.sol\";\n\ninterface IProxy is IBaseProxy {\n  /**\n   * @dev Emitted when the admin account has changed.\n   */\n  event LocalAdminChanged(address indexed sender, address indexed proxy, address newAdmin);\n\n  event SafeModeChanged(address indexed sender, address indexed proxy, bytes32 indexed realm, bool status);\n\n  event UpgradeStatusChanged(address indexed sender, address indexed proxy, bytes32 indexed realm, bool status);\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n   */\n  event Initialized(\n    address indexed sender,\n    address indexed proxy,\n    address indexed subject,\n    string name,\n    string version,\n    bytes32 realm,\n    uint16 initCount\n  );\n\n  function upgradeTo(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) external returns (bytes memory);\n\n  function setSafeMode(bool status) external returns (bool);\n\n  function setUpgradeStatus(bool status) external returns (bool);\n\n  function setLocalAdmin(address newAdmin) external returns (bool);\n\n  function contractName() external view returns (bytes32);\n\n  function contractVersion() external view returns (bytes32);\n\n  function contractRealm() external view returns (bytes32);\n\n  function contractContext() external view returns (bytes32);\n\n  function accessControlManager() external view returns (address);\n\n  function subjectAddress() external view returns (address);\n\n  function isSafeMode() external view returns (bool);\n\n  function isUpgradable() external view returns (bool);\n\n  function localAdmin() external view returns (address);\n\n  function domainSeparator() external view returns (bytes32);\n\n  function initVersion() external view returns (uint16);\n\n}\n"
    },
    "src/contracts/lib/LContextUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the context\n */\nlibrary LContextUtils {\n  function generateCtx(address contractId) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(contractId));\n  }\n}\n"
    },
    "src/contracts/lib/cryptography/LECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../LStrings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary LECDSA {\n  enum RecoverError {\n    NoError,\n    InvalidSignature,\n    InvalidSignatureLength,\n    InvalidSignatureS,\n    InvalidSignatureV\n  }\n\n  function _throwError(RecoverError error) private pure {\n    if (error == RecoverError.NoError) {\n      return; // no error: do nothing\n    } else if (error == RecoverError.InvalidSignature) {\n      revert(\"ECDSA: invalid signature\");\n    } else if (error == RecoverError.InvalidSignatureLength) {\n      revert(\"ECDSA: invalid signature length\");\n    } else if (error == RecoverError.InvalidSignatureS) {\n      revert(\"ECDSA: invalid signature 's' value\");\n    } else if (error == RecoverError.InvalidSignatureV) {\n      revert(\"ECDSA: invalid signature 'v' value\");\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature` or error string. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   *\n   * Documentation for signature generation:\n   * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n   * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n   *\n   */\n  function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n    // Check the signature length\n    // - case 65: r,s,v signature (standard)\n    // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n      return tryRecover(hash, v, r, s);\n    } else if (signature.length == 64) {\n      bytes32 r;\n      bytes32 vs;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        vs := mload(add(signature, 0x40))\n      }\n      return tryRecover(hash, r, vs);\n    } else {\n      return (address(0), RecoverError.InvalidSignatureLength);\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature`. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   */\n  function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n   *\n   * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n   */\n  function tryRecover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address, RecoverError) {\n    bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\n    return tryRecover(hash, v, r, s);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n   */\n  function recover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   */\n  function tryRecover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address, RecoverError) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      return (address(0), RecoverError.InvalidSignatureS);\n    }\n    if (v != 27 && v != 28) {\n      return (address(0), RecoverError.InvalidSignatureV);\n    }\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    if (signer == address(0)) {\n      return (address(0), RecoverError.InvalidSignature);\n    }\n\n    return (signer, RecoverError.NoError);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   */\n  function recover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", LStrings.toString(s.length), s));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Typed Data, created from a\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\n   * to the one signed with the\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n   * JSON-RPC method as part of EIP-712.\n   *\n   * See {recover}.\n   */\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n  }\n}\n"
    },
    "src/contracts/lib/proxy/LClones.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n */\nlibrary LClones {\n  /**\n   * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n   *\n   * This function uses the create opcode, which should never revert.\n   */\n  function clone(address implementation) internal returns (address instance) {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(ptr, 0x14), shl(0x60, implementation))\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      instance := create(0, ptr, 0x37)\n    }\n    require(instance != address(0), \"ERC1167: create failed\");\n  }\n\n  /**\n   * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n   *\n   * This function uses the create2 opcode and a `salt` to deterministically deploy\n   * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n   * the clones cannot be deployed twice at the same address.\n   */\n  function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(ptr, 0x14), shl(0x60, implementation))\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      instance := create2(0, ptr, 0x37, salt)\n    }\n    require(instance != address(0), \"ERC1167: create2 failed\");\n  }\n\n  /**\n   * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n   */\n  function predictDeterministicAddress(\n    address implementation,\n    bytes32 salt,\n    address deployer\n  ) internal pure returns (address predicted) {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(ptr, 0x14), shl(0x60, implementation))\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n      mstore(add(ptr, 0x38), shl(0x60, deployer))\n      mstore(add(ptr, 0x4c), salt)\n      mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n      predicted := keccak256(add(ptr, 0x37), 0x55)\n    }\n  }\n\n  /**\n   * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n   */\n  function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n    return predictDeterministicAddress(implementation, salt, address(this));\n  }\n}\n"
    },
    "src/contracts/proxy/IBaseProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IBaseProxy {\n  event Upgraded(address indexed sender, address indexed proxy, address indexed newImplementation);\n}\n"
    },
    "src/contracts/lib/LStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev String operations.\n */\nlibrary LStrings {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n   */\n  function toHexString(address addr) internal pure returns (string memory) {\n      return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n"
    },
    "src/contracts/lib/LAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the address type\n */\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary LAddress {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"SendValue Failed\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, \"Call Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Call With Value Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Insufficient Balance For Call\");\n    require(LAddress.isContract(target), \"Illegal Contract Address\");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Static Call Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(LAddress.isContract(target), \"Illegal Contract Address\");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Delegate Call Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory message\n  ) internal returns (bytes memory) {\n    require(LAddress.isContract(target), \"Illegal Contract Address\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return LAddress.verifyCallResult(success, returndata, message);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason using the provided one.\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "src/contracts/proxy/IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n  /**\n   * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n   * address.\n   *\n   * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n   * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n   * function revert if invoked through a proxy.\n   */\n  function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "src/contracts/proxy/BaseProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract BaseProxy {\n  /**\n   * @dev Delegates the current call to `implementation`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _delegate(address implementation) internal virtual {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates the current call to the address returned by `_implementation()`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _fallback() internal virtual {\n    _beforeFallback();\n    _delegate(_implementation());\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  fallback() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n   * is empty.\n   */\n  receive() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n   * call, or as part of the Solidity `fallback` or `receive` functions.\n   *\n   * If overridden should call `super._beforeFallback()`.\n   */\n  function _beforeFallback() internal virtual {}\n}\n"
    },
    "src/contracts/lib/LStorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary LStorageSlot {\n  struct AddressSlot {\n    address value;\n  }\n\n  struct BooleanSlot {\n    bool value;\n  }\n\n  struct Bytes32Slot {\n    bytes32 value;\n  }\n\n  struct Uint256Slot {\n    uint256 value;\n  }\n\n  /**\n   * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n   */\n  function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n   */\n  function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n   */\n  function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n   */\n  function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n}\n"
    },
    "src/contracts/utils/Message.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Message {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n"
    },
    "src/contracts/utils/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "src/contracts/utils/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/token/lively/LivelyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Extra.sol\";\nimport \"./IERC20Pause.sol\";\nimport \"./IERC20Lock.sol\";\nimport \"./LivelyStorage.sol\";\nimport \"../asset/IAssetEntity.sol\";\nimport \"../asset/IAssetManagerERC20.sol\";\nimport \"../asset/ERC20/IAssetERC20.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\nimport \"../../lib/token/LTokenERC20.sol\";\nimport \"../../lib/cryptography/LECDSA.sol\";\nimport \"../../lib/LCounters.sol\";\nimport \"../../lib/math/LBasisPointsMath.sol\";\nimport \"../../lib/math/LSafeMath.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../acl/IContextManagement.sol\";\n\ncontract LivelyToken is LivelyStorage, BaseUUPSProxy, IERC20, IERC20Extra, IERC20Pause, IERC20Lock {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LCounters for LCounters.Counter;\n  using LBasisPointsMath for uint256;\n  using LSafeMath for uint256;\n\n  struct InitRequest {\n    string domainName;\n    string domainVersion;\n    string domainRealm;\n    bytes signature;\n    uint256 taxRateValue;\n    address accessControlManager;\n  }\n\n  constructor() {}\n\n  function lockToken(LockTokenRequest calldata lockRequest) external returns (bytes32) {\n    _policyInterceptor(this.lockToken.selector, lockRequest.source, true, true);\n    return _lockToken(lockRequest);\n  }\n\n  function batchLockToken(LockTokenRequest[] calldata lockRequest) external returns (bytes32[] memory) {\n    _policyInterceptor(this.batchLockToken.selector, address(0), true, false);\n    uint totalAmount = 0;\n    bytes32[] memory lockIds = new bytes32[](lockRequest.length);\n    for (uint i = 0; i < lockRequest.length; i++) {\n      require(!_data.pausedList.contains(lockRequest[i].source), \"ERC20Pause: Account Suspended\");\n      lockIds[i] = _lockToken(lockRequest[i]);\n      totalAmount += lockRequest[i].amount;\n    }\n\n    emit BatchTokenLocked(_msgSender(), totalAmount);\n    return lockIds;\n  }\n\n  function claimToken(bytes32 lockId) external returns (uint256) {\n    _policyInterceptor(this.claimToken.selector, _msgSender(), true, true);\n      return _claimToken(lockId);\n  }\n\n  function batchClaimToken(bytes32[] calldata lockIds) external returns (uint256) {    \n    _policyInterceptor(this.batchClaimToken.selector, _msgSender(), true, true);\n    uint totalAmount = 0;\n    for (uint i = 0; i < lockIds.length; i++) {\n      totalAmount += _claimToken(lockIds[i]);\n    }\n\n    emit BatchTokenClaimed(_msgSender(), totalAmount);\n    return totalAmount;\n  }\n\n  function unlockToken(UnLockTokenRequest calldata unlockRequest) external returns (uint256) {\n    _policyInterceptor(this.unlockToken.selector, unlockRequest.account, true, true);\n    return _unlockToken(unlockRequest);\n  }\n\n  function batchUnlockToken(UnLockTokenRequest[] calldata unlockRequest) external returns (uint256) {\n    _policyInterceptor(this.batchUnlockToken.selector, address(0), true, false);\n    uint totalAmount = 0;\n    for (uint i = 0; i < unlockRequest.length; i++) {\n      require(!_data.pausedList.contains(unlockRequest[i].account), \"ERC20Pause: Account Suspended\");\n      totalAmount += _unlockToken(unlockRequest[i]);\n    }\n\n    emit BatchTokenUnlocked(_msgSender(), totalAmount);\n    return totalAmount;\n  }\n\n  function pause(address account) external {\n    _policyInterceptor(this.pause.selector, address(0), false, false);\n    require(account != address(0), \"Invalid Account Address\");\n    require(!_data.pausedList.contains(account), \"Account Already Paused\");\n    _data.pausedList.add(account);\n    emit Paused(_msgSender(), account);\n  }\n\n  function unpause(address account) external {\n    _policyInterceptor(this.unpause.selector, address(0), false, false);\n    require(account != address(0), \"Invalid Account Address\");\n    require(_data.pausedList.contains(account), \"Account Not Found\");\n    _data.pausedList.remove(account);\n    emit Unpaused(_msgSender(), account);\n  }\n\n  function pauseAll() external {\n    _policyInterceptor(this.pauseAll.selector, address(0), false, false);\n    _isPaused = true;\n    emit PausedAll(_msgSender());\n  }\n\n  function unpauseAll() external {\n    _policyInterceptor(this.unpauseAll.selector, address(0), false, false);\n    _isPaused = false;\n    emit UnpausedAll(_msgSender());\n  }\n\n  function updateTaxRate(uint256 rate) external returns (bool) {\n    _policyInterceptor(this.updateTaxRate.selector, address(0), false, false);\n    _taxRate = rate;\n    emit TaxRateUpdated(_msgSender(), rate);\n    return true;\n  }\n\n  function batchUpdateTaxWhitelist(BatchUpdateTaxWhitelistRequest[] calldata request) external {\n    _policyInterceptor(this.batchUpdateTaxWhitelist.selector, address(0), false, false);\n    for (uint256 i = 0; i < request.length; i++) {\n      _updateTaxWhitelist(request[i].account, request[i].isDeleted);\n    }\n  }\n\n  function updateTaxWhitelist(address account, bool isDeleted) external returns (bool) {\n    _policyInterceptor(this.updateTaxWhitelist.selector, address(0), false, false);\n    return _updateTaxWhitelist(account, isDeleted);\n  }\n\n  function transfer(address recipient, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.transfer.selector, _msgSender(), true, true);\n    if (_taxRate > 0 && !_data.taxWhitelist.contains(_msgSender())) {\n      _taxTransfer(_msgSender(), recipient, amount);\n    } else {\n      _transfer(_msgSender(), recipient, amount);\n    }\n    return true;\n  }\n\n  function transferFrom(address source, address recipient, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.transferFrom.selector, source, true, true);\n    return _transferFrom(source, recipient, amount);\n  }\n\n  function batchTransfer(BatchTransferRequest[] calldata request) external returns (bool) {\n    _policyInterceptor(this.batchTransfer.selector, _msgSender(), true, true);\n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < request.length; i++) {\n      totalAmount += request[i].amount;\n      _transfer(_msgSender(), request[i].to, request[i].amount);\n    }\n\n    emit BatchTransfer(_msgSender(), totalAmount);\n    return true;\n  }\n\n  function batchTransferFrom(BatchTransferFromRequest[] calldata request) external returns (bool) {    \n    _policyInterceptor(this.batchTransferFrom.selector, address(0), true, false);\n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < request.length; i++) {\n      require(!_data.pausedList.contains(request[i].from), \"ERC20Pause: Account Suspended\");\n      totalAmount += request[i].amount;\n      _transferFrom(request[i].from, request[i].to, request[i].amount);\n    }\n\n    emit BatchTransferFrom(_msgSender(), totalAmount);\n    return true;\n  }\n\n  function approve(address spender, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.approve.selector, _msgSender(), true, true);\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.increaseAllowance.selector, _msgSender(), true, true);\n    address owner = _msgSender();\n    uint256 currentAllowance = _allowance(owner, spender) + amount;\n    _approve(owner, spender, currentAllowance);\n    emit ApprovalIncreased(owner, spender, amount);\n    return currentAllowance;\n  }\n\n  function decreaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.decreaseAllowance.selector, _msgSender(), true, true);\n    address owner = _msgSender();\n    _spendAllowance(owner, spender, amount);\n    emit ApprovalDecreased(owner, spender, amount);\n    return _allowance(owner, spender);\n  }\n\n   function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    bytes calldata signature\n  ) external returns (bool) {\n    _policyInterceptor(this.permit.selector, owner, true, true);\n    require(block.timestamp <= deadline, \"Permit Deadline Expired\");\n    bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n    bytes32 hash = LECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    address signer = LECDSA.recover(hash, signature);\n\n    require(signer == owner, \"Illegal ECDASA Signature\");\n    _approve(owner, spender, value);\n    return true;\n  }\n\n  function mint(address account, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.mint.selector, account, true, true);\n    return _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.burn.selector, account, true, true);\n    require(account != address(0), \"Invalid Account Address\");\n    uint256 accountBalance = _data.accounts[account].balance;\n    require(accountBalance >= amount, \"Insufficient Account Balance\");\n    unchecked {\n      _data.accounts[account].balance = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n    emit Burn(_msgSender(), account, amount, _totalSupply);\n    return _totalSupply;\n  }\n\n  function name() external view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() external view returns (string memory) {\n    return _symbol;\n  }\n\n  function totalSupply() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) external view returns (uint256) {\n    return _data.accounts[account].balance;\n  }\n\n  function totalBalanceOf(address account) external view returns (uint256) {\n    return _data.accounts[account].lockBalance + _data.accounts[account].balance;\n  }\n\n  function lockBalanceOf(address account) external view returns (uint256) {\n    return _data.accounts[account].lockBalance;\n  }\n\n  function allowance(address owner, address spender) external view returns (uint256) {\n    return _allowance(owner, spender);\n  }\n\n  function taxRate() external view returns (uint256) {\n    return _taxRate;\n  }\n\n  function taxTreasury() external view returns (address) {\n    return _taxTreasury;\n  }\n\n  function taxWhitelist() external view returns (address[] memory) {\n    return _data.taxWhitelist.values();\n  }\n\n  function nonce(address owner) external view returns (uint256) {\n    return _data.accounts[owner].nonce.current();\n  }\n\n  function isPaused(address account) external view returns (bool) {\n    return account != address(0) && _data.pausedList.contains(account);\n  }\n\n  function isPausedAll() external view returns (bool) {\n    return _isPaused;\n  }\n\n  function pausedAccounts() external view returns (address[] memory) {\n    return _data.pausedList.values();\n  }\n\n  function lockInfo(bytes32 lockId, address account) external view returns (uint256, uint128, uint128, address, uint8) {\n    AssetLock storage lock = _data.locks[account][lockId];\n    return (lock.amount, lock.lockedAt, lock.claimedAt, lock.source, uint8(lock.status));\n  }\n\n  function decimals() external pure returns (uint8) {\n    return 18;\n  }\n\n  function initialize(InitRequest calldata request) public onlyProxy onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(request.domainRealm));\n    __BASE_UUPS_init(request.domainName, request.domainVersion, realm, request.accessControlManager);\n\n    _name = \"LIVELY\";\n    _symbol = \"LVL\";\n    _taxRate = request.taxRateValue;\n    _isTokenDistributed = false;\n    _initContext(request.domainName, request.domainVersion, realm, request.signature);\n  }\n\n  function _tokensDistributionValidation(address account) private view {\n    require(_data.accounts[account].balance == 0, \"AssetId Already Distributed\");\n  }\n\n  function tokensDistribution(address assetManager, address[7] calldata assets) public safeModeCheck aclCheck(this.tokensDistribution.selector) returns (bool) {\n    require(!_isTokenDistributed, \"Token Already Distributed\");\n\n    try IERC165(assetManager).supportsInterface(type(IAssetManagerERC20).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetManagerERC20\");\n    } catch {\n      revert(\"Illegal IAssetManagerERC20\");\n    }     \n\n    _mint(assetManager, 5_000_000_000 * 10 ** 18);  // 5 billion tokens according to tokenomics\n\n    for (uint i = 0; i < 7; i++) {\n       try IERC165(assets[i]).supportsInterface(type(IAssetEntity).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid IAssetEntity\");\n      } catch {\n        revert(\"Illegal IAssetEntity\");\n      }\n      require(IAssetEntity(assets[i]).assetToken() == address(this), \"Invalid Asset Token\");\n      if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_AUDIO_VIDEO_PROGRAM_ASSET\"))) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 500_000_000 * 10 ** 18);     // 10% \n\n      } else if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_FOUNDING_TEAM_ASSET\"))) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 900_000_000 * 10 ** 18);     // 18%\n\n      } else if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_TREASURY_ASSET\"))) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 750_000_000 * 10 ** 18);     // 15%\n\n      } else if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_PUBLIC_SALE_ASSET\"))) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 2_000_000_000 * 10 ** 18);   // 40%\n\n      } else if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_VALIDATORS_REWARDS_ASSET\"))) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 300_000_000 * 10 ** 18);     // 6%\n\n      } else if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_CROWD_FOUNDING_ASSET\"))) {\n        _tokensDistributionValidation(assets[i]);\n        _transfer(_msgSender(), assets[i], 550_000_000 * 10 ** 18);     // 11%\n\n      } else if (IAssetEntity(assets[i]).assetName() == keccak256(abi.encodePacked(\"LIVELY_TAX_TREASURY_ASSET\"))) {\n        require(_taxTreasury == address(0), \"TaxTreasury Already Registered\");\n        _taxTreasury = assets[i];\n\n      } else {\n        revert(\"Asset Not Supported\");\n      }\n    }\n\n    _isTokenDistributed = true;\n    return true;\n  }\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {  \n    return\n      interfaceId == type(IERC20).interfaceId ||\n      interfaceId == type(IERC20Extra).interfaceId ||\n      interfaceId == type(IERC20Pause).interfaceId ||\n      interfaceId == type(IERC20Lock).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function getLibrary() public pure returns(address) {\n    return address(LTokenERC20);\n  }\n\n  function _initContext(\n    string calldata domainName,\n    string calldata domainVersion,\n    bytes32 realm,\n    bytes calldata signature\n  ) internal {\n    (IContextManagement.RequestContext memory rc, IContextManagement.RequestRegisterContext[] memory rrc) = LTokenERC20\n      .createRequestContext(_domainName, _domainVersion, _domainRealm);\n\n    IContextManagement(_accessControlManager).registerContext(signature, rc, rrc);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      domainName,\n      domainVersion,\n      realm,\n      _getInitializedCount()\n    );\n  }\n\n  function _updateTaxWhitelist(address account, bool isDeleted) internal returns (bool){\n    emit TaxWhitelistUpdated(_msgSender(), account, isDeleted);\n    return LTokenERC20.updateTaxWhitelist(_data, account, isDeleted);\n  }\n\n  function _mint(address account, uint256 amount) internal returns (uint256) {\n    require(account != address(0), \"Invalid Account Address\");\n    _totalSupply += amount;\n    _data.accounts[account].balance += amount;\n    emit Mint(_msgSender(), account, amount, _totalSupply);\n    return _totalSupply;\n  }\n\n  function _transfer(address src, address dest, uint256 amount) internal {\n    LTokenERC20.transfer(_data, src, dest, amount);\n    emit Transfer(src, dest, amount);\n  }\n\n  function _taxTransfer(\n    address source,\n    address recipient,\n    uint256 amount\n  ) internal {\n    uint256 tax = amount.mulBP(_taxRate);\n    uint256 tokensToTransfer = amount.sub(tax, \"Insufficient Transfer Amount\");\n\n    _transfer(source, _taxTreasury, tax);\n    _transfer(source, recipient, tokensToTransfer);\n  }\n\n  function _transferFrom(\n    address source,\n    address recipient,\n    uint256 amount\n  ) internal returns (bool) {\n    address spender = _msgSender();\n    if (_taxRate > 0 && !_data.taxWhitelist.contains(_msgSender())) {\n      _taxTransfer(source, recipient, amount);\n    } else {\n      _transfer(source, recipient, amount);\n    }\n\n    _spendAllowance(source, spender, amount);    \n    emit TransferFrom(spender, source, recipient, amount);\n    return true;\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal {\n    require(owner != address(0), \"Invalid Owner Address\");\n    require(spender != address(0), \"Invalid Spender Address\");\n\n    _data.allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _spendAllowance(address owner, address spender, uint256 amount) internal {\n    uint256 currentAllowance = _allowance(owner, spender);\n    require(currentAllowance >= amount, \"Insufficient Account Allowance\");\n    unchecked {\n      _approve(owner, spender, currentAllowance - amount);\n    }\n  }\n\n  function _useNonce(address owner) internal returns (uint256 current) {\n    LCounters.Counter storage localNonce = _data.accounts[owner].nonce;\n    current = localNonce.current();\n    localNonce.increment();\n  }\n\n  function _lockToken(LockTokenRequest calldata lockRequest) internal returns (bytes32) {\n    bytes32 lockId = LTokenERC20.lockToken(_data, lockRequest);  \n    emit TokenLocked(lockId, _msgSender(), lockRequest.source, lockRequest.dest, lockRequest.timestamp, lockRequest.amount);\n    return lockId;\n  }\n\n  function _claimToken(bytes32 lockId) internal returns (uint256) {\n    uint lockAmount = LTokenERC20.claimToken(_data, lockId);\n    emit TokenClaimed(lockId, _msgSender(), _data.locks[_msgSender()][lockId].source, lockAmount);\n    return lockAmount;\n  }\n\n  function _unlockToken(UnLockTokenRequest calldata unlockRequest) internal returns (uint256) {\n    (address srcAccount, uint lockAmount) = LTokenERC20.unlockToken(_data, unlockRequest);\n    emit TokenUnlocked(unlockRequest.lockId, _msgSender(), unlockRequest.account, srcAccount, lockAmount, unlockRequest.reason);\n    return lockAmount;\n  }\n\n  function _allowance(address owner, address spender) internal view returns (uint256) {\n    return _data.allowances[owner][spender];\n  }\n\n  function _policyInterceptor(bytes4 funcSelector, address account, bool isCheckingTokenPaused, bool isCheckingAccountPaused) private safeModeCheck aclCheck(funcSelector) {\n    if(isCheckingTokenPaused) {\n      require(!_isPaused, \"ERC20Pause: Call Rejected\");\n    }\n\n    if (isCheckingAccountPaused) {\n      require(!_data.pausedList.contains(account), \"ERC20Pause: Account Suspended\");\n    }\n  }\n}\n"
    },
    "src/contracts/token/lively/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "src/contracts/token/lively/IERC20Extra.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IERC20Extra {\n  struct BatchTransferRequest {\n    address to;\n    uint256 amount;\n  }\n\n  struct BatchTransferFromRequest {\n    address from;\n    address to;\n    uint256 amount;\n  }\n\n  struct BatchUpdateTaxWhitelistRequest {\n    address account;\n    bool isDeleted;\n  }\n\n  event ApprovalIncreased(address indexed owner, address indexed spender, uint256 amount);\n\n  event ApprovalDecreased(address indexed owner, address indexed spender, uint256 amount);\n\n  event TransferFrom(address indexed sender, address indexed from, address indexed to, uint256 amount);\n\n  event BatchTransfer(address indexed sender, uint256 totalAmount);\n\n  event BatchTransferFrom(address indexed sender, uint256 totalAmount);\n\n  event TaxRateUpdated(address indexed sender, uint256 rate);\n\n  event TaxWhitelistUpdated(address indexed sender, address indexed account, bool isDeleted);\n\n  event Burn(address indexed sender, address indexed account, uint256 amount, uint256 totalSupply);\n\n  event Mint(address indexed sender, address indexed account, uint256 amount, uint256 totalSupply);\n\n  function increaseAllowance(address spender, uint256 amount) external returns (uint256);\n\n  function decreaseAllowance(address spender, uint256 amount) external returns (uint256);\n\n  function burn(address account, uint256 amount) external returns (uint256);\n\n  function mint(address account, uint256 amount) external returns (uint256);\n\n  function batchTransfer(BatchTransferRequest[] calldata request) external returns (bool);\n\n  function batchTransferFrom(BatchTransferFromRequest[] calldata request) external returns (bool);\n\n  function updateTaxRate(uint256 taxRate) external returns (bool);\n\n  function updateTaxWhitelist(address account, bool isDeleted) external returns (bool);\n\n  function batchUpdateTaxWhitelist(BatchUpdateTaxWhitelistRequest[] calldata request) external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    bytes calldata signature\n  ) external returns (bool);\n\n  function taxRate() external view returns (uint256);\n\n  function taxTreasury() external view returns (address);\n\n  function taxWhitelist() external view returns (address[] memory);\n\n  function nonce(address owner) external view returns (uint256);\n}\n"
    },
    "src/contracts/token/lively/IERC20Pause.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IERC20Pause {\n  event Paused(address indexed sender, address indexed account);\n\n  event Unpaused(address indexed sender, address indexed account);\n\n  event PausedAll(address indexed sender);\n\n  event UnpausedAll(address indexed sender);\n\n  function pause(address account) external;\n\n  function unpause(address account) external;\n\n  function pauseAll() external;\n\n  function unpauseAll() external;\n\n  function isPaused(address account) external view returns (bool);\n\n  function isPausedAll() external view returns (bool);\n\n  function pausedAccounts() external view returns (address[] memory);\n}\n"
    },
    "src/contracts/token/lively/IERC20Lock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IERC20Lock {\n\n  struct LockTokenRequest {\n    address source;\n    address dest;\n    uint256 timestamp;\n    uint256 amount;\n  }\n\n  struct UnLockTokenRequest {\n    bytes32 lockId;\n    address account;\n    string reason;\n  }\n\n  event TokenLocked(bytes32 indexed id, address indexed sender, address indexed src, address account, uint256 timestamp, uint256 amount);\n\n  event TokenClaimed(bytes32 indexed id, address indexed sender, address indexed src, uint256 amount);\n\n  event TokenUnlocked(bytes32 indexed id, address indexed sender, address indexed account, address dest, uint256 amount, string reason);\n\n  event BatchTokenClaimed(address indexed sender, uint256 totalAmount);\n\n  event BatchTokenUnlocked(address indexed sender, uint256 totalAmount);\n\n  event BatchTokenLocked(address indexed sender, uint256 totalAmount);\n\n  function lockToken(LockTokenRequest calldata lockRequest) external returns (bytes32);\n\n  function batchLockToken(LockTokenRequest[] calldata lockRequest) external returns (bytes32[] memory);\n\n  function unlockToken(UnLockTokenRequest calldata unlockRequest) external returns (uint256);\n\n  function batchUnlockToken(UnLockTokenRequest[] calldata unlockRequest) external returns (uint256);\n\n  function claimToken(bytes32 lockId) external returns (uint256);\n\n  function batchClaimToken(bytes32[] calldata lockIds) external returns (uint256);\n\n  function lockInfo(bytes32 lockId, address account) external view returns (uint256, uint128, uint128, address, uint8);\n\n  function totalBalanceOf(address account) external view returns (uint256);\n\n  function lockBalanceOf(address account) external view returns (uint256);\n\n}"
    },
    "src/contracts/token/lively/LivelyStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../proxy/BaseUUPSStorage.sol\";\nimport \"../../lib/LCounters.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\n\nabstract contract LivelyStorage is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LCounters for LCounters.Counter;\n\n  enum LockState {\n    NONE,\n    LOCKED,\n    CLAIMED,\n    UNLOCKED\n  }\n\n  struct AccountInfo {\n    uint256 balance;\n    uint256 lockBalance;\n    LCounters.Counter nonce;\n  }\n\n  struct AssetLock {\n    uint256 amount;\n    uint128 lockedAt;\n    uint128 claimedAt;\n    address source;\n    LockState status;    \n  }\n\n  struct DataCollection {\n    mapping(address => AccountInfo) accounts;\n    mapping(address => mapping(address => uint256)) allowances;\n    mapping(address => mapping(bytes32 => AssetLock)) locks;\n    LEnumerableSet.AddressSet pausedList;\n    LEnumerableSet.AddressSet taxWhitelist;\n  }\n\n  bytes32 internal constant _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n  string internal _name;\n  string internal _symbol;\n  uint256 internal _totalSupply;\n  uint256 internal _taxRate;\n  address internal _taxTreasury;\n  bool internal _isPaused;\n  bool internal _isTokenDistributed;\n\n  DataCollection internal _data;\n\n}\n"
    },
    "src/contracts/token/asset/IAssetEntity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IAssetEntity {\n\n  enum Status {\n    NONE,\n    ACTIVE,\n    SAFE_MODE\n  }\n\n  enum AssetType {\n    NONE,\n    ERC20,\n    ERC721,\n    ERC1155\n  }\n\n  event AssetInitialized(\n    address indexed sender,\n    address indexed assetId,\n    address indexed tokenId,\n    address assetManager,\n    address assetSubject,\n    string name,\n    string version,\n    bytes32 realm,\n    bytes32 role\n  );\n  \n  event AssetSafeModeChanged(address indexed sender, address indexed assetId, bytes32 indexed realm, bool status);\n\n  function assetSafeModeSet(bool status) external returns (bool);\n\n  function assetSafeMode() external view returns (bool);\n\n  function assetType() external view returns (AssetType);\n\n  function assetToken() external view returns (address);\n\n  function assetName() external view returns (bytes32);\n\n  function assetVersion() external view returns (bytes32);\n\n  function assetRealm() external view returns (bytes32);\n\n  function assetRole() external view returns (bytes32);\n\n  function assetAcl() external view returns (address);\n\n  function assetInitVersion() external view returns (uint16);\n}"
    },
    "src/contracts/token/asset/IAssetManagerERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../lively/IERC20Extra.sol\";\nimport \"../lively/IERC20Lock.sol\";\nimport \"./IAssetEntity.sol\";\n\ninterface IAssetManagerERC20 {\n\n  struct CreateAssetRequest {\n    bytes32 role; \n    bytes32 salt;\n    address tokenId; \n    string assetName; \n    string assetVersion;     \n  }\n\n  event AssetSubjectUpdated(address indexed sender, address indexed assetSubject);\n\n  event TokenRegistered(address indexed sender, address indexed tokenId, string tokenName, string tokenSymbol);\n  \n  event AssetCreated(address indexed sender, address indexed assetId, address indexed tokenId, address assetSubject);\n\n  event AssetRegistered(address indexed sender, address indexed assetId, address indexed tokenId);\n\n  event AssetRemoved(address indexed sender, address indexed assetId, address indexed tokenId);\n  \n  event TokenSafeModeChanged(address indexed sender, address indexed tokenId, bool isEnabled);\n\n  function createAsset(CreateAssetRequest calldata request) external returns (address);\n\n  function updateAssetSubject(address assetSubject, bytes calldata assetCreationSignature) external returns (bool);\n\n  function registerToken(address tokenId) external returns (bool);\n\n  function registerAsset(address assetId) external returns (bool);\n\n  function removeAsset(address assetId) external returns (bool);\n\n  function setSafeModeToken(address tokenId, bool isEnabled) external returns (bool);\n\n  function tokenLock(address assetId, IERC20Lock.LockTokenRequest calldata lockRequest) external returns (bytes32);\n\n  function tokenBatchLock(address assetId, IERC20Lock.LockTokenRequest[] calldata lockRequests) external returns (bytes32[] memory);\n\n  function tokenTransfer(address assetId, address to, uint256 amount) external returns (bool);\n\n  function tokenBatchTransfer(address assetId, IERC20Extra.BatchTransferRequest[] calldata request) external returns (bool);\n\n  function tokenTransferFrom(address assetId, address from, address to, uint256 amount) external returns (bool);\n\n  function tokenBatchTransferFrom(address assetId, IERC20Extra.BatchTransferFromRequest[] calldata request) external returns (bool);\n\n  function tokenApprove(address assetId, address spender, uint256 amount) external returns (bool);\n\n  function tokenIncreaseAllowance(address assetId, address spender, uint256 amount) external returns (uint256);\n\n  function tokenDecreaseAllowance(address assetId, address spender, uint256 amount) external returns (uint256);\n\n  function getAllTokens() external view returns(address[] memory);\n\n  function getTokenInfo(address tokenId) external view returns (IAssetEntity.Status, address[] memory);\n\n  function isAssetExists(address assetId) external view returns (bool);\n\n  function isTokenExists(address tokenId) external view returns (bool);\n\n  function getAssetSubject() external view returns (address);\n\n  function predictAddress(address implementation, bytes32 salt, address deployer) external view returns (address);\n}"
    },
    "src/contracts/token/asset/ERC20/IAssetERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../lively/IERC20Extra.sol\";\nimport \"../../lively/IERC20Lock.sol\";\n\ninterface IAssetERC20 {\n\n  event AssetERC20Called(address indexed sender, address indexed assetId, bytes4 indexed functionSelector);\n\n  function tokenLock(IERC20Lock.LockTokenRequest calldata lockRequest) external returns (bytes32);\n\n  function tokenBatchLock(IERC20Lock.LockTokenRequest[] calldata lockRequests) external returns (bytes32[] memory);\n\n  function tokenTransfer(address to, uint256 amount) external returns (bool);\n\n  function tokenBatchTransfer(IERC20Extra.BatchTransferRequest[] calldata request) external returns (bool);\n\n  function tokenTransferFrom(address from, address to, uint256 amount) external returns (bool);\n\n  function tokenBatchTransferFrom(IERC20Extra.BatchTransferFromRequest[] calldata request) external returns (bool);\n\n  function tokenApprove(address spender, uint256 amount) external returns (bool);\n\n  function tokenIncreaseAllowance(address spender, uint256 amount) external returns (uint256);\n\n  function tokenDecreaseAllowance(address spender, uint256 amount) external returns (uint256);\n\n  function tokenBalance() external view returns (uint256); \n\n  function assetBalance() external view returns (uint256); \n}"
    },
    "src/contracts/lib/token/LTokenERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../token/lively/IERC20.sol\";\nimport \"../../token/lively/IERC20Extra.sol\";\nimport \"../../token/lively/IERC20Pause.sol\";\nimport \"../../token/lively/IERC20Lock.sol\";\nimport \"../../token/lively/LivelyStorage.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../acl/IAccessControl.sol\";\nimport \"../struct/LEnumerableSet.sol\";\n\nlibrary LTokenERC20 {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LTokenERC20\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  bytes32 public constant LIVELY_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_SYSTEM_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_SYSTEM_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_ANONYMOUS_ROLE = keccak256(abi.encodePacked(\"LIVELY_ANONYMOUS_ROLE\"));\n  bytes32 public constant LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE = keccak256(abi.encodePacked(\"LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE\"));\n  bytes32 public constant LIVELY_ASSET_MANAGER_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_MANAGER_ROLE\"));\n\n  function createRequestContext(\n    bytes32 domainName,\n    bytes32 domainVersion,\n    bytes32 realm\n  )\n    external\n    view\n    returns (IContextManagement.RequestContext memory, IContextManagement.RequestRegisterContext[] memory)\n  {\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](5);\n    rrc[0].role = LIVELY_ANONYMOUS_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](10);\n    rrc[0].funcSelectors[0] = IERC20.transfer.selector;\n    rrc[0].funcSelectors[1] = IERC20.transferFrom.selector;\n    rrc[0].funcSelectors[2] = IERC20.approve.selector;\n    rrc[0].funcSelectors[3] = IERC20Extra.batchTransfer.selector;\n    rrc[0].funcSelectors[4] = IERC20Extra.batchTransferFrom.selector;\n    rrc[0].funcSelectors[5] = IERC20Extra.permit.selector;\n    rrc[0].funcSelectors[6] = IERC20Extra.increaseAllowance.selector;\n    rrc[0].funcSelectors[7] = IERC20Extra.decreaseAllowance.selector;\n    rrc[0].funcSelectors[8] = IERC20Lock.claimToken.selector;\n    rrc[0].funcSelectors[9] = IERC20Lock.batchClaimToken.selector;\n\n    rrc[1].role = LIVELY_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](12);\n    rrc[1].funcSelectors[0] = IProxy.setUpgradeStatus.selector;\n    rrc[1].funcSelectors[1] = IProxy.setSafeMode.selector;\n    rrc[1].funcSelectors[2] = IERC20Extra.burn.selector;\n    rrc[1].funcSelectors[3] = IERC20Extra.mint.selector;\n    rrc[1].funcSelectors[4] = IERC20Extra.updateTaxRate.selector;\n    rrc[1].funcSelectors[5] = IERC20Extra.updateTaxWhitelist.selector;   \n    rrc[1].funcSelectors[6] = IERC20Extra.batchUpdateTaxWhitelist.selector;\n    rrc[1].funcSelectors[7] = IERC20Pause.pause.selector;\n    rrc[1].funcSelectors[8] = IERC20Pause.unpause.selector;\n    rrc[1].funcSelectors[9] = IERC20Pause.pauseAll.selector;\n    rrc[1].funcSelectors[10] = IERC20Pause.unpauseAll.selector;\n    rrc[1].funcSelectors[11] = bytes4(keccak256(\"withdrawBalance(address)\"));\n\n    rrc[2].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[2].isEnabled = true;\n    rrc[2].funcSelectors = new bytes4[](2);\n    rrc[2].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[2].funcSelectors[1] = IProxy.upgradeTo.selector;\n\n    rrc[3].role = LIVELY_ASSET_MANAGER_ROLE;\n    rrc[3].isEnabled = true;\n    rrc[3].funcSelectors = new bytes4[](3);\n    rrc[3].funcSelectors[0] = IERC20Lock.lockToken.selector;  \n    rrc[3].funcSelectors[1] = IERC20Lock.batchLockToken.selector;  \n    rrc[3].funcSelectors[2] = bytes4(keccak256(\"tokensDistribution(address,address[7])\"));\n    \n    rrc[4].role = LIVELY_COMMUNITY_DAO_EXECUTOR_ROLE;\n    rrc[4].isEnabled = true;\n    rrc[4].funcSelectors = new bytes4[](2);\n    rrc[4].funcSelectors[0] = IERC20Lock.unlockToken.selector;\n    rrc[4].funcSelectors[1] = IERC20Lock.batchUnlockToken.selector;\n\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: domainName,\n      version: domainVersion,\n      realm: realm,\n      contractId: address(this),\n      status: true\n    });\n\n    return (rc, rrc);\n  }\n\n  function lockToken(LivelyStorage.DataCollection storage data, IERC20Lock.LockTokenRequest memory lockRequest) external returns(bytes32) {\n    require(lockRequest.source != address(0), \"Invalid Source Address\");\n    require(lockRequest.dest != address(0), \"Invalid Destination Address\");\n    require(lockRequest.source != lockRequest.dest, \"Illegal Destination Address\");\n    require(lockRequest.timestamp > block.timestamp + 1 days, \"Illegal Timestamp\");\n    require(lockRequest.amount > 0, \"Illegal amount\");\n\n    bytes32 lockId = keccak256(abi.encodePacked(lockRequest.source, lockRequest.dest, lockRequest.timestamp, lockRequest.amount));\n    require(data.locks[lockRequest.dest][lockId].source == address(0), \"LockId Already Exists\");\n    \n    uint256 srcBalance = data.accounts[lockRequest.source].balance;\n    require(srcBalance >= lockRequest.amount, \"Insufficient Account Balance\");\n    unchecked {\n      data.accounts[lockRequest.source].balance = srcBalance - lockRequest.amount;\n    }\n    data.accounts[lockRequest.dest].lockBalance += lockRequest.amount;\n\n    LivelyStorage.AssetLock storage assetLock = data.locks[lockRequest.dest][lockId];\n    assetLock.lockedAt = uint128(block.timestamp);\n    assetLock.claimedAt = uint128(lockRequest.timestamp);\n    assetLock.source = lockRequest.source;\n    assetLock.amount = lockRequest.amount;\n    assetLock.status = LivelyStorage.LockState.LOCKED;\n    return lockId;\n  }\n\n  function claimToken(LivelyStorage.DataCollection storage data, bytes32 lockId) external returns(uint256) {\n    require(lockId != bytes32(0), \"Invalid LockId\");\n    require(data.locks[msg.sender][lockId].source != address(0), \"LockId Not Found\");\n    require(data.locks[msg.sender][lockId].claimedAt < uint128(block.timestamp), \"Illegal Claim Lock\");\n\n    uint256 lockAmount = data.locks[msg.sender][lockId].amount;\n    uint256 lockBalance = data.accounts[msg.sender].lockBalance;\n    require(lockBalance >= lockAmount, \"Insufficient Account Lock Balance\");\n    unchecked {\n      data.accounts[msg.sender].lockBalance = lockBalance - lockAmount;\n    }\n    data.accounts[msg.sender].balance += lockAmount;\n    data.locks[msg.sender][lockId].status = LivelyStorage.LockState.CLAIMED;\n    return lockAmount;\n  }  \n\n  function unlockToken(LivelyStorage.DataCollection storage data, IERC20Lock.UnLockTokenRequest calldata unlockRequest) external returns (address, uint256) {\n    require(unlockRequest.lockId != bytes32(0), \"Invalid LockId\");\n    require(data.locks[unlockRequest.account][unlockRequest.lockId].source != address(0), \"LockId Not Found\");\n    require(data.locks[unlockRequest.account][unlockRequest.lockId].status == LivelyStorage.LockState.LOCKED, \"Invalid Lock State\");\n\n    uint256 lockAmount = data.locks[unlockRequest.account][unlockRequest.lockId].amount;\n    uint256 lockBalance = data.accounts[unlockRequest.account].lockBalance;\n    address srcAccount = data.locks[unlockRequest.account][unlockRequest.lockId].source;    \n    require(lockBalance >= lockAmount, \"Insufficient Account Lock Balance\");\n    unchecked {\n      data.accounts[unlockRequest.account].lockBalance = lockBalance - lockAmount;\n    }\n    data.accounts[srcAccount].balance += lockAmount;\n    data.locks[unlockRequest.account][unlockRequest.lockId].status = LivelyStorage.LockState.UNLOCKED;\n    return (srcAccount,lockAmount);\n  }\n\n  function transfer(LivelyStorage.DataCollection storage data, address src, address dest, uint256 amount) external {\n    require(src != address(0), \"Invalid Source Address\");\n    require(dest != address(0), \"Invalid Destination Address\");\n    require(src != dest, \"Illegal Self Transfer\");\n    require(amount > 0, \"Invalid Transfer Amount\");\n\n    uint256 srcBalance = data.accounts[src].balance;\n    require(srcBalance >= amount, \"Insufficient Account Balance\");\n    unchecked {\n      data.accounts[src].balance = srcBalance - amount;\n    }\n    data.accounts[dest].balance += amount;\n  }\n\n  function updateTaxWhitelist(LivelyStorage.DataCollection storage data, address account, bool isDeleted) external returns (bool){\n    require(account != address(0), \"Invalid Account Address\");\n    if (isDeleted) {\n      require(data.taxWhitelist.contains(account), \"Account Not Found\");\n      data.taxWhitelist.remove(account);\n    } else {\n      require(!data.taxWhitelist.contains(account), \"Account Already Exists\");\n      data.taxWhitelist.add(account);\n    }\n\n    return true;\n  }\n\n}\n"
    },
    "src/contracts/lib/LCounters.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary LCounters {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    unchecked {\n      counter._value += 1;\n    }\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n    unchecked {\n      counter._value = value - 1;\n    }\n  }\n\n  function reset(Counter storage counter) internal {\n    counter._value = 0;\n  }\n}\n"
    },
    "src/contracts/lib/math/LBasisPointsMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport \"./LSafeMath.sol\";\n\nlibrary LBasisPointsMath {\n  using LSafeMath for uint256;\n\n  uint256 private constant _BASIS_POINTS = 10000;\n\n  function mulBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    return amt.mul(bp).div(_BASIS_POINTS);\n  }\n\n  function divBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    require(bp > 0, \"Illegal Divide Zero\");\n    return amt.mul(_BASIS_POINTS).div(bp);\n  }\n\n  function addBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    if (amt == 0) return 0;\n    if (bp == 0) return amt;\n    return amt.add(mulBP(amt, bp));\n  }\n\n  function subBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    if (amt == 0) return 0;\n    if (bp == 0) return amt;\n    return amt.sub(mulBP(amt, bp));\n  }\n}\n"
    },
    "src/contracts/lib/math/LSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary LSafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, with an overflow flag.\n   */\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      uint256 c = a + b;\n      if (c < a) return (false, 0);\n      return (true, c);\n    }\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n   */\n  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b > a) return (false, 0);\n      return (true, a - b);\n    }\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n   */\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n      // benefit is lost if 'b' is also tested.\n      // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n      if (a == 0) return (true, 0);\n      uint256 c = a * b;\n      if (c / a != b) return (false, 0);\n      return (true, c);\n    }\n  }\n\n  /**\n   * @dev Returns the division of two unsigned integers, with a division by zero flag.\n   */\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b == 0) return (false, 0);\n      return (true, a / b);\n    }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n   */\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b == 0) return (false, 0);\n      return (true, a % b);\n    }\n  }\n\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   *\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   *\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator.\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * reverting when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a % b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {trySub}.\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b <= a, errorMessage);\n      return a - b;\n    }\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b > 0, errorMessage);\n      return a / b;\n    }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * reverting with custom message when dividing by zero.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {tryMod}.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b > 0, errorMessage);\n      return a % b;\n    }\n  }\n}\n"
    },
    "src/contracts/token/asset/ERC20/AssetERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IAssetERC20.sol\";\nimport \"../IAssetEntity.sol\";\nimport \"../IAssetManagerERC20.sol\";\nimport \"../../lively/IERC20.sol\";\nimport \"../../../proxy/Initializable.sol\";\nimport \"../../../utils/Message.sol\";\nimport \"../../../utils/ERC165.sol\";\nimport \"../../../lib/cryptography/LECDSA.sol\";\nimport \"../../../lib/LContextUtils.sol\";\nimport \"../../../lib/LAddress.sol\";\nimport \"../../../acl/IAccessControl.sol\";\nimport \"../../../acl/IContextManagement.sol\";\n\ncontract AssetERC20 is Initializable, Message, ERC165, IAssetERC20, IAssetEntity {\n  using LAddress for address;\n\n  struct InitRequest {\n    bytes32 domainRealm;\n    bytes32 assetRole;\n    bytes32 salt;\n    address subject;\n    address erc20Token;\n    address accessControl;\n    address assetManager;\n    string domainName;\n    string domainVersion;\n    bytes signature;\n  }\n\n  bytes32 private constant _LIVELY_ASSET_GROUP = keccak256(abi.encodePacked(\"LIVELY_ASSET_GROUP\"));\n  bytes32 private constant _LIVELY_ASSET_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_ADMIN_ROLE\"));\n  bytes32 private constant _LIVELY_ASSET_MANAGER_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_MANAGER_ROLE\"));\n\n  address private _accessControlManager;\n  address private _erc20Token;\n  bytes32 private _domainName;\n  bytes32 private _domainVersion;\n  bytes32 private _domainRealm;\n  bytes32 private _assetRole;\n  bool private _isSafeMode;\n  \n  constructor() { _isSafeMode = true; }\n\n  function initialize(InitRequest calldata request) public initializer {\n\n    try IERC165(request.erc20Token).supportsInterface(type(IERC20).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid ERC20Token Address\");\n    } catch {\n      revert(\"Illegal ERC20Token Address\");\n    }\n\n    try IERC165(request.erc20Token).supportsInterface(type(IERC20Extra).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid ERC20TokenExtra Address\");\n    } catch {\n      revert(\"Illegal ERC20TokenExtra Address\");\n    }\n\n    try IERC165(request.erc20Token).supportsInterface(type(IERC20Lock).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid ERC20TokenLock Address\");\n    } catch {\n      revert(\"Illegal ERC20TokenLock\");\n    }\n\n    try IERC165(request.accessControl).supportsInterface(type(IAccessControl).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid AccessControlManager\");\n    } catch {\n      revert(\"Illegal AccessControlManager\");\n    }     \n\n    try IERC165(request.assetManager).supportsInterface(type(IAssetManagerERC20).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetManagerERC20\");\n    } catch {\n      revert(\"Illegal IAssetManagerERC20\");\n    }     \n\n    _accessControlManager = request.accessControl;\n    require(IAccessControl(_accessControlManager).isRoleEnabled(request.assetRole), \"Role Not Found OR Disabled \");\n\n    _domainRealm = request.domainRealm;    \n    _domainName = keccak256(abi.encodePacked(request.domainName));\n    _domainVersion = keccak256(abi.encodePacked(request.domainVersion));    \n    _erc20Token = request.erc20Token;\n    _assetRole = request.assetRole;\n    _isSafeMode = false;\n  \n    (IContextManagement.RequestPredictContext memory rpc, IContextManagement.RequestRegisterContext[] memory rrc) = \n      _createRequestContext(_domainName, _domainVersion, _domainRealm, _assetRole, request.salt, request.subject, request.assetManager);\n\n    IContextManagement(_accessControlManager).registerPredictContext(request.signature, rpc, rrc);\n\n    emit AssetInitialized(\n      _msgSender(),\n      address(this),\n      _erc20Token,\n      request.assetManager,\n      request.subject,\n      request.domainName,\n      request.domainVersion,\n      _domainRealm,\n      _assetRole      \n    );\n  }\n\n  function _createRequestContext(\n    bytes32 domainName,\n    bytes32 domainVersion,\n    bytes32 realm,\n    bytes32 role,\n    bytes32 salt,\n    address subject,\n    address deployer\n  )\n    internal\n    pure\n    returns (IContextManagement.RequestPredictContext memory, IContextManagement.RequestRegisterContext[] memory)\n  {\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n\n    rrc[0].role = _LIVELY_ASSET_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](1);\n    rrc[0].funcSelectors[0] = this.assetSafeModeSet.selector;\n\n    rrc[1].role = role;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](10);\n    rrc[1].funcSelectors[0] = IAssetERC20.tokenLock.selector;\n    rrc[1].funcSelectors[1] = IAssetERC20.tokenBatchLock.selector;\n    rrc[1].funcSelectors[2] = IAssetERC20.tokenTransfer.selector;\n    rrc[1].funcSelectors[3] = IAssetERC20.tokenBatchTransfer.selector;\n    rrc[1].funcSelectors[4] = IAssetERC20.tokenTransferFrom.selector;\n    rrc[1].funcSelectors[5] = IAssetERC20.tokenBatchTransferFrom.selector;\n    rrc[1].funcSelectors[6] = IAssetERC20.tokenApprove.selector;\n    rrc[1].funcSelectors[7] = IAssetERC20.tokenIncreaseAllowance.selector;\n    rrc[1].funcSelectors[8] = IAssetERC20.tokenDecreaseAllowance.selector;\n    rrc[1].funcSelectors[9] = this.withdrawBalance.selector;\n\n    IContextManagement.RequestPredictContext memory rpc = IContextManagement.RequestPredictContext({\n      name: domainName,\n      version: domainVersion,\n      realm: realm,\n      salt: salt,\n      subject: subject, \n      deployer: deployer,\n      status: true\n    });\n\n    return (rpc, rrc);\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return\n      interfaceId == type(IAssetEntity).interfaceId ||\n      interfaceId == type(IAssetERC20).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function tokenLock(IERC20Lock.LockTokenRequest calldata lockRequest) external returns (bytes32) {\n    _policyInterceptor(this.tokenLock.selector);\n    require(lockRequest.source == address(this), \"Illegal Source Addres\");\n\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenLock.selector);\n    return IERC20Lock(_erc20Token).lockToken(lockRequest);\n  }\n\n  function tokenBatchLock(IERC20Lock.LockTokenRequest[] calldata lockRequests) external returns (bytes32[] memory) {\n    _policyInterceptor(this.tokenBatchLock.selector);\n    for(uint i = 0; i < lockRequests.length; i++) {\n      require(lockRequests[i].source == address(this), \"Illegal Source Addres\");\n    }\n\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenBatchLock.selector);  \n    return IERC20Lock(_erc20Token).batchLockToken(lockRequests);\n  }\n\n  function tokenTransfer(address to, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.tokenTransfer.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenTransfer.selector);\n    return IERC20(_erc20Token).transfer(to, amount);\n  }\n\n  function tokenBatchTransfer(IERC20Extra.BatchTransferRequest[] calldata request) external returns (bool) {\n    _policyInterceptor(this.tokenBatchTransfer.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenBatchTransfer.selector);\n    return IERC20Extra(_erc20Token).batchTransfer(request);\n  }\n\n  function tokenTransferFrom(address from, address to, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.tokenTransferFrom.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenTransferFrom.selector);\n    return IERC20(_erc20Token).transferFrom(from, to, amount);\n  }\n\n  function tokenBatchTransferFrom(IERC20Extra.BatchTransferFromRequest[] calldata request) external returns (bool) {\n    _policyInterceptor(this.tokenBatchTransferFrom.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenBatchTransferFrom.selector);\n    return IERC20Extra(_erc20Token).batchTransferFrom(request);\n  }\n\n  function tokenApprove(address spender, uint256 amount) external returns (bool) {\n    _policyInterceptor(this.tokenApprove.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenApprove.selector);\n    return IERC20(_erc20Token).approve(spender, amount);\n  }\n\n  function tokenIncreaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.tokenIncreaseAllowance.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenIncreaseAllowance.selector);\n    return IERC20Extra(_erc20Token).increaseAllowance(spender, amount);\n  }\n\n  function tokenDecreaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    _policyInterceptor(this.tokenDecreaseAllowance.selector);\n    emit AssetERC20Called(_msgSender(), address(this), this.tokenDecreaseAllowance.selector);\n    return IERC20Extra(_erc20Token).decreaseAllowance(spender, amount);\n  }\n\n  function assetSafeModeSet(bool status) override public returns (bool) {\n    require(IAccessControl(_accessControlManager).hasAccess(LContextUtils.generateCtx(address(this)),_msgSender(),this.assetSafeModeSet.selector), \"AssetERC20 Access Denied\");\n    require(_getInitializedCount() > 0, \"AssetERC20 Not Initialized\");\n    _isSafeMode = status;    \n    emit AssetSafeModeChanged(_msgSender(), address(this), _domainRealm, status);\n    return status;  \n  }\n\n  function withdrawBalance(address recepient) public {\n    _policyInterceptor(this.withdrawBalance.selector);\n    payable(recepient).transfer(address(this).balance);\n  }\n\n  function assetSafeMode() external view returns (bool) {\n    return _isSafeMode;\n  }\n\n  function assetType() external pure returns (AssetType) {\n    return AssetType.ERC20;\n  }\n\n  function assetToken() external view returns (address) {\n    return _erc20Token;\n  }\n\n  function assetName() external view returns (bytes32) {\n    return _domainName;\n  }\n\n  function assetVersion() external view returns (bytes32) {\n    return _domainVersion;\n  }\n\n  function assetRealm() external view returns (bytes32) {\n    return _domainRealm;\n  }\n\n  function assetRole() external view returns (bytes32) {\n    return _assetRole;\n  }\n\n   function assetAcl() external view returns (address) {\n    return _accessControlManager;\n   }\n\n  function assetInitVersion() external view returns (uint16) {\n    return _getInitializedCount();\n  }\n\n  // solhint-disable-next-line\n  receive() external payable {}\n\n  // solhint-disable-next-line\n  fallback() external payable {}\n\n  function tokenBalance() external view returns (uint256) {\n    return IERC20(_erc20Token).balanceOf(address(this));\n  }\n\n  function assetBalance() external view returns (uint256) {\n    return address(this).balance;\n  }\n\n  function _policyInterceptor(bytes4 funcSelector) private view {\n    require(!_isSafeMode, \"SafeMode: AssetERC20 Call Rejected\");\n    require(IAccessControl(_accessControlManager).hasAccess(LContextUtils.generateCtx(address(this)),_msgSender(),funcSelector), \"AssetERC20 Access Denied\");\n  }\n\n}"
    },
    "src/contracts/test/acl/AccessControlManagerTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./AccessControlStorageTest.sol\";\nimport \"../../acl/IAccessControl.sol\";\nimport \"../../acl/IGroupManagement.sol\";\nimport \"../../acl/IRealmManagement.sol\";\nimport \"../../acl/IRoleManagement.sol\";\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../lib/struct/LEnumerableMap.sol\";\nimport \"../../lib/acl/LContextManagement.sol\";\nimport \"../../lib/acl/LRoleManagement.sol\";\nimport \"../../lib/acl/LGroupManagement.sol\";\nimport \"../../lib/acl/LRealmManagement.sol\";\nimport \"../../lib/acl/LAccessControl.sol\";\nimport \"../../proxy/Initializable.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\n\ncontract AccessControlManagerTest is\n  AccessControlStorageTest,\n  BaseUUPSProxy\n  // IContextManagement,\n  // IAccessControl,\n  // IGroupManagement,\n  // IRealmManagement,\n  // IRoleManagement\n{\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableMap for LEnumerableMap.Bytes32ToBytes32Map;\n  using LEnumerableMap for LEnumerableMap.AddressToUintMap;\n\n  constructor() {}\n\n  function initialize() public onlyProxy reinitializer(2) {\n    _data.dummy_1 = 100;\n    dummy_2 = keccak256(\"UPDATE_TEST\");\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n    return\n      interfaceId == type(IAccessControl).interfaceId ||\n      interfaceId == type(IContextManagement).interfaceId ||\n      interfaceId == type(IRoleManagement).interfaceId ||\n      interfaceId == type(IGroupManagement).interfaceId ||\n      interfaceId == type(IRealmManagement).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n}\n"
    },
    "src/contracts/test/acl/AccessControlStorageTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../lib/struct/LEnumerableMap.sol\";\nimport \"../../proxy/BaseUUPSStorage.sol\";\n\nabstract contract AccessControlStorageTest is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableMap for LEnumerableMap.Bytes32ToBytes32Map;\n  using LEnumerableMap for LEnumerableMap.AddressToUintMap;\n\n  enum Status {\n    NONE,\n    ENABLED,\n    DISABLED\n  }\n\n  struct RoleStat {\n    bytes32 role;\n    Status status;\n  }\n\n  struct Context {\n    bytes32 realm;\n    address contractId;\n    bool isEnabled;\n    mapping(bytes4 => RoleStat) resources; // function selector => RoleStat\n    LEnumerableSet.Bytes32Set funcSet;\n  }\n\n  struct Role {\n    bytes32 group;\n    string name;\n    bool isEnabled;\n    LEnumerableSet.AddressSet accountSet;\n  }\n\n  struct Realm {\n    string name;\n    bool isEnabled;\n    bool isUpgradable;\n    LEnumerableSet.Bytes32Set ctxSet;\n  }\n\n  struct Group {\n    string name;\n    bool isEnabled;\n    LEnumerableSet.Bytes32Set roleSet;\n  }\n\n  struct DataCollections {\n    mapping(address => mapping(bytes32 => Status)) accountMap;\n    mapping(bytes32 => Context) ctxMap;\n    mapping(bytes32 => Role) roleMap;\n    mapping(bytes32 => Realm) realmMap;\n    mapping(bytes32 => Group) groupMap;\n    uint256 dummy_1;\n  }\n\n  DataCollections internal _data;\n  bytes32 internal dummy_2;\n}\n"
    },
    "src/contracts/utils/MulticallUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../lib/LAddress.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = _functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(LAddress.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return LAddress.verifyCallResult(success, returndata, \"Address: Call Failed\");\n    }\n}\n"
    },
    "src/contracts/test/proxy/ERC1967UpgradeTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../lib/LAddress.sol\";\nimport \"../../lib/LStorageSlot.sol\";\n\nabstract contract ERC1967UpgradeTest {\n  bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n  // invalid\n  bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  event Upgraded(address indexed implementation);\n\n  function _getImplementation() internal view returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    require(LAddress.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      LAddress.functionDelegateCall(newImplementation, data);\n    }\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n      } catch {\n        revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n      }\n      _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Emitted when the admin account has changed.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Returns the current admin.\n   */\n  function _getAdmin() internal view returns (address) {\n    return LStorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 admin slot.\n   */\n  function _setAdmin(address newAdmin) private {\n    require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   *\n   * Emits an {AdminChanged} event.\n   */\n  function _changeAdmin(address newAdmin) internal {\n    emit AdminChanged(_getAdmin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n   * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n   */\n  bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n}\n"
    },
    "src/contracts/test/proxy/UUPSUpgradeableTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../proxy/IERC1822.sol\";\nimport \"./ERC1967UpgradeTest.sol\";\nimport \"../../utils/ERC165.sol\";\n\ncontract UUPSUpgradeableTest is IERC1822Proxiable, ERC1967UpgradeTest, ERC165 {\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n  address private immutable __self = address(this);\n\n  modifier onlyProxy() {\n    require(address(this) != __self, \"Function must be called through delegatecall\");\n    require(_getImplementation() == __self, \"Function must be called through active proxy\");\n    _;\n  }\n\n  modifier notDelegated() {\n    require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n    _;\n  }\n\n  function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n    return _IMPLEMENTATION_SLOT;\n  }\n\n  function upgradeTo(address newImplementation) external virtual onlyProxy {\n    _authorizeUpgrade(newImplementation);\n    _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n  }\n\n  function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n    _authorizeUpgrade(newImplementation);\n    _upgradeToAndCallUUPS(newImplementation, data, true);\n  }\n\n  function _authorizeUpgrade(address newImplementation) internal virtual {}\n}\n"
    },
    "src/contracts/token/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../utils/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "src/contracts/token/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "src/contracts/token/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../utils/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IBaseProxy.sol\";\nimport \"./BaseProxy.sol\";\nimport \"./IERC1822.sol\";\nimport \"./IProxy.sol\";\nimport \"./BaseUUPSStorage.sol\";\nimport \"../lib/LAddress.sol\";\nimport \"../lib/LStorageSlot.sol\";\nimport \"../utils/IERC165.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\n\ncontract Proxy is BaseUUPSStorage, BaseProxy, IBaseProxy {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address logic, bytes memory data) payable {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = msg.sender;\n    _isSafeMode = true;\n    _upgradeToAndCallUUPS(logic, data, false);\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view override returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) private {\n    _setImplementation(newImplementation);\n    emit Upgraded(msg.sender, address(this), _implementation());\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) private returns (bytes memory) {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      return LAddress.functionDelegateCall(newImplementation, data);\n    }\n    return new bytes(0);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) private returns (bytes memory) {\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n      return new bytes(0);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"Invalid UUPS Contract\");\n      } catch {\n        revert(\"Illegal UUPS Contract\");\n      }\n\n      try IERC165(newImplementation).supportsInterface(type(IProxy).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid IProxy Contract\");\n      } catch {\n        revert(\"Illegal IProxy Contract\");\n      }\n      return _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n}\n"
    },
    "src/contracts/token/asset/AssetManagerStorageERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IAssetEntity.sol\";\nimport \"../../proxy/BaseUUPSStorage.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\n\nabstract contract AssetManagerStorageERC20 is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  struct TokenData {    \n    LEnumerableSet.AddressSet assets;\n    IAssetEntity.Status status;\n  }\n\n  struct DataCollection {\n    mapping(address => TokenData) tokens;\n    LEnumerableSet.AddressSet tokensSet;\n  }\n\n  address internal _assetSubjectERC20;\n  bytes internal _assetCreationSignature;\n  DataCollection internal _data;\n}"
    },
    "src/contracts/lib/token/LAssetManagerERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../token/asset/IAssetManagerERC20.sol\";\nimport \"../../token/asset/AssetManagerStorageERC20.sol\";\nimport \"../../token/asset/ERC20/AssetERC20.sol\";\nimport \"../../token/lively/IERC20.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../acl/IGroupManagement.sol\";\nimport \"../../acl/IRoleManagement.sol\";\nimport \"../../acl/IAccessControl.sol\";\nimport \"../../utils/IERC165.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../LContextUtils.sol\";\nimport \"../proxy/LClones.sol\";\n\nlibrary LAssetManagerERC20 {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LClones for address;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LAssetManagerERC20\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  bytes32 public constant LIVELY_ASSET_GROUP = keccak256(abi.encodePacked(\"LIVELY_ASSET_GROUP\"));\n  bytes32 public constant LIVELY_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_SYSTEM_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_SYSTEM_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_ASSET_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_ASSET_MANAGER_ROLE = keccak256(abi.encodePacked(\"LIVELY_ASSET_MANAGER_ROLE\"));\n\n  function createRequestContext(\n    bytes32 domainName,\n    bytes32 domainVersion,\n    bytes32 realm\n  )\n    external\n    view\n    returns (IContextManagement.RequestContext memory, IContextManagement.RequestRegisterContext[] memory)\n  {\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](3);\n\n    rrc[0].role = LIVELY_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](2);\n    rrc[0].funcSelectors[0] = IProxy.setUpgradeStatus.selector;\n    rrc[0].funcSelectors[1] = IProxy.setSafeMode.selector;\n\n    rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](2);\n    rrc[1].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[1].funcSelectors[1] = IProxy.upgradeTo.selector;\n\n    rrc[2].role = LIVELY_ASSET_ADMIN_ROLE;\n    rrc[2].isEnabled = true;\n    rrc[2].funcSelectors = new bytes4[](17);\n    rrc[2].funcSelectors[0] = IAssetManagerERC20.tokenLock.selector;\n    rrc[2].funcSelectors[1] = IAssetManagerERC20.tokenBatchLock.selector;\n    rrc[2].funcSelectors[2] = IAssetManagerERC20.tokenTransfer.selector;\n    rrc[2].funcSelectors[3] = IAssetManagerERC20.tokenBatchTransfer.selector;\n    rrc[2].funcSelectors[4] = IAssetManagerERC20.tokenTransferFrom.selector;\n    rrc[2].funcSelectors[5] = IAssetManagerERC20.tokenBatchTransferFrom.selector;\n    rrc[2].funcSelectors[6] = IAssetManagerERC20.tokenApprove.selector;\n    rrc[2].funcSelectors[7] = IAssetManagerERC20.tokenIncreaseAllowance.selector;\n    rrc[2].funcSelectors[8] = IAssetManagerERC20.tokenDecreaseAllowance.selector;\n    rrc[2].funcSelectors[9] =  IAssetManagerERC20.createAsset.selector;\n    rrc[2].funcSelectors[10] = IAssetManagerERC20.updateAssetSubject.selector;\n    rrc[2].funcSelectors[11] = IAssetManagerERC20.registerToken.selector;\n    rrc[2].funcSelectors[12] = IAssetManagerERC20.registerAsset.selector;\n    rrc[2].funcSelectors[13] = IAssetManagerERC20.removeAsset.selector;\n    rrc[2].funcSelectors[14] = IAssetManagerERC20.setSafeModeToken.selector;\n    rrc[2].funcSelectors[15] = bytes4(keccak256(\"livelyTokensDistribution(address)\"));\n    rrc[2].funcSelectors[16] = bytes4(keccak256(\"withdrawBalance(address)\"));\n      \n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: domainName,\n      version: domainVersion,\n      realm: realm,\n      contractId: address(this),\n      status: true\n    });\n\n    return (rc, rrc);\n  }\n\n  function createAsset(AssetManagerStorageERC20.DataCollection storage data, IAssetManagerERC20.CreateAssetRequest calldata request, address accessControlManager, address assetSubject, bytes calldata assetCreationSignature) external returns (address, address) {\n    require(bytes(request.assetName).length > 0 , \"Invalid Asset Name\");\n    require(bytes(request.assetVersion).length > 0 , \"Invalid Asset Version\");\n    require(request.tokenId != address(0) , \"Invalid TokenId Address\");\n    require(assetSubject != address(0), \"Invalid Asset Subject ERC20\");\n    require(data.tokensSet.contains(request.tokenId), \"TokenId Not Found\");\n\n    bytes32 assetGroup = LIVELY_ASSET_GROUP;\n    require(IGroupManagement(accessControlManager).hasGroupRole(assetGroup, request.role), \"Asset Role Not Found\");\n  \n    AssetManagerStorageERC20.TokenData storage tokenData = data.tokens[request.tokenId];\n    require(!tokenData.assets.contains(assetSubject.predictDeterministicAddress(request.salt)), \"AssetId Already Exists\");\n\n    AssetERC20.InitRequest memory initRequest = AssetERC20.InitRequest ({\n      domainName: request.assetName,\n      domainVersion: request.assetVersion,  \n      domainRealm: IProxy(address(this)).contractRealm(),\n      erc20Token: request.tokenId,\n      accessControl: accessControlManager,\n      assetManager: address(this),\n      assetRole: request.role,\n      salt: request.salt,\n      subject: assetSubject,\n      signature: assetCreationSignature\n    });\n\n    address newAsset = assetSubject.cloneDeterministic(request.salt);\n    AssetERC20(payable(newAsset)).initialize(initRequest);\n    tokenData.assets.add(newAsset);\n    return (newAsset, assetSubject);\n  }\n\n  function registerToken(AssetManagerStorageERC20.DataCollection storage data, address tokenId) external returns (string memory, string memory) {   \n    require(!data.tokensSet.contains(tokenId), \"TokenId Already Registered\");\n\n    try IERC165(tokenId).supportsInterface(type(IERC20).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid ERC20\");\n    } catch {\n      revert(\"Illegal ERC20\");\n    }\n\n    try IERC165(tokenId).supportsInterface(type(IERC20Extra).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid ERC20Extra\");\n    } catch {\n      revert(\"Illegal ERC20Extra\");\n    }\n\n    try IERC165(tokenId).supportsInterface(type(IERC20Lock).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid ERC20Lock\");\n    } catch {\n      revert(\"Illegal ERC20Lock\");\n    }\n\n    string memory tokenName = IERC20(tokenId).name();\n    string memory tokenSymbol = IERC20(tokenId).symbol();\n\n    data.tokensSet.add(tokenId);\n    AssetManagerStorageERC20.TokenData storage tokenData = data.tokens[tokenId];\n    tokenData.status = IAssetEntity.Status.ACTIVE;\n    return (tokenName, tokenSymbol);\n  }\n\n  function registerAsset(AssetManagerStorageERC20.DataCollection storage data, address assetId) external returns (bool, address) {\n    require(assetId != address(0), \"Invalid AssetId Address\");\n    \n    try IERC165(assetId).supportsInterface(type(IAssetERC20).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetERC20\");\n    } catch {\n      revert(\"Illegal IAssetERC20\");\n    }\n\n    try IERC165(assetId).supportsInterface(type(IAssetEntity).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetEntity\");\n    } catch {\n      revert(\"Illegal IAssetEntity\");\n    }\n\n\n    address tokenId = IAssetEntity(assetId).assetToken();\n    require(data.tokensSet.contains(tokenId), \"TokenId Not Found\");\n    \n    AssetManagerStorageERC20.TokenData storage tokenData = data.tokens[tokenId];\n    require(!tokenData.assets.contains(assetId), \"AssetId Already Registered\");\n    \n    tokenData.assets.add(assetId);\n    if(IAssetEntity(assetId).assetSafeMode()) {\n      IAssetEntity(assetId).assetSafeModeSet(false);\n    }\n    return (true, tokenId);\n  }\n\n  function removeAsset(AssetManagerStorageERC20.DataCollection storage data, address assetId) external returns (address) {\n    require(assetId != address(0), \"Invalid AssetId Address\");\n    \n    address tokenId = IAssetEntity(assetId).assetToken();\n    require(data.tokensSet.contains(tokenId), \"TokenId Not Found\");\n    \n    AssetManagerStorageERC20.TokenData storage tokenData = data.tokens[tokenId];\n    require(tokenData.assets.contains(assetId), \"AssetId Not Found\");\n    \n    tokenData.assets.remove(assetId);\n    if(!IAssetEntity(assetId).assetSafeMode()) {\n      IAssetEntity(assetId).assetSafeModeSet(true);\n    }    \n    return tokenId;\n  }\n\n  function setSafeModeToken(AssetManagerStorageERC20.DataCollection storage data, address tokenId, bool isEnabled) external returns (bool) {    \n    require(data.tokensSet.contains(tokenId), \"TokenId Not Found\");\n    AssetManagerStorageERC20.TokenData storage tokenData = data.tokens[tokenId];\n    for(uint i = 0; i < tokenData.assets.length(); i++) {\n      IAssetEntity(tokenData.assets.at(i)).assetSafeModeSet(isEnabled);\n    }\n\n    tokenData.status = IAssetEntity.Status.SAFE_MODE;  \n    return true;\n  }\n\n  function predictAddress(address implementation, bytes32 salt, address deployer) external pure returns (address) {\n    return implementation.predictDeterministicAddress(salt, deployer);\n  }\n}"
    },
    "src/contracts/token/asset/AssetManagerERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IAssetManagerERC20.sol\";\nimport \"./IAssetEntity.sol\";\nimport \"./AssetManagerStorageERC20.sol\";\nimport \"./ERC20/IAssetERC20.sol\";\nimport \"../lively/IERC20.sol\";\nimport \"../lively/LivelyToken.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\nimport \"../../lib/token/LAssetManagerERC20.sol\";\n\ncontract AssetManagerERC20 is AssetManagerStorageERC20, BaseUUPSProxy, IAssetManagerERC20 {\n\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  struct InitRequest {\n    string domainName;\n    string domainVersion;\n    string domainRealm;    \n    address accessControlManager;\n    bytes assetManagerSignature;\n  }\n\n  constructor() {}\n\n  function initialize(InitRequest calldata request) public onlyProxy onlyLocalAdmin initializer {\n\n    bytes32 realm = keccak256(abi.encodePacked(request.domainRealm));\n    __BASE_UUPS_init(request.domainName, request.domainVersion, realm, request.accessControlManager);\n\n    (IContextManagement.RequestContext memory rc, IContextManagement.RequestRegisterContext[] memory rrc) = \n      LAssetManagerERC20.createRequestContext(_domainName, _domainVersion, _domainRealm);\n\n    IContextManagement(_accessControlManager).registerContext(request.assetManagerSignature, rc, rrc);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      request.domainName,\n      request.domainVersion,\n      realm,\n      _getInitializedCount()\n    );\n  }\n\n  function livelyTokensDistribution(address tokenId) public returns (bool) {\n    _policyInterceptor(this.livelyTokensDistribution.selector);\n    require(_data.tokensSet.contains(tokenId), \"TokenId Not Found\");\n    \n    TokenData storage tokenData = _data.tokens[tokenId];\n    require(tokenData.assets.length() == 7, \"Asset Required Failed\");\n\n    address[7] memory assets;\n    for(uint i = 0; i < 7; i++) {\n      assets[i] = tokenData.assets.at(i);\n    }\n    return LivelyToken(payable(tokenId)).tokensDistribution(address(this), assets);\n  }\n\n   /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IAssetManagerERC20).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  function tokenLock(address assetId, IERC20Lock.LockTokenRequest calldata lockRequest) external returns (bytes32) {\n    _validationAndPolicyInterceptor(assetId, this.tokenLock.selector);\n    return IAssetERC20(assetId).tokenLock(lockRequest);\n  }\n\n  function tokenBatchLock(address assetId, IERC20Lock.LockTokenRequest[] calldata lockRequests) external returns (bytes32[] memory) {\n    _validationAndPolicyInterceptor(assetId, this.tokenBatchLock.selector);\n    return IAssetERC20(assetId).tokenBatchLock(lockRequests);\n  }\n\n  function tokenTransfer(address assetId, address to, uint256 amount) external returns (bool) {\n    _validationAndPolicyInterceptor(assetId, this.tokenTransfer.selector);\n    return IAssetERC20(assetId).tokenTransfer(to, amount);\n  }\n\n  function tokenBatchTransfer(address assetId, IERC20Extra.BatchTransferRequest[] calldata request) external returns (bool) {\n    _validationAndPolicyInterceptor(assetId, this.tokenBatchTransfer.selector);\n    return IAssetERC20(assetId).tokenBatchTransfer(request);\n  }\n\n  function tokenTransferFrom(address assetId, address from, address to, uint256 amount) external returns (bool) {\n    _validationAndPolicyInterceptor(assetId, this.tokenTransferFrom.selector);\n    return IAssetERC20(assetId).tokenTransferFrom(from, to, amount);\n  }\n\n  function tokenBatchTransferFrom(address assetId, IERC20Extra.BatchTransferFromRequest[] calldata request) external returns (bool) {\n    _validationAndPolicyInterceptor(assetId, this.tokenBatchTransferFrom.selector);\n    return IAssetERC20(assetId).tokenBatchTransferFrom(request);\n  }\n\n  function tokenApprove(address assetId, address spender, uint256 amount) external returns (bool) {\n    _validationAndPolicyInterceptor(assetId, this.tokenApprove.selector);\n    return IAssetERC20(assetId).tokenApprove(spender, amount);\n  }\n\n  function tokenIncreaseAllowance(address assetId, address spender, uint256 amount) external returns (uint256) {\n    _validationAndPolicyInterceptor(assetId, this.tokenIncreaseAllowance.selector);\n    return IAssetERC20(assetId).tokenIncreaseAllowance(spender, amount);\n  }\n\n  function tokenDecreaseAllowance(address assetId, address spender, uint256 amount) external returns (uint256) {\n    _validationAndPolicyInterceptor(assetId, this.tokenDecreaseAllowance.selector);\n    return IAssetERC20(assetId).tokenDecreaseAllowance(spender, amount);\n  }\n\n  function createAsset(CreateAssetRequest calldata request) external returns (address) {\n    _policyInterceptor(this.createAsset.selector);\n    (address newAsset, address assetSubject) = LAssetManagerERC20.createAsset(_data, request, _accessControlManager, _assetSubjectERC20, _assetCreationSignature);\n    emit AssetCreated(_msgSender(), newAsset, request.tokenId, assetSubject);\n    return newAsset;\n  }\n\n  function registerToken(address tokenId) external returns (bool) {\n    _policyInterceptor(this.registerToken.selector);\n    (string memory tokenName, string memory tokenSymbol) = LAssetManagerERC20.registerToken(_data, tokenId);\n    emit TokenRegistered(_msgSender(), tokenId, tokenName, tokenSymbol);\n    return true;\n  }\n\n  function registerAsset(address assetId) external returns (bool) {\n    _policyInterceptor(this.registerAsset.selector);\n    (bool result, address tokenId) = LAssetManagerERC20.registerAsset(_data, assetId);\n    emit AssetRegistered(_msgSender(), assetId, tokenId);\n    return result;\n  }\n\n  function removeAsset(address assetId) external returns (bool) { \n    _policyInterceptor(this.removeAsset.selector);\n    address tokenId = LAssetManagerERC20.removeAsset(_data, assetId);\n    emit AssetRemoved(_msgSender(), assetId, tokenId);\n    return true;\n  }\n\n  function updateAssetSubject(address assetSubject, bytes calldata assetCreationSignature) external returns (bool) {\n    _policyInterceptor(this.updateAssetSubject.selector);\n    try IERC165(assetSubject).supportsInterface(type(IAssetERC20).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetERC20\");\n    } catch {\n      revert(\"Illegal IAssetERC20\");\n    }\n\n    try IERC165(assetSubject).supportsInterface(type(IAssetEntity).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetEntity\");\n    } catch {\n      revert(\"Illegal IAssetEntity\");\n    }\n\n    require(_assetSubjectERC20 != assetSubject, \"AssetSubject Already Exists\");\n    require(assetCreationSignature.length > 0, \"Invalid Signature\");\n    _assetSubjectERC20 = assetSubject;\n    _assetCreationSignature = assetCreationSignature;\n    emit AssetSubjectUpdated(_msgSender(), assetSubject);\n    return true;\n  }\n\n  function setSafeModeToken(address tokenId, bool isEnabled) external returns (bool) {\n    _policyInterceptor(this.setSafeModeToken.selector);\n    emit TokenSafeModeChanged(_msgSender(), tokenId, isEnabled);\n    return LAssetManagerERC20.setSafeModeToken(_data, tokenId, isEnabled);\n  }\n\n  function getAllTokens() external view returns(address[] memory) {\n    return _data.tokensSet.values();\n  }\n\n  function getTokenInfo(address tokenId) external view returns (IAssetEntity.Status, address[] memory) {\n   TokenData storage tokenData = _data.tokens[tokenId];\n    return (tokenData.status, tokenData.assets.values());\n  }\n\n  function isSafeModeAsset(address assetId) external view returns (bool) {\n    return IAssetEntity(assetId).assetSafeMode();\n  }\n\n  function isAssetExists(address assetId) external view returns (bool) {\n    return _data.tokens[IAssetEntity(assetId).assetToken()].assets.contains(assetId);\n  }\n\n  function isTokenExists(address tokenId) external view returns (bool) {\n    return _data.tokensSet.contains(tokenId);\n  }\n\n  function predictAddress(address implementation, bytes32 salt, address deployer) external pure returns (address) {\n    return LAssetManagerERC20.predictAddress(implementation, salt, deployer);\n  }\n\n  function getAssetSubject() external view returns (address) {\n    return _assetSubjectERC20;\n  }\n\n  function getLibrary() public pure returns(address) {\n    return address(LAssetManagerERC20);\n  }\n\n  function _policyInterceptor(bytes4 funcSelector) private safeModeCheck aclCheck(funcSelector) {}\n\n  function _validationAndPolicyInterceptor(address assetId, bytes4 funcSelector) private {\n    _policyInterceptor(funcSelector);\n    require(assetId != address(0), \"Invalid AssetId\");\n\n    try IERC165(assetId).supportsInterface(type(IAssetEntity).interfaceId) returns (bool isSupported) {\n      require(isSupported, \"Invalid IAssetEntity\");\n    } catch {\n      revert(\"Illegal IAssetEntity\");\n    }\n\n    address tokenId = IAssetEntity(assetId).assetToken();\n    require(_data.tokensSet.contains(tokenId), \"TokenId Not Found\");\n    \n    TokenData storage tokenData = _data.tokens[tokenId];    \n    require(tokenData.assets.contains(assetId), \"AssetId Not Found\");\n  }\n}"
    },
    "src/contracts/lib/token/LSafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../token/lively/IERC20.sol\";\nimport \"../../token/lively/IERC20Extra.sol\";\nimport \"../../token/lively/IERC20Lock.sol\";\nimport \"../LAddress.sol\";\n\n/**\n * @title LSafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary LSafeERC20 {\n    using LAddress for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transfer.selector, to, value));    \n    }\n\n    function batchTransfer(IERC20Extra token, IERC20Extra.BatchTransferRequest[] calldata request) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.batchTransfer.selector, request));\n    }    \n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function batchTransferFrom(IERC20Extra token, IERC20Extra.BatchTransferFromRequest[] calldata request) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.batchTransferFrom.selector, request));\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Extra token,\n        address spender,\n        uint256 value\n    ) internal returns (uint256) {\n        bytes memory returndata = _callMandatoryReturn(address(token), abi.encodeWithSelector(token.increaseAllowance.selector, spender, value));                   \n        return abi.decode(returndata, (uint256));       \n    }\n\n    function safeDecreaseAllowance(\n        IERC20Extra token,\n        address spender,\n        uint256 value\n    ) internal returns (uint256) {        \n        bytes memory returndata = _callMandatoryReturn(address(token), abi.encodeWithSelector(token.decreaseAllowance.selector, spender, value));\n        return abi.decode(returndata, (uint256));\n    }\n\n    function safePermit(\n        IERC20Extra token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        bytes calldata signature\n    ) internal {\n        uint256 nonceBefore = token.nonce(owner);\n        token.permit(owner, spender, value, deadline, signature);\n        uint256 nonceAfter = token.nonce(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20Extra: Permit Failed\");\n    }\n\n    function lockToken(IERC20Lock token, IERC20Lock.LockTokenRequest calldata lockRequest) internal returns (bytes32) {\n        bytes memory returndata = _callMandatoryReturn(address(token), abi.encodeWithSelector(token.lockToken.selector, lockRequest));                   \n        return abi.decode(returndata, (bytes32));\n    }\n\n    function batchLockToken(IERC20Lock token, IERC20Lock.LockTokenRequest[] calldata lockRequest) internal returns (bytes32[] memory) {\n        bytes memory returndata = _callMandatoryReturn(address(token), abi.encodeWithSelector(token.batchLockToken.selector, lockRequest));                   \n        return abi.decode(returndata, (bytes32[]));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(address token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: Call Failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: Operation Failed\");\n        }\n    }\n\n    function _callMandatoryReturn(address token, bytes memory data) private returns (bytes memory){\n        return address(token).functionCall(data, \"SafeERC20: Call Failed\");\n    }\n}\n"
    },
    "src/contracts/utils/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../lib/cryptography/LECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n */\nabstract contract EIP712 {\n  /* solhint-disable var-name-mixedcase */\n  // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n  // invalidate the cached domain separator if the chain id changes.\n  bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n  uint256 private immutable _CACHED_CHAIN_ID;\n  address private immutable _CACHED_THIS;\n\n  bytes32 private immutable _HASHED_NAME;\n  bytes32 private immutable _HASHED_VERSION;\n  bytes32 private immutable _TYPE_HASH;\n\n  /* solhint-enable var-name-mixedcase */\n\n  /**\n   * @dev Initializes the domain separator and parameter caches.\n   *\n   * The meaning of `name` and `version` is specified in\n   * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n   *\n   * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n   * - `version`: the current major version of the signing domain.\n   *\n   * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n   * contract upgrade].\n   */\n  constructor(string memory name, string memory version) {\n    bytes32 hashedName = keccak256(bytes(name));\n    bytes32 hashedVersion = keccak256(bytes(version));\n    bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    _HASHED_NAME = hashedName;\n    _HASHED_VERSION = hashedVersion;\n    _CACHED_CHAIN_ID = block.chainid;\n    _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n    _CACHED_THIS = address(this);\n    _TYPE_HASH = typeHash;\n  }\n\n  /**\n   * @dev Returns the domain separator for the current chain.\n   */\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n      return _CACHED_DOMAIN_SEPARATOR;\n    } else {\n      return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n    }\n  }\n\n  function _buildDomainSeparator(\n    bytes32 typeHash,\n    bytes32 nameHash,\n    bytes32 versionHash\n  ) private view returns (bytes32) {\n    return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n  }\n\n  /**\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n   * function returns the hash of the fully encoded EIP712 message for this domain.\n   *\n   * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n   *\n   * ```solidity\n   * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n   *     keccak256(\"Mail(address to,string contents)\"),\n   *     mailTo,\n   *     keccak256(bytes(mailContents))\n   * )));\n   * address signer = ECDSA.recover(digest, signature);\n   * ```\n   */\n  function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n    return LECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n}\n"
    },
    "src/contracts/lib/cryptography/LSignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./LECDSA.sol\";\nimport \"../LAddress.sol\";\nimport \"../../utils/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n */\nlibrary LSignatureChecker {\n  /**\n   * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n   * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n   *\n   * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n   * change through time. It could return true at block N and false at block N+1 (or the opposite).\n   */\n  function isValidSignatureNow(\n    address signer,\n    bytes32 hash,\n    bytes memory signature\n  ) internal view returns (bool) {\n    (address recovered, LECDSA.RecoverError error) = LECDSA.tryRecover(hash, signature);\n    if (error == LECDSA.RecoverError.NoError && recovered == signer) {\n      return true;\n    }\n\n    (bool success, bytes memory result) = signer.staticcall(\n      abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n    );\n    return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\n  }\n}\n"
    },
    "src/contracts/utils/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n  /**\n   * @dev Should return whether the signature provided is valid for the provided data\n   * @param hash      Hash of the data to be signed\n   * @param signature Signature byte array associated with _data\n   */\n  function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "src/contracts/test/proxy/BaseUUPSProxyTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\nimport \"../../acl/IContextManagement.sol\";\n\ncontract BaseUUPSProxyTest is BaseUUPSProxy {\n  bytes32 public constant LIVELY_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_SYSTEM_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_SYSTEM_ADMIN_ROLE\"));\n\n  event UpgradeToAnonymous(address indexed sender, address indexed newImplementation);\n  event UpgradeToTester(address indexed sender, address indexed newImplementation);\n\n  function initialize(\n    string calldata domainName,\n    string calldata domainVersion,\n    string calldata domainRealm,\n    bytes memory signature,\n    address accessControlManager\n  ) public onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n    __BASE_UUPS_init(domainName, domainVersion, realm, accessControlManager);\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: keccak256(abi.encodePacked(domainName)),\n      version: keccak256(abi.encodePacked(domainVersion)),\n      realm: realm,\n      contractId: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n    rrc[0].role = LIVELY_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](2);\n    rrc[0].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[0].funcSelectors[1] = IProxy.setUpgradeStatus.selector;\n\n    rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](2);\n    rrc[1].funcSelectors[0] = IProxy.setSafeMode.selector;\n    rrc[1].funcSelectors[1] = IProxy.upgradeTo.selector;\n    IContextManagement(accessControlManager).registerContext(signature, rc, rrc);\n  }\n\n  function initializeWithInvalidRealm(\n    string calldata domainName,\n    string calldata domainVersion,\n    string calldata domainRealm,\n    bytes memory signature,\n    address accessControlManager\n  ) public onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n    _domainName = keccak256(abi.encodePacked(domainName));\n    _domainVersion = keccak256(abi.encodePacked(domainVersion));\n    _domainRealm = realm;\n    if (accessControlManager == address(0)) {\n      _accessControlManager = address(this);\n    } else {\n      try IERC165(accessControlManager).supportsInterface(type(IAccessControl).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid AccessControlManager\");\n      } catch {\n        revert(\"Illegal AccessControlManager\");\n      }\n      _accessControlManager = accessControlManager;\n    }\n    _isUpgradable = false;\n    _isSafeMode = false;\n\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: keccak256(abi.encodePacked(domainName)),\n      version: keccak256(abi.encodePacked(domainVersion)),\n      realm: realm,\n      contractId: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n    rrc[0].role = LIVELY_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](2);\n    rrc[0].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[0].funcSelectors[1] = IProxy.setUpgradeStatus.selector;\n\n    rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](2);\n    rrc[1].funcSelectors[0] = IProxy.setSafeMode.selector;\n    rrc[1].funcSelectors[1] = IProxy.upgradeTo.selector;\n    IContextManagement(accessControlManager).registerContext(signature, rc, rrc);\n  }\n\n  function initializeWithInvalidRole(\n    string calldata domainName,\n    string calldata domainVersion,\n    string calldata domainRealm,\n    bytes memory signature,\n    address accessControlManager\n  ) public onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n    __BASE_UUPS_init(domainName, domainVersion, realm, accessControlManager);\n\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: keccak256(abi.encodePacked(domainName)),\n      version: keccak256(abi.encodePacked(domainVersion)),\n      realm: realm,\n      contractId: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](1);\n    rrc[0].role = keccak256(abi.encodePacked(\"LIVELY_WORLD_ADMIN\"));\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](2);\n    rrc[0].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[0].funcSelectors[1] = IProxy.setUpgradeStatus.selector;\n\n    IContextManagement(accessControlManager).registerContext(signature, rc, rrc);\n  }\n\n  function reInitialize(bytes memory signature) public onlyLocalAdmin reinitializer(2) {\n    _domainRealm = keccak256(abi.encodePacked(\"LIVELY_VERSE_REALM\"));\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: _domainName,\n      version: _domainVersion,\n      realm: _domainRealm,\n      contractId: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestUpdateContext[] memory ruc = new IContextManagement.RequestUpdateContext[](5);\n    ruc[0].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[0].updateStatus = IContextManagement.UpdateContextStatus.DISABLE;\n    ruc[0].funcSelectors = new bytes4[](1);\n    ruc[0].funcSelectors[0] = IProxy.upgradeTo.selector;\n\n    ruc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[1].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n    ruc[1].funcSelectors = new bytes4[](1);\n    ruc[1].funcSelectors[0] = this.upgradeToAndCall.selector;\n\n    ruc[2].role = keccak256(abi.encodePacked(\"TESTER_ROLE\"));\n    ruc[2].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n    ruc[2].funcSelectors = new bytes4[](1);\n    ruc[2].funcSelectors[0] = this.upgradeToTesterRole.selector;\n\n    ruc[3].role = keccak256(abi.encodePacked(\"LIVELY_ANONYMOUS_ROLE\"));\n    ruc[3].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n    ruc[3].funcSelectors = new bytes4[](1);\n    ruc[3].funcSelectors[0] = this.upgradeToAnonymousRole.selector;\n\n    ruc[4].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[4].updateStatus = IContextManagement.UpdateContextStatus.REMOVE;\n    ruc[4].funcSelectors = new bytes4[](1);\n    ruc[4].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n\n    IContextManagement(_accessControlManager).updateContext(\n      LContextUtils.generateCtx(address(this)),\n      signature,\n      rc,\n      ruc\n    );\n  }\n\n  function reInitializeWithInvalidRealm(bytes memory signature) public onlyLocalAdmin reinitializer(2) {\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: _domainName,\n      version: _domainVersion,\n      realm: keccak256(abi.encodePacked(\"LIVELY_REALM\")),\n      contractId: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestUpdateContext[] memory ruc = new IContextManagement.RequestUpdateContext[](2);\n    ruc[0].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[0].updateStatus = IContextManagement.UpdateContextStatus.DISABLE;\n    ruc[0].funcSelectors = new bytes4[](1);\n    ruc[0].funcSelectors[0] = IProxy.upgradeTo.selector;\n\n    ruc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[1].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n    ruc[1].funcSelectors = new bytes4[](1);\n    ruc[1].funcSelectors[0] = this.upgradeToAndCall.selector;\n\n    IContextManagement(_accessControlManager).updateContext(\n      LContextUtils.generateCtx(address(this)),\n      signature,\n      rc,\n      ruc\n    );\n  }\n\n  function reInitializeWithInvalidRole(bytes memory signature) public onlyLocalAdmin reinitializer(2) {\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: _domainName,\n      version: _domainVersion,\n      realm: _domainRealm,\n      contractId: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestUpdateContext[] memory rrc = new IContextManagement.RequestUpdateContext[](1);\n    rrc[0].role = keccak256(abi.encodePacked(\"LIVELY_WORLD_ADMIN\"));\n    rrc[0].updateStatus = IContextManagement.UpdateContextStatus.DISABLE;\n    rrc[0].funcSelectors = new bytes4[](1);\n    rrc[0].funcSelectors[0] = IProxy.upgradeTo.selector;\n\n    IContextManagement(_accessControlManager).updateContext(\n      LContextUtils.generateCtx(address(this)),\n      signature,\n      rc,\n      rrc\n    );\n  }\n\n  //    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n  //        return _IMPLEMENTATION_SLOT;\n  //    }\n\n  function upgradeToTesterRole(address newImplementation) external virtual onlyProxy {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_isUpgradable, \"Upgrade Call Rejected\");\n    require(_hasPermission(this.upgradeToTesterRole.selector), \"upgradeToTesterRole Forbidden\");\n    emit UpgradeToTester(msg.sender, newImplementation);\n  }\n\n  function upgradeToAnonymousRole(address newImplementation) external virtual onlyProxy {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_isUpgradable, \"Upgrade Call Rejected\");\n    require(_hasPermission(this.upgradeToAnonymousRole.selector), \"upgradeToAnonymousRole Forbidden\");\n    emit UpgradeToAnonymous(msg.sender, newImplementation);\n  }\n\n  function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n    _authorizeUpgrade(newImplementation);\n    _upgradeToAndCallUUPS(newImplementation, data, true);\n  }\n\n  //    function _authorizeUpgrade(address newImplementation) internal virtual override {}\n}\n"
    },
    "src/contracts/test/proxy/ERC1967ProxyTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../../proxy/BaseProxy.sol\";\nimport \"./ERC1967UpgradeTest.sol\";\n\ncontract ERC1967ProxyTest is BaseProxy, ERC1967UpgradeTest {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    _upgradeToAndCall(_logic, _data, false);\n  }\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _implementation() internal view virtual override returns (address impl) {\n    return ERC1967UpgradeTest._getImplementation();\n  }\n}\n"
    },
    "src/contracts/lib/LArrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./math/LMath.sol\";\nimport \"./math/LSafeCast.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary LArrays {\n  /**\n   * @dev Searches a sorted `array` and returns the first index that contains\n   * a value greater or equal to `element`. If no such index exists (i.e. all\n   * values in the array are strictly less than `element`), the array length is\n   * returned. Time complexity O(log n).\n   *\n   * `array` is expected to be sorted in ascending order, and to contain no\n   * repeated elements.\n   */\n  function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n    if (array.length == 0) {\n      return 0;\n    }\n\n    uint256 low = 0;\n    uint256 high = array.length;\n\n    while (low < high) {\n      uint256 mid = LMath.average(low, high);\n\n      // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n      // because Math.average rounds down (it does integer division with truncation).\n      if (array[mid] > element) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n    if (low > 0 && array[low - 1] == element) {\n      return low - 1;\n    } else {\n      return low;\n    }\n  }\n\n  function findIndex(uint256[] storage array, uint256 element) internal view returns (int256) {\n    for (uint256 i = 0; i < array.length; i++) {\n      if (array[i] == element) {\n        return LSafeCast.toInt256(i);\n      }\n    }\n    return -1;\n  }\n\n  function deleteIndex(uint256[] storage array, uint256 index) internal {\n    require(index < array.length, \"Invalid Index\");\n    array[index] = array[array.length - 1];\n    array.pop();\n  }\n\n  function findIndex(bytes32[] storage array, bytes32 element) internal view returns (int256) {\n    for (uint256 i = 0; i < array.length; i++) {\n      if (array[i] == element) {\n        return LSafeCast.toInt256(i);\n      }\n    }\n    return -1;\n  }\n\n  function deleteIndex(bytes32[] storage array, uint256 index) internal {\n    require(index < array.length, \"Invalid Index\");\n    array[index] = array[array.length - 1];\n    array.pop();\n  }\n}\n"
    },
    "src/contracts/lib/math/LMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary LMath {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n   * zero.\n   */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n   *\n   * This differs from standard division with `/` in that it rounds up instead\n   * of rounding down.\n   */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n   * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n   * with further edits by Uniswap Labs also under MIT license.\n   */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n    unchecked {\n      // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n      // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n      // variables such that product = prod1 * 2^256 + prod0.\n      uint256 prod0; // Least significant 256 bits of the product\n      uint256 prod1; // Most significant 256 bits of the product\n      assembly {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n      }\n\n      // Handle non-overflow cases, 256 by 256 division.\n      if (prod1 == 0) {\n        return prod0 / denominator;\n      }\n\n      // Make sure the result is less than 2^256. Also prevents denominator == 0.\n      require(denominator > prod1);\n\n      ///////////////////////////////////////////////\n      // 512 by 256 division.\n      ///////////////////////////////////////////////\n\n      // Make division exact by subtracting the remainder from [prod1 prod0].\n      uint256 remainder;\n      assembly {\n        // Compute remainder using mulmod.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512 bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n      }\n\n      // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n      // See https://cs.stackexchange.com/q/138556/92363.\n\n      // Does not overflow because the denominator cannot be zero at this stage in the function.\n      uint256 twos = denominator & (~denominator + 1);\n      assembly {\n        // Divide denominator by twos.\n        denominator := div(denominator, twos)\n\n        // Divide [prod1 prod0] by twos.\n        prod0 := div(prod0, twos)\n\n        // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n        twos := add(div(sub(0, twos), twos), 1)\n      }\n\n      // Shift in bits from prod1 into prod0.\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n      // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n      // four bits. That is, denominator * inv = 1 mod 2^4.\n      uint256 inverse = (3 * denominator) ^ 2;\n\n      // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n      // in modular arithmetic, doubling the correct bits in each step.\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n      // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n      // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n      // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inverse;\n      return result;\n    }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n   */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator,\n    Rounding rounding\n  ) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n   *\n   * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n   */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`.\n    // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n    // This gives `2**k < a <= 2**(k+1)`  `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n    // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n    // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1;\n    uint256 x = a;\n    if (x >> 128 > 0) {\n      x >>= 128;\n      result <<= 64;\n    }\n    if (x >> 64 > 0) {\n      x >>= 64;\n      result <<= 32;\n    }\n    if (x >> 32 > 0) {\n      x >>= 32;\n      result <<= 16;\n    }\n    if (x >> 16 > 0) {\n      x >>= 16;\n      result <<= 8;\n    }\n    if (x >> 8 > 0) {\n      x >>= 8;\n      result <<= 4;\n    }\n    if (x >> 4 > 0) {\n      x >>= 4;\n      result <<= 2;\n    }\n    if (x >> 2 > 0) {\n      result <<= 1;\n    }\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n    unchecked {\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      return min(result, a / result);\n    }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n   */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n    uint256 result = sqrt(a);\n    if (rounding == Rounding.Up && result * result < a) {\n      result += 1;\n    }\n    return result;\n  }\n}\n"
    },
    "src/contracts/lib/math/LSafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary LSafeCast {\n  /**\n   * @dev Returns the downcasted uint248 from uint256, reverting on\n   * overflow (when the input is greater than largest uint248).\n   *\n   * Counterpart to Solidity's `uint248` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 248 bits\n   */\n  function toUint248(uint256 value) internal pure returns (uint248) {\n    require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n    return uint248(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint240 from uint256, reverting on\n   * overflow (when the input is greater than largest uint240).\n   *\n   * Counterpart to Solidity's `uint240` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 240 bits\n   */\n  function toUint240(uint256 value) internal pure returns (uint240) {\n    require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n    return uint240(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint232 from uint256, reverting on\n   * overflow (when the input is greater than largest uint232).\n   *\n   * Counterpart to Solidity's `uint232` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 232 bits\n   */\n  function toUint232(uint256 value) internal pure returns (uint232) {\n    require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n    return uint232(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint224 from uint256, reverting on\n   * overflow (when the input is greater than largest uint224).\n   *\n   * Counterpart to Solidity's `uint224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   */\n  function toUint224(uint256 value) internal pure returns (uint224) {\n    require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n    return uint224(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint216 from uint256, reverting on\n   * overflow (when the input is greater than largest uint216).\n   *\n   * Counterpart to Solidity's `uint216` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 216 bits\n   */\n  function toUint216(uint256 value) internal pure returns (uint216) {\n    require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n    return uint216(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint208 from uint256, reverting on\n   * overflow (when the input is greater than largest uint208).\n   *\n   * Counterpart to Solidity's `uint208` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 208 bits\n   */\n  function toUint208(uint256 value) internal pure returns (uint208) {\n    require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n    return uint208(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint200 from uint256, reverting on\n   * overflow (when the input is greater than largest uint200).\n   *\n   * Counterpart to Solidity's `uint200` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 200 bits\n   */\n  function toUint200(uint256 value) internal pure returns (uint200) {\n    require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n    return uint200(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint192 from uint256, reverting on\n   * overflow (when the input is greater than largest uint192).\n   *\n   * Counterpart to Solidity's `uint192` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 192 bits\n   */\n  function toUint192(uint256 value) internal pure returns (uint192) {\n    require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n    return uint192(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint184 from uint256, reverting on\n   * overflow (when the input is greater than largest uint184).\n   *\n   * Counterpart to Solidity's `uint184` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 184 bits\n   */\n  function toUint184(uint256 value) internal pure returns (uint184) {\n    require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n    return uint184(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint176 from uint256, reverting on\n   * overflow (when the input is greater than largest uint176).\n   *\n   * Counterpart to Solidity's `uint176` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 176 bits\n   */\n  function toUint176(uint256 value) internal pure returns (uint176) {\n    require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n    return uint176(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint168 from uint256, reverting on\n   * overflow (when the input is greater than largest uint168).\n   *\n   * Counterpart to Solidity's `uint168` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 168 bits\n   */\n  function toUint168(uint256 value) internal pure returns (uint168) {\n    require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n    return uint168(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint160 from uint256, reverting on\n   * overflow (when the input is greater than largest uint160).\n   *\n   * Counterpart to Solidity's `uint160` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 160 bits\n   */\n  function toUint160(uint256 value) internal pure returns (uint160) {\n    require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n    return uint160(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint152 from uint256, reverting on\n   * overflow (when the input is greater than largest uint152).\n   *\n   * Counterpart to Solidity's `uint152` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 152 bits\n   */\n  function toUint152(uint256 value) internal pure returns (uint152) {\n    require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n    return uint152(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint144 from uint256, reverting on\n   * overflow (when the input is greater than largest uint144).\n   *\n   * Counterpart to Solidity's `uint144` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 144 bits\n   */\n  function toUint144(uint256 value) internal pure returns (uint144) {\n    require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n    return uint144(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint136 from uint256, reverting on\n   * overflow (when the input is greater than largest uint136).\n   *\n   * Counterpart to Solidity's `uint136` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 136 bits\n   */\n  function toUint136(uint256 value) internal pure returns (uint136) {\n    require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n    return uint136(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint128 from uint256, reverting on\n   * overflow (when the input is greater than largest uint128).\n   *\n   * Counterpart to Solidity's `uint128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   */\n  function toUint128(uint256 value) internal pure returns (uint128) {\n    require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n    return uint128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint120 from uint256, reverting on\n   * overflow (when the input is greater than largest uint120).\n   *\n   * Counterpart to Solidity's `uint120` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 120 bits\n   */\n  function toUint120(uint256 value) internal pure returns (uint120) {\n    require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n    return uint120(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint112 from uint256, reverting on\n   * overflow (when the input is greater than largest uint112).\n   *\n   * Counterpart to Solidity's `uint112` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 112 bits\n   */\n  function toUint112(uint256 value) internal pure returns (uint112) {\n    require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n    return uint112(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint104 from uint256, reverting on\n   * overflow (when the input is greater than largest uint104).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 104 bits\n   */\n  function toUint104(uint256 value) internal pure returns (uint104) {\n    require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n    return uint104(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint96 from uint256, reverting on\n   * overflow (when the input is greater than largest uint96).\n   *\n   * Counterpart to Solidity's `uint96` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   */\n  function toUint96(uint256 value) internal pure returns (uint96) {\n    require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n    return uint96(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint88 from uint256, reverting on\n   * overflow (when the input is greater than largest uint88).\n   *\n   * Counterpart to Solidity's `uint88` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 88 bits\n   */\n  function toUint88(uint256 value) internal pure returns (uint88) {\n    require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n    return uint88(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint80 from uint256, reverting on\n   * overflow (when the input is greater than largest uint80).\n   *\n   * Counterpart to Solidity's `uint80` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 80 bits\n   */\n  function toUint80(uint256 value) internal pure returns (uint80) {\n    require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n    return uint80(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint72 from uint256, reverting on\n   * overflow (when the input is greater than largest uint72).\n   *\n   * Counterpart to Solidity's `uint72` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 72 bits\n   */\n  function toUint72(uint256 value) internal pure returns (uint72) {\n    require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n    return uint72(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint64 from uint256, reverting on\n   * overflow (when the input is greater than largest uint64).\n   *\n   * Counterpart to Solidity's `uint64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   */\n  function toUint64(uint256 value) internal pure returns (uint64) {\n    require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n    return uint64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint56 from uint256, reverting on\n   * overflow (when the input is greater than largest uint56).\n   *\n   * Counterpart to Solidity's `uint56` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 56 bits\n   */\n  function toUint56(uint256 value) internal pure returns (uint56) {\n    require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n    return uint56(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint48 from uint256, reverting on\n   * overflow (when the input is greater than largest uint48).\n   *\n   * Counterpart to Solidity's `uint48` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 48 bits\n   */\n  function toUint48(uint256 value) internal pure returns (uint48) {\n    require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n    return uint48(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint40 from uint256, reverting on\n   * overflow (when the input is greater than largest uint40).\n   *\n   * Counterpart to Solidity's `uint40` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 40 bits\n   */\n  function toUint40(uint256 value) internal pure returns (uint40) {\n    require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n    return uint40(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint32 from uint256, reverting on\n   * overflow (when the input is greater than largest uint32).\n   *\n   * Counterpart to Solidity's `uint32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   */\n  function toUint32(uint256 value) internal pure returns (uint32) {\n    require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n    return uint32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint24 from uint256, reverting on\n   * overflow (when the input is greater than largest uint24).\n   *\n   * Counterpart to Solidity's `uint24` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 24 bits\n   */\n  function toUint24(uint256 value) internal pure returns (uint24) {\n    require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n    return uint24(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint16 from uint256, reverting on\n   * overflow (when the input is greater than largest uint16).\n   *\n   * Counterpart to Solidity's `uint16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   */\n  function toUint16(uint256 value) internal pure returns (uint16) {\n    require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n    return uint16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint8 from uint256, reverting on\n   * overflow (when the input is greater than largest uint8).\n   *\n   * Counterpart to Solidity's `uint8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits\n   */\n  function toUint8(uint256 value) internal pure returns (uint8) {\n    require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n    return uint8(value);\n  }\n\n  /**\n   * @dev Converts a signed int256 into an unsigned uint256.\n   *\n   * Requirements:\n   *\n   * - input must be greater than or equal to 0.\n   */\n  function toUint256(int256 value) internal pure returns (uint256) {\n    require(value >= 0, \"SafeCast: value must be positive\");\n    return uint256(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int248 from int256, reverting on\n   * overflow (when the input is less than smallest int248 or\n   * greater than largest int248).\n   *\n   * Counterpart to Solidity's `int248` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 248 bits\n   */\n  function toInt248(int256 value) internal pure returns (int248) {\n    require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n    return int248(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int240 from int256, reverting on\n   * overflow (when the input is less than smallest int240 or\n   * greater than largest int240).\n   *\n   * Counterpart to Solidity's `int240` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 240 bits\n   */\n  function toInt240(int256 value) internal pure returns (int240) {\n    require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n    return int240(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int232 from int256, reverting on\n   * overflow (when the input is less than smallest int232 or\n   * greater than largest int232).\n   *\n   * Counterpart to Solidity's `int232` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 232 bits\n   */\n  function toInt232(int256 value) internal pure returns (int232) {\n    require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n    return int232(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int224 from int256, reverting on\n   * overflow (when the input is less than smallest int224 or\n   * greater than largest int224).\n   *\n   * Counterpart to Solidity's `int224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   */\n  function toInt224(int256 value) internal pure returns (int224) {\n    require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n    return int224(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int216 from int256, reverting on\n   * overflow (when the input is less than smallest int216 or\n   * greater than largest int216).\n   *\n   * Counterpart to Solidity's `int216` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 216 bits\n   */\n  function toInt216(int256 value) internal pure returns (int216) {\n    require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n    return int216(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int208 from int256, reverting on\n   * overflow (when the input is less than smallest int208 or\n   * greater than largest int208).\n   *\n   * Counterpart to Solidity's `int208` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 208 bits\n   */\n  function toInt208(int256 value) internal pure returns (int208) {\n    require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n    return int208(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int200 from int256, reverting on\n   * overflow (when the input is less than smallest int200 or\n   * greater than largest int200).\n   *\n   * Counterpart to Solidity's `int200` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 200 bits\n   */\n  function toInt200(int256 value) internal pure returns (int200) {\n    require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n    return int200(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int192 from int256, reverting on\n   * overflow (when the input is less than smallest int192 or\n   * greater than largest int192).\n   *\n   * Counterpart to Solidity's `int192` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 192 bits\n   */\n  function toInt192(int256 value) internal pure returns (int192) {\n    require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n    return int192(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int184 from int256, reverting on\n   * overflow (when the input is less than smallest int184 or\n   * greater than largest int184).\n   *\n   * Counterpart to Solidity's `int184` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 184 bits\n   */\n  function toInt184(int256 value) internal pure returns (int184) {\n    require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n    return int184(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int176 from int256, reverting on\n   * overflow (when the input is less than smallest int176 or\n   * greater than largest int176).\n   *\n   * Counterpart to Solidity's `int176` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 176 bits\n   */\n  function toInt176(int256 value) internal pure returns (int176) {\n    require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n    return int176(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int168 from int256, reverting on\n   * overflow (when the input is less than smallest int168 or\n   * greater than largest int168).\n   *\n   * Counterpart to Solidity's `int168` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 168 bits\n   */\n  function toInt168(int256 value) internal pure returns (int168) {\n    require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n    return int168(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int160 from int256, reverting on\n   * overflow (when the input is less than smallest int160 or\n   * greater than largest int160).\n   *\n   * Counterpart to Solidity's `int160` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 160 bits\n   */\n  function toInt160(int256 value) internal pure returns (int160) {\n    require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n    return int160(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int152 from int256, reverting on\n   * overflow (when the input is less than smallest int152 or\n   * greater than largest int152).\n   *\n   * Counterpart to Solidity's `int152` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 152 bits\n   */\n  function toInt152(int256 value) internal pure returns (int152) {\n    require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n    return int152(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int144 from int256, reverting on\n   * overflow (when the input is less than smallest int144 or\n   * greater than largest int144).\n   *\n   * Counterpart to Solidity's `int144` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 144 bits\n   */\n  function toInt144(int256 value) internal pure returns (int144) {\n    require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n    return int144(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int136 from int256, reverting on\n   * overflow (when the input is less than smallest int136 or\n   * greater than largest int136).\n   *\n   * Counterpart to Solidity's `int136` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 136 bits\n   */\n  function toInt136(int256 value) internal pure returns (int136) {\n    require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n    return int136(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int128 from int256, reverting on\n   * overflow (when the input is less than smallest int128 or\n   * greater than largest int128).\n   *\n   * Counterpart to Solidity's `int128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   */\n  function toInt128(int256 value) internal pure returns (int128) {\n    require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n    return int128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int120 from int256, reverting on\n   * overflow (when the input is less than smallest int120 or\n   * greater than largest int120).\n   *\n   * Counterpart to Solidity's `int120` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 120 bits\n   */\n  function toInt120(int256 value) internal pure returns (int120) {\n    require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n    return int120(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int112 from int256, reverting on\n   * overflow (when the input is less than smallest int112 or\n   * greater than largest int112).\n   *\n   * Counterpart to Solidity's `int112` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 112 bits\n   */\n  function toInt112(int256 value) internal pure returns (int112) {\n    require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n    return int112(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int104 from int256, reverting on\n   * overflow (when the input is less than smallest int104 or\n   * greater than largest int104).\n   *\n   * Counterpart to Solidity's `int104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 104 bits\n   */\n  function toInt104(int256 value) internal pure returns (int104) {\n    require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n    return int104(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int96 from int256, reverting on\n   * overflow (when the input is less than smallest int96 or\n   * greater than largest int96).\n   *\n   * Counterpart to Solidity's `int96` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   */\n  function toInt96(int256 value) internal pure returns (int96) {\n    require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n    return int96(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int88 from int256, reverting on\n   * overflow (when the input is less than smallest int88 or\n   * greater than largest int88).\n   *\n   * Counterpart to Solidity's `int88` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 88 bits\n   */\n  function toInt88(int256 value) internal pure returns (int88) {\n    require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n    return int88(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int80 from int256, reverting on\n   * overflow (when the input is less than smallest int80 or\n   * greater than largest int80).\n   *\n   * Counterpart to Solidity's `int80` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 80 bits\n   */\n  function toInt80(int256 value) internal pure returns (int80) {\n    require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n    return int80(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int72 from int256, reverting on\n   * overflow (when the input is less than smallest int72 or\n   * greater than largest int72).\n   *\n   * Counterpart to Solidity's `int72` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 72 bits\n   */\n  function toInt72(int256 value) internal pure returns (int72) {\n    require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n    return int72(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int64 from int256, reverting on\n   * overflow (when the input is less than smallest int64 or\n   * greater than largest int64).\n   *\n   * Counterpart to Solidity's `int64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   */\n  function toInt64(int256 value) internal pure returns (int64) {\n    require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n    return int64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int56 from int256, reverting on\n   * overflow (when the input is less than smallest int56 or\n   * greater than largest int56).\n   *\n   * Counterpart to Solidity's `int56` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 56 bits\n   */\n  function toInt56(int256 value) internal pure returns (int56) {\n    require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n    return int56(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int48 from int256, reverting on\n   * overflow (when the input is less than smallest int48 or\n   * greater than largest int48).\n   *\n   * Counterpart to Solidity's `int48` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 48 bits\n   */\n  function toInt48(int256 value) internal pure returns (int48) {\n    require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n    return int48(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int40 from int256, reverting on\n   * overflow (when the input is less than smallest int40 or\n   * greater than largest int40).\n   *\n   * Counterpart to Solidity's `int40` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 40 bits\n   */\n  function toInt40(int256 value) internal pure returns (int40) {\n    require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n    return int40(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int32 from int256, reverting on\n   * overflow (when the input is less than smallest int32 or\n   * greater than largest int32).\n   *\n   * Counterpart to Solidity's `int32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   */\n  function toInt32(int256 value) internal pure returns (int32) {\n    require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n    return int32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int24 from int256, reverting on\n   * overflow (when the input is less than smallest int24 or\n   * greater than largest int24).\n   *\n   * Counterpart to Solidity's `int24` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 24 bits\n   */\n  function toInt24(int256 value) internal pure returns (int24) {\n    require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n    return int24(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int16 from int256, reverting on\n   * overflow (when the input is less than smallest int16 or\n   * greater than largest int16).\n   *\n   * Counterpart to Solidity's `int16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   */\n  function toInt16(int256 value) internal pure returns (int16) {\n    require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n    return int16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int8 from int256, reverting on\n   * overflow (when the input is less than smallest int8 or\n   * greater than largest int8).\n   *\n   * Counterpart to Solidity's `int8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits\n   */\n  function toInt8(int256 value) internal pure returns (int8) {\n    require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n    return int8(value);\n  }\n\n  /**\n   * @dev Converts an unsigned uint256 into a signed int256.\n   *\n   * Requirements:\n   *\n   * - input must be less than or equal to maxInt256.\n   */\n  function toInt256(uint256 value) internal pure returns (int256) {\n    // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n    require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n    return int256(value);\n  }\n}\n"
    },
    "src/contracts/lib/struct/LDoubleEndedQueueUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../math/LSafeCast.sol\";\n\n/**\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\n * the existing queue contents are left in storage.\n *\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\n * used in storage, and not in memory.\n * ```\n * DoubleEndedQueue.Bytes32Deque queue;\n * ```\n */\nlibrary DoubleEndedQueueUpgradeable {\n    /**\n     * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\n     */\n    error Empty();\n\n    /**\n     * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\n     */\n    error OutOfBounds();\n\n    /**\n     * @dev Indices are signed integers because the queue can grow in any direction. They are 128 bits so begin and end\n     * are packed in a single storage slot for efficient access. Since the items are added one at a time we can safely\n     * assume that these 128-bit indices will not overflow, and use unchecked arithmetic.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * Indices are in the range [begin, end) which means the first item is at data[begin] and the last item is at\n     * data[end - 1].\n     */\n    struct Bytes32Deque {\n        int128 _begin;\n        int128 _end;\n        mapping(int128 => bytes32) _data;\n    }\n\n    /**\n     * @dev Inserts an item at the end of the queue.\n     */\n    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 backIndex = deque._end;\n        deque._data[backIndex] = value;\n        unchecked {\n            deque._end = backIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the end of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        value = deque._data[backIndex];\n        delete deque._data[backIndex];\n        deque._end = backIndex;\n    }\n\n    /**\n     * @dev Inserts an item at the beginning of the queue.\n     */\n    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 frontIndex;\n        unchecked {\n            frontIndex = deque._begin - 1;\n        }\n        deque._data[frontIndex] = value;\n        deque._begin = frontIndex;\n    }\n\n    /**\n     * @dev Removes the item at the beginning of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        value = deque._data[frontIndex];\n        delete deque._data[frontIndex];\n        unchecked {\n            deque._begin = frontIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Returns the item at the beginning of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        return deque._data[frontIndex];\n    }\n\n    /**\n     * @dev Returns the item at the end of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        return deque._data[backIndex];\n    }\n\n    /**\n     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\n     * `length(deque) - 1`.\n     *\n     * Reverts with `OutOfBounds` if the index is out of bounds.\n     */\n    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\n        // int256(deque._begin) is a safe upcast\n        int128 idx = LSafeCast.toInt128(int256(deque._begin) + LSafeCast.toInt256(index));\n        if (idx >= deque._end) revert OutOfBounds();\n        return deque._data[idx];\n    }\n\n    /**\n     * @dev Resets the queue back to being empty.\n     *\n     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\n     * out on potential gas refunds.\n     */\n    function clear(Bytes32Deque storage deque) internal {\n        deque._begin = 0;\n        deque._end = 0;\n    }\n\n    /**\n     * @dev Returns the number of items in the queue.\n     */\n    function length(Bytes32Deque storage deque) internal view returns (uint256) {\n        // The interface preserves the invariant that begin <= end so we assume this will not overflow.\n        // We also assume there are at most int256.max items in the queue.\n        unchecked {\n            return uint256(int256(deque._end) - int256(deque._begin));\n        }\n    }\n\n    /**\n     * @dev Returns true if the queue is empty.\n     */\n    function empty(Bytes32Deque storage deque) internal view returns (bool) {\n        return deque._end <= deque._begin;\n    }\n}\n"
    },
    "src/contracts/lib/LCheckpoints.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./math/LMath.sol\";\nimport \"./math/LSafeCast.sol\";\n\n/**\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n */\nlibrary LCheckpoints {\n    struct Checkpoint {\n        uint32 _blockNumber;\n        uint224 _value;\n    }\n\n    struct History {\n        Checkpoint[] _checkpoints;\n    }\n\n    /**\n     * @dev Returns the value in the latest checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(History storage self) internal view returns (uint256) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : self._checkpoints[pos - 1]._value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise.\n     */\n    function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n\n        uint256 high = self._checkpoints.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = LMath.average(low, high);\n            if (self._checkpoints[mid]._blockNumber > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : self._checkpoints[high - 1]._value;\n    }\n\n    /**\n     * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\n     *\n     * Returns previous value and new value.\n     */\n    function push(History storage self, uint256 value) internal returns (uint256, uint256) {\n        uint256 pos = self._checkpoints.length;\n        uint256 old = latest(self);\n        if (pos > 0 && self._checkpoints[pos - 1]._blockNumber == block.number) {\n            self._checkpoints[pos - 1]._value = LSafeCast.toUint224(value);\n        } else {\n            self._checkpoints.push(\n                Checkpoint({_blockNumber: LSafeCast.toUint32(block.number), _value: LSafeCast.toUint224(value)})\n            );\n        }\n        return (old, value);\n    }\n\n    /**\n     * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\n     * be set to `op(latest, delta)`.\n     *\n     * Returns previous value and new value.\n     */\n    function push(\n        History storage self,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) internal returns (uint256, uint256) {\n        return push(self, op(latest(self), delta));\n    }\n}\n"
    },
    "src/contracts/lib/LBase64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n */\nlibrary LBase64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/contracts/lib/LCreate2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary LCreate2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint160(uint256(_data)));\n    }\n}\n"
    },
    "src/contracts/lib/LTimers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Tooling for timepoints, timers and delays\n */\nlibrary LTimers {\n  struct Timestamp {\n    uint64 _deadline;\n  }\n\n  function getDeadline(Timestamp memory timer) internal pure returns (uint64) {\n    return timer._deadline;\n  }\n\n  function setDeadline(Timestamp storage timer, uint64 timestamp) internal {\n    timer._deadline = timestamp;\n  }\n\n  function reset(Timestamp storage timer) internal {\n    timer._deadline = 0;\n  }\n\n  function isUnset(Timestamp memory timer) internal pure returns (bool) {\n    return timer._deadline == 0;\n  }\n\n  function isStarted(Timestamp memory timer) internal pure returns (bool) {\n    return timer._deadline > 0;\n  }\n\n  function isPending(Timestamp memory timer) internal view returns (bool) {\n    return timer._deadline > block.timestamp;\n  }\n\n  function isExpired(Timestamp memory timer) internal view returns (bool) {\n    return isStarted(timer) && timer._deadline <= block.timestamp;\n  }\n\n  struct BlockNumber {\n    uint64 _deadline;\n  }\n\n  function getDeadline(BlockNumber memory timer) internal pure returns (uint64) {\n    return timer._deadline;\n  }\n\n  function setDeadline(BlockNumber storage timer, uint64 timestamp) internal {\n    timer._deadline = timestamp;\n  }\n\n  function reset(BlockNumber storage timer) internal {\n    timer._deadline = 0;\n  }\n\n  function isUnset(BlockNumber memory timer) internal pure returns (bool) {\n    return timer._deadline == 0;\n  }\n\n  function isStarted(BlockNumber memory timer) internal pure returns (bool) {\n    return timer._deadline > 0;\n  }\n\n  function isPending(BlockNumber memory timer) internal view returns (bool) {\n    return timer._deadline > block.number;\n  }\n\n  function isExpired(BlockNumber memory timer) internal view returns (bool) {\n    return isStarted(timer) && timer._deadline <= block.number;\n  }\n}\n"
    },
    "src/contracts/lib/cryptography/LMerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary LMerkleProof {\n  /**\n   * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n   * defined by `root`. For this, a `proof` must be provided, containing\n   * sibling hashes on the branch from the leaf to the root of the tree. Each\n   * pair of leaves and each pair of pre-images are assumed to be sorted.\n   */\n  function verify(\n    bytes32[] memory proof,\n    bytes32 root,\n    bytes32 leaf\n  ) internal pure returns (bool) {\n    return processProof(proof, leaf) == root;\n  }\n\n  /**\n   * @dev Calldata version of {verify}\n   */\n  function verifyCalldata(\n    bytes32[] calldata proof,\n    bytes32 root,\n    bytes32 leaf\n  ) internal pure returns (bool) {\n    return processProofCalldata(proof, leaf) == root;\n  }\n\n  /**\n   * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n   * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n   * hash matches the root of the tree. When processing the proof, the pairs\n   * of leafs & pre-images are assumed to be sorted.\n   */\n  function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n      computedHash = _hashPair(computedHash, proof[i]);\n    }\n    return computedHash;\n  }\n\n  /**\n   * @dev Calldata version of {processProof}\n   */\n  function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n      computedHash = _hashPair(computedHash, proof[i]);\n    }\n    return computedHash;\n  }\n\n  /**\n   * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n   * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n   */\n  function multiProofVerify(\n    bytes32[] memory proof,\n    bool[] memory proofFlags,\n    bytes32 root,\n    bytes32[] memory leaves\n  ) internal pure returns (bool) {\n    return processMultiProof(proof, proofFlags, leaves) == root;\n  }\n\n  /**\n   * @dev Calldata version of {multiProofVerify}\n   */\n  function multiProofVerifyCalldata(\n    bytes32[] calldata proof,\n    bool[] calldata proofFlags,\n    bytes32 root,\n    bytes32[] memory leaves\n  ) internal pure returns (bool) {\n    return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n  }\n\n  /**\n   * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n   * consuming from one or the other at each step according to the instructions given by\n   * `proofFlags`.\n   */\n  function processMultiProof(\n    bytes32[] memory proof,\n    bool[] memory proofFlags,\n    bytes32[] memory leaves\n  ) internal pure returns (bytes32 merkleRoot) {\n    // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n    // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n    // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n    // the merkle tree.\n    uint256 leavesLen = leaves.length;\n    uint256 totalHashes = proofFlags.length;\n\n    // Check proof validity.\n    require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n    // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n    // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n    bytes32[] memory hashes = new bytes32[](totalHashes);\n    uint256 leafPos = 0;\n    uint256 hashPos = 0;\n    uint256 proofPos = 0;\n    // At each step, we compute the next hash using two values:\n    // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n    //   get the next hash.\n    // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n    //   `proof` array.\n    for (uint256 i = 0; i < totalHashes; i++) {\n      bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n      bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n      hashes[i] = _hashPair(a, b);\n    }\n\n    if (totalHashes > 0) {\n      return hashes[totalHashes - 1];\n    } else if (leavesLen > 0) {\n      return leaves[0];\n    } else {\n      return proof[0];\n    }\n  }\n\n  /**\n   * @dev Calldata version of {processMultiProof}\n   */\n  function processMultiProofCalldata(\n    bytes32[] calldata proof,\n    bool[] calldata proofFlags,\n    bytes32[] memory leaves\n  ) internal pure returns (bytes32 merkleRoot) {\n    // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n    // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n    // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n    // the merkle tree.\n    uint256 leavesLen = leaves.length;\n    uint256 totalHashes = proofFlags.length;\n\n    // Check proof validity.\n    require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n    // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n    // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n    bytes32[] memory hashes = new bytes32[](totalHashes);\n    uint256 leafPos = 0;\n    uint256 hashPos = 0;\n    uint256 proofPos = 0;\n    // At each step, we compute the next hash using two values:\n    // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n    //   get the next hash.\n    // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n    //   `proof` array.\n    for (uint256 i = 0; i < totalHashes; i++) {\n      bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n      bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n      hashes[i] = _hashPair(a, b);\n    }\n\n    if (totalHashes > 0) {\n      return hashes[totalHashes - 1];\n    } else if (leavesLen > 0) {\n      return leaves[0];\n    } else {\n      return proof[0];\n    }\n  }\n\n  function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n    return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n  }\n\n  function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x00, a)\n      mstore(0x20, b)\n      value := keccak256(0x00, 0x40)\n    }\n  }\n}\n"
    },
    "src/contracts/lib/math/LSignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary LSignedMath {\n  /**\n   * @dev Returns the largest of two signed numbers.\n   */\n  function max(int256 a, int256 b) internal pure returns (int256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two signed numbers.\n   */\n  function min(int256 a, int256 b) internal pure returns (int256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two signed numbers without overflow.\n   * The result is rounded towards zero.\n   */\n  function average(int256 a, int256 b) internal pure returns (int256) {\n    // Formula from the book \"Hacker's Delight\"\n    int256 x = (a & b) + ((a ^ b) >> 1);\n    return x + (int256(uint256(x) >> 255) & (a ^ b));\n  }\n\n  /**\n   * @dev Returns the absolute unsigned value of a signed value.\n   */\n  function abs(int256 n) internal pure returns (uint256) {\n    unchecked {\n      // must be unchecked in order to support `n = type(int256).min`\n      return uint256(n >= 0 ? n : -n);\n    }\n  }\n}\n"
    },
    "src/contracts/lib/math/LSignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary LSignedSafeMath {\n  /**\n   * @dev Returns the multiplication of two signed integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   *\n   * - Multiplication cannot overflow.\n   */\n  function mul(int256 a, int256 b) internal pure returns (int256) {\n    return a * b;\n  }\n\n  /**\n   * @dev Returns the integer division of two signed integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator.\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(int256 a, int256 b) internal pure returns (int256) {\n    return a / b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two signed integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(int256 a, int256 b) internal pure returns (int256) {\n    return a - b;\n  }\n\n  /**\n   * @dev Returns the addition of two signed integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   *\n   * - Addition cannot overflow.\n   */\n  function add(int256 a, int256 b) internal pure returns (int256) {\n    return a + b;\n  }\n}\n"
    },
    "src/contracts/lib/struct/LBitMapsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\n */\nlibrary LBitMaps {\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(\n        BitMap storage bitmap,\n        uint256 index,\n        bool value\n    ) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}\n"
    },
    "src/contracts/test/proxy/Relay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev This contract provides a fallback function that relay all calls to another contract using the EVM\n * instruction `call`. We refer to the second contract as the _destContract behind the forwarder\n *\n * Additionally, forward to the _destContract can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_forward} function.\n *\n * The success and return data of the call will be returned back to the caller of the relay.\n */\ncontract Relay {\n    address private _destContract;\n\n    constructor(address destContract) {\n        _destContract = destContract;\n    }\n\n    /**\n     * @dev Forwards the current call to `_destContract`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _forward(uint256 value) internal {\n        assembly {\n            // loading state variable to stack\n            let addr := sload(_destContract.slot)\n\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := call(gas(), addr, value, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Forward the current call to the address returned by `_destContract`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _forward(msg.value);\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_destContract`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    // solhint-disable-next-line\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_destContract`. Will run if call data\n     * is empty.\n     */\n    // solhint-disable-next-line\n    receive() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "src/contracts/token/lively/IShortTermDeposite.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @dev Extension of {ERC20} that allows caller to freeze to token accounts\n * in a way that can be recognized off-chain (via event analysis).\n */\ninterface IShortTermDeposite {\n  event STDDeposited(\n    address indexed sender,\n    uint256 amount,\n    uint256 balance,\n    uint256 interest,\n    uint128 timestamp,\n    uint64 aprId\n  );\n\n  event STDWithdrawn(\n    address indexed sender,\n    uint256 amount,\n    uint256 balance,\n    uint256 interest,\n    uint128 timestamp,\n    uint64 aprId\n  );\n\n  event STDClaimed(address indexed sender, uint256 balance, uint256 interest, uint128 timestamp, uint64 aprId);\n\n  function depositeStd(uint256 amount) external returns (uint256);\n\n  function withdrawStd(uint256 amount) external returns (uint256);\n\n  function claimStd() external returns (uint256);\n\n  function getStdInfo(address account)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint128,\n      uint128\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
