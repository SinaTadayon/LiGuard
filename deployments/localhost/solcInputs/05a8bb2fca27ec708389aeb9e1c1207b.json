{
  "language": "Solidity",
  "sources": {
    "src/contracts/acl/AccessControlManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"./IAccessControl.sol\";\nimport \"./AccessControlStorage.sol\";\nimport \"./IGroupManagement.sol\";\nimport \"./IRealmManagement.sol\";\nimport \"./IRoleManagement.sol\";\nimport \"./IContextManagement.sol\";\nimport \"../lib/struct/LEnumerableSet.sol\";\nimport \"../lib/struct/LEnumerableMap.sol\";\nimport \"../lib/acl/LContextManagement.sol\";\nimport \"../lib/acl/LRoleManagement.sol\";\nimport \"../lib/acl/LGroupManagement.sol\";\nimport \"../lib/acl/LRealmManagement.sol\";\nimport \"../lib/acl/LAccessControl.sol\";\nimport \"../proxy/Initializable.sol\";\nimport \"../proxy/BaseUUPSProxy.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract AccessControlManager is\n  AccessControlStorage,\n  BaseUUPSProxy,\n  IContextManagement,\n  IAccessControl,\n  IGroupManagement,\n  IRealmManagement,\n  IRoleManagement\n{\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableMap for LEnumerableMap.Bytes32ToBytes32Map;\n  using LEnumerableMap for LEnumerableMap.AddressToUintMap;\n\n  constructor() {}\n\n  function initialize(\n    string calldata domainName,\n    string calldata domainVersion,\n    string calldata domainRealm,\n    address accessControlManager\n  ) public onlyProxy onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n\n    LAccessControl.initializeContext(_dataMaps);\n\n    __BASE_UUPS_init(domainName, domainVersion, realm, accessControlManager);\n\n    RequestRegisterContext[] memory rc = LAccessControl.createRequestContext();\n    LContextManagement.registerAccessControlManagerContext(_dataMaps, address(this), realm, rc);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      domainName,\n      domainVersion,\n      realm,\n      _getInitializedCount()\n    );\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n    return\n      interfaceId == type(IAccessControl).interfaceId ||\n      interfaceId == type(IContextManagement).interfaceId ||\n      interfaceId == type(IRoleManagement).interfaceId ||\n      interfaceId == type(IGroupManagement).interfaceId ||\n      interfaceId == type(IRealmManagement).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function hasAccess(\n    bytes32 context,\n    address account,\n    bytes4 signature\n  ) external view returns (bool) {\n    return LAccessControl.hasAccess(_dataMaps, context, account, signature);\n  }\n\n  function isLivelySystemAdmin(address account) external view returns (bool) {\n    return LAccessControl.isLivelySystemAdmin(_dataMaps, account);\n  }\n\n  function isLivelyAdmin(address account) external view returns (bool) {\n    return LAccessControl.isLivelyAdmin(_dataMaps, account);\n  }\n\n  function isLivelyGeneralGroup(bytes32 role) external view returns (bool) {\n    return LAccessControl.isLivelyGeneralGroup(_dataMaps, role);\n  }\n\n  function isLivelyGeneralRealm(bytes32 context) external view returns (bool) {\n    return LAccessControl.isLivelyGeneralRealm(_dataMaps, context);\n  }\n\n  function isContextSafeMode(bytes32 context) external view returns (bool) {\n    return LAccessControl.isContextSafeMode(_dataMaps, context);\n  }\n\n  function isContextUpgradable(bytes32 context) external view returns (bool) {\n    return LAccessControl.isContextUpgradable(_dataMaps, context);\n  }\n\n  function isRealmUpgradable(bytes32 realm) external view returns (bool) {\n    return LAccessControl.isRealmUpgradable(_dataMaps, realm);\n  }\n\n  function isGroupExists(bytes32 group) external view returns (bool) {\n    return LAccessControl.isGroupExists(_dataMaps, group);\n  }\n\n  function isGroupEnabled(bytes32 group) external view returns (bool) {\n    return LAccessControl.isGroupEnabled(_dataMaps, group);\n  }\n\n  function isContextExists(bytes32 context) external view returns (bool) {\n    return LAccessControl.isContextExists(_dataMaps, context);\n  }\n\n  function isContextFunctionExists(bytes32 context, bytes4 functionSelector) external view returns (bool) {\n    return LAccessControl.isContextFunctionExists(_dataMaps, context, functionSelector);\n  }\n\n  function isContextFunctionEnabled(bytes32 context, bytes4 functionSelector) external view returns (bool) {\n    return LAccessControl.isContextFunctionEnabled(_dataMaps, context, functionSelector);\n  }\n\n  function isContextEnabled(bytes32 context) external view returns (bool) {\n    return LAccessControl.isContextEnabled(_dataMaps, context);\n  }\n\n  function isRoleExists(bytes32 role) external view returns (bool) {\n    return LAccessControl.isRoleExists(_dataMaps, role);\n  }\n\n  function isRoleEnabled(bytes32 role) external view returns (bool) {\n    return LAccessControl.isRoleEnabled(_dataMaps, role);\n  }\n\n  function isRealmExists(bytes32 realm) external view returns (bool) {\n    return LAccessControl.isRealmExists(_dataMaps, realm);\n  }\n\n  function isRealmEnabled(bytes32 realm) external view returns (bool) {\n    return LAccessControl.isRealmEnabled(_dataMaps, realm);\n  }\n\n  function registerContext(\n    bytes memory signature,\n    RequestContext calldata rc,\n    RequestRegisterContext[] calldata rcr\n  ) external returns (bytes32) {\n    (bytes32 context, address sender) = LContextManagement.registerContext(_dataMaps, signature, rc, rcr);\n    emit ContextRegistered(context, rc.smca, sender, rc.realm);\n    return context;\n  }\n\n  function updateContext(\n    bytes32 ctx,\n    bytes memory signature,\n    RequestContext calldata rc,\n    RequestUpdateContext[] calldata rcr\n  ) external returns (address) {\n    (address smca, address sender) = LContextManagement.updateContext(_dataMaps, ctx, signature, rc, rcr);\n    emit ContextUpdated(ctx, smca, sender, rc.realm);\n    return smca;\n  }\n\n  function addContextFuncRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool) {\n    bytes32 realm = LContextManagement.addContextFuncRole(_dataMaps, ctx, functionSelector, role);\n    emit ContextFuncRoleAdded(ctx, role, msg.sender, functionSelector, realm);\n    return true;\n  }\n\n  function removeContextFunc(bytes32 ctx, bytes4 functionSelector) external returns (bool) {\n    bytes32 realm = LContextManagement.removeContextFunc(_dataMaps, ctx, functionSelector);\n    emit ContextFuncRemoved(ctx, msg.sender, functionSelector, realm);\n    return true;\n  }\n\n  function grantContextRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool) {\n    bytes32 realm = LContextManagement.grantContextRole(_dataMaps, ctx, functionSelector, role);\n    emit ContextRoleGranted(ctx, role, msg.sender, functionSelector, realm);\n    return true;\n  }\n\n  function revokeContextRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool) {\n    bytes32 realm = LContextManagement.revokeContextRole(_dataMaps, ctx, functionSelector, role);\n    emit ContextRoleRevoked(ctx, role, msg.sender, functionSelector, realm);\n    return true;\n  }\n\n  function setContextStatus(bytes32 ctx, bool status) external returns (bool) {\n    (bool success, bytes32 realm) = LContextManagement.setContextStatus(_dataMaps, ctx, status);\n    emit ContextStatusChanged(ctx, _msgSender(), realm, status);\n    return success;\n  }\n\n  function setContextRealm(bytes32 ctx, bytes32 realm) external returns (bool) {\n    (bool success, bytes32 oldRealm) = LContextManagement.setContextRealm(_dataMaps, ctx, realm);\n    emit ContextRealmChanged(ctx, _msgSender(), realm, oldRealm);\n    return success;\n  }\n\n  function hasContextRole(\n    bytes32 ctx,\n    bytes32 role,\n    bytes4 functionSelector\n  ) external view returns (bool) {\n    return LContextManagement.hasContextRole(_dataMaps, ctx, role, functionSelector);\n  }\n\n  function getContextInfo(bytes32 ctx) external view returns (ResponseContext memory) {\n    return LContextManagement.getContextInfo(_dataMaps, ctx);\n  }\n\n  function getContextFuncs(bytes32 ctx) external view returns (bytes4[] memory) {\n    return LContextManagement.getContextFuncs(_dataMaps, ctx);\n  }\n\n  function registerGroup(string calldata name, bool status) external returns (bytes32) {\n    bytes32 group = LGroupManagement.registerGroup(_dataMaps, name, status);\n    emit GroupRegistered(group, _msgSender(), name, status);\n    return group;\n  }\n\n  function setGroupStatus(bytes32 group, bool status) external returns (bool) {\n    emit GroupStatusChanged(group, _msgSender(), status);\n    return LGroupManagement.setGroupStatus(_dataMaps, group, status);\n  }\n\n  function hasGroupRole(bytes32 group, bytes32 role) external view returns (bool) {\n    return LGroupManagement.hasGroupRole(_dataMaps, group, role);\n  }\n\n  function getGroupInfo(bytes32 group) external view returns (string memory, bool) {\n    return LGroupManagement.getGroupInfo(_dataMaps, group);\n  }\n\n  function getGroupRoles(bytes32 group) external view returns (bytes32[] memory) {\n    return LGroupManagement.getGroupRoles(_dataMaps, group);\n  }\n\n  function registerRealm(\n    string calldata name,\n    bool status,\n    bool isUpgradable\n  ) external returns (bytes32) {\n    bytes32 realm = LRealmManagement.registerRealm(_dataMaps, name, status, isUpgradable);\n    emit RealmRegistered(realm, _msgSender(), name, status, isUpgradable);\n    return realm;\n  }\n\n  function setRealmStatus(bytes32 realm, bool status) external returns (bool) {\n    emit RealmStatusChanged(realm, _msgSender(), status);\n    return LRealmManagement.setRealmStatus(_dataMaps, realm, status);\n  }\n\n  function setRealmUpgradeStatus(bytes32 realm, bool status) external returns (bool) {\n    emit RealmUpgradeStatusChanged(realm, _msgSender(), status);\n    return LRealmManagement.setRealmUpgradeStatus(_dataMaps, realm, status);\n  }\n\n  function hasRealmContext(bytes32 realm, bytes32 context) external view returns (bool) {\n    return LRealmManagement.hasRealmContext(_dataMaps, realm, context);\n  }\n\n  function getRealmInfo(bytes32 realm)\n    external\n    view\n    returns (\n      string memory,\n      bool,\n      bool\n    )\n  {\n    return LRealmManagement.getRealmInfo(_dataMaps, realm);\n  }\n\n  function getRealmContexts(bytes32 realm) external view returns (bytes32[] memory) {\n    return LRealmManagement.getRealmContexts(_dataMaps, realm);\n  }\n\n  function grantRoleAccount(bytes32 role, address account) external returns (bool) {\n    emit RoleAccountGranted(role, account, _msgSender());\n    return LRoleManagement.grantRoleAccount(_dataMaps, role, account);\n  }\n\n  function revokeRoleAccount(bytes32 role, address account) external returns (bool) {\n    emit RoleAccountRevoked(role, account, _msgSender());\n    return LRoleManagement.revokeRoleAccount(_dataMaps, role, account);\n  }\n\n  function registerRole(\n    string calldata name,\n    bytes32 group,\n    bool status\n  ) external returns (bytes32) {\n    bytes32 role = LRoleManagement.registerRole(_dataMaps, name, group, status);\n    emit RoleRegistered(role, name, _msgSender(), group, status);\n    return role;\n  }\n\n  function setRoleStatus(bytes32 role, bool status) external returns (bool) {\n    (bool success, bytes32 group) = LRoleManagement.setRoleStatus(_dataMaps, role, status);\n    emit RoleStatusChanged(role, _msgSender(), group, status);\n    return success;\n  }\n\n  function setRoleGroup(bytes32 role, bytes32 group) external returns (bool) {\n    (bool success, bytes32 oldGroup) = LRoleManagement.setRoleGroup(_dataMaps, role, group);\n    emit RoleGroupChanged(role, _msgSender(), group, oldGroup);\n    return success;\n  }\n\n  function getRoleInfo(bytes32 role)\n    external\n    view\n    returns (\n      string memory,\n      bytes32,\n      bool\n    )\n  {\n    return LRoleManagement.getRoleInfo(_dataMaps, role);\n  }\n\n  function getRoleAccounts(bytes32 role) external view returns (address[] memory) {\n    return LRoleManagement.getRoleAccounts(_dataMaps, role);\n  }\n\n  function hasRoleAccount(bytes32 role, address account) external view returns (bool) {\n    return LRoleManagement.hasRoleAccount(_dataMaps, role, account);\n  }\n\n  function livelyGeneralRealmRole() external pure returns (bytes32) {\n    return _LIVELY_GENERAL_REALM;\n  }\n\n  function livelyGeneralGroupRole() external pure returns (bytes32) {\n    return _LIVELY_GENERAL_GROUP;\n  }\n\n  function livelySystemAdminRole() external pure returns (bytes32) {\n    return _LIVELY_SYSTEM_ADMIN_ROLE;\n  }\n\n  function livelyAdminRole() external pure returns (bytes32) {\n    return _LIVELY_ADMIN_ROLE;\n  }\n\n  function livelyAnonymousRole() external pure returns (bytes32) {\n    return _LIVELY_ANONYMOUS_ROLE;\n  }\n}\n"
    },
    "src/contracts/acl/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\ninterface IAccessControl {\n  /**\n   * @dev Function called by apps to check ACL\n   * @return boolean indicating whether the ACL allows\n   */\n  function hasAccess(\n    bytes32 context,\n    address account,\n    bytes4 signature\n  ) external view returns (bool);\n\n  function isLivelySystemAdmin(address account) external view returns (bool);\n\n  function isLivelyAdmin(address account) external view returns (bool);\n\n  function isLivelyGeneralGroup(bytes32 role) external view returns (bool);\n\n  function isLivelyGeneralRealm(bytes32 context) external view returns (bool);\n\n  function isContextSafeMode(bytes32 context) external view returns (bool);\n\n  function isContextUpgradable(bytes32 context) external view returns (bool);\n\n  function isContextExists(bytes32 context) external view returns (bool);\n\n  function isContextFunctionExists(bytes32 context, bytes4 functionSelector) external view returns (bool);\n\n  function isContextFunctionEnabled(bytes32 context, bytes4 functionSelector) external view returns (bool);\n\n  function isContextEnabled(bytes32 context) external view returns (bool);\n\n  function isGroupExists(bytes32 group) external view returns (bool);\n\n  function isGroupEnabled(bytes32 group) external view returns (bool);\n\n  function isRoleExists(bytes32 role) external view returns (bool);\n\n  function isRoleEnabled(bytes32 role) external view returns (bool);\n\n  function isRealmExists(bytes32 realm) external view returns (bool);\n\n  function isRealmEnabled(bytes32 realm) external view returns (bool);\n\n  function isRealmUpgradable(bytes32 realm) external view returns (bool);\n\n  function livelyGeneralRealmRole() external pure returns (bytes32);\n\n  function livelyGeneralGroupRole() external pure returns (bytes32);\n\n  function livelySystemAdminRole() external pure returns (bytes32);\n\n  function livelyAdminRole() external pure returns (bytes32);\n\n  function livelyAnonymousRole() external pure returns (bytes32);\n}\n"
    },
    "src/contracts/acl/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../lib/struct/LEnumerableSet.sol\";\nimport \"../lib/struct/LEnumerableMap.sol\";\nimport \"../proxy/BaseUUPSStorage.sol\";\n\nabstract contract AccessControlStorage is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableMap for LEnumerableMap.Bytes32ToBytes32Map;\n  using LEnumerableMap for LEnumerableMap.AddressToUintMap;\n\n  enum Status {\n    NONE,\n    ENABLED,\n    DISABLED\n  }\n\n  struct RoleStat {\n    bytes32 role;\n    Status status;\n  }\n\n  struct Context {\n    bytes32 realm;\n    address smca; // smart contract address\n    bool isEnabled;\n    mapping(bytes4 => RoleStat) resources; // function selector => RoleStat\n    LEnumerableSet.Bytes32Set funcSet;\n  }\n\n  struct Role {\n    string name;\n    bytes32 group;\n    bool isEnabled;\n    LEnumerableSet.AddressSet accountSet;\n  }\n\n  struct Realm {\n    string name;\n    bool isEnabled;\n    bool isUpgradable;\n    LEnumerableSet.Bytes32Set ctxSet;\n  }\n\n  struct Group {\n    string name;\n    bool isEnabled;\n    LEnumerableSet.Bytes32Set roleSet;\n  }\n\n  struct DataMaps {\n    mapping(address => mapping(bytes32 => Status)) accountMap;\n    mapping(bytes32 => Context) ctxMap;\n    mapping(bytes32 => Role) roleMap;\n    mapping(bytes32 => Realm) realmMap;\n    mapping(bytes32 => Group) groupMap;\n  }\n\n  bytes32 internal constant _LIVELY_GENERAL_REALM = keccak256(abi.encodePacked(\"LIVELY_GENERAL_REALM\"));\n  bytes32 internal constant _LIVELY_GENERAL_GROUP = keccak256(abi.encodePacked(\"LIVELY_GENERAL_GROUP\"));\n  bytes32 internal constant _LIVELY_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ADMIN_ROLE\"));\n  bytes32 internal constant _LIVELY_SYSTEM_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_SYSTEM_ADMIN_ROLE\"));\n  bytes32 internal constant _LIVELY_ANONYMOUS_ROLE = keccak256(abi.encodePacked(\"LIVELY_ANONYMOUS_ROLE\"));\n\n  DataMaps internal _dataMaps;\n}\n"
    },
    "src/contracts/acl/IGroupManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\ninterface IGroupManagement {\n  event GroupRegistered(bytes32 indexed group, address indexed sender, string name, bool status);\n\n  event GroupStatusChanged(bytes32 indexed group, address indexed sender, bool status);\n\n  function registerGroup(string calldata name, bool status) external returns (bytes32);\n\n  function setGroupStatus(bytes32 group, bool status) external returns (bool);\n\n  function hasGroupRole(bytes32 group, bytes32 role) external view returns (bool);\n\n  function getGroupInfo(bytes32 group) external view returns (string memory, bool);\n\n  function getGroupRoles(bytes32 group) external view returns (bytes32[] memory);\n}\n"
    },
    "src/contracts/acl/IRealmManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\ninterface IRealmManagement {\n  event RealmRegistered(bytes32 indexed realm, address indexed sender, string name, bool status, bool isUpgradable);\n\n  event RealmStatusChanged(bytes32 indexed realm, address indexed sender, bool status);\n\n  event RealmUpgradeStatusChanged(bytes32 indexed realm, address indexed sender, bool status);\n\n  function registerRealm(\n    string calldata name,\n    bool status,\n    bool isUpgradable\n  ) external returns (bytes32);\n\n  function setRealmStatus(bytes32 realm, bool status) external returns (bool);\n\n  function setRealmUpgradeStatus(bytes32 realm, bool status) external returns (bool);\n\n  function hasRealmContext(bytes32 realm, bytes32 context) external view returns (bool);\n\n  function getRealmInfo(bytes32 realm)\n    external\n    view\n    returns (\n      string memory,\n      bool,\n      bool\n    );\n\n  function getRealmContexts(bytes32 realm) external view returns (bytes32[] memory);\n}\n"
    },
    "src/contracts/acl/IRoleManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\ninterface IRoleManagement {\n  event RoleAccountGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n  event RoleAccountRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n  event RoleRegistered(\n    bytes32 indexed role,\n    string indexed name,\n    address indexed sender,\n    bytes32 group,\n    bool isEnabled\n  );\n\n  event RoleStatusChanged(bytes32 indexed role, address indexed sender, bytes32 indexed group, bool status);\n\n  event RoleGroupChanged(bytes32 indexed role, address indexed sender, bytes32 indexed newGroup, bytes32 oldGroup);\n\n  function registerRole(\n    string calldata name,\n    bytes32 group,\n    bool status\n  ) external returns (bytes32);\n\n  function grantRoleAccount(bytes32 role, address account) external returns (bool);\n\n  function revokeRoleAccount(bytes32 role, address account) external returns (bool);\n\n  function setRoleStatus(bytes32 role, bool status) external returns (bool);\n\n  function setRoleGroup(bytes32 role, bytes32 group) external returns (bool);\n\n  function getRoleInfo(bytes32 role)\n    external\n    view\n    returns (\n      string memory,\n      bytes32,\n      bool\n    );\n\n  function getRoleAccounts(bytes32 role) external view returns (address[] memory);\n\n  function hasRoleAccount(bytes32 role, address account) external view returns (bool);\n}\n"
    },
    "src/contracts/acl/IContextManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\ninterface IContextManagement {\n  enum UpdateContextStatus {\n    DISABLE,\n    ENABLE,\n    REMOVE\n  }\n\n  struct RequestContext {\n    bytes32 name;\n    bytes32 version;\n    bytes32 realm;\n    address smca;\n    bool status;\n  }\n\n  struct RequestRegisterContext {\n    bytes32 role;\n    bytes4[] funcSelectors;\n    bool isEnabled;\n  }\n\n  struct RequestUpdateContext {\n    bytes32 role;\n    bytes4[] funcSelectors;\n    UpdateContextStatus updateStatus;\n  }\n\n  struct ResponseContext {\n    bytes32 name;\n    bytes32 version;\n    bytes32 realm;\n    address smca;\n    bool isSafeMode;\n    bool isUpgradable;\n  }\n\n  event ContextRegistered(bytes32 indexed context, address indexed scma, address indexed sender, bytes32 realm);\n\n  event ContextUpdated(bytes32 indexed context, address indexed scma, address indexed sender, bytes32 realm);\n\n  event ContextStatusChanged(bytes32 indexed context, address indexed sender, bytes32 indexed realm, bool status);\n\n  event ContextFuncRoleAdded(\n    bytes32 indexed context,\n    bytes32 indexed role,\n    address indexed sender,\n    bytes4 functionSelector,\n    bytes32 realm\n  );\n\n  event ContextFuncRemoved(bytes32 indexed context, address indexed sender, bytes4 functionSelector, bytes32 realm);\n\n  event ContextRoleGranted(\n    bytes32 indexed context,\n    bytes32 indexed role,\n    address indexed sender,\n    bytes4 functionSelector,\n    bytes32 realm\n  );\n\n  event ContextRoleRevoked(\n    bytes32 indexed context,\n    bytes32 indexed role,\n    address indexed sender,\n    bytes4 functionSelector,\n    bytes32 realm\n  );\n\n  event ContextRealmChanged(bytes32 indexed context, address indexed sender, bytes32 indexed realm, bytes32 oldRealm);\n\n  function registerContext(\n    bytes memory signature,\n    RequestContext calldata rc,\n    RequestRegisterContext[] calldata rcr\n  ) external returns (bytes32);\n\n  function updateContext(\n    bytes32 ctx,\n    bytes memory signature,\n    RequestContext calldata rc,\n    RequestUpdateContext[] calldata ruc\n  ) external returns (address);\n\n  function addContextFuncRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool);\n\n  function removeContextFunc(bytes32 ctx, bytes4 functionSelector) external returns (bool);\n\n  function grantContextRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool);\n\n  function revokeContextRole(\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bool);\n\n  function setContextRealm(bytes32 ctx, bytes32 realm) external returns (bool);\n\n  function setContextStatus(bytes32 ctx, bool status) external returns (bool);\n\n  function hasContextRole(\n    bytes32 ctx,\n    bytes32 role,\n    bytes4 functionSelector\n  ) external view returns (bool);\n\n  function getContextInfo(bytes32 ctx) external view returns (ResponseContext memory);\n\n  function getContextFuncs(bytes32 ctx) external view returns (bytes4[] memory);\n}\n"
    },
    "src/contracts/lib/struct/LEnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary LEnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n    return _values(set._inner);\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(AddressSet storage set) internal view returns (address[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "src/contracts/lib/struct/LEnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"./LEnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) since v4.6.0\n */\nlibrary LEnumerableMap {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Map type with\n  // bytes32 keys and values.\n  // The Map implementation uses private functions, and user-facing\n  // implementations (such as Uint256ToAddressMap) are just wrappers around\n  // the underlying Map.\n  // This means that we can only create new EnumerableMaps for types that fit\n  // in bytes32.\n\n  struct Bytes32ToBytes32Map {\n    // Storage of keys\n    LEnumerableSet.Bytes32Set _keys;\n    mapping(bytes32 => bytes32) _values;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n   * key. O(1).\n   *\n   * Returns true if the key was added to the map, that is if it was not\n   * already present.\n   */\n  function set(\n    Bytes32ToBytes32Map storage map,\n    bytes32 key,\n    bytes32 value\n  ) internal returns (bool) {\n    map._values[key] = value;\n    return map._keys.add(key);\n  }\n\n  /**\n   * @dev Removes a key-value pair from a map. O(1).\n   *\n   * Returns true if the key was removed from the map, that is if it was present.\n   */\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n    delete map._values[key];\n    return map._keys.remove(key);\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n   */\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n    return map._keys.contains(key);\n  }\n\n  /**\n   * @dev Returns the number of key-value pairs in the map. O(1).\n   */\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n    return map._keys.length();\n  }\n\n  /**\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n   *\n   * Note that there are no guarantees on the ordering of entries inside the\n   * array, and it may change when more entries are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n    bytes32 key = map._keys.at(index);\n    return (key, map._values[key]);\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`.  O(1).\n   * Does not revert if `key` is not in the map.\n   */\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n    bytes32 value = map._values[key];\n    if (value == bytes32(0)) {\n      return (contains(map, key), bytes32(0));\n    } else {\n      return (true, value);\n    }\n  }\n\n  /**\n   * @dev Returns the value associated with `key`.  O(1).\n   *\n   * Requirements:\n   *\n   * - `key` must be in the map.\n   */\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n    return value;\n  }\n\n  /**\n   * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {_tryGet}.\n   */\n  function get(\n    Bytes32ToBytes32Map storage map,\n    bytes32 key,\n    string memory errorMessage\n  ) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    require(value != 0 || contains(map, key), errorMessage);\n    return value;\n  }\n\n  // UintToAddressMap\n  struct UintToAddressMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n   * key. O(1).\n   *\n   * Returns true if the key was added to the map, that is if it was not\n   * already present.\n   */\n  function set(\n    UintToAddressMap storage map,\n    uint256 key,\n    address value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the key was removed from the map, that is if it was present.\n   */\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n    return remove(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n   */\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n    return contains(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n   */\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (uint256(key), address(uint160(uint256(value))));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`.  O(1).\n   * Does not revert if `key` is not in the map.\n   *\n   * _Available since v3.4._\n   */\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n    return (success, address(uint160(uint256(value))));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`.  O(1).\n   *\n   * Requirements:\n   *\n   * - `key` must be in the map.\n   */\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {tryGet}.\n   */\n  function get(\n    UintToAddressMap storage map,\n    uint256 key,\n    string memory errorMessage\n  ) internal view returns (address) {\n    return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n  }\n\n  // AddressToUintMap\n  struct AddressToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n   * key. O(1).\n   *\n   * Returns true if the key was added to the map, that is if it was not\n   * already present.\n   */\n  function set(\n    AddressToUintMap storage map,\n    address key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the key was removed from the map, that is if it was present.\n   */\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n    return remove(map._inner, bytes32(uint256(uint160(key))));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n   */\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n    return contains(map._inner, bytes32(uint256(uint160(key))));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n   */\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (address(uint160(uint256(key))), uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`.  O(1).\n   * Does not revert if `key` is not in the map.\n   *\n   * _Available since v3.4._\n   */\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`.  O(1).\n   *\n   * Requirements:\n   *\n   * - `key` must be in the map.\n   */\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {tryGet}.\n   */\n  function get(\n    AddressToUintMap storage map,\n    address key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n  }\n}\n"
    },
    "src/contracts/lib/acl/LContextManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../LContextUtils.sol\";\nimport \"./LAccessControl.sol\";\nimport \"../cryptography/LECDSA.sol\";\n\nimport \"hardhat/console.sol\";\n\nlibrary LContextManagement {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LContextManagement\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  bytes32 public constant TYPE_HASH =\n    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n  bytes32 public constant MESSAGE_TYPEHASH =\n    keccak256(\"Context(address contract,string name,string version,string realm)\");\n\n  function registerAccessControlManagerContext(\n    AccessControlStorage.DataMaps storage data,\n    address newContract,\n    bytes32 realm,\n    IContextManagement.RequestRegisterContext[] calldata rc\n  ) external returns (bytes32) {\n    return _registerContext(data, newContract, realm, true, rc);\n  }\n\n  function registerContext(\n    AccessControlStorage.DataMaps storage data,\n    bytes memory signature,\n    IContextManagement.RequestContext calldata rc,\n    IContextManagement.RequestRegisterContext[] calldata rrc\n  ) external returns (bytes32, address) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n\n    bytes32 structHash = _getMessageHash(rc.smca, rc.name, rc.version, rc.realm);\n    bytes32 msgDigest = _hashTypedDataV4(structHash);\n    (address msgSigner, LECDSA.RecoverError recoverErr) = LECDSA.tryRecover(msgDigest, signature);\n\n    require(recoverErr == LECDSA.RecoverError.NoError, \"Illegal ECDASA Signature\");\n\n    // console.log(\"blockchain id: %d\", block.chainid);\n    // console.log(\"msgDigest id\");\n    // console.logBytes32(msgDigest);\n    // console.log(\"registerContext msgSigner is %s\", msgSigner);\n\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msgSigner,\n        IContextManagement.registerContext.selector\n      ),\n      \"RegisterContext Access Denied\"\n    );\n    return (_registerContext(data, rc.smca, rc.realm, rc.status, rrc), msgSigner);\n  }\n\n  function _getMessageHash(\n    address smca,\n    bytes32 name,\n    bytes32 version,\n    bytes32 realm\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encode(MESSAGE_TYPEHASH, smca, name, version, realm));\n  }\n\n  function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {\n    return LECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          TYPE_HASH,\n          IProxy(address(this)).contractName(),\n          IProxy(address(this)).contractVersion(),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  function _registerContext(\n    AccessControlStorage.DataMaps storage data,\n    address newContract,\n    bytes32 realm,\n    bool status,\n    IContextManagement.RequestRegisterContext[] calldata rrc\n  ) private returns (bytes32) {\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    bytes32 ctx = LContextUtils.generateCtx(newContract);\n    require(data.ctxMap[ctx].smca == address(0), \"Context Already Registered\");\n    data.realmMap[realm].ctxSet.add(ctx);\n    AccessControlStorage.Context storage newContext = data.ctxMap[ctx];\n    newContext.realm = realm;\n    newContext.smca = newContract;\n    newContext.isEnabled = status;\n\n    for (uint256 i = 0; i < rrc.length; i++) {\n      require(bytes(data.roleMap[rrc[i].role].name).length != 0, \"Role Not Found\");\n      for (uint256 j = 0; j < rrc[i].funcSelectors.length; j++) {\n        newContext.resources[rrc[i].funcSelectors[j]].role = rrc[i].role;\n        newContext.resources[rrc[i].funcSelectors[j]].status = rrc[i].isEnabled\n          ? AccessControlStorage.Status.ENABLED\n          : AccessControlStorage.Status.DISABLED;\n        newContext.funcSet.add(rrc[i].funcSelectors[j]);\n      }\n    }\n\n    return ctx;\n  }\n\n  function updateContext(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 ctx,\n    bytes memory signature,\n    IContextManagement.RequestContext calldata rc,\n    IContextManagement.RequestUpdateContext[] calldata ruc\n  ) external returns (address, address) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n\n    bytes32 structHash = _getMessageHash(rc.smca, rc.name, rc.version, rc.realm);\n    bytes32 msgDigest = _hashTypedDataV4(structHash);\n    (address msgSigner, LECDSA.RecoverError recoverErr) = LECDSA.tryRecover(msgDigest, signature);\n    require(recoverErr == LECDSA.RecoverError.NoError, \"Illegal ECDASA Signature\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msgSigner,\n        IContextManagement.updateContext.selector\n      ),\n      \"UpdateContext Access Denied\"\n    );\n    return (_updateContext(data, ctx, rc.realm, rc.status, ruc), msgSigner);\n  }\n\n  function _updateContext(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 ctx,\n    bytes32 realm,\n    bool status,\n    IContextManagement.RequestUpdateContext[] calldata ruc\n  ) internal returns (address) {\n    address smca = data.ctxMap[ctx].smca;\n    require(smca != address(0), \"Context Not Found\");\n    require(smca == msg.sender, \"Update Context Forbidden\");\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    data.ctxMap[ctx].isEnabled = status;\n\n    if (data.ctxMap[ctx].realm != realm) {\n      data.realmMap[data.ctxMap[ctx].realm].ctxSet.remove(ctx);\n      data.realmMap[realm].ctxSet.add(ctx);\n    }\n    data.ctxMap[ctx].realm = realm;\n\n    for (uint256 i = 0; i < ruc.length; i++) {\n      require(bytes(data.roleMap[ruc[i].role].name).length != 0, \"Role Not Found\");\n      for (uint256 j = 0; j < ruc[i].funcSelectors.length; j++) {\n        if (\n          ruc[i].updateStatus == IContextManagement.UpdateContextStatus.ENABLE ||\n          ruc[i].updateStatus == IContextManagement.UpdateContextStatus.DISABLE\n        ) {\n          data.ctxMap[ctx].resources[ruc[i].funcSelectors[j]].role = ruc[i].role;\n          data.ctxMap[ctx].resources[ruc[i].funcSelectors[j]].status = ruc[i].updateStatus ==\n            IContextManagement.UpdateContextStatus.ENABLE\n            ? AccessControlStorage.Status.ENABLED\n            : AccessControlStorage.Status.DISABLED;\n          if (!data.ctxMap[ctx].funcSet.contains(ruc[i].funcSelectors[j])) {\n            data.ctxMap[ctx].funcSet.add(ruc[i].funcSelectors[j]);\n          }\n        } else {\n          delete data.ctxMap[ctx].resources[ruc[i].funcSelectors[j]].role;\n          delete data.ctxMap[ctx].resources[ruc[i].funcSelectors[j]].status;\n          data.ctxMap[ctx].funcSet.remove(ruc[i].funcSelectors[j]);\n        }\n      }\n    }\n    return smca;\n  }\n\n  function addContextFuncRole(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.addContextFuncRole.selector\n      ),\n      \"AddContextFuncRole Access Denied\"\n    );\n    require(data.ctxMap[ctx].smca != address(0), \"Context Not Found\");\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(!data.ctxMap[ctx].funcSet.contains(functionSelector), \"FunctionSelector Already Exists\");\n    data.ctxMap[ctx].resources[functionSelector].role = role;\n    data.ctxMap[ctx].resources[functionSelector].status = AccessControlStorage.Status.ENABLED;\n    data.ctxMap[ctx].funcSet.add(functionSelector);\n    return data.ctxMap[ctx].realm;\n  }\n\n  function removeContextFunc(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 ctx,\n    bytes4 functionSelector\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.removeContextFunc.selector\n      ),\n      \"RemoveContextFunc Access Denied\"\n    );\n\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Remove ACL Context\");\n    require(data.ctxMap[ctx].smca != address(0), \"Context Not Found\");\n    require(data.ctxMap[ctx].funcSet.contains(functionSelector), \"FunctionSelector Not Found\");\n    delete data.ctxMap[ctx].resources[functionSelector].role;\n    delete data.ctxMap[ctx].resources[functionSelector].status;\n    data.ctxMap[ctx].funcSet.remove(functionSelector);\n    return data.ctxMap[ctx].realm;\n  }\n\n  function grantContextRole(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.grantContextRole.selector\n      ),\n      \"GrantContextRole Access Denied\"\n    );\n\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Grant ACL Context\");\n    require(data.ctxMap[ctx].smca != address(0), \"Context Not Found\");\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(data.ctxMap[ctx].funcSet.contains(functionSelector), \"FunctionSelector Not Found\");\n    data.ctxMap[ctx].resources[functionSelector].role = role;\n    data.ctxMap[ctx].resources[functionSelector].status = AccessControlStorage.Status.ENABLED;\n    return data.ctxMap[ctx].realm;\n  }\n\n  function revokeContextRole(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 ctx,\n    bytes4 functionSelector,\n    bytes32 role\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.revokeContextRole.selector\n      ),\n      \"RevokeContextRole Access Denied\"\n    );\n\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Revoke ACL Context\");\n    require(data.ctxMap[ctx].smca != address(0), \"Context Not Found\");\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(data.ctxMap[ctx].funcSet.contains(functionSelector), \"FunctionSelector Not Found\");\n    data.ctxMap[ctx].resources[functionSelector].status = AccessControlStorage.Status.DISABLED;\n    return data.ctxMap[ctx].realm;\n  }\n\n  function setContextStatus(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 ctx,\n    bool status\n  ) external returns (bool, bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.setContextStatus.selector\n      ),\n      \"SetContextStatus Access Denied\"\n    );\n\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Change ACL Context Status\");\n    require(data.ctxMap[ctx].smca != address(0), \"Context Not Found\");\n    data.ctxMap[ctx].isEnabled = status;\n    return (true, data.ctxMap[ctx].realm);\n  }\n\n  function setContextRealm(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 ctx,\n    bytes32 realm\n  ) external returns (bool, bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IContextManagement.setContextRealm.selector\n      ),\n      \"SetContextRealm Access Denied\"\n    );\n    require(LContextUtils.generateCtx(address(this)) != ctx, \"Illegal Change ACL Context Realm\");\n    require(data.ctxMap[ctx].smca != address(0), \"Context Not Found\");\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    require(data.ctxMap[ctx].realm != realm, \"Illegal Realm Duplication\");\n    bytes32 oldRealm = data.ctxMap[ctx].realm;\n    data.realmMap[realm].ctxSet.add(ctx);\n    data.realmMap[data.ctxMap[ctx].realm].ctxSet.remove(ctx);\n    return (true, oldRealm);\n  }\n\n  function hasContextRole(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 ctx,\n    bytes32 role,\n    bytes4 functionSelector\n  ) external view returns (bool) {\n    return\n      data.ctxMap[ctx].smca != address(0) &&\n      data.ctxMap[ctx].resources[functionSelector].role == role &&\n      data.ctxMap[ctx].resources[functionSelector].status == AccessControlStorage.Status.ENABLED;\n  }\n\n  function getContextInfo(AccessControlStorage.DataMaps storage data, bytes32 ctx)\n    external\n    view\n    returns (IContextManagement.ResponseContext memory)\n  {\n    require(data.ctxMap[ctx].smca != address(0), \"Context Not Found\");\n    bytes32 name = IProxy(data.ctxMap[ctx].smca).contractName();\n    bytes32 version = IProxy(data.ctxMap[ctx].smca).contractVersion();\n    bool isSafeMode = IProxy(data.ctxMap[ctx].smca).isSafeMode();\n    bool isUpgradable = IProxy(data.ctxMap[ctx].smca).isUpgradable();\n\n    return\n      IContextManagement.ResponseContext({\n        name: name,\n        version: version,\n        smca: data.ctxMap[ctx].smca,\n        realm: data.ctxMap[ctx].realm,\n        isSafeMode: isSafeMode,\n        isUpgradable: isUpgradable\n      });\n  }\n\n  function getContextFuncs(AccessControlStorage.DataMaps storage data, bytes32 ctx)\n    external\n    view\n    returns (bytes4[] memory)\n  {\n    require(data.ctxMap[ctx].smca != address(0), \"Context Not Found\");\n    bytes4[] memory funcs = new bytes4[](data.ctxMap[ctx].funcSet.length());\n    for (uint32 i = 0; i < data.ctxMap[ctx].funcSet.length(); i++) {\n      funcs[i] = bytes4(data.ctxMap[ctx].funcSet.at(i));\n    }\n    return funcs;\n  }\n}\n"
    },
    "src/contracts/lib/acl/LRoleManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../../acl/IRoleManagement.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../LContextUtils.sol\";\nimport \"./LAccessControl.sol\";\n\nlibrary LRoleManagement {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LRoleManagement\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  function registerRole(\n    AccessControlStorage.DataMaps storage data,\n    string calldata name,\n    bytes32 group,\n    bool isEnabled\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.registerRole.selector\n      ),\n      \"RegisterRole Access Denied\"\n    );\n    require(bytes(data.groupMap[group].name).length != 0, \"Group Not Found\");\n    require(bytes(name).length != 0, \"Role Name Invalid\");\n    bytes32 roleKey = keccak256(abi.encodePacked(name));\n    require(bytes(data.roleMap[roleKey].name).length == 0, \"Role Already Registered\");\n\n    data.groupMap[group].roleSet.add(roleKey);\n    AccessControlStorage.Role storage newRole = data.roleMap[roleKey];\n    newRole.name = name;\n    newRole.group = group;\n    newRole.isEnabled = isEnabled;\n    return roleKey;\n  }\n\n  function grantRoleAccount(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 role,\n    address account\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.grantRoleAccount.selector\n      ),\n      \"GrantRoleAccount Access Denied\"\n    );\n    require(role != LAccessControl.LIVELY_ANONYMOUS_ROLE, \"Illegal Grant Anonymous Role\");\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(account != address(0), \"Address Invalid\");\n    data.accountMap[account][role] = AccessControlStorage.Status.ENABLED;\n    if (!data.roleMap[role].accountSet.contains(account)) {\n      data.roleMap[role].accountSet.add(account);\n    }\n    return true;\n  }\n\n  function revokeRoleAccount(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 role,\n    address account\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.revokeRoleAccount.selector\n      ),\n      \"RevokeRoleAccount Access Denied\"\n    );\n    if (role == LAccessControl.LIVELY_ADMIN_ROLE || role == LAccessControl.LIVELY_SYSTEM_ADMIN_ROLE) {\n      require(data.roleMap[role].accountSet.length() > 1, \"Illegal Revoke Role Account\");\n    }\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(account != address(0), \"Address Invalid\");\n    require(data.roleMap[role].accountSet.contains(account), \"Account Not Found\");\n    require(data.accountMap[account][role] != AccessControlStorage.Status.NONE, \"Account Role Not Found\");\n    data.accountMap[account][role] = AccessControlStorage.Status.DISABLED;\n    data.roleMap[role].accountSet.remove(account);\n    return true;\n  }\n\n  function setRoleStatus(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 role,\n    bool status\n  ) external returns (bool, bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.setRoleStatus.selector\n      ),\n      \"SetRoleStatus Access Denied\"\n    );\n    require(\n      role != LAccessControl.LIVELY_ANONYMOUS_ROLE &&\n        role != LAccessControl.LIVELY_ADMIN_ROLE &&\n        role != LAccessControl.LIVELY_SYSTEM_ADMIN_ROLE,\n      \"Illegal Change Role Status\"\n    );\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    data.roleMap[role].isEnabled = status;\n    return (true, data.roleMap[role].group);\n  }\n\n  function setRoleGroup(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 role,\n    bytes32 group\n  ) external returns (bool, bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRoleManagement.setRoleGroup.selector\n      ),\n      \"SetRoleGroup Access Denied\"\n    );\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    require(bytes(data.groupMap[group].name).length != 0, \"Group Not Found\");\n    require(data.roleMap[role].group != group, \"Illegal Group Duplication\");\n    bytes32 oldGroup = data.roleMap[role].group;\n    data.groupMap[data.roleMap[role].group].roleSet.remove(role);\n    data.groupMap[group].roleSet.add(role);\n    data.roleMap[role].group = group;\n    return (true, oldGroup);\n  }\n\n  function getRoleInfo(AccessControlStorage.DataMaps storage data, bytes32 role)\n    external\n    view\n    returns (\n      string memory,\n      bytes32,\n      bool\n    )\n  {\n    return (data.roleMap[role].name, data.roleMap[role].group, data.roleMap[role].isEnabled);\n  }\n\n  function getRoleAccounts(AccessControlStorage.DataMaps storage data, bytes32 role)\n    external\n    view\n    returns (address[] memory)\n  {\n    require(bytes(data.roleMap[role].name).length != 0, \"Role Not Found\");\n    return data.roleMap[role].accountSet.values();\n  }\n\n  function hasRoleAccount(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 role,\n    address account\n  ) external view returns (bool) {\n    return\n      bytes(data.roleMap[role].name).length != 0 &&\n      account != address(0) &&\n      data.accountMap[account][role] == AccessControlStorage.Status.ENABLED;\n  }\n}\n"
    },
    "src/contracts/lib/acl/LGroupManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../../acl/IGroupManagement.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../LContextUtils.sol\";\nimport \"./LAccessControl.sol\";\n\nlibrary LGroupManagement {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LGroupManagement\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  function registerGroup(\n    AccessControlStorage.DataMaps storage data,\n    string calldata name,\n    bool status\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IGroupManagement.registerGroup.selector\n      ),\n      \"RegisterGroup Access Denied\"\n    );\n    require(bytes(name).length != 0, \"Group Name Invalid\");\n    bytes32 groupKey = keccak256(abi.encodePacked(name));\n    require(bytes(data.groupMap[groupKey].name).length == 0, \"Group Already Registered\");\n\n    AccessControlStorage.Group storage newGroup = data.groupMap[groupKey];\n    newGroup.name = name;\n    newGroup.isEnabled = status;\n    return groupKey;\n  }\n\n  function setGroupStatus(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 group,\n    bool status\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n\n    if (group == LAccessControl.LIVELY_GENERAL_GROUP) {\n      bytes32 context = LContextUtils.generateCtx(address(this));\n      bytes4 signature = IRealmManagement.setRealmStatus.selector;\n      bytes32 role = data.ctxMap[context].resources[signature].role;\n      require(\n        data.ctxMap[context].isEnabled &&\n          data.ctxMap[context].resources[signature].status == AccessControlStorage.Status.ENABLED &&\n          data.realmMap[data.ctxMap[context].realm].isEnabled &&\n          data.accountMap[msg.sender][role] == AccessControlStorage.Status.ENABLED,\n        \"SetGroupStatus Access Denied\"\n      );\n    } else {\n      require(\n        LAccessControl.hasAccess(\n          data,\n          LContextUtils.generateCtx(address(this)),\n          msg.sender,\n          IGroupManagement.setGroupStatus.selector\n        ),\n        \"SetGroupStatus Access Denied\"\n      );\n    }\n    require(bytes(data.groupMap[group].name).length != 0, \"Group Not Found\");\n    data.groupMap[group].isEnabled = status;\n    return true;\n  }\n\n  function hasGroupRole(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 group,\n    bytes32 role\n  ) external view returns (bool) {\n    return bytes(data.groupMap[group].name).length != 0 && data.groupMap[group].roleSet.contains(role);\n  }\n\n  function getGroupInfo(AccessControlStorage.DataMaps storage data, bytes32 group)\n    external\n    view\n    returns (string memory, bool)\n  {\n    return (data.groupMap[group].name, data.groupMap[group].isEnabled);\n  }\n\n  function getGroupRoles(AccessControlStorage.DataMaps storage data, bytes32 group)\n    external\n    view\n    returns (bytes32[] memory)\n  {\n    return data.groupMap[group].roleSet.values();\n  }\n}\n"
    },
    "src/contracts/lib/acl/LRealmManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../../acl/IRealmManagement.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../LContextUtils.sol\";\nimport \"./LAccessControl.sol\";\n\nlibrary LRealmManagement {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LRealmManagement\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  function registerRealm(\n    AccessControlStorage.DataMaps storage data,\n    string calldata name,\n    bool status,\n    bool isUpgradable\n  ) external returns (bytes32) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRealmManagement.registerRealm.selector\n      ),\n      \"RegisterRealm Access Denied\"\n    );\n    require(bytes(name).length != 0, \"Realm Name Invalid\");\n    bytes32 realmKey = keccak256(abi.encodePacked(name));\n    require(bytes(data.realmMap[realmKey].name).length == 0, \"Realm Already Registered\");\n\n    AccessControlStorage.Realm storage newRealm = data.realmMap[realmKey];\n    newRealm.name = name;\n    newRealm.isEnabled = status;\n    newRealm.isUpgradable = isUpgradable;\n    return realmKey;\n  }\n\n  function setRealmStatus(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 realm,\n    bool status\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    if (LAccessControl.LIVELY_GENERAL_REALM == realm) {\n      bytes32 context = LContextUtils.generateCtx(address(this));\n      bytes4 signature = IRealmManagement.setRealmStatus.selector;\n      bytes32 role = data.ctxMap[context].resources[signature].role;\n      require(\n        data.ctxMap[context].isEnabled &&\n          data.ctxMap[context].resources[signature].status == AccessControlStorage.Status.ENABLED &&\n          data.groupMap[data.roleMap[role].group].isEnabled &&\n          data.accountMap[msg.sender][role] == AccessControlStorage.Status.ENABLED,\n        \"SetRealmStatus Access Denied\"\n      );\n    } else {\n      require(\n        LAccessControl.hasAccess(\n          data,\n          LContextUtils.generateCtx(address(this)),\n          msg.sender,\n          IRealmManagement.setRealmStatus.selector\n        ),\n        \"SetRealmStatus Access Denied\"\n      );\n    }\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    data.realmMap[realm].isEnabled = status;\n    return true;\n  }\n\n  function setRealmUpgradeStatus(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 realm,\n    bool status\n  ) external returns (bool) {\n    require(!IProxy(address(this)).isSafeMode(), \"SafeMode: Call Rejected\");\n    require(\n      LAccessControl.hasAccess(\n        data,\n        LContextUtils.generateCtx(address(this)),\n        msg.sender,\n        IRealmManagement.setRealmUpgradeStatus.selector\n      ),\n      \"SetRealmUpgradeStatus Access Denied\"\n    );\n    require(bytes(data.realmMap[realm].name).length != 0, \"Realm Not Found\");\n    data.realmMap[realm].isUpgradable = status;\n    return true;\n  }\n\n  function hasRealmContext(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 realm,\n    bytes32 context\n  ) external view returns (bool) {\n    return bytes(data.realmMap[realm].name).length != 0 && data.realmMap[realm].ctxSet.contains(context);\n  }\n\n  function getRealmInfo(AccessControlStorage.DataMaps storage data, bytes32 realm)\n    external\n    view\n    returns (\n      string memory,\n      bool,\n      bool\n    )\n  {\n    return (data.realmMap[realm].name, data.realmMap[realm].isEnabled, data.realmMap[realm].isUpgradable);\n  }\n\n  function getRealmContexts(AccessControlStorage.DataMaps storage data, bytes32 realm)\n    external\n    view\n    returns (bytes32[] memory)\n  {\n    return data.realmMap[realm].ctxSet.values();\n  }\n}\n"
    },
    "src/contracts/lib/acl/LAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../acl/IRoleManagement.sol\";\nimport \"../../acl/IGroupManagement.sol\";\nimport \"../../acl/IRealmManagement.sol\";\nimport \"../../acl/AccessControlStorage.sol\";\nimport \"../struct/LEnumerableSet.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../LContextUtils.sol\";\n\nimport \"hardhat/console.sol\";\n\nlibrary LAccessControl {\n  using LEnumerableSet for LEnumerableSet.Bytes32Set;\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LAccessControl\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  bytes32 public constant LIVELY_GENERAL_REALM = keccak256(abi.encodePacked(\"LIVELY_GENERAL_REALM\"));\n  bytes32 public constant LIVELY_GENERAL_GROUP = keccak256(abi.encodePacked(\"LIVELY_GENERAL_GROUP\"));\n  bytes32 public constant LIVELY_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_SYSTEM_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_SYSTEM_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_ANONYMOUS_ROLE = keccak256(abi.encodePacked(\"LIVELY_ANONYMOUS_ROLE\"));\n\n  function initializeContext(AccessControlStorage.DataMaps storage data) external {\n    data.accountMap[msg.sender][LIVELY_ADMIN_ROLE] = AccessControlStorage.Status.ENABLED;\n    data.accountMap[msg.sender][LIVELY_SYSTEM_ADMIN_ROLE] = AccessControlStorage.Status.ENABLED;\n\n    data.roleMap[LIVELY_ADMIN_ROLE].name = \"LIVELY_ADMIN_ROLE\";\n    data.roleMap[LIVELY_ADMIN_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_ADMIN_ROLE].group = LIVELY_GENERAL_GROUP;\n    data.roleMap[LIVELY_ADMIN_ROLE].accountSet.add(msg.sender);\n\n    data.roleMap[LIVELY_SYSTEM_ADMIN_ROLE].name = \"LIVELY_SYSTEM_ADMIN_ROLE\";\n    data.roleMap[LIVELY_SYSTEM_ADMIN_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_SYSTEM_ADMIN_ROLE].group = LIVELY_GENERAL_GROUP;\n    data.roleMap[LIVELY_SYSTEM_ADMIN_ROLE].accountSet.add(msg.sender);\n\n    data.roleMap[LIVELY_ANONYMOUS_ROLE].name = \"LIVELY_ANONYMOUS_ROLE\";\n    data.roleMap[LIVELY_ANONYMOUS_ROLE].isEnabled = true;\n    data.roleMap[LIVELY_ANONYMOUS_ROLE].group = LIVELY_GENERAL_GROUP;\n    data.roleMap[LIVELY_ANONYMOUS_ROLE].accountSet.add(msg.sender);\n\n    data.groupMap[LIVELY_GENERAL_GROUP].name = \"LIVELY_GENERAL_GROUP\";\n    data.groupMap[LIVELY_GENERAL_GROUP].isEnabled = true;\n    data.groupMap[LIVELY_GENERAL_GROUP].roleSet.add(LIVELY_ADMIN_ROLE);\n    data.groupMap[LIVELY_GENERAL_GROUP].roleSet.add(LIVELY_SYSTEM_ADMIN_ROLE);\n\n    data.realmMap[LIVELY_GENERAL_REALM].name = \"LIVELY_GENERAL_REALM\";\n    data.realmMap[LIVELY_GENERAL_REALM].isEnabled = true;\n    data.realmMap[LIVELY_GENERAL_REALM].isUpgradable = true;\n    data.realmMap[LIVELY_GENERAL_REALM].ctxSet.add(LContextUtils.generateCtx(address(this)));\n  }\n\n  function createRequestContext() external pure returns (IContextManagement.RequestRegisterContext[] memory) {\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n    rrc[0].role = LIVELY_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](18);\n    rrc[0].funcSelectors[0] = IProxy.setUpgradeStatus.selector;\n    rrc[0].funcSelectors[1] = IContextManagement.addContextFuncRole.selector;\n    rrc[0].funcSelectors[2] = IContextManagement.removeContextFunc.selector;\n    rrc[0].funcSelectors[3] = IContextManagement.grantContextRole.selector;\n    rrc[0].funcSelectors[4] = IContextManagement.revokeContextRole.selector;\n    rrc[0].funcSelectors[5] = IContextManagement.setContextRealm.selector;\n    rrc[0].funcSelectors[6] = IContextManagement.setContextStatus.selector;\n    rrc[0].funcSelectors[7] = IRoleManagement.registerRole.selector;\n    rrc[0].funcSelectors[8] = IRoleManagement.grantRoleAccount.selector;\n    rrc[0].funcSelectors[9] = IRoleManagement.revokeRoleAccount.selector;\n    rrc[0].funcSelectors[10] = IRoleManagement.setRoleStatus.selector;\n    rrc[0].funcSelectors[11] = IRoleManagement.setRoleGroup.selector;\n    rrc[0].funcSelectors[12] = IGroupManagement.registerGroup.selector;\n    rrc[0].funcSelectors[13] = IGroupManagement.setGroupStatus.selector;\n    rrc[0].funcSelectors[14] = IRealmManagement.registerRealm.selector;\n    rrc[0].funcSelectors[15] = IRealmManagement.setRealmStatus.selector;\n    rrc[0].funcSelectors[16] = IRealmManagement.setRealmUpgradeStatus.selector;\n    rrc[0].funcSelectors[17] = bytes4(keccak256(\"withdrawBalance(address)\"));\n\n    rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](5);\n    rrc[1].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[1].funcSelectors[1] = IProxy.setSafeMode.selector;\n    rrc[1].funcSelectors[2] = IProxy.upgradeTo.selector;\n    rrc[1].funcSelectors[3] = IContextManagement.registerContext.selector;\n    rrc[1].funcSelectors[4] = IContextManagement.updateContext.selector;\n\n    return rrc;\n  }\n\n  function hasAccess(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 context,\n    address account,\n    bytes4 signature\n  ) external view returns (bool) {\n    bytes32 role = data.ctxMap[context].resources[signature].role;\n    // console.log(\"hasAccess called, address: %s\", account);\n\n    // console.log(\"data.ctxMap[context].smca: %s\", data.ctxMap[context].smca);\n    // console.log(\"data.ctxMap[context].isEnabled:\");\n    // console.logBool(data.ctxMap[context].isEnabled);\n    // console.log(\"data.ctxMap[context].realm: \");\n    // console.logBytes32(data.ctxMap[context].realm);\n    // console.log(\"data.ctxMap[context].resources[signature].status: \");\n    // console.logBytes1(bytes1(uint8(data.ctxMap[context].resources[signature].status)));\n    // console.log(\"data.ctxMap[context].resources[signature].role: \");\n    // console.logBytes32(data.ctxMap[context].resources[signature].role);\n\n    // console.log(\"data.realmMap[data.ctxMap[context].realm].name: %s\", data.realmMap[data.ctxMap[context].realm].name);\n    // console.log(\"data.realmMap[data.ctxMap[context].realm].isEnabled: \");\n    // console.logBool(data.realmMap[data.ctxMap[context].realm].isEnabled);\n\n    // console.log(\"data.groupMap[data.roleMap[role].group].name: %s\", data.groupMap[data.roleMap[role].group].name);\n    // console.log(\"data.groupMap[data.roleMap[role].group].isEnabled: \");\n    // console.logBool(data.groupMap[data.roleMap[role].group].isEnabled);\n\n    // console.log(\"data.accountMap[account][role]: \");\n    // console.logBytes1(bytes1(uint8(data.accountMap[account][role])));\n\n    if (role == LIVELY_ANONYMOUS_ROLE) {\n      return\n        data.ctxMap[context].isEnabled &&\n        data.ctxMap[context].resources[signature].status == AccessControlStorage.Status.ENABLED;\n    } else {\n      return\n        data.ctxMap[context].isEnabled &&\n        data.ctxMap[context].resources[signature].status == AccessControlStorage.Status.ENABLED &&\n        data.realmMap[data.ctxMap[context].realm].isEnabled &&\n        data.groupMap[data.roleMap[role].group].isEnabled &&\n        data.accountMap[account][role] == AccessControlStorage.Status.ENABLED;\n    }\n  }\n\n  function isLivelySystemAdmin(AccessControlStorage.DataMaps storage data, address account)\n    external\n    view\n    returns (bool)\n  {\n    return data.accountMap[account][LIVELY_SYSTEM_ADMIN_ROLE] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isLivelyAdmin(AccessControlStorage.DataMaps storage data, address account) external view returns (bool) {\n    return data.accountMap[account][LIVELY_ADMIN_ROLE] == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isLivelyGeneralGroup(AccessControlStorage.DataMaps storage data, bytes32 role) external view returns (bool) {\n    return data.groupMap[LIVELY_GENERAL_GROUP].roleSet.contains(role);\n  }\n\n  function isLivelyGeneralRealm(AccessControlStorage.DataMaps storage data, bytes32 context)\n    external\n    view\n    returns (bool)\n  {\n    return data.realmMap[LIVELY_GENERAL_REALM].ctxSet.contains(context);\n  }\n\n  function isContextSafeMode(AccessControlStorage.DataMaps storage data, bytes32 context) external view returns (bool) {\n    return IProxy(data.ctxMap[context].smca).isSafeMode();\n  }\n\n  function isContextUpgradable(AccessControlStorage.DataMaps storage data, bytes32 context)\n    external\n    view\n    returns (bool)\n  {\n    return IProxy(data.ctxMap[context].smca).isUpgradable();\n  }\n\n  function isRealmUpgradable(AccessControlStorage.DataMaps storage data, bytes32 realm) external view returns (bool) {\n    if (bytes(data.realmMap[realm].name).length == 0) return false;\n    return data.realmMap[realm].isUpgradable;\n  }\n\n  function isGroupExists(AccessControlStorage.DataMaps storage data, bytes32 group) external view returns (bool) {\n    return bytes(data.groupMap[group].name).length > 0;\n  }\n\n  function isGroupEnabled(AccessControlStorage.DataMaps storage data, bytes32 group) external view returns (bool) {\n    return bytes(data.groupMap[group].name).length > 0 && data.groupMap[group].isEnabled;\n  }\n\n  function isContextExists(AccessControlStorage.DataMaps storage data, bytes32 context) external view returns (bool) {\n    return data.ctxMap[context].smca != address(0);\n  }\n\n  function isContextFunctionExists(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 context,\n    bytes4 functionSelector\n  ) external view returns (bool) {\n    return data.ctxMap[context].smca != address(0) && data.ctxMap[context].funcSet.contains(functionSelector);\n  }\n\n  function isContextFunctionEnabled(\n    AccessControlStorage.DataMaps storage data,\n    bytes32 context,\n    bytes4 functionSelector\n  ) external view returns (bool) {\n    return\n      data.ctxMap[context].smca != address(0) &&\n      data.ctxMap[context].resources[functionSelector].status == AccessControlStorage.Status.ENABLED;\n  }\n\n  function isContextEnabled(AccessControlStorage.DataMaps storage data, bytes32 context) external view returns (bool) {\n    return data.ctxMap[context].smca != address(0) && data.ctxMap[context].isEnabled;\n  }\n\n  function isRoleExists(AccessControlStorage.DataMaps storage data, bytes32 role) external view returns (bool) {\n    return bytes(data.roleMap[role].name).length > 0;\n  }\n\n  function isRoleEnabled(AccessControlStorage.DataMaps storage data, bytes32 role) external view returns (bool) {\n    return bytes(data.roleMap[role].name).length > 0 && data.roleMap[role].isEnabled;\n  }\n\n  function isRealmExists(AccessControlStorage.DataMaps storage data, bytes32 realm) external view returns (bool) {\n    return bytes(data.realmMap[realm].name).length > 0;\n  }\n\n  function isRealmEnabled(AccessControlStorage.DataMaps storage data, bytes32 realm) external view returns (bool) {\n    return bytes(data.realmMap[realm].name).length > 0 && data.realmMap[realm].isEnabled;\n  }\n}\n"
    },
    "src/contracts/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../lib/LAddress.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n   * @custom:oz-retyped-from bool\n   */\n  uint16 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private _initializing;\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n   * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n   */\n  modifier initializer() {\n    bool isTopLevelCall = !_initializing;\n    require(\n      (isTopLevelCall && _initialized < 1) || (!LAddress.isContract(address(this)) && _initialized == 1),\n      \"Contract Already Initialized\"\n    );\n    _initialized = 1;\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n   * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n   * used to initialize parent contracts.\n   *\n   * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n   * initialization step. This is essential to configure modules that are added through upgrades and that require\n   * initialization.\n   *\n   * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n   * a contract, executing them in the right order is up to the developer or operator.\n   */\n  modifier reinitializer(uint16 version) {\n    require(!_initializing && _initialized < version, \"Contract Already Initialized\");\n    _initialized = version;\n    _initializing = true;\n    _;\n    _initializing = false;\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n   * {initializer} and {reinitializer} modifiers, directly or indirectly.\n   */\n  modifier onlyInitializing() {\n    require(_initializing, \"Contract Not Initializing\");\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n   * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n   * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n   * through proxies.\n   */\n  function _disableInitializers() internal virtual {\n    require(!_initializing, \"Contract Initializing Invalid\");\n    if (_initialized < type(uint16).max) {\n      _initialized = type(uint16).max;\n    }\n  }\n\n  function _getInitializedCount() internal view returns (uint16) {\n    return _initialized;\n  }\n\n  function _isInitializing() internal view returns (bool) {\n    return _initializing;\n  }\n}\n"
    },
    "src/contracts/proxy/BaseUUPSProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"./IERC1822.sol\";\nimport \"./IProxy.sol\";\nimport \"./BaseProxy.sol\";\nimport \"./BaseUUPSStorage.sol\";\nimport \"./Initializable.sol\";\nimport \"../lib/LAddress.sol\";\nimport \"../lib/LStorageSlot.sol\";\nimport \"../acl/IAccessControl.sol\";\nimport \"../acl/IContextManagement.sol\";\nimport \"../utils/Message.sol\";\nimport \"../utils/ERC165.sol\";\nimport \"../lib/LContextUtils.sol\";\n\n// import \"hardhat/console.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n\n * An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\n\nabstract contract BaseUUPSProxy is\n  BaseUUPSStorage,\n  BaseProxy,\n  Initializable,\n  IProxy,\n  IERC1822Proxiable,\n  Message,\n  ERC165\n{\n  /**\n   * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n   * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n   * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n   * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n   * fail.\n   */\n  modifier onlyProxy() {\n    require(address(this) != __self, \"Illegal Contract Call\");\n    require(_implementation() == __self, \"Proxy Called Invalid\");\n    _;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyLocalAdmin() {\n    require(_getLocalAdmin() == _msgSender(), \"Caller Not Authorized\");\n    _;\n  }\n\n  /**\n   * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n   * callable on the implementing contract but not through proxies.\n   */\n  modifier notDelegated() {\n    require(address(this) == __self, \"Illegal Contract Delegatecall\");\n    _;\n  }\n\n  modifier safeModeCheck() {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    _;\n  }\n\n  modifier aclCheck(bytes4 selector) {\n    require(_hasPermission(selector), \"Access Denied\");\n    _;\n  }\n\n  function _hasPermission(bytes4 selector) internal returns (bool) {\n    if (address(this) == _accessControlManager) {\n      bytes memory data = abi.encodeWithSelector(\n        IAccessControl.hasAccess.selector,\n        LContextUtils.generateCtx(address(this)),\n        _msgSender(),\n        selector\n      );\n      bytes memory returndata = LAddress.functionDelegateCall(_implementation(), data, \"Delegatecall hasAccess Failed\");\n      return uint8(returndata[returndata.length - 1]) == 1;\n    } else {\n      return\n        IAccessControl(_accessControlManager).hasAccess(\n          LContextUtils.generateCtx(address(this)),\n          _msgSender(),\n          selector\n        );\n    }\n  }\n\n  function _isRealmUpgradable() internal returns (bool) {\n    if (address(this) == _accessControlManager) {\n      bytes memory data = abi.encodeWithSelector(IAccessControl.isRealmUpgradable.selector, _domainRealm);\n      bytes memory returndata = LAddress.functionDelegateCall(\n        _implementation(),\n        data,\n        \"Delegatecall isRealmUpgradable Failed\"\n      );\n      return uint8(returndata[returndata.length - 1]) == 1;\n    } else {\n      return IAccessControl(_accessControlManager).isRealmUpgradable(_domainRealm);\n    }\n  }\n\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n   */\n\n  constructor() {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n    // set contract Admin (implementation contract)\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = _msgSender();\n\n    // set _isUpgradable and _isSafeMode of contact\n    _isUpgradable = false;\n    _isSafeMode = true;\n  }\n\n  function __BASE_UUPS_init(\n    string calldata domainName,\n    string calldata domainVersion,\n    bytes32 domainRealm,\n    address accessControl\n  ) internal {\n    __BASE_UUPS_init_unchained(domainName, domainVersion, domainRealm, accessControl);\n  }\n\n  function __BASE_UUPS_init_unchained(\n    string calldata domainName,\n    string calldata domainVersion,\n    bytes32 domainRealm,\n    address accessControl\n  ) internal onlyInitializing {\n    _domainName = keccak256(abi.encodePacked(domainName));\n    _domainVersion = keccak256(abi.encodePacked(domainVersion));\n    _domainRealm = domainRealm;\n    if (accessControl == address(0)) {\n      _accessControlManager = address(this);\n    } else {\n      try IERC165(accessControl).supportsInterface(type(IAccessControl).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid AccessControlManager\");\n      } catch {\n        revert(\"Illegal AccessControlManager\");\n      }\n      _accessControlManager = accessControl;\n    }\n    _isUpgradable = false;\n    _isSafeMode = false;\n    _setLocalAdmin(_msgSender());\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return\n      interfaceId == type(IProxy).interfaceId ||\n      interfaceId == type(IERC1822Proxiable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _implementation() internal view override returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    require(LAddress.isContract(newImplementation), \"Illegal Contract Address\");\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(msg.sender, address(this), newImplementation);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal returns (bytes memory) {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      return LAddress.functionDelegateCall(newImplementation, data, \"Delegatecall Failed\");\n    }\n    return new bytes(0);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal returns (bytes memory) {\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n      return new bytes(0);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"Invalid UUPS Contract\");\n      } catch {\n        revert(\"Illegal UUPS Contract\");\n      }\n\n      try IERC165(newImplementation).supportsInterface(type(IProxy).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid IProxy Contract\");\n      } catch {\n        revert(\"Illegal IProxy Contract\");\n      }\n\n      return _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n\n  /**\n   * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n   * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n   *\n   * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n   * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n   * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n   */\n  function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n    return _IMPLEMENTATION_SLOT;\n  }\n\n  function upgradeTo(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) external virtual onlyProxy returns (bytes memory) {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_isUpgradable, \"Upgrade Call Rejected\");\n    _authorizeUpgrade(newImplementation);\n    return _upgradeToAndCallUUPS(newImplementation, data, forceCall);\n  }\n\n  /**\n   * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n   * {upgradeTo} and {upgradeToAndCall}.\n   *\n   * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n   *\n   * ```solidity\n   * function _authorizeUpgrade(address) internal override onlyOwner {}\n   * ```\n   */\n  function _authorizeUpgrade(address newImplementation) internal virtual {\n    require(newImplementation != _implementation(), \"Illegal New Implementation\");\n    require(_hasPermission(this.upgradeTo.selector), \"Upgrade Context Forbidden\");\n  }\n\n  function localAdmin() external view returns (address) {\n    return _getLocalAdmin();\n  }\n\n  function setLocalAdmin(address newLocalAdmin) external onlyProxy returns (bool) {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_hasPermission(this.setLocalAdmin.selector), \"SetLocalAdmin Forbidden\");\n    require(newLocalAdmin != address(0), \"Address Invalid\");\n    _setLocalAdmin(newLocalAdmin);\n    return true;\n  }\n\n  /**\n   * @dev Returns the current admin.require(!_isSafeMode, \"SafeMode: Call Rejected\");\n   */\n  function _getLocalAdmin() internal view returns (address) {\n    return LStorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 admin slot.\n   */\n  function _setLocalAdmin(address newAdmin) internal {\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    emit LocalAdminChanged(_msgSender(), address(this), newAdmin);\n  }\n\n  // In each upgrade the initialize requirement must be changed\n  function setSafeMode(bool status) external onlyProxy returns (bool) {\n    require(_getInitializedCount() > 0, \"Contract Not Initialized\");\n    require(_hasPermission(this.setSafeMode.selector), \"SetSafeMode Forbidden\");\n    _isSafeMode = status;\n    emit SafeModeChanged(_msgSender(), address(this), _domainRealm, status);\n    return status;\n  }\n\n  function setUpgradeStatus(bool status) external onlyProxy returns (bool) {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_hasPermission(this.setUpgradeStatus.selector), \"SetUpgradeStatus Forbidden\");\n    require(_isRealmUpgradable(), \"Realm Upgrade Forbidden\");\n    _isUpgradable = status;\n    emit UpgradeStatusChanged(_msgSender(), address(this), _domainRealm, status);\n    return status;\n  }\n\n  function contractName() external view returns (bytes32) {\n    return _domainName;\n  }\n\n  function contractVersion() external view returns (bytes32) {\n    return _domainVersion;\n  }\n\n  function contractRealm() external view returns (bytes32) {\n    return _domainRealm;\n  }\n\n  function contractContext() external view returns (bytes32) {\n    return LContextUtils.generateCtx(address(this));\n  }\n\n  function accessControlManager() external view returns (address) {\n    return _accessControlManager;\n  }\n\n  function subjectAddress() external view returns (address) {\n    return _implementation();\n  }\n\n  function isSafeMode() external view returns (bool) {\n    return _isSafeMode;\n  }\n\n  function isUpgradable() external view returns (bool) {\n    return _isUpgradable;\n  }\n\n  function domainSeparator() external view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    return keccak256(abi.encode(_TYPE_HASH, _domainName, _domainVersion, block.chainid, address(this)));\n  }\n\n  function initVersion() external view returns (uint16) {\n    return _getInitializedCount();\n  }\n\n  function initStatus() external view returns (bool) {\n    return _isInitializing();\n  }\n\n  function withdrawBalance(address recepient) public {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_hasPermission(this.withdrawBalance.selector), \"Withdraw Balance Forbidden\");\n    payable(recepient).transfer(address(this).balance);\n  }\n\n  // solhint-disable-next-line\n  receive() external payable override {}\n\n  // solhint-disable-next-line\n  fallback() external payable override {}\n}\n"
    },
    "src/contracts/proxy/BaseUUPSStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n */\n\nabstract contract BaseUUPSStorage {\n  // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n  bytes32 internal constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n   * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n   */\n  bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  bytes32 internal constant _TYPE_HASH =\n    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n  address internal immutable __self = address(this);\n  address internal _accessControlManager;\n  bytes32 internal _domainName;\n  bytes32 internal _domainVersion;\n  bytes32 internal _domainRealm;\n  bool internal _isSafeMode;\n  bool internal _isUpgradable;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[64] private __gap;\n}\n"
    },
    "src/contracts/proxy/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"./IBaseProxy.sol\";\n\ninterface IProxy is IBaseProxy {\n  /**\n   * @dev Emitted when the admin account has changed.\n   */\n  event LocalAdminChanged(address indexed sender, address indexed proxy, address newAdmin);\n\n  event SafeModeChanged(address indexed sender, address indexed proxy, bytes32 indexed realm, bool status);\n\n  event UpgradeStatusChanged(address indexed sender, address indexed proxy, bytes32 indexed realm, bool status);\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n   */\n  event Initialized(\n    address indexed sender,\n    address indexed proxy,\n    address indexed subject,\n    string name,\n    string version,\n    bytes32 realm,\n    uint16 initCount\n  );\n\n  function upgradeTo(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) external returns (bytes memory);\n\n  function setSafeMode(bool status) external returns (bool);\n\n  function setUpgradeStatus(bool status) external returns (bool);\n\n  function setLocalAdmin(address newAdmin) external returns (bool);\n\n  function contractName() external view returns (bytes32);\n\n  function contractVersion() external view returns (bytes32);\n\n  function contractRealm() external view returns (bytes32);\n\n  function contractContext() external view returns (bytes32);\n\n  function accessControlManager() external view returns (address);\n\n  function subjectAddress() external view returns (address);\n\n  function isSafeMode() external view returns (bool);\n\n  function isUpgradable() external view returns (bool);\n\n  function localAdmin() external view returns (address);\n\n  function domainSeparator() external view returns (bytes32);\n\n  function initVersion() external view returns (uint16);\n\n  function initStatus() external view returns (bool);\n}\n"
    },
    "src/contracts/lib/LContextUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @dev Collection of functions related to the context\n */\nlibrary LContextUtils {\n  function generateCtx(address contractAddress) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(contractAddress));\n  }\n}\n"
    },
    "src/contracts/lib/cryptography/LECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../LStrings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary LECDSA {\n  enum RecoverError {\n    NoError,\n    InvalidSignature,\n    InvalidSignatureLength,\n    InvalidSignatureS,\n    InvalidSignatureV\n  }\n\n  function _throwError(RecoverError error) private pure {\n    if (error == RecoverError.NoError) {\n      return; // no error: do nothing\n    } else if (error == RecoverError.InvalidSignature) {\n      revert(\"ECDSA: invalid signature\");\n    } else if (error == RecoverError.InvalidSignatureLength) {\n      revert(\"ECDSA: invalid signature length\");\n    } else if (error == RecoverError.InvalidSignatureS) {\n      revert(\"ECDSA: invalid signature 's' value\");\n    } else if (error == RecoverError.InvalidSignatureV) {\n      revert(\"ECDSA: invalid signature 'v' value\");\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature` or error string. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   *\n   * Documentation for signature generation:\n   * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n   * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n   *\n   */\n  function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n    // Check the signature length\n    // - case 65: r,s,v signature (standard)\n    // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n      return tryRecover(hash, v, r, s);\n    } else if (signature.length == 64) {\n      bytes32 r;\n      bytes32 vs;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        vs := mload(add(signature, 0x40))\n      }\n      return tryRecover(hash, r, vs);\n    } else {\n      return (address(0), RecoverError.InvalidSignatureLength);\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature`. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   */\n  function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n   *\n   * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n   */\n  function tryRecover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address, RecoverError) {\n    bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\n    return tryRecover(hash, v, r, s);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n   */\n  function recover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   */\n  function tryRecover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address, RecoverError) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      return (address(0), RecoverError.InvalidSignatureS);\n    }\n    if (v != 27 && v != 28) {\n      return (address(0), RecoverError.InvalidSignatureV);\n    }\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    if (signer == address(0)) {\n      return (address(0), RecoverError.InvalidSignature);\n    }\n\n    return (signer, RecoverError.NoError);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   */\n  function recover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", LStrings.toString(s.length), s));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Typed Data, created from a\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\n   * to the one signed with the\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n   * JSON-RPC method as part of EIP-712.\n   *\n   * See {recover}.\n   */\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "src/contracts/proxy/IBaseProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\ninterface IBaseProxy {\n  event Upgraded(address indexed sender, address indexed proxy, address indexed newImplementation);\n}\n"
    },
    "src/contracts/lib/LStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @dev String operations.\n */\nlibrary LStrings {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n}\n"
    },
    "src/contracts/lib/LAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary LAddress {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"SendValue Failed\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, \"Call Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Call With Value Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Insufficient Balance For Call\");\n    require(LAddress.isContract(target), \"Illegal Contract Address\");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Static Call Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(LAddress.isContract(target), \"Illegal Contract Address\");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Delegate Call Failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory message\n  ) internal returns (bytes memory) {\n    require(LAddress.isContract(target), \"Illegal Contract Address\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return LAddress.verifyCallResult(success, returndata, message);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason using the provided one.\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "src/contracts/proxy/IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n  /**\n   * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n   * address.\n   *\n   * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n   * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n   * function revert if invoked through a proxy.\n   */\n  function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "src/contracts/proxy/BaseProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract BaseProxy {\n  /**\n   * @dev Delegates the current call to `implementation`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _delegate(address implementation) internal virtual {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates the current call to the address returned by `_implementation()`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _fallback() internal virtual {\n    _beforeFallback();\n    _delegate(_implementation());\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  fallback() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n   * is empty.\n   */\n  receive() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n   * call, or as part of the Solidity `fallback` or `receive` functions.\n   *\n   * If overridden should call `super._beforeFallback()`.\n   */\n  function _beforeFallback() internal virtual {}\n}\n"
    },
    "src/contracts/lib/LStorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary LStorageSlot {\n  struct AddressSlot {\n    address value;\n  }\n\n  struct BooleanSlot {\n    bool value;\n  }\n\n  struct Bytes32Slot {\n    bytes32 value;\n  }\n\n  struct Uint256Slot {\n    uint256 value;\n  }\n\n  /**\n   * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n   */\n  function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n   */\n  function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n   */\n  function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n   */\n  function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n    assembly {\n      r.slot := slot\n    }\n  }\n}\n"
    },
    "src/contracts/utils/Message.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Message {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n"
    },
    "src/contracts/utils/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "src/contracts/utils/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/token/lively/LivelyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Extra.sol\";\nimport \"./IERC20Pause.sol\";\nimport \"./LivelyStorage.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\nimport \"../../lib/token/LTokenERC20.sol\";\nimport \"../../lib/cryptography/LECDSA.sol\";\nimport \"../../lib/LCounters.sol\";\nimport \"../../lib/math/LBasisPointsMath.sol\";\nimport \"../../lib/math/LSafeMath.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\nimport \"../../acl/IContextManagement.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract LivelyToken is LivelyStorage, BaseUUPSProxy, IERC20, IERC20Extra, IERC20Pause {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LCounters for LCounters.Counter;\n  using LBasisPointsMath for uint256;\n  using LSafeMath for uint256;\n\n  struct InitRequest {\n    string domainName;\n    string domainVersion;\n    string domainRealm;\n    bytes signature;\n    uint256 taxRateValue;\n    uint256 totalSupplyAmount;\n    address accessControlManager;\n    address taxTreasuryAddress;\n    address assetManager;\n  }\n\n  constructor() {}\n\n  function initialize(InitRequest calldata request) public onlyProxy onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(request.domainRealm));\n    __BASE_UUPS_init(request.domainName, request.domainVersion, realm, request.accessControlManager);\n\n    _name = \"LIVELY\";\n    _symbol = \"LVL\";\n    _taxRate = request.taxRateValue;\n    _taxTreasury = request.taxTreasuryAddress;\n    _mint(request.assetManager, request.totalSupplyAmount);\n    initContext(request.domainName, request.domainVersion, realm, request.signature);\n  }\n\n  function initContext(\n    string calldata domainName,\n    string calldata domainVersion,\n    bytes32 realm,\n    bytes calldata signature\n  ) internal {\n    (IContextManagement.RequestContext memory rc, IContextManagement.RequestRegisterContext[] memory rrc) = LTokenERC20\n      .createRequestContext(_domainName, _domainVersion, _domainRealm);\n\n    IContextManagement(_accessControlManager).registerContext(signature, rc, rrc);\n\n    emit Initialized(\n      _msgSender(),\n      address(this),\n      _implementation(),\n      domainName,\n      domainVersion,\n      realm,\n      _getInitializedCount()\n    );\n  }\n\n  function distributeToken() public view onlyProxy onlyLocalAdmin safeModeCheck returns (bool) {\n    require(_getInitializedCount() == 1, \"Token Already Distributed\");\n    return true;\n  }\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return\n      interfaceId == type(IERC20).interfaceId ||\n      interfaceId == type(IERC20Extra).interfaceId ||\n      interfaceId == type(IERC20Pause).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  modifier whenNotPaused() {\n    require(!_isPaused, \"ERC20Pause: Call Rejected\");\n    _;\n  }\n\n  modifier whenAccountNotPaused(address account) {\n    require(!_pausedList.contains(account), \"ERC20Pause: Account Suspended\");\n    _;\n  }\n\n  function pause(address account) external safeModeCheck aclCheck(this.pause.selector) {\n    require(account != address(0), \"Invalid Account Address\");\n    require(!_pausedList.contains(account), \"Account Already Paused\");\n    _pausedList.add(account);\n    emit Paused(_msgSender(), account);\n  }\n\n  function unpause(address account) external safeModeCheck aclCheck(this.unpause.selector) {\n    require(account != address(0), \"Invalid Account Address\");\n    require(_pausedList.contains(account), \"Account Not Found\");\n    _pausedList.remove(account);\n    emit Unpaused(_msgSender(), account);\n  }\n\n  function pauseAll() external safeModeCheck aclCheck(this.pauseAll.selector) {\n    _isPaused = true;\n    emit PausedAll(_msgSender());\n  }\n\n  function unpauseAll() external safeModeCheck aclCheck(this.unpauseAll.selector) {\n    _isPaused = false;\n    emit UnpausedAll(_msgSender());\n  }\n\n  function isPaused(address account) external view returns (bool) {\n    return account != address(0) && _pausedList.contains(account);\n  }\n\n  function isPausedAll() external view returns (bool) {\n    return _isPaused;\n  }\n\n  function pausedAccounts() external view returns (address[] memory) {\n    return _pausedList.values();\n  }\n\n  function updateTaxRate(uint256 rate) external safeModeCheck aclCheck(this.updateTaxRate.selector) returns (bool) {\n    _taxRate = rate;\n    emit TaxRateUpdated(_msgSender(), rate);\n    return true;\n  }\n\n  function batchUpdateTaxWhitelist(BatchUpdateTaxWhitelistRequest[] calldata request) external {\n    for (uint256 i = 0; i < request.length; i++) {\n      _updateTaxWhitelist(request[i].account, request[i].isDeleted);\n    }\n  }\n\n  function updateTaxWhitelist(address account, bool isDeleted) external returns (bool) {\n    return _updateTaxWhitelist(account, isDeleted);\n  }\n\n  function _updateTaxWhitelist(address account, bool isDeleted)\n    internal\n    safeModeCheck\n    aclCheck(this.updateTaxWhitelist.selector)\n    returns (bool)\n  {\n    require(account != address(0), \"Invalid Account Address\");\n    if (isDeleted) {\n      require(_taxWhitelist.contains(account), \"Account Not Found\");\n      _taxWhitelist.remove(account);\n    } else {\n      require(!_taxWhitelist.contains(account), \"Account Already Exists\");\n      _taxWhitelist.add(account);\n    }\n\n    emit TaxWhitelistUpdated(_msgSender(), account, isDeleted);\n    return true;\n  }\n\n  function taxRate() external view returns (uint256) {\n    return _taxRate;\n  }\n\n  function taxTreasury() external view returns (address) {\n    return _taxTreasury;\n  }\n\n  function taxWhitelist() external view returns (address[] memory) {\n    return _taxWhitelist.values();\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    bytes calldata signature\n  ) external returns (bool) {\n    require(block.timestamp <= deadline, \"Permit Expired Deadline\");\n    bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n    bytes32 hash = LECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    address signer = LECDSA.recover(hash, signature);\n\n    // console.log(\"singer address: %s, nonce: %d\", signer, this.nonce(owner));\n\n    require(signer == owner, \"Illegal ECDASA Signature\");\n\n    _approve(owner, spender, value);\n    return true;\n  }\n\n  function nonce(address owner) external view returns (uint256) {\n    return _accounts[owner].nonce.current();\n  }\n\n  function _useNonce(address owner) internal returns (uint256 current) {\n    LCounters.Counter storage localNonce = _accounts[owner].nonce;\n    current = localNonce.current();\n    localNonce.increment();\n  }\n\n  function name() external view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() external view returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() external pure returns (uint8) {\n    return 18;\n  }\n\n  function totalSupply() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) external view returns (uint256) {\n    return _accounts[account].balance;\n  }\n\n  function allowance(address owner, address spender) external view returns (uint256) {\n    return _allowance(owner, spender);\n  }\n\n  function approve(address spender, uint256 amount) external returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function transfer(address recipient, uint256 amount) external returns (bool) {\n    if (_taxRate > 0 && !_taxWhitelist.contains(_msgSender())) {\n      _taxTransfer(_msgSender(), recipient, amount);\n    } else {\n      _transfer(_msgSender(), recipient, amount);\n    }\n    return true;\n  }\n\n  function transferFrom(\n    address source,\n    address recipient,\n    uint256 amount\n  ) external returns (bool) {\n    return _transferFrom(source, recipient, amount);\n  }\n\n  function batchTransfer(BatchTransferRequest[] calldata request) external returns (bool) {\n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < request.length; i++) {\n      totalAmount += request[i].amount;\n      _transfer(_msgSender(), request[i].recipient, request[i].amount);\n    }\n\n    emit BatchTransfer(_msgSender(), totalAmount);\n    return true;\n  }\n\n  function batchTransferFrom(BatchTransferFromRequest[] calldata request) external returns (bool) {\n    uint256 totalAmount = 0;\n    for (uint256 i = 0; i < request.length; i++) {\n      totalAmount += request[i].amount;\n      _transferFrom(request[i].source, request[i].recipient, request[i].amount);\n    }\n\n    emit BatchTransferFrom(_msgSender(), totalAmount);\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    address owner = _msgSender();\n    uint256 currentAllowance = _allowance(owner, spender) + amount;\n    _approve(owner, spender, currentAllowance);\n    emit ApprovalIncremented(owner, spender, amount);\n    return currentAllowance;\n  }\n\n  function decreaseAllowance(address spender, uint256 amount) external returns (uint256) {\n    address owner = _msgSender();\n    _spendAllowance(owner, spender, amount);\n    emit ApprovalDecresed(owner, spender, amount);\n    return _allowance(owner, spender);\n  }\n\n  function mint(address account, uint256 amount)\n    external\n    safeModeCheck\n    whenNotPaused\n    whenAccountNotPaused(account)\n    aclCheck(this.mint.selector)\n    returns (uint256)\n  {\n    return _mint(account, amount);\n  }\n\n  function _mint(address account, uint256 amount) internal returns (uint256) {\n    require(account != address(0), \"Invalid Account Address\");\n    _totalSupply += amount;\n    _accounts[account].balance += amount;\n    emit Mint(_msgSender(), account, amount, _totalSupply);\n    return _totalSupply;\n  }\n\n  function burn(address account, uint256 amount)\n    external\n    safeModeCheck\n    whenNotPaused\n    whenAccountNotPaused(account)\n    aclCheck(this.burn.selector)\n    returns (uint256)\n  {\n    require(account != address(0), \"Invalid Account Address\");\n    uint256 accountBalance = _accounts[account].balance;\n    require(accountBalance >= amount, \"Insufficient Account Balance\");\n    unchecked {\n      _accounts[account].balance = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n    emit Burn(_msgSender(), account, amount, _totalSupply);\n    return _totalSupply;\n  }\n\n  function _transfer(\n    address src,\n    address dest,\n    uint256 amount\n  ) internal safeModeCheck whenNotPaused whenAccountNotPaused(src) aclCheck(this.transfer.selector) {\n    require(src != address(0), \"Invalid Source Address\");\n    require(dest != address(0), \"Invalid Destination Address\");\n    require(src != dest, \"Illegal Self Transfer\");\n    require(amount > 0, \"Invalid Transfer Amount\");\n\n    uint256 srcBalance = _accounts[src].balance;\n    require(srcBalance >= amount, \"Insufficient Account Balance\");\n    unchecked {\n      _accounts[src].balance = srcBalance - amount;\n    }\n    _accounts[dest].balance += amount;\n\n    emit Transfer(src, dest, amount);\n  }\n\n  function _taxTransfer(\n    address source,\n    address recipient,\n    uint256 amount\n  ) internal {\n    uint256 tax = amount.mulBP(_taxRate);\n    uint256 tokensToTransfer = amount.sub(tax, \"Insufficient Transfer Amount\");\n\n    _transfer(source, _taxTreasury, tax);\n    _transfer(source, recipient, tokensToTransfer);\n  }\n\n  function _transferFrom(\n    address source,\n    address recipient,\n    uint256 amount\n  ) internal returns (bool) {\n    address spender = _msgSender();\n    if (_taxRate > 0 && !_taxWhitelist.contains(_msgSender())) {\n      _taxTransfer(source, recipient, amount);\n    } else {\n      _transfer(source, recipient, amount);\n    }\n    _spendAllowance(source, spender, amount);\n\n    emit TransferFrom(spender, source, recipient, amount);\n    return true;\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal safeModeCheck whenNotPaused whenAccountNotPaused(owner) aclCheck(this.approve.selector) {\n    require(owner != address(0), \"Invalid Owner Address\");\n    require(spender != address(0), \"Invalid Spender Address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _spendAllowance(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal {\n    uint256 currentAllowance = _allowance(owner, spender);\n    require(currentAllowance >= amount, \"Insufficient Account Allowance\");\n    unchecked {\n      _approve(owner, spender, currentAllowance - amount);\n    }\n  }\n\n  function _allowance(address owner, address spender) internal view returns (uint256) {\n    return _allowances[owner][spender];\n  }\n}\n"
    },
    "src/contracts/token/lively/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  event Transfer(address indexed sender, address indexed recipient, uint256 amount);\n\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address source,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "src/contracts/token/lively/IERC20Extra.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\ninterface IERC20Extra {\n  event ApprovalIncremented(address indexed owner, address indexed spender, uint256 amount);\n\n  event ApprovalDecresed(address indexed owner, address indexed spender, uint256 amount);\n\n  event TransferFrom(address indexed sender, address indexed from, address indexed to, uint256 amount);\n\n  event BatchTransfer(address indexed sender, uint256 totalAmount);\n\n  event BatchTransferFrom(address indexed sender, uint256 totalAmount);\n\n  event TaxRateUpdated(address indexed sender, uint256 rate);\n\n  event TaxWhitelistUpdated(address indexed sender, address indexed account, bool isDeleted);\n\n  event Burn(address indexed sender, address indexed account, uint256 amount, uint256 totalSupply);\n\n  event Mint(address indexed sender, address indexed account, uint256 amount, uint256 totalSupply);\n\n  struct BatchTransferRequest {\n    address recipient;\n    uint256 amount;\n  }\n\n  struct BatchTransferFromRequest {\n    address source;\n    address recipient;\n    uint256 amount;\n  }\n\n  struct BatchUpdateTaxWhitelistRequest {\n    address account;\n    bool isDeleted;\n  }\n\n  function increaseAllowance(address spender, uint256 value) external returns (uint256);\n\n  function decreaseAllowance(address spender, uint256 value) external returns (uint256);\n\n  function burn(address account, uint256 amount) external returns (uint256);\n\n  function mint(address account, uint256 amount) external returns (uint256);\n\n  function batchTransfer(BatchTransferRequest[] calldata request) external returns (bool);\n\n  function batchTransferFrom(BatchTransferFromRequest[] calldata request) external returns (bool);\n\n  function updateTaxRate(uint256 taxRate) external returns (bool);\n\n  function updateTaxWhitelist(address account, bool isDeleted) external returns (bool);\n\n  function batchUpdateTaxWhitelist(BatchUpdateTaxWhitelistRequest[] calldata request) external;\n\n  function taxRate() external view returns (uint256);\n\n  function taxTreasury() external view returns (address);\n\n  function taxWhitelist() external view returns (address[] memory);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    bytes calldata signature\n  ) external returns (bool);\n\n  function nonce(address owner) external view returns (uint256);\n}\n"
    },
    "src/contracts/token/lively/IERC20Pause.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\ninterface IERC20Pause {\n  event Paused(address indexed sender, address indexed account);\n\n  event Unpaused(address indexed sender, address indexed account);\n\n  event PausedAll(address indexed sender);\n\n  event UnpausedAll(address indexed sender);\n\n  function pause(address account) external;\n\n  function unpause(address account) external;\n\n  function pauseAll() external;\n\n  function unpauseAll() external;\n\n  function isPaused(address account) external view returns (bool);\n\n  function isPausedAll() external view returns (bool);\n\n  function pausedAccounts() external view returns (address[] memory);\n}\n"
    },
    "src/contracts/token/lively/LivelyStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../../proxy/BaseUUPSStorage.sol\";\nimport \"../../lib/LCounters.sol\";\nimport \"../../lib/struct/LEnumerableSet.sol\";\n\nabstract contract LivelyStorage is BaseUUPSStorage {\n  using LEnumerableSet for LEnumerableSet.AddressSet;\n  using LCounters for LCounters.Counter;\n  // struct ShortTermDeposit {\n  //     uint256 balance;\n  //     uint256 interest;\n  //     uint128 aprId;\n  //     uint128 timestamp;\n  // }\n\n  // struct APYSnapshot {\n  //     uint256 rate;\n  //     uint128 timestamp;\n  // }\n\n  struct AccountInfo {\n    uint256 balance;\n    LCounters.Counter nonce;\n  }\n\n  bytes32 internal constant _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n  mapping(address => AccountInfo) internal _accounts;\n  mapping(address => mapping(address => uint256)) internal _allowances;\n\n  // mapping(address => ShortTermDeposit) internal _stdMap;\n  // APYSnapshot[] internal _apySnapshots;\n  // LCounters.Counter internal _apyId;\n  LEnumerableSet.AddressSet internal _pausedList;\n  LEnumerableSet.AddressSet internal _taxWhitelist;\n  string internal _name;\n  string internal _symbol;\n  uint256 internal _totalSupply;\n  uint256 internal _taxRate;\n  address internal _taxTreasury;\n  bool internal _isPaused;\n}\n"
    },
    "src/contracts/lib/token/LTokenERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../../token/lively/IERC20.sol\";\nimport \"../../token/lively/IERC20Extra.sol\";\nimport \"../../token/lively/IERC20Pause.sol\";\nimport \"../../proxy/IProxy.sol\";\nimport \"../../acl/IContextManagement.sol\";\nimport \"../../acl/IAccessControl.sol\";\n\nlibrary LTokenERC20 {\n  bytes32 public constant LIB_NAME = keccak256(abi.encodePacked(\"LTokenERC20\"));\n  bytes32 public constant LIB_VERSION = keccak256(abi.encodePacked(\"1.0.0\"));\n\n  function createRequestContext(\n    bytes32 domainName,\n    bytes32 domainVersion,\n    bytes32 realm\n  )\n    external\n    view\n    returns (IContextManagement.RequestContext memory, IContextManagement.RequestRegisterContext[] memory)\n  {\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](3);\n    rrc[0].role = IAccessControl(IProxy(address(this)).accessControlManager()).livelyAnonymousRole();\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](2);\n    rrc[0].funcSelectors[0] = IERC20.transfer.selector;\n    rrc[0].funcSelectors[1] = IERC20.approve.selector;\n\n    rrc[1].role = IAccessControl(IProxy(address(this)).accessControlManager()).livelyAdminRole();\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](10);\n    rrc[1].funcSelectors[0] = IProxy.setUpgradeStatus.selector;\n    rrc[1].funcSelectors[1] = IERC20Extra.burn.selector;\n    rrc[1].funcSelectors[2] = IERC20Extra.mint.selector;\n    rrc[1].funcSelectors[3] = IERC20Extra.updateTaxRate.selector;\n    rrc[1].funcSelectors[4] = IERC20Extra.updateTaxWhitelist.selector;\n    rrc[1].funcSelectors[5] = IERC20Pause.pause.selector;\n    rrc[1].funcSelectors[6] = IERC20Pause.unpause.selector;\n    rrc[1].funcSelectors[7] = IERC20Pause.pauseAll.selector;\n    rrc[1].funcSelectors[8] = IERC20Pause.unpauseAll.selector;\n    rrc[1].funcSelectors[9] = bytes4(keccak256(\"withdrawBalance(address)\"));\n\n    rrc[2].role = IAccessControl(IProxy(address(this)).accessControlManager()).livelySystemAdminRole();\n    rrc[2].isEnabled = true;\n    rrc[2].funcSelectors = new bytes4[](3);\n    rrc[2].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[2].funcSelectors[1] = IProxy.setSafeMode.selector;\n    rrc[2].funcSelectors[2] = IProxy.upgradeTo.selector;\n\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: domainName,\n      version: domainVersion,\n      realm: realm,\n      smca: address(this),\n      status: true\n    });\n\n    return (rc, rrc);\n  }\n}\n"
    },
    "src/contracts/lib/LCounters.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary LCounters {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    unchecked {\n      counter._value += 1;\n    }\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n    unchecked {\n      counter._value = value - 1;\n    }\n  }\n\n  function reset(Counter storage counter) internal {\n    counter._value = 0;\n  }\n}\n"
    },
    "src/contracts/lib/math/LBasisPointsMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"./LSafeMath.sol\";\n\nlibrary LBasisPointsMath {\n  using LSafeMath for uint256;\n\n  uint256 private constant _BASIS_POINTS = 10000;\n\n  function mulBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    return amt.mul(bp).div(_BASIS_POINTS);\n  }\n\n  function divBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    require(bp > 0, \"Illegal Divide Zero\");\n    return amt.mul(_BASIS_POINTS).div(bp);\n  }\n\n  function addBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    if (amt == 0) return 0;\n    if (bp == 0) return amt;\n    return amt.add(mulBP(amt, bp));\n  }\n\n  function subBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n    if (amt == 0) return 0;\n    if (bp == 0) return amt;\n    return amt.sub(mulBP(amt, bp));\n  }\n}\n"
    },
    "src/contracts/lib/math/LSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary LSafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, with an overflow flag.\n   *\n   * _Available since v3.4._\n   */\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      uint256 c = a + b;\n      if (c < a) return (false, 0);\n      return (true, c);\n    }\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n   *\n   * _Available since v3.4._\n   */\n  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b > a) return (false, 0);\n      return (true, a - b);\n    }\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n   *\n   * _Available since v3.4._\n   */\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n      // benefit is lost if 'b' is also tested.\n      // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n      if (a == 0) return (true, 0);\n      uint256 c = a * b;\n      if (c / a != b) return (false, 0);\n      return (true, c);\n    }\n  }\n\n  /**\n   * @dev Returns the division of two unsigned integers, with a division by zero flag.\n   *\n   * _Available since v3.4._\n   */\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b == 0) return (false, 0);\n      return (true, a / b);\n    }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n   *\n   * _Available since v3.4._\n   */\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b == 0) return (false, 0);\n      return (true, a % b);\n    }\n  }\n\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   *\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   *\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator.\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * reverting when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a % b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {trySub}.\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b <= a, errorMessage);\n      return a - b;\n    }\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b > 0, errorMessage);\n      return a / b;\n    }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * reverting with custom message when dividing by zero.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {tryMod}.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b > 0, errorMessage);\n      return a % b;\n    }\n  }\n}\n"
    },
    "src/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"./IBaseProxy.sol\";\nimport \"./BaseProxy.sol\";\nimport \"./IERC1822.sol\";\nimport \"./IProxy.sol\";\nimport \"./BaseUUPSStorage.sol\";\nimport \"../lib/LAddress.sol\";\nimport \"../lib/LStorageSlot.sol\";\nimport \"../utils/IERC165.sol\";\n\n// import \"hardhat/console.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\n\ncontract Proxy is BaseUUPSStorage, BaseProxy, IBaseProxy {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address logic, bytes memory data) payable {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n    assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = msg.sender;\n    _isSafeMode = true;\n    _upgradeToAndCallUUPS(logic, data, false);\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view override returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) private {\n    _setImplementation(newImplementation);\n    emit Upgraded(msg.sender, address(this), _implementation());\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) private returns (bytes memory) {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      return LAddress.functionDelegateCall(newImplementation, data);\n    }\n    return new bytes(0);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) private returns (bytes memory) {\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n      return new bytes(0);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"Invalid UUPS Contract\");\n      } catch {\n        revert(\"Illegal UUPS Contract\");\n      }\n\n      try IERC165(newImplementation).supportsInterface(type(IProxy).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid IProxy Contract\");\n      } catch {\n        revert(\"Illegal IProxy Contract\");\n      }\n      return _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n}\n"
    },
    "src/contracts/test/proxy/UUPSUpgradeableTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../../proxy/IERC1822.sol\";\nimport \"./ERC1967UpgradeTest.sol\";\nimport \"../../utils/ERC165.sol\";\n\ncontract UUPSUpgradeableTest is IERC1822Proxiable, ERC1967UpgradeTest, ERC165 {\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n  address private immutable __self = address(this);\n\n  modifier onlyProxy() {\n    require(address(this) != __self, \"Function must be called through delegatecall\");\n    require(_getImplementation() == __self, \"Function must be called through active proxy\");\n    _;\n  }\n\n  modifier notDelegated() {\n    require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n    _;\n  }\n\n  function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n    return _IMPLEMENTATION_SLOT;\n  }\n\n  function upgradeTo(address newImplementation) external virtual onlyProxy {\n    _authorizeUpgrade(newImplementation);\n    _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n  }\n\n  function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n    _authorizeUpgrade(newImplementation);\n    _upgradeToAndCallUUPS(newImplementation, data, true);\n  }\n\n  function _authorizeUpgrade(address newImplementation) internal virtual {}\n}\n"
    },
    "src/contracts/test/proxy/ERC1967UpgradeTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../lib/LAddress.sol\";\nimport \"../../lib/LStorageSlot.sol\";\n\nabstract contract ERC1967UpgradeTest {\n  bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n  // invalid\n  bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  event Upgraded(address indexed implementation);\n\n  function _getImplementation() internal view returns (address) {\n    return LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    require(LAddress.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n    LStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      LAddress.functionDelegateCall(newImplementation, data);\n    }\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (LStorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n        require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n      } catch {\n        revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n      }\n      _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Emitted when the admin account has changed.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Returns the current admin.\n   */\n  function _getAdmin() internal view returns (address) {\n    return LStorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 admin slot.\n   */\n  function _setAdmin(address newAdmin) private {\n    require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n    LStorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   *\n   * Emits an {AdminChanged} event.\n   */\n  function _changeAdmin(address newAdmin) internal {\n    emit AdminChanged(_getAdmin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n   * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n   */\n  bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n}\n"
    },
    "src/contracts/lib/cryptography/LSignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"./LECDSA.sol\";\nimport \"../LAddress.sol\";\nimport \"../../utils/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n */\nlibrary LSignatureChecker {\n  /**\n   * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n   * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n   *\n   * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n   * change through time. It could return true at block N and false at block N+1 (or the opposite).\n   */\n  function isValidSignatureNow(\n    address signer,\n    bytes32 hash,\n    bytes memory signature\n  ) internal view returns (bool) {\n    (address recovered, LECDSA.RecoverError error) = LECDSA.tryRecover(hash, signature);\n    if (error == LECDSA.RecoverError.NoError && recovered == signer) {\n      return true;\n    }\n\n    (bool success, bytes memory result) = signer.staticcall(\n      abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n    );\n    return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\n  }\n}\n"
    },
    "src/contracts/utils/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n  /**\n   * @dev Should return whether the signature provided is valid for the provided data\n   * @param hash      Hash of the data to be signed\n   * @param signature Signature byte array associated with _data\n   */\n  function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "src/contracts/utils/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../lib/cryptography/LECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n */\nabstract contract EIP712 {\n  /* solhint-disable var-name-mixedcase */\n  // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n  // invalidate the cached domain separator if the chain id changes.\n  bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n  uint256 private immutable _CACHED_CHAIN_ID;\n  address private immutable _CACHED_THIS;\n\n  bytes32 private immutable _HASHED_NAME;\n  bytes32 private immutable _HASHED_VERSION;\n  bytes32 private immutable _TYPE_HASH;\n\n  /* solhint-enable var-name-mixedcase */\n\n  /**\n   * @dev Initializes the domain separator and parameter caches.\n   *\n   * The meaning of `name` and `version` is specified in\n   * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n   *\n   * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n   * - `version`: the current major version of the signing domain.\n   *\n   * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n   * contract upgrade].\n   */\n  constructor(string memory name, string memory version) {\n    bytes32 hashedName = keccak256(bytes(name));\n    bytes32 hashedVersion = keccak256(bytes(version));\n    bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    _HASHED_NAME = hashedName;\n    _HASHED_VERSION = hashedVersion;\n    _CACHED_CHAIN_ID = block.chainid;\n    _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n    _CACHED_THIS = address(this);\n    _TYPE_HASH = typeHash;\n  }\n\n  /**\n   * @dev Returns the domain separator for the current chain.\n   */\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n      return _CACHED_DOMAIN_SEPARATOR;\n    } else {\n      return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n    }\n  }\n\n  function _buildDomainSeparator(\n    bytes32 typeHash,\n    bytes32 nameHash,\n    bytes32 versionHash\n  ) private view returns (bytes32) {\n    return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n  }\n\n  /**\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n   * function returns the hash of the fully encoded EIP712 message for this domain.\n   *\n   * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n   *\n   * ```solidity\n   * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n   *     keccak256(\"Mail(address to,string contents)\"),\n   *     mailTo,\n   *     keccak256(bytes(mailContents))\n   * )));\n   * address signer = ECDSA.recover(digest, signature);\n   * ```\n   */\n  function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n    return LECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n}\n"
    },
    "src/contracts/test/proxy/BaseUUPSProxyTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../../proxy/IERC1822.sol\";\nimport \"../../proxy/BaseUUPSProxy.sol\";\nimport \"../../acl/IContextManagement.sol\";\n\ncontract BaseUUPSProxyTest is BaseUUPSProxy {\n  bytes32 public constant LIVELY_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_ADMIN_ROLE\"));\n  bytes32 public constant LIVELY_SYSTEM_ADMIN_ROLE = keccak256(abi.encodePacked(\"LIVELY_SYSTEM_ADMIN_ROLE\"));\n\n  event UpgradeToAnonymous(address indexed sender, address indexed newImplementation);\n  event UpgradeToTester(address indexed sender, address indexed newImplementation);\n\n  function initialize(\n    string calldata domainName,\n    string calldata domainVersion,\n    string calldata domainRealm,\n    bytes memory signature,\n    address accessControlManager\n  ) public onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n    __BASE_UUPS_init(domainName, domainVersion, realm, accessControlManager);\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: keccak256(abi.encodePacked(domainName)),\n      version: keccak256(abi.encodePacked(domainVersion)),\n      realm: realm,\n      smca: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n    rrc[0].role = LIVELY_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](2);\n    rrc[0].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[0].funcSelectors[1] = IProxy.setUpgradeStatus.selector;\n\n    rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](2);\n    rrc[1].funcSelectors[0] = IProxy.setSafeMode.selector;\n    rrc[1].funcSelectors[1] = IProxy.upgradeTo.selector;\n    IContextManagement(accessControlManager).registerContext(signature, rc, rrc);\n  }\n\n  function initializeWithInvalidRealm(\n    string calldata domainName,\n    string calldata domainVersion,\n    string calldata domainRealm,\n    bytes memory signature,\n    address accessControlManager\n  ) public onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n    _domainName = keccak256(abi.encodePacked(domainName));\n    _domainVersion = keccak256(abi.encodePacked(domainVersion));\n    _domainRealm = realm;\n    if (accessControlManager == address(0)) {\n      _accessControlManager = address(this);\n    } else {\n      try IERC165(accessControlManager).supportsInterface(type(IAccessControl).interfaceId) returns (bool isSupported) {\n        require(isSupported, \"Invalid AccessControlManager\");\n      } catch {\n        revert(\"Illegal AccessControlManager\");\n      }\n      _accessControlManager = accessControlManager;\n    }\n    _isUpgradable = false;\n    _isSafeMode = false;\n\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: keccak256(abi.encodePacked(domainName)),\n      version: keccak256(abi.encodePacked(domainVersion)),\n      realm: realm,\n      smca: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](2);\n    rrc[0].role = LIVELY_ADMIN_ROLE;\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](2);\n    rrc[0].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[0].funcSelectors[1] = IProxy.setUpgradeStatus.selector;\n\n    rrc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    rrc[1].isEnabled = true;\n    rrc[1].funcSelectors = new bytes4[](2);\n    rrc[1].funcSelectors[0] = IProxy.setSafeMode.selector;\n    rrc[1].funcSelectors[1] = IProxy.upgradeTo.selector;\n    IContextManagement(accessControlManager).registerContext(signature, rc, rrc);\n  }\n\n  function initializeWithInvalidRole(\n    string calldata domainName,\n    string calldata domainVersion,\n    string calldata domainRealm,\n    bytes memory signature,\n    address accessControlManager\n  ) public onlyLocalAdmin initializer {\n    bytes32 realm = keccak256(abi.encodePacked(domainRealm));\n    __BASE_UUPS_init(domainName, domainVersion, realm, accessControlManager);\n\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: keccak256(abi.encodePacked(domainName)),\n      version: keccak256(abi.encodePacked(domainVersion)),\n      realm: realm,\n      smca: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestRegisterContext[] memory rrc = new IContextManagement.RequestRegisterContext[](1);\n    rrc[0].role = keccak256(abi.encodePacked(\"LIVELY_WORLD_ADMIN\"));\n    rrc[0].isEnabled = true;\n    rrc[0].funcSelectors = new bytes4[](2);\n    rrc[0].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n    rrc[0].funcSelectors[1] = IProxy.setUpgradeStatus.selector;\n\n    IContextManagement(accessControlManager).registerContext(signature, rc, rrc);\n  }\n\n  function reInitialize(bytes memory signature) public onlyLocalAdmin reinitializer(2) {\n    _domainRealm = keccak256(abi.encodePacked(\"LIVELY_VERSE_REALM\"));\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: _domainName,\n      version: _domainVersion,\n      realm: _domainRealm,\n      smca: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestUpdateContext[] memory ruc = new IContextManagement.RequestUpdateContext[](5);\n    ruc[0].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[0].updateStatus = IContextManagement.UpdateContextStatus.DISABLE;\n    ruc[0].funcSelectors = new bytes4[](1);\n    ruc[0].funcSelectors[0] = IProxy.upgradeTo.selector;\n\n    ruc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[1].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n    ruc[1].funcSelectors = new bytes4[](1);\n    ruc[1].funcSelectors[0] = this.upgradeToAndCall.selector;\n\n    ruc[2].role = keccak256(abi.encodePacked(\"TESTER_ROLE\"));\n    ruc[2].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n    ruc[2].funcSelectors = new bytes4[](1);\n    ruc[2].funcSelectors[0] = this.upgradeToTesterRole.selector;\n\n    ruc[3].role = keccak256(abi.encodePacked(\"LIVELY_ANONYMOUS_ROLE\"));\n    ruc[3].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n    ruc[3].funcSelectors = new bytes4[](1);\n    ruc[3].funcSelectors[0] = this.upgradeToAnonymousRole.selector;\n\n    ruc[4].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[4].updateStatus = IContextManagement.UpdateContextStatus.REMOVE;\n    ruc[4].funcSelectors = new bytes4[](1);\n    ruc[4].funcSelectors[0] = IProxy.setLocalAdmin.selector;\n\n    IContextManagement(_accessControlManager).updateContext(\n      LContextUtils.generateCtx(address(this)),\n      signature,\n      rc,\n      ruc\n    );\n  }\n\n  function reInitializeWithInvalidRealm(bytes memory signature) public onlyLocalAdmin reinitializer(2) {\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: _domainName,\n      version: _domainVersion,\n      realm: keccak256(abi.encodePacked(\"LIVELY_REALM\")),\n      smca: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestUpdateContext[] memory ruc = new IContextManagement.RequestUpdateContext[](2);\n    ruc[0].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[0].updateStatus = IContextManagement.UpdateContextStatus.DISABLE;\n    ruc[0].funcSelectors = new bytes4[](1);\n    ruc[0].funcSelectors[0] = IProxy.upgradeTo.selector;\n\n    ruc[1].role = LIVELY_SYSTEM_ADMIN_ROLE;\n    ruc[1].updateStatus = IContextManagement.UpdateContextStatus.ENABLE;\n    ruc[1].funcSelectors = new bytes4[](1);\n    ruc[1].funcSelectors[0] = this.upgradeToAndCall.selector;\n\n    IContextManagement(_accessControlManager).updateContext(\n      LContextUtils.generateCtx(address(this)),\n      signature,\n      rc,\n      ruc\n    );\n  }\n\n  function reInitializeWithInvalidRole(bytes memory signature) public onlyLocalAdmin reinitializer(2) {\n    IContextManagement.RequestContext memory rc = IContextManagement.RequestContext({\n      name: _domainName,\n      version: _domainVersion,\n      realm: _domainRealm,\n      smca: address(this),\n      status: true\n    });\n\n    IContextManagement.RequestUpdateContext[] memory rrc = new IContextManagement.RequestUpdateContext[](1);\n    rrc[0].role = keccak256(abi.encodePacked(\"LIVELY_WORLD_ADMIN\"));\n    rrc[0].updateStatus = IContextManagement.UpdateContextStatus.DISABLE;\n    rrc[0].funcSelectors = new bytes4[](1);\n    rrc[0].funcSelectors[0] = IProxy.upgradeTo.selector;\n\n    IContextManagement(_accessControlManager).updateContext(\n      LContextUtils.generateCtx(address(this)),\n      signature,\n      rc,\n      rrc\n    );\n  }\n\n  //    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n  //        return _IMPLEMENTATION_SLOT;\n  //    }\n\n  function upgradeToTesterRole(address newImplementation) external virtual onlyProxy {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_isUpgradable, \"Upgrade Call Rejected\");\n    require(_hasPermission(this.upgradeToTesterRole.selector), \"upgradeToTesterRole Forbidden\");\n    emit UpgradeToTester(msg.sender, newImplementation);\n  }\n\n  function upgradeToAnonymousRole(address newImplementation) external virtual onlyProxy {\n    require(!_isSafeMode, \"SafeMode: Call Rejected\");\n    require(_isUpgradable, \"Upgrade Call Rejected\");\n    require(_hasPermission(this.upgradeToAnonymousRole.selector), \"upgradeToAnonymousRole Forbidden\");\n    emit UpgradeToAnonymous(msg.sender, newImplementation);\n  }\n\n  function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n    _authorizeUpgrade(newImplementation);\n    _upgradeToAndCallUUPS(newImplementation, data, true);\n  }\n\n  //    function _authorizeUpgrade(address newImplementation) internal virtual override {}\n}\n"
    },
    "src/contracts/test/proxy/ERC1967ProxyTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.15 <0.9.0;\n\nimport \"../../proxy/BaseProxy.sol\";\nimport \"./ERC1967UpgradeTest.sol\";\n\ncontract ERC1967ProxyTest is BaseProxy, ERC1967UpgradeTest {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    _upgradeToAndCall(_logic, _data, false);\n  }\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _implementation() internal view virtual override returns (address impl) {\n    return ERC1967UpgradeTest._getImplementation();\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}